<?xml version='1.0' encoding='UTF-8'?><?xml-stylesheet href="http://www.blogger.com/styles/atom.css" type="text/css"?><feed xmlns='http://www.w3.org/2005/Atom' xmlns:openSearch='http://a9.com/-/spec/opensearchrss/1.0/' xmlns:georss='http://www.georss.org/georss' xmlns:gd='http://schemas.google.com/g/2005' xmlns:thr='http://purl.org/syndication/thread/1.0'><id>tag:blogger.com,1999:blog-7370998606556338092.archive</id><updated>2015-01-03T16:04:40.258+01:00</updated><title type='text'>JTechLog</title><link rel='http://schemas.google.com/g/2005#feed' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/archive'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/archive'/><link rel='http://schemas.google.com/g/2005#post' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/archive'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/'/><author><name>István Viczián</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><generator version='7.00' uri='http://www.blogger.com'>Blogger</generator><entry><id>tag:blogger.com,1999:blog-7370998606556338092.layout</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#template'/><title type='text'>Sablon: JTechLog</title><content type='text'>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
&lt;html expr:dir='data:blog.languageDirection' xmlns='http://www.w3.org/1999/xhtml' xmlns:b='http://www.google.com/2005/gml/b' xmlns:data='http://www.google.com/2005/gml/data' xmlns:expr='http://www.google.com/2005/gml/expr'&gt;
  &lt;head&gt;
    &lt;b:include data='blog' name='all-head-content'/&gt;
    &lt;title&gt;JTechLog - Viczián István Java blogja&lt;/title&gt;
    &lt;b:skin&gt;&lt;![CDATA[

/* Variable definitions
   ====================
   &lt;Variable name="bgcolor" description="Page Background Color"
             type="color" default="#fff" value="#ffffff"&gt;
   &lt;Variable name="textcolor" description="Text Color"
             type="color" default="#333" value="#333333"&gt;
   &lt;Variable name="linkcolor" description="Link Color"
             type="color" default="#58a" value="#736B59"&gt;
   &lt;Variable name="pagetitlecolor" description="Blog Title Color"
             type="color" default="#666" value="#666666"&gt;
   &lt;Variable name="descriptioncolor" description="Blog Description Color"
             type="color" default="#999" value="#999999"&gt;
   &lt;Variable name="titlecolor" description="Post Title Color"
             type="color" default="#c60" value="#736B59"&gt;
   &lt;Variable name="bordercolor" description="Border Color"
             type="color" default="#ccc" value="#cccccc"&gt;
   &lt;Variable name="sidebarcolor" description="Sidebar Title Color"
             type="color" default="#999" value="#999999"&gt;
   &lt;Variable name="sidebartextcolor" description="Sidebar Text Color"
             type="color" default="#666" value="#666666"&gt;
   &lt;Variable name="visitedlinkcolor" description="Visited Link Color"
             type="color" default="#999" value="#736B59"&gt;
   &lt;Variable name="bodyfont" description="Text Font"
             type="font" default="normal normal 100% Georgia, Serif" value="normal normal 100% Georgia, Serif"&gt;
   &lt;Variable name="headerfont" description="Sidebar Title Font"
             type="font"
             default="normal normal 78% 'Trebuchet MS',Trebuchet,Arial,Verdana,Sans-serif" value="normal normal 78% 'Trebuchet MS',Trebuchet,Arial,Verdana,Sans-serif"&gt;
   &lt;Variable name="pagetitlefont" description="Blog Title Font"
             type="font"
             default="normal normal 200% Georgia, Serif" value="normal normal 200% Georgia, Serif"&gt;
   &lt;Variable name="descriptionfont" description="Blog Description Font"
             type="font"
             default="normal normal 78% 'Trebuchet MS', Trebuchet, Arial, Verdana, Sans-serif" value="normal normal 78% 'Trebuchet MS', Trebuchet, Arial, Verdana, Sans-serif"&gt;
   &lt;Variable name="postfooterfont" description="Post Footer Font"
             type="font"
             default="normal normal 78% 'Trebuchet MS', Trebuchet, Arial, Verdana, Sans-serif" value="normal normal 78% 'Trebuchet MS', Trebuchet, Arial, Verdana, Sans-serif"&gt;
   &lt;Variable name="startSide" description="Side where text starts in blog language"
             type="automatic" default="left" value="left"&gt;
   &lt;Variable name="endSide" description="Side where text ends in blog language"
             type="automatic" default="right" value="right"&gt;
*/

/* Use this with templates/template-twocol.html */

body {
  background:$bgcolor;
  margin:0;
  color:$textcolor;
  font:x-small Georgia Serif;
  font-size/* */:/**/small;
  font-size: /**/small;
  text-align: center;
  }
a:link {
  color:$linkcolor;
  }
a:visited {
  color:$visitedlinkcolor;
  }
a:hover {
  color:$titlecolor;
  text-decoration:underline;
}
a img {
  border-width:0;
  }

/* Header
-----------------------------------------------
 */

#header-wrapper {
  width:815px;
  margin:0 auto 10px;
}

#header-inner {
  background-position: center;
  margin-left: auto;
  margin-right: auto;
}

#header { 
  margin: 5px;
  text-align: center;
  color:$pagetitlecolor;
}

#header h1 {
  margin:5px 5px 0;
  padding:15px 20px .25em;
  line-height:1.2em;
  text-transform:uppercase;
  letter-spacing:.2em;
  font: $pagetitlefont;
}

#header a {
  color:$pagetitlecolor;
  }

#header a:hover {
  color:$pagetitlecolor;
  }

#header .description {
  margin:0 5px 5px;
  padding:0 20px 15px;
  max-width:700px;
  text-transform:uppercase;
  letter-spacing:.2em;
  line-height: 1.4em;
  font: $descriptionfont;
  color: $descriptioncolor;
 }

#header img {
  margin-$startSide: auto;
  margin-$endSide: auto;
}

.titlewrapper {
    background: url("http://sites.google.com/site/viczianistvan/images/top.gif") no-repeat left bottom;
    height: 62px;
}


/* Outer-Wrapper
----------------------------------------------- */
#outer-wrapper {
  width: 815px;
  margin:0 auto;
  padding:10px;
  text-align:$startSide;
  font: $bodyfont;
  }

#main-wrapper {
  width: 560px;
  float: $startSide;
  word-wrap: break-word; /* fix for long text breaking sidebar float in IE */
  overflow: hidden;     /* fix for long non-text content breaking IE sidebar float */
  }

#sidebar-wrapper {
  width: 220px;
  float: $endSide;
  word-wrap: break-word; /* fix for long text breaking sidebar float in IE */
  overflow: hidden;      /* fix for long non-text content breaking IE sidebar float */
}


/* Headings
----------------------------------------------- */

h2 {
  margin:1.5em 0 .75em;
  font:$headerfont;
  line-height: 1.4em;
  text-transform:uppercase;
  letter-spacing:.2em;
  color:$sidebarcolor;
}


/* Posts
-----------------------------------------------
 */
.date-header {
  margin:1.5em 0 .5em;
  font:$headerfont;
  line-height: 1.4em;
  text-transform:uppercase;
  letter-spacing:.2em;
  color:$sidebarcolor;
}

.post {
  margin:.5em 0 1.5em;
  border-bottom:1px dotted $bordercolor;
  padding-bottom:1.5em;
  }

.post h2 {
  margin:.25em 0 0;
  font: $bodyfont;
  padding:0 0 4px;
  font-size:140%;
  font-weight:normal;
  line-height:1.4em;
  text-transform:none;
  letter-spacing:normal;
  color:$titlecolor;
}

.post h2 a, .post h2 a:visited, .post h2 strong {
  display:block;
  color:$titlecolor;
  font-weight:normal;
}

.post h2 strong, .post h2 a:hover {
  color:$textcolor;
}

.post h3 {
  margin:.25em 0 0;
  padding:0 0 4px;
  font-size:120%;
  font-weight:normal;
  line-height:1.4em;
  color:$titlecolor;
}

.post h4 {
  margin:.25em 0 0;
  padding:0 0 4px;
  font-size:100%;
  font-weight:normal;
  line-height:1.4em;
  color:$titlecolor;
}

.post-body {
  margin:0 0 .75em;
  line-height:1.6em;
}

.post-body blockquote {
  line-height:1.3em;  
}

.post-footer {
  margin: .75em 0;
  color:$sidebarcolor;
  text-transform:uppercase;
  letter-spacing:.1em;
  font: $postfooterfont;
  line-height: 1.4em;
}

.comment-link {
  margin-$startSide:.6em;
  }
.post img {
  padding:4px;
  border:1px solid $bordercolor;
  }
.post blockquote {
  margin:1em 20px;
  }
.post blockquote p {
  margin:.75em 0;
  }
  
.post code {
  background-color: #F7F7F7;
  padding: 2px;
}

/* Comments
----------------------------------------------- */
#comments h4 {
  margin:1em 0;
  font-weight: bold;
  line-height: 1.4em;
  text-transform:uppercase;
  letter-spacing:.2em;
  color: $sidebarcolor;
  }

#comments-block {
  margin:1em 0 1.5em;
  line-height:1.6em;
  }
#comments-block .comment-author {
  margin:.5em 0;
  }
#comments-block .comment-body {
  margin:.25em 0 0;
  }
#comments-block .comment-footer {
  margin:-.25em 0 2em;
  line-height: 1.4em;
  text-transform:uppercase;
  letter-spacing:.1em;
  }
#comments-block .comment-body p {
  margin:0 0 .75em;
  }
.deleted-comment {
  font-style:italic;
  color:gray;
  }

#blog-pager-newer-link {
  float: $startSide;
 }
 
#blog-pager-older-link {
  float: $endSide;
 }

#blog-pager { 
  text-align: center;
 }

.feed-links {
  clear: both;
  line-height: 2.5em;
}

/* Sidebar Content
----------------------------------------------- */
.sidebar { 
  color: $sidebartextcolor;
  line-height: 1.5em;
 }

.sidebar ul {
  list-style:none;
  margin:0 0 0;
  padding:0 0 0;
}
.sidebar li {
  margin:0;
  padding-top:0;
  padding-$endSide:0;
  padding-bottom:.25em;
  padding-$startSide:15px;
  text-indent:-15px;
  line-height:1.5em;
  }

.sidebar .widget, .main .widget { 
  border-bottom:1px dotted $bordercolor;
  margin:0 0 1.5em;
  padding:0 0 1.5em;
 }

.main .Blog { 
  border-bottom-width: 0;
}


/* Profile 
----------------------------------------------- */
.profile-img { 
  float: $startSide;
  margin-top: 0;
  margin-$endSide: 5px;
  margin-bottom: 5px;
  margin-$startSide: 0;
  padding: 4px;
  border: 1px solid $bordercolor;
}

.profile-data {
  margin:0;
  text-transform:uppercase;
  letter-spacing:.1em;
  font: $postfooterfont;
  color: $sidebarcolor;
  font-weight: bold;
  line-height: 1.6em;
}

.profile-datablock { 
  margin:.5em 0 .5em;
}

.profile-textblock { 
  margin: 0.5em 0;
  line-height: 1.6em;
}

.profile-link { 
  font: $postfooterfont;
  text-transform: uppercase;
  letter-spacing: .1em;
}

/* Footer
----------------------------------------------- */
#footer {
  width:660px;
  clear:both;
  margin:0 auto;
  padding-top:15px;
  line-height: 1.6em;
  text-transform:uppercase;
  letter-spacing:.1em;
  text-align: center;
}

/* Syntax hightlight
----------------------------------------------- */

.prettyprint {
  background: #f7f7f7;
  font-family: Menlo, 'Bitstream Vera Sans Mono', 'DejaVu Sans Mono', Monaco, Consolas, monospace;
  font-size: 12px;
  line-height: 1.5;
  border: 1px solid #ccc;
  padding: 10px;
  word-break: break-all;
  word-wrap: break-word;
  white-space: pre-wrap;
  text-indent: 0;
}

.pln {
  color: #333333;
}

.str {
color: #dd1144;
}

.kwd {
color: #333333;
}

.com {
color: #999988;
}

.typ {
color: #445588;
}

.lit {
color: #445588;
}

.pun {
color: #333333;
}

.opn {
color: #333333;
}

.clo {
color: #333333;
}

.tag {
color: navy;
}

.atn {
color: teal;
}

.atv {
color: #dd1144;
}

.dec {
color: #333333;
}

.var {
color: teal;
}

.fun {
color: #990000;
}


]]&gt;&lt;/b:skin&gt;

&lt;meta content='Nn/Q9eIQ0pXW5/ItO/gBedPr9Drv4PaP3HytWAek0Zk=' name='verify-v1'/&gt;
&lt;meta content='Viczián István' lang='hu' name='Author'/&gt;
&lt;meta content='JTechLog - Viczián István Java blogja. Hírek, tapasztalatok a Java platform világából.' lang='hu' name='Description'/&gt;
&lt;meta content='Viczián István, Java, blog, JTechLog' lang='hu' name='Keywords'/&gt;
&lt;link href='http://sites.google.com/site/viczianistvan/images/favicon.ico' rel='SHORTCUT ICON'/&gt;

&lt;script src='http://sites.google.com/site/viczianistvan/js/prototype.js' type='text/javascript'/&gt;
&lt;script src='http://sites.google.com/site/viczianistvan/js/scriptaculous.js?load=effects,builder' type='text/javascript'/&gt;
&lt;script src='http://sites.google.com/site/viczianistvan/js/lightbox.js' type='text/javascript'/&gt;
&lt;link href='http://sites.google.com/site/viczianistvan/css/lightbox.css' media='screen' rel='stylesheet' type='text/css'/&gt;

&lt;link href='http://sites.google.com/site/viczianistvan/css/shCore.css' rel='stylesheet' type='text/css'/&gt;
&lt;link href='http://sites.google.com/site/viczianistvan/css/shThemeDefault.css' rel='stylesheet' type='text/css'/&gt;
&lt;script src='http://sites.google.com/site/viczianistvan/js/shCore.js' type='text/javascript'/&gt;
&lt;script src='http://sites.google.com/site/viczianistvan/js/shBrushXml.js' type='text/javascript'/&gt;
&lt;script src='http://sites.google.com/site/viczianistvan/js/shBrushSql.js' type='text/javascript'/&gt;
&lt;script src='http://sites.google.com/site/viczianistvan/js/shBrushJava.js' type='text/javascript'/&gt;
&lt;script src='http://sites.google.com/site/viczianistvan/js/shBrushJScript.js' type='text/javascript'/&gt;
&lt;script src='http://sites.google.com/site/viczianistvan/js/shBrushPython.js' type='text/javascript'/&gt;

&lt;script type='text/javascript'&gt;

  var _gaq = _gaq || [];
  _gaq.push([&amp;#39;_setAccount&amp;#39;, &amp;#39;UA-478386-2&amp;#39;]);
  _gaq.push([&amp;#39;_trackPageview&amp;#39;]);

  (function() {
    var ga = document.createElement(&amp;#39;script&amp;#39;); ga.type = &amp;#39;text/javascript&amp;#39;; ga.async = true;
    ga.src = (&amp;#39;https:&amp;#39; == document.location.protocol ? &amp;#39;https://ssl&amp;#39; : &amp;#39;http://www&amp;#39;) + &amp;#39;.google-analytics.com/ga.js&amp;#39;;
    var s = document.getElementsByTagName(&amp;#39;script&amp;#39;)[0]; s.parentNode.insertBefore(ga, s);
  })();

&lt;/script&gt;

  &lt;/head&gt;

  &lt;body&gt;
  &lt;b:section class='navbar' id='navbar' maxwidgets='1' showaddelement='no'&gt;
    &lt;b:widget id='Navbar1' locked='true' title='Navbar' type='Navbar'&gt;
      &lt;b:includable id='main'&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
    function setAttributeOnload(object, attribute, val) {
      if(window.addEventListener) {
        window.addEventListener(&amp;#39;load&amp;#39;,
          function(){ object[attribute] = val; }, false);
      } else {
        window.attachEvent(&amp;#39;onload&amp;#39;, function(){ object[attribute] = val; });
      }
    }
  &amp;lt;/script&amp;gt;
&amp;lt;div id=&amp;quot;navbar-iframe-container&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;https://apis.google.com/js/plusone.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
        gapi.load(&amp;quot;gapi.iframes:gapi.iframes.style.bubble&amp;quot;, function() {
          if (gapi.iframes &amp;amp;&amp;amp; gapi.iframes.getContext) {
            gapi.iframes.getContext().openChild({
                url: &amp;#39;https://www.blogger.com/navbar.g?targetBlogID\0757370998606556338092\46blogName\75JTechLog\46publishMode\75PUBLISH_MODE_HOSTED\46navbarType\75SILVER\46layoutType\75LAYOUTS\46searchRoot\75http://www.jtechlog.hu/search\46blogLocale\75hu\46v\0752\46homepageUrl\75http://www.jtechlog.hu/\46blogFollowUrl\75https://plus.google.com/115891152269405230539\46vt\75-7509522559313976093&amp;#39;,
                where: document.getElementById(&amp;quot;navbar-iframe-container&amp;quot;),
                id: &amp;quot;navbar-iframe&amp;quot;
            });
          }
        });
      &amp;lt;/script&amp;gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
(function() {
var script = document.createElement(&amp;#39;script&amp;#39;);
script.type = &amp;#39;text/javascript&amp;#39;;
script.src = &amp;#39;//pagead2.googlesyndication.com/pagead/js/google_top_exp.js&amp;#39;;
var head = document.getElementsByTagName(&amp;#39;head&amp;#39;)[0];
if (head) {
head.appendChild(script);
}})();
&amp;lt;/script&amp;gt;
&lt;/b:includable&gt;
    &lt;/b:widget&gt;
  &lt;/b:section&gt;


  &lt;div id='outer-wrapper'&gt;&lt;div id='wrap2'&gt;

    &lt;!-- skip links for text browsers --&gt;
    &lt;span id='skiplinks' style='display:none;'&gt;
      &lt;a href='#main'&gt;skip to main &lt;/a&gt; |
      &lt;a href='#sidebar'&gt;skip to sidebar&lt;/a&gt;
    &lt;/span&gt;

    &lt;div id='header-wrapper'&gt;
      &lt;b:section class='header' id='header' maxwidgets='1' showaddelement='no'&gt;
        &lt;b:widget id='Header1' locked='true' title='JTechLog (fejléc)' type='Header'&gt;
          &lt;b:includable id='main'&gt;

  &lt;b:if cond='data:useImage'&gt;
    &lt;b:if cond='data:imagePlacement == &amp;quot;BEHIND&amp;quot;'&gt;
      &lt;!--
      Show image as background to text. You can't really calculate the width
      reliably in JS because margins are not taken into account by any of
      clientWidth, offsetWidth or scrollWidth, so we don't force a minimum
      width if the user is using shrink to fit.
      This results in a margin-width's worth of pixels being cropped. If the
      user is not using shrink to fit then we expand the header.
      --&gt;
      &lt;b:if cond='data:mobile'&gt;
          &lt;div id='header-inner'&gt;
            &lt;div class='titlewrapper' style='background: transparent'&gt;
              &lt;h1 class='title' style='background: transparent; border-width: 0px'&gt;
                &lt;b:include name='title'/&gt;
              &lt;/h1&gt;
            &lt;/div&gt;
            &lt;b:include name='description'/&gt;
          &lt;/div&gt;
        &lt;b:else/&gt;
          &lt;div expr:style='&amp;quot;background-image: url(\&amp;quot;&amp;quot; + data:sourceUrl + &amp;quot;\&amp;quot;); &amp;quot;                        + &amp;quot;background-position: &amp;quot;                        + data:backgroundPositionStyleStr + &amp;quot;; &amp;quot;                        + data:widthStyleStr                        + &amp;quot;min-height: &amp;quot; + data:height                        + &amp;quot;_height: &amp;quot; + data:height                        + &amp;quot;background-repeat: no-repeat; &amp;quot;' id='header-inner'&gt;
            &lt;div class='titlewrapper' style='background: transparent'&gt;
              &lt;h1 class='title' style='background: transparent; border-width: 0px'&gt;
                &lt;b:include name='title'/&gt;
              &lt;/h1&gt;
            &lt;/div&gt;
            &lt;b:include name='description'/&gt;
          &lt;/div&gt;
        &lt;/b:if&gt;
    &lt;b:else/&gt;
      &lt;!--Show the image only--&gt;
      &lt;div id='header-inner'&gt;
        &lt;a expr:href='data:blog.homepageUrl' style='display: block'&gt;
          &lt;img expr:alt='data:title' expr:height='data:height' expr:id='data:widget.instanceId + &amp;quot;_headerimg&amp;quot;' expr:src='data:sourceUrl' expr:width='data:width' style='display: block'/&gt;
        &lt;/a&gt;
        &lt;!--Show the description--&gt;
        &lt;b:if cond='data:imagePlacement == &amp;quot;BEFORE_DESCRIPTION&amp;quot;'&gt;
          &lt;b:include name='description'/&gt;
        &lt;/b:if&gt;
      &lt;/div&gt;
    &lt;/b:if&gt;
  &lt;b:else/&gt;
    &lt;!--No header image --&gt;
    &lt;div id='header-inner'&gt;
      &lt;div class='titlewrapper'&gt;
        &lt;h1 class='title'&gt;
          &lt;b:include name='title'/&gt;
        &lt;/h1&gt;
      &lt;/div&gt;
      &lt;b:include name='description'/&gt;
    &lt;/div&gt;
  &lt;/b:if&gt;
&lt;/b:includable&gt;
          &lt;b:includable id='description'&gt;
  &lt;div class='descriptionwrapper'&gt;
    &lt;p class='description'&gt;&lt;span&gt;&lt;data:description/&gt;&lt;/span&gt;&lt;/p&gt;
  &lt;/div&gt;
&lt;/b:includable&gt;
          &lt;b:includable id='title'&gt;
  &lt;b:if cond='data:blog.url == data:blog.homepageUrl'&gt;
    &lt;data:title/&gt;
  &lt;b:else/&gt;
    &lt;a expr:href='data:blog.homepageUrl'&gt;&lt;data:title/&gt;&lt;/a&gt;
  &lt;/b:if&gt;
&lt;/b:includable&gt;
        &lt;/b:widget&gt;
      &lt;/b:section&gt;
    &lt;/div&gt;
 
    &lt;div id='content-wrapper'&gt;

      &lt;div id='crosscol-wrapper' style='text-align:center'&gt;
        &lt;b:section class='crosscol' id='crosscol' showaddelement='no'/&gt;
      &lt;/div&gt;

      &lt;div id='main-wrapper'&gt;
        &lt;b:section class='main' id='main' showaddelement='no'&gt;
          &lt;b:widget id='Blog1' locked='true' title='Blogbejegyzések' type='Blog'&gt;
            &lt;b:includable id='main' var='top'&gt;
  &lt;b:if cond='data:mobile == &amp;quot;false&amp;quot;'&gt;

    &lt;!-- posts --&gt;
    &lt;div class='blog-posts hfeed'&gt;

      &lt;b:include data='top' name='status-message'/&gt;

      &lt;data:defaultAdStart/&gt;
      &lt;b:loop values='data:posts' var='post'&gt;
        &lt;b:if cond='data:post.isDateStart'&gt;
          &lt;b:if cond='data:post.isFirstPost == &amp;quot;false&amp;quot;'&gt;
            &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;
          &lt;/b:if&gt;
        &lt;/b:if&gt;
        &lt;b:if cond='data:post.isDateStart'&gt;
          &amp;lt;div class=&amp;quot;date-outer&amp;quot;&amp;gt;
        &lt;/b:if&gt;
        &lt;b:if cond='data:post.dateHeader'&gt;
          &lt;div class='date-header'&gt;&lt;span&gt;&lt;data:post.dateHeader/&gt;&lt;/span&gt;&lt;/div&gt;
        &lt;/b:if&gt;
        &lt;b:if cond='data:post.isDateStart'&gt;
          &amp;lt;div class=&amp;quot;date-posts&amp;quot;&amp;gt;
        &lt;/b:if&gt;
        &lt;div class='post-outer'&gt;
        &lt;b:include data='post' name='post'/&gt;
        &lt;b:if cond='data:blog.pageType == &amp;quot;static_page&amp;quot;'&gt;
          &lt;b:include data='post' name='comment_picker'/&gt;
        &lt;/b:if&gt;
        &lt;b:if cond='data:blog.pageType == &amp;quot;item&amp;quot;'&gt;
          &lt;b:include data='post' name='comment_picker'/&gt;
        &lt;/b:if&gt;
        &lt;/div&gt;
        &lt;b:if cond='data:post.includeAd'&gt;
          &lt;b:if cond='data:post.isFirstPost'&gt;
            &lt;data:defaultAdEnd/&gt;
          &lt;b:else/&gt;
            &lt;data:adEnd/&gt;
          &lt;/b:if&gt;
          &lt;div class='inline-ad'&gt;
            &lt;data:adCode/&gt;
          &lt;/div&gt;
          &lt;data:adStart/&gt;
        &lt;/b:if&gt;
      &lt;/b:loop&gt;
      &lt;b:if cond='data:numPosts != 0'&gt;
        &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;
      &lt;/b:if&gt;
      &lt;data:adEnd/&gt;
    &lt;/div&gt;

    &lt;!-- navigation --&gt;
    &lt;b:include name='nextprev'/&gt;

    &lt;!-- feed links --&gt;
    &lt;b:include name='feedLinks'/&gt;

    &lt;b:if cond='data:top.showStars'&gt;
      &lt;script src='//www.google.com/jsapi' type='text/javascript'/&gt;
      &lt;script type='text/javascript'&gt;
        google.load(&amp;quot;annotations&amp;quot;, &amp;quot;1&amp;quot;, {&amp;quot;locale&amp;quot;: &amp;quot;&lt;data:top.languageCode/&gt;&amp;quot;});
        function initialize() {
          google.annotations.setApplicationId(&lt;data:top.blogspotReviews/&gt;);
          google.annotations.createAll();
          google.annotations.fetch();
        }
        google.setOnLoadCallback(initialize);
      &lt;/script&gt;
    &lt;/b:if&gt;

  &lt;b:else/&gt;
    &lt;b:include name='mobile-main'/&gt;
  &lt;/b:if&gt;

  &lt;b:if cond='data:top.showDummy'&gt;
    &lt;data:top.dummyBootstrap/&gt;
  &lt;/b:if&gt;

&lt;/b:includable&gt;
            &lt;b:includable id='backlinkDeleteIcon' var='backlink'&gt;
  &lt;span expr:class='&amp;quot;item-control &amp;quot; + data:backlink.adminClass'&gt;
    &lt;a expr:href='data:backlink.deleteUrl' expr:title='data:top.deleteBacklinkMsg'&gt;
      &lt;img src='//www.blogger.com/img/icon_delete13.gif'/&gt;
    &lt;/a&gt;
  &lt;/span&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='backlinks' var='post'&gt;
  &lt;a name='links'/&gt;&lt;h4&gt;&lt;data:post.backlinksLabel/&gt;&lt;/h4&gt;
  &lt;b:if cond='data:post.numBacklinks != 0'&gt;
    &lt;dl class='comments-block' id='comments-block'&gt;
      &lt;b:loop values='data:post.backlinks' var='backlink'&gt;
        &lt;div class='collapsed-backlink backlink-control'&gt;
          &lt;dt class='comment-title'&gt;
            &lt;span class='backlink-toggle-zippy'&gt;&amp;#160;&lt;/span&gt;
            &lt;a expr:href='data:backlink.url' rel='nofollow'&gt;&lt;data:backlink.title/&gt;&lt;/a&gt;
            &lt;b:include data='backlink' name='backlinkDeleteIcon'/&gt;
          &lt;/dt&gt;
          &lt;dd class='comment-body collapseable'&gt;
            &lt;data:backlink.snippet/&gt;
          &lt;/dd&gt;
          &lt;dd class='comment-footer collapseable'&gt;
            &lt;span class='comment-author'&gt;&lt;data:post.authorLabel/&gt; &lt;data:backlink.author/&gt;&lt;/span&gt;
            &lt;span class='comment-timestamp'&gt;&lt;data:post.timestampLabel/&gt; &lt;data:backlink.timestamp/&gt;&lt;/span&gt;
          &lt;/dd&gt;
        &lt;/div&gt;
      &lt;/b:loop&gt;
    &lt;/dl&gt;
  &lt;/b:if&gt;
  &lt;p class='comment-footer'&gt;
    &lt;a class='comment-link' expr:href='data:post.createLinkUrl' expr:id='data:widget.instanceId + &amp;quot;_backlinks-create-link&amp;quot;' target='_blank'&gt;&lt;data:post.createLinkLabel/&gt;&lt;/a&gt;
  &lt;/p&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='comment-form' var='post'&gt;
  &lt;div class='comment-form'&gt;
    &lt;a name='comment-form'/&gt;
    &lt;b:if cond='data:mobile'&gt;
      &lt;h4 id='comment-post-message'&gt;
        &lt;a expr:id='data:widget.instanceId + &amp;quot;_comment-editor-toggle-link&amp;quot;' href='javascript:void(0)'&gt;&lt;data:postCommentMsg/&gt;&lt;/a&gt;&lt;/h4&gt;
      &lt;p&gt;&lt;data:blogCommentMessage/&gt;&lt;/p&gt;
      &lt;data:blogTeamBlogMessage/&gt;
      &lt;a expr:href='data:post.commentFormIframeSrc' id='comment-editor-src'/&gt;
      &lt;iframe allowtransparency='true' class='blogger-iframe-colorize blogger-comment-from-post' frameborder='0' height='410' id='comment-editor' name='comment-editor' src='' style='display: none' width='100%'/&gt;
    &lt;b:else/&gt;
      &lt;h4 id='comment-post-message'&gt;&lt;data:postCommentMsg/&gt;&lt;/h4&gt;
      &lt;p&gt;&lt;data:blogCommentMessage/&gt;&lt;/p&gt;
      &lt;data:blogTeamBlogMessage/&gt;
      &lt;a expr:href='data:post.commentFormIframeSrc' id='comment-editor-src'/&gt;
      &lt;iframe allowtransparency='true' class='blogger-iframe-colorize blogger-comment-from-post' frameborder='0' height='410' id='comment-editor' name='comment-editor' src='' width='100%'/&gt;
    &lt;/b:if&gt;
    &lt;data:post.friendConnectJs/&gt;
    &lt;data:post.cmtfpIframe/&gt;
    &lt;script type='text/javascript'&gt;
      BLOG_CMT_createIframe(&amp;#39;&lt;data:post.appRpcRelayPath/&gt;&amp;#39;);
    &lt;/script&gt;
  &lt;/div&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='commentDeleteIcon' var='comment'&gt;
  &lt;span expr:class='&amp;quot;item-control &amp;quot; + data:comment.adminClass'&gt;
    &lt;b:if cond='data:showCmtPopup'&gt;
      &lt;div class='goog-toggle-button'&gt;
        &lt;div class='goog-inline-block comment-action-icon'/&gt;
      &lt;/div&gt;
    &lt;b:else/&gt;
      &lt;a class='comment-delete' expr:href='data:comment.deleteUrl' expr:title='data:top.deleteCommentMsg'&gt;
        &lt;img src='//www.blogger.com/img/icon_delete13.gif'/&gt;
      &lt;/a&gt;
    &lt;/b:if&gt;
  &lt;/span&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='comment_count_picker' var='post'&gt;
  &lt;b:if cond='data:post.commentSource == 1'&gt;
    &lt;span class='cmt_count_iframe_holder' expr:data-count='data:post.numComments' expr:data-onclick='data:post.addCommentOnclick' expr:data-post-url='data:post.url' expr:data-url='data:post.canonicalUrl'&gt;
    &lt;/span&gt;
  &lt;b:else/&gt;
    &lt;a class='comment-link' expr:href='data:post.addCommentUrl' expr:onclick='data:post.addCommentOnclick'&gt;
      &lt;data:post.commentLabelFull/&gt;:
    &lt;/a&gt;
  &lt;/b:if&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='comment_picker' var='post'&gt;
  &lt;b:if cond='data:post.commentSource == 1'&gt;
    &lt;b:include data='post' name='iframe_comments'/&gt;
  &lt;b:else/&gt;
    &lt;b:if cond='data:post.showThreadedComments'&gt;
      &lt;b:include data='post' name='threaded_comments'/&gt;
    &lt;b:else/&gt;
      &lt;b:include data='post' name='comments'/&gt;
    &lt;/b:if&gt;
  &lt;/b:if&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='comments' var='post'&gt;
  &lt;div class='comments' id='comments'&gt;
    &lt;a name='comments'/&gt;
    &lt;b:if cond='data:post.allowComments'&gt;
      &lt;h4&gt;&lt;data:post.commentLabelFull/&gt;:&lt;/h4&gt;

      &lt;b:if cond='data:post.commentPagingRequired'&gt;
        &lt;span class='paging-control-container'&gt;
          &lt;b:if cond='data:post.hasOlderLinks'&gt;
            &lt;a expr:class='data:post.oldLinkClass' expr:href='data:post.oldestLinkUrl'&gt;&lt;data:post.oldestLinkText/&gt;&lt;/a&gt;
              &amp;#160;
            &lt;a expr:class='data:post.oldLinkClass' expr:href='data:post.olderLinkUrl'&gt;&lt;data:post.olderLinkText/&gt;&lt;/a&gt;
              &amp;#160;
          &lt;/b:if&gt;

          &lt;data:post.commentRangeText/&gt;

          &lt;b:if cond='data:post.hasNewerLinks'&gt;
            &amp;#160;
            &lt;a expr:class='data:post.newLinkClass' expr:href='data:post.newerLinkUrl'&gt;&lt;data:post.newerLinkText/&gt;&lt;/a&gt;
            &amp;#160;
            &lt;a expr:class='data:post.newLinkClass' expr:href='data:post.newestLinkUrl'&gt;&lt;data:post.newestLinkText/&gt;&lt;/a&gt;
          &lt;/b:if&gt;
        &lt;/span&gt;
      &lt;/b:if&gt;

      &lt;div expr:id='data:widget.instanceId + &amp;quot;_comments-block-wrapper&amp;quot;'&gt;
        &lt;dl expr:class='data:post.avatarIndentClass' id='comments-block'&gt;
          &lt;b:loop values='data:post.comments' var='comment'&gt;
            &lt;dt expr:class='&amp;quot;comment-author &amp;quot; + data:comment.authorClass' expr:id='data:comment.anchorName'&gt;
              &lt;b:if cond='data:comment.favicon'&gt;
                &lt;img expr:src='data:comment.favicon' height='16px' style='margin-bottom:-2px;' width='16px'/&gt;
              &lt;/b:if&gt;
              &lt;a expr:name='data:comment.anchorName'/&gt;
              &lt;b:if cond='data:blog.enabledCommentProfileImages'&gt;
                &lt;data:comment.authorAvatarImage/&gt;
              &lt;/b:if&gt;
              &lt;b:if cond='data:comment.authorUrl'&gt;
                &lt;a expr:href='data:comment.authorUrl' rel='nofollow'&gt;&lt;data:comment.author/&gt;&lt;/a&gt;
              &lt;b:else/&gt;
                &lt;data:comment.author/&gt;
              &lt;/b:if&gt;
              &lt;data:commentPostedByMsg/&gt;
            &lt;/dt&gt;
            &lt;dd class='comment-body' expr:id='data:widget.instanceId + data:comment.cmtBodyIdPostfix'&gt;
              &lt;b:if cond='data:comment.isDeleted'&gt;
                &lt;span class='deleted-comment'&gt;&lt;data:comment.body/&gt;&lt;/span&gt;
              &lt;b:else/&gt;
                &lt;p&gt;
                  &lt;data:comment.body/&gt;
                &lt;/p&gt;
              &lt;/b:if&gt;
            &lt;/dd&gt;
            &lt;dd class='comment-footer'&gt;
              &lt;span class='comment-timestamp'&gt;
                &lt;a expr:href='data:comment.url' title='comment permalink'&gt;
                  &lt;data:comment.timestamp/&gt;
                &lt;/a&gt;
                &lt;b:include data='comment' name='commentDeleteIcon'/&gt;
              &lt;/span&gt;
            &lt;/dd&gt;
          &lt;/b:loop&gt;
        &lt;/dl&gt;
      &lt;/div&gt;

      &lt;b:if cond='data:post.commentPagingRequired'&gt;
        &lt;span class='paging-control-container'&gt;
          &lt;a expr:class='data:post.oldLinkClass' expr:href='data:post.oldestLinkUrl'&gt;
            &lt;data:post.oldestLinkText/&gt;
          &lt;/a&gt;
          &lt;a expr:class='data:post.oldLinkClass' expr:href='data:post.olderLinkUrl'&gt;
            &lt;data:post.olderLinkText/&gt;
          &lt;/a&gt;
          &amp;#160;
          &lt;data:post.commentRangeText/&gt;
          &amp;#160;
          &lt;a expr:class='data:post.newLinkClass' expr:href='data:post.newerLinkUrl'&gt;
            &lt;data:post.newerLinkText/&gt;
          &lt;/a&gt;
          &lt;a expr:class='data:post.newLinkClass' expr:href='data:post.newestLinkUrl'&gt;
            &lt;data:post.newestLinkText/&gt;
          &lt;/a&gt;
        &lt;/span&gt;
      &lt;/b:if&gt;

      &lt;p class='comment-footer'&gt;
        &lt;b:if cond='data:post.embedCommentForm'&gt;
          &lt;b:if cond='data:post.allowNewComments'&gt;
            &lt;b:include data='post' name='comment-form'/&gt;
          &lt;b:else/&gt;
            &lt;data:post.noNewCommentsText/&gt;
          &lt;/b:if&gt;
        &lt;b:else/&gt;
          &lt;b:if cond='data:post.allowComments'&gt;
            &lt;a expr:href='data:post.addCommentUrl' expr:onclick='data:post.addCommentOnclick'&gt;&lt;data:postCommentMsg/&gt;&lt;/a&gt;
          &lt;/b:if&gt;
        &lt;/b:if&gt;

      &lt;/p&gt;
    &lt;/b:if&gt;
    &lt;b:if cond='data:showCmtPopup'&gt;
      &lt;div id='comment-popup'&gt;
        &lt;iframe allowtransparency='true' frameborder='0' id='comment-actions' name='comment-actions' scrolling='no'&gt;
        &lt;/iframe&gt;
      &lt;/div&gt;
    &lt;/b:if&gt;

    &lt;div id='backlinks-container'&gt;
    &lt;div expr:id='data:widget.instanceId + &amp;quot;_backlinks-container&amp;quot;'&gt;
       &lt;b:if cond='data:post.showBacklinks'&gt;
         &lt;b:include data='post' name='backlinks'/&gt;
       &lt;/b:if&gt;
    &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='feedLinks'&gt;
  &lt;b:if cond='data:blog.pageType != &amp;quot;item&amp;quot;'&gt; &lt;!-- Blog feed links --&gt;
    &lt;b:if cond='data:feedLinks'&gt;
      &lt;div class='blog-feeds'&gt;
        &lt;b:include data='feedLinks' name='feedLinksBody'/&gt;
      &lt;/div&gt;
    &lt;/b:if&gt;

    &lt;b:else/&gt; &lt;!--Post feed links --&gt;
    &lt;div class='post-feeds'&gt;
      &lt;b:loop values='data:posts' var='post'&gt;
        &lt;b:if cond='data:post.allowComments'&gt;
          &lt;b:if cond='data:post.feedLinks'&gt;
            &lt;b:include data='post.feedLinks' name='feedLinksBody'/&gt;
          &lt;/b:if&gt;
        &lt;/b:if&gt;
      &lt;/b:loop&gt;
    &lt;/div&gt;
  &lt;/b:if&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='feedLinksBody' var='links'&gt;
  &lt;div class='feed-links'&gt;
  &lt;data:feedLinksMsg/&gt;
  &lt;b:loop values='data:links' var='f'&gt;
     &lt;a class='feed-link' expr:href='data:f.url' expr:type='data:f.mimeType' target='_blank'&gt;&lt;data:f.name/&gt; (&lt;data:f.feedType/&gt;)&lt;/a&gt;
  &lt;/b:loop&gt;
  &lt;/div&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='iframe_comments' var='post'&gt;

  &lt;b:if cond='data:post.allowIframeComments'&gt;
    &lt;script expr:src='data:post.iframeCommentSrc' type='text/javascript'/&gt;
    &lt;div class='cmt_iframe_holder' expr:data-href='data:post.canonicalUrl' expr:data-viewtype='data:post.viewType'/&gt;

    &lt;b:if cond='data:post.embedCommentForm == &amp;quot;false&amp;quot;'&gt;
      &lt;a expr:href='data:post.addCommentUrl' expr:onclick='data:post.addCommentOnclick'&gt;&lt;data:postCommentMsg/&gt;&lt;/a&gt;
    &lt;/b:if&gt;
  &lt;/b:if&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='mobile-index-post' var='post'&gt;
  &lt;div class='mobile-date-outer date-outer'&gt;
    &lt;b:if cond='data:post.dateHeader'&gt;
      &lt;div class='date-header'&gt;
        &lt;span&gt;&lt;data:post.dateHeader/&gt;&lt;/span&gt;
      &lt;/div&gt;
    &lt;/b:if&gt;

    &lt;div class='mobile-post-outer'&gt;
      &lt;a expr:href='data:post.url'&gt;
        &lt;h2 class='mobile-index-title entry-title' itemprop='name'&gt;
          &lt;data:post.title/&gt;
        &lt;/h2&gt;

        &lt;div class='mobile-index-arrow'&gt;&amp;amp;rsaquo;&lt;/div&gt;

        &lt;div class='mobile-index-contents'&gt;
          &lt;b:if cond='data:post.thumbnailUrl'&gt;
            &lt;div class='mobile-index-thumbnail'&gt;
              &lt;div class='Image'&gt;
                &lt;img expr:src='data:post.thumbnailUrl'/&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/b:if&gt;

          &lt;div class='post-body'&gt;
            &lt;b:if cond='data:post.snippet'&gt;&lt;data:post.snippet/&gt;&lt;/b:if&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        &lt;div style='clear: both;'/&gt;
      &lt;/a&gt;

      &lt;div class='mobile-index-comment'&gt;
        &lt;b:if cond='data:blog.pageType != &amp;quot;static_page&amp;quot;'&gt;
          &lt;b:if cond='data:post.allowComments'&gt;
            &lt;b:if cond='data:post.numComments != 0'&gt;
              &lt;b:include data='post' name='comment_count_picker'/&gt;
            &lt;/b:if&gt;
          &lt;/b:if&gt;
        &lt;/b:if&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='mobile-main' var='top'&gt;
    &lt;!-- posts --&gt;
    &lt;div class='blog-posts hfeed'&gt;

      &lt;b:include data='top' name='status-message'/&gt;

      &lt;b:if cond='data:blog.pageType == &amp;quot;index&amp;quot;'&gt;
        &lt;b:loop values='data:posts' var='post'&gt;
          &lt;b:include data='post' name='mobile-index-post'/&gt;
        &lt;/b:loop&gt;
      &lt;b:else/&gt;
        &lt;b:loop values='data:posts' var='post'&gt;
          &lt;b:include data='post' name='mobile-post'/&gt;
        &lt;/b:loop&gt;
      &lt;/b:if&gt;
    &lt;/div&gt;

   &lt;b:include name='mobile-nextprev'/&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='mobile-nextprev'&gt;
  &lt;div class='blog-pager' id='blog-pager'&gt;
    &lt;b:if cond='data:newerPageUrl'&gt;
      &lt;div class='mobile-link-button' id='blog-pager-newer-link'&gt;
      &lt;a class='blog-pager-newer-link' expr:href='data:newerPageUrl' expr:id='data:widget.instanceId + &amp;quot;_blog-pager-newer-link&amp;quot;' expr:title='data:newerPageTitle'&gt;&amp;amp;lsaquo;&lt;/a&gt;
      &lt;/div&gt;
    &lt;/b:if&gt;

    &lt;b:if cond='data:olderPageUrl'&gt;
      &lt;div class='mobile-link-button' id='blog-pager-older-link'&gt;
      &lt;a class='blog-pager-older-link' expr:href='data:olderPageUrl' expr:id='data:widget.instanceId + &amp;quot;_blog-pager-older-link&amp;quot;' expr:title='data:olderPageTitle'&gt;&amp;amp;rsaquo;&lt;/a&gt;
      &lt;/div&gt;
    &lt;/b:if&gt;

    &lt;div class='mobile-link-button' id='blog-pager-home-link'&gt;
    &lt;a class='home-link' expr:href='data:blog.homepageUrl'&gt;&lt;data:homeMsg/&gt;&lt;/a&gt;
    &lt;/div&gt;

    &lt;div class='mobile-desktop-link'&gt;
      &lt;a class='home-link' expr:href='data:desktopLinkUrl'&gt;&lt;data:desktopLinkMsg/&gt;&lt;/a&gt;
    &lt;/div&gt;

  &lt;/div&gt;
  &lt;div class='clear'/&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='mobile-post' var='post'&gt;
  &lt;div class='date-outer'&gt;
    &lt;b:if cond='data:post.dateHeader'&gt;
      &lt;div class='date-header'&gt;&lt;span&gt;&lt;data:post.dateHeader/&gt;&lt;/span&gt;&lt;/div&gt;
    &lt;/b:if&gt;
    &lt;div class='date-posts'&gt;
      &lt;div class='post-outer'&gt;

        &lt;div class='post hentry uncustomized-post-template' itemscope='itemscope' itemtype='http://schema.org/BlogPosting'&gt;
          &lt;b:if cond='data:post.thumbnailUrl'&gt;
            &lt;meta expr:content='data:post.thumbnailUrl' itemprop='image_url'/&gt;
          &lt;/b:if&gt;
          &lt;meta expr:content='data:blog.blogId' itemprop='blogId'/&gt;
          &lt;meta expr:content='data:post.id' itemprop='postId'/&gt;

          &lt;a expr:name='data:post.id'/&gt;
          &lt;b:if cond='data:post.title'&gt;
            &lt;h2 class='post-title entry-title' itemprop='name'&gt;
              &lt;b:if cond='data:post.link'&gt;
                &lt;a expr:href='data:post.link'&gt;&lt;data:post.title/&gt;&lt;/a&gt;
              &lt;b:else/&gt;
                &lt;b:if cond='data:post.url'&gt;
                  &lt;b:if cond='data:blog.url != data:post.url'&gt;
                    &lt;a expr:href='data:post.url'&gt;&lt;data:post.title/&gt;&lt;/a&gt;
                  &lt;b:else/&gt;
                    &lt;data:post.title/&gt;
                  &lt;/b:if&gt;
                &lt;b:else/&gt;
                  &lt;data:post.title/&gt;
                &lt;/b:if&gt;
              &lt;/b:if&gt;
            &lt;/h2&gt;
          &lt;/b:if&gt;

          &lt;div class='post-header'&gt;
            &lt;div class='post-header-line-1'/&gt;
          &lt;/div&gt;

          &lt;div class='post-body entry-content' expr:id='&amp;quot;post-body-&amp;quot; + data:post.id' itemprop='articleBody'&gt;
            &lt;data:post.body/&gt;
            &lt;div style='clear: both;'/&gt; &lt;!-- clear for photos floats --&gt;
          &lt;/div&gt;

          &lt;div class='post-footer'&gt;
            &lt;div class='post-footer-line post-footer-line-1'&gt;
              &lt;span class='post-author vcard'&gt;
                &lt;b:if cond='data:top.showAuthor'&gt;
                  &lt;b:if cond='data:post.authorProfileUrl'&gt;
                    &lt;span class='fn' itemprop='author' itemscope='itemscope' itemtype='http://schema.org/Person'&gt;
                      &lt;meta expr:content='data:post.authorProfileUrl' itemprop='url'/&gt;
                      &lt;a expr:href='data:post.authorProfileUrl' rel='author' title='author profile'&gt;
                        &lt;span itemprop='name'&gt;&lt;data:post.author/&gt;&lt;/span&gt;
                      &lt;/a&gt;
                    &lt;/span&gt;
                  &lt;b:else/&gt;
                    &lt;span class='fn' itemprop='author' itemscope='itemscope' itemtype='http://schema.org/Person'&gt;
                      &lt;span itemprop='name'&gt;&lt;data:post.author/&gt;&lt;/span&gt;
                    &lt;/span&gt;
                  &lt;/b:if&gt;
                &lt;/b:if&gt;
              &lt;/span&gt;

              &lt;span class='post-timestamp'&gt;
                &lt;b:if cond='data:top.showTimestamp'&gt;
                  &lt;data:top.timestampLabel/&gt;
                  &lt;b:if cond='data:post.url'&gt;
                    &lt;meta expr:content='data:post.canonicalUrl' itemprop='url'/&gt;
                    &lt;a class='timestamp-link' expr:href='data:post.url' rel='bookmark' title='permanent link'&gt;&lt;abbr class='published' expr:title='data:post.timestampISO8601' itemprop='datePublished'&gt;&lt;data:post.timestamp/&gt;&lt;/abbr&gt;&lt;/a&gt;
                  &lt;/b:if&gt;
                &lt;/b:if&gt;
              &lt;/span&gt;

              &lt;span class='post-comment-link'&gt;
                &lt;b:if cond='data:blog.pageType != &amp;quot;item&amp;quot;'&gt;
                  &lt;b:if cond='data:blog.pageType != &amp;quot;static_page&amp;quot;'&gt;
                    &lt;b:if cond='data:post.allowComments'&gt;
                      &lt;b:include data='post' name='comment_count_picker'/&gt;
                    &lt;/b:if&gt;
                  &lt;/b:if&gt;
                &lt;/b:if&gt;
              &lt;/span&gt;
            &lt;/div&gt;

            &lt;div class='post-footer-line post-footer-line-2'&gt;
              &lt;b:if cond='data:top.showMobileShare'&gt;
                &lt;div class='mobile-link-button goog-inline-block' id='mobile-share-button'&gt;
                  &lt;a href='javascript:void(0);'&gt;&lt;data:shareMsg/&gt;&lt;/a&gt;
                &lt;/div&gt;
              &lt;/b:if&gt;
              &lt;b:if cond='data:top.showDummy'&gt;
                &lt;div class='goog-inline-block dummy-container'&gt;&lt;data:post.dummyTag/&gt;&lt;/div&gt;
              &lt;/b:if&gt;
            &lt;/div&gt;

          &lt;/div&gt;
        &lt;/div&gt;

        &lt;b:if cond='data:blog.pageType == &amp;quot;static_page&amp;quot;'&gt;
          &lt;b:include data='post' name='comment_picker'/&gt;
        &lt;/b:if&gt;
        &lt;b:if cond='data:blog.pageType == &amp;quot;item&amp;quot;'&gt;
          &lt;b:include data='post' name='comment_picker'/&gt;
        &lt;/b:if&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='nextprev'&gt;
  &lt;div class='blog-pager' id='blog-pager'&gt;
    &lt;b:if cond='data:newerPageUrl'&gt;
      &lt;span id='blog-pager-newer-link'&gt;
      &lt;a class='blog-pager-newer-link' expr:href='data:newerPageUrl' expr:id='data:widget.instanceId + &amp;quot;_blog-pager-newer-link&amp;quot;' expr:title='data:newerPageTitle'&gt;&lt;data:newerPageTitle/&gt;&lt;/a&gt;
      &lt;/span&gt;
    &lt;/b:if&gt;

    &lt;b:if cond='data:olderPageUrl'&gt;
      &lt;span id='blog-pager-older-link'&gt;
      &lt;a class='blog-pager-older-link' expr:href='data:olderPageUrl' expr:id='data:widget.instanceId + &amp;quot;_blog-pager-older-link&amp;quot;' expr:title='data:olderPageTitle'&gt;&lt;data:olderPageTitle/&gt;&lt;/a&gt;
      &lt;/span&gt;
    &lt;/b:if&gt;

    &lt;a class='home-link' expr:href='data:blog.homepageUrl'&gt;&lt;data:homeMsg/&gt;&lt;/a&gt;

    &lt;b:if cond='data:mobileLinkUrl'&gt;
      &lt;div class='blog-mobile-link'&gt;
        &lt;a expr:href='data:mobileLinkUrl'&gt;&lt;data:mobileLinkMsg/&gt;&lt;/a&gt;
      &lt;/div&gt;
    &lt;/b:if&gt;

  &lt;/div&gt;
  &lt;div class='clear'/&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='post' var='post'&gt;
  &lt;div class='post hentry'&gt;
    &lt;a expr:name='data:post.id'/&gt;
    &lt;b:if cond='data:post.title'&gt;
      &lt;h2 class='post-title entry-title'&gt;
     &lt;b:if cond='data:post.link'&gt;
       &lt;a expr:href='data:post.link'&gt;&lt;data:post.title/&gt;&lt;/a&gt;
     &lt;b:else/&gt;
        &lt;b:if cond='data:post.url'&gt;
          &lt;a expr:href='data:post.url'&gt;&lt;data:post.title/&gt;&lt;/a&gt;
        &lt;b:else/&gt;
          &lt;data:post.title/&gt;
        &lt;/b:if&gt;
     &lt;/b:if&gt;
      &lt;/h2&gt;
    &lt;/b:if&gt;

    &lt;div class='post-header'&gt;
    &lt;div class='post-header-line-1'/&gt;
    &lt;/div&gt;

    &lt;div class='post-body entry-content'&gt;
      &lt;data:post.body/&gt;
      &lt;div style='clear: both;'/&gt; &lt;!-- clear for photos floats --&gt;
    &lt;/div&gt;

    &lt;b:if cond='data:post.hasJumpLink'&gt;
      &lt;div class='jump-link'&gt;
        &lt;a expr:href='data:post.url + &amp;quot;#more&amp;quot;' expr:title='data:post.title'&gt;&lt;data:post.jumpText/&gt;&lt;/a&gt;
      &lt;/div&gt;
    &lt;/b:if&gt;

    &lt;div class='post-footer'&gt;
    &lt;div class='post-footer-line post-footer-line-1'&gt;&lt;span class='post-author vcard'&gt;
        &lt;b:if cond='data:top.showAuthor'&gt;
          &lt;data:top.authorLabel/&gt;
          &lt;span class='fn'&gt;&lt;data:post.author/&gt;&lt;/span&gt;
        &lt;/b:if&gt;
      &lt;/span&gt; &lt;span class='post-timestamp'&gt;
        &lt;b:if cond='data:top.showTimestamp'&gt;
          &lt;data:top.timestampLabel/&gt;
        &lt;b:if cond='data:post.url'&gt;
          &lt;a class='timestamp-link' expr:href='data:post.url' rel='bookmark' title='permanent link'&gt;&lt;abbr class='published' expr:title='data:post.timestampISO8601'&gt;&lt;data:post.timestamp/&gt;&lt;/abbr&gt;&lt;/a&gt;
        &lt;/b:if&gt;
        &lt;/b:if&gt;
      &lt;/span&gt; &lt;span class='post-comment-link'&gt;
        &lt;b:if cond='data:blog.pageType != &amp;quot;item&amp;quot;'&gt;
          &lt;b:if cond='data:blog.pageType != &amp;quot;static_page&amp;quot;'&gt;
            &lt;b:if cond='data:post.allowComments'&gt;
              &lt;a class='comment-link' expr:href='data:post.addCommentUrl' expr:onclick='data:post.addCommentOnclick'&gt;&lt;b:if cond='data:post.numComments == 1'&gt;1 &lt;data:top.commentLabel/&gt;&lt;b:else/&gt;&lt;data:post.numComments/&gt; &lt;data:top.commentLabelPlural/&gt;&lt;/b:if&gt;&lt;/a&gt;
            &lt;/b:if&gt;
          &lt;/b:if&gt;
        &lt;/b:if&gt;
      &lt;/span&gt; &lt;span class='post-icons'&gt;
        &lt;!-- email post links --&gt;
        &lt;b:if cond='data:post.emailPostUrl'&gt;
          &lt;span class='item-action'&gt;
          &lt;a expr:href='data:post.emailPostUrl' expr:title='data:top.emailPostMsg'&gt;
              &lt;img alt='' class='icon-action' height='13' src='http://img1.blogblog.com/img/icon18_email.gif' width='18'/&gt;
          &lt;/a&gt;
          &lt;/span&gt;
        &lt;/b:if&gt;

        &lt;!-- quickedit pencil --&gt;
        &lt;b:include data='post' name='postQuickEdit'/&gt;
      &lt;/span&gt; &lt;div class='post-share-buttons'&gt;
      &lt;/div&gt; &lt;/div&gt;

      &lt;div class='post-footer-line post-footer-line-2'&gt;&lt;span class='post-labels'&gt;
        &lt;b:if cond='data:post.labels'&gt;
          &lt;data:postLabelsLabel/&gt;
          &lt;b:loop values='data:post.labels' var='label'&gt;
            &lt;a expr:href='data:label.url' rel='tag'&gt;&lt;data:label.name/&gt;&lt;/a&gt;&lt;b:if cond='data:label.isLast != &amp;quot;true&amp;quot;'&gt;,&lt;/b:if&gt;
          &lt;/b:loop&gt;
        &lt;/b:if&gt;
      &lt;/span&gt; &lt;/div&gt;

      &lt;div class='post-footer-line post-footer-line-3'/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='postQuickEdit' var='post'&gt;
  &lt;b:if cond='data:post.editUrl'&gt;
    &lt;span expr:class='&amp;quot;item-control &amp;quot; + data:post.adminClass'&gt;
      &lt;a expr:href='data:post.editUrl' expr:title='data:top.editPostMsg'&gt;
        &lt;img alt='' class='icon-action' height='18' src='http://img2.blogblog.com/img/icon18_edit_allbkg.gif' width='18'/&gt;
      &lt;/a&gt;
    &lt;/span&gt;
  &lt;/b:if&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='shareButtons' var='post'&gt;
  &lt;b:if cond='data:top.showEmailButton'&gt;&lt;a class='goog-inline-block share-button sb-email' expr:href='data:post.sharePostUrl + &amp;quot;&amp;amp;target=email&amp;quot;' expr:title='data:top.emailThisMsg' target='_blank'&gt;&lt;span class='share-button-link-text'&gt;&lt;data:top.emailThisMsg/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/b:if&gt;&lt;b:if cond='data:top.showBlogThisButton'&gt;&lt;a class='goog-inline-block share-button sb-blog' expr:href='data:post.sharePostUrl + &amp;quot;&amp;amp;target=blog&amp;quot;' expr:onclick='&amp;quot;window.open(this.href, \&amp;quot;_blank\&amp;quot;, \&amp;quot;height=270,width=475\&amp;quot;); return false;&amp;quot;' expr:title='data:top.blogThisMsg' target='_blank'&gt;&lt;span class='share-button-link-text'&gt;&lt;data:top.blogThisMsg/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/b:if&gt;&lt;b:if cond='data:top.showTwitterButton'&gt;&lt;a class='goog-inline-block share-button sb-twitter' expr:href='data:post.sharePostUrl + &amp;quot;&amp;amp;target=twitter&amp;quot;' expr:title='data:top.shareToTwitterMsg' target='_blank'&gt;&lt;span class='share-button-link-text'&gt;&lt;data:top.shareToTwitterMsg/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/b:if&gt;&lt;b:if cond='data:top.showFacebookButton'&gt;&lt;a class='goog-inline-block share-button sb-facebook' expr:href='data:post.sharePostUrl + &amp;quot;&amp;amp;target=facebook&amp;quot;' expr:onclick='&amp;quot;window.open(this.href, \&amp;quot;_blank\&amp;quot;, \&amp;quot;height=430,width=640\&amp;quot;); return false;&amp;quot;' expr:title='data:top.shareToFacebookMsg' target='_blank'&gt;&lt;span class='share-button-link-text'&gt;&lt;data:top.shareToFacebookMsg/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/b:if&gt;&lt;b:if cond='data:top.showPinterestButton'&gt;&lt;a class='goog-inline-block share-button sb-pinterest' expr:href='data:post.sharePostUrl + &amp;quot;&amp;amp;target=pinterest&amp;quot;' expr:title='data:top.shareToPinterestMsg' target='_blank'&gt;&lt;span class='share-button-link-text'&gt;&lt;data:top.shareToPinterestMsg/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/b:if&gt;&lt;b:if cond='data:top.showDummy'&gt;&lt;div class='goog-inline-block dummy-container'&gt;&lt;data:post.dummyTag/&gt;&lt;/div&gt;&lt;/b:if&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='status-message'&gt;
  &lt;b:if cond='data:navMessage'&gt;
  &lt;div class='status-msg-wrap'&gt;
    &lt;div class='status-msg-body'&gt;
      &lt;data:navMessage/&gt;
    &lt;/div&gt;
    &lt;div class='status-msg-border'&gt;
      &lt;div class='status-msg-bg'&gt;
        &lt;div class='status-msg-hidden'&gt;&lt;data:navMessage/&gt;&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div style='clear: both;'/&gt;
  &lt;/b:if&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='threaded-comment-form' var='post'&gt;
  &lt;div class='comment-form'&gt;
    &lt;a name='comment-form'/&gt;
    &lt;b:if cond='data:mobile'&gt;
      &lt;p&gt;&lt;data:blogCommentMessage/&gt;&lt;/p&gt;
      &lt;data:blogTeamBlogMessage/&gt;
      &lt;a expr:href='data:post.commentFormIframeSrc' id='comment-editor-src'/&gt;
      &lt;iframe allowtransparency='true' class='blogger-iframe-colorize blogger-comment-from-post' frameborder='0' height='410' id='comment-editor' name='comment-editor' src='' style='display: none' width='100%'/&gt;
    &lt;b:else/&gt;
      &lt;p&gt;&lt;data:blogCommentMessage/&gt;&lt;/p&gt;
      &lt;data:blogTeamBlogMessage/&gt;
      &lt;a expr:href='data:post.commentFormIframeSrc' id='comment-editor-src'/&gt;
      &lt;iframe allowtransparency='true' class='blogger-iframe-colorize blogger-comment-from-post' frameborder='0' height='410' id='comment-editor' name='comment-editor' src='' width='100%'/&gt;
    &lt;/b:if&gt;
    &lt;data:post.friendConnectJs/&gt;
    &lt;data:post.cmtfpIframe/&gt;
    &lt;script type='text/javascript'&gt;
      BLOG_CMT_createIframe(&amp;#39;&lt;data:post.appRpcRelayPath/&gt;&amp;#39;);
    &lt;/script&gt;
  &lt;/div&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='threaded_comment_js' var='post'&gt;
  &lt;script async='async' expr:src='data:post.commentSrc' type='text/javascript'/&gt;

  &lt;script type='text/javascript'&gt;
    (function() {
      var items = &lt;data:post.commentJso/&gt;;
      var msgs = &lt;data:post.commentMsgs/&gt;;
      var config = &lt;data:post.commentConfig/&gt;;

// &lt;![CDATA[
      var cursor = null;
      if (items &amp;&amp; items.length &gt; 0) {
        cursor = parseInt(items[items.length - 1].timestamp) + 1;
      }

      var bodyFromEntry = function(entry) {
        if (entry.gd$extendedProperty) {
          for (var k in entry.gd$extendedProperty) {
            if (entry.gd$extendedProperty[k].name == 'blogger.contentRemoved') {
              return '&lt;span class="deleted-comment"&gt;' + entry.content.$t + '&lt;/span&gt;';
            }
          }
        }
        return entry.content.$t;
      }

      var parse = function(data) {
        cursor = null;
        var comments = [];
        if (data &amp;&amp; data.feed &amp;&amp; data.feed.entry) {
          for (var i = 0, entry; entry = data.feed.entry[i]; i++) {
            var comment = {};
            // comment ID, parsed out of the original id format
            var id = /blog-(\d+).post-(\d+)/.exec(entry.id.$t);
            comment.id = id ? id[2] : null;
            comment.body = bodyFromEntry(entry);
            comment.timestamp = Date.parse(entry.published.$t) + '';
            if (entry.author &amp;&amp; entry.author.constructor === Array) {
              var auth = entry.author[0];
              if (auth) {
                comment.author = {
                  name: (auth.name ? auth.name.$t : undefined),
                  profileUrl: (auth.uri ? auth.uri.$t : undefined),
                  avatarUrl: (auth.gd$image ? auth.gd$image.src : undefined)
                };
              }
            }
            if (entry.link) {
              if (entry.link[2]) {
                comment.link = comment.permalink = entry.link[2].href;
              }
              if (entry.link[3]) {
                var pid = /.*comments\/default\/(\d+)\?.*/.exec(entry.link[3].href);
                if (pid &amp;&amp; pid[1]) {
                  comment.parentId = pid[1];
                }
              }
            }
            comment.deleteclass = 'item-control blog-admin';
            if (entry.gd$extendedProperty) {
              for (var k in entry.gd$extendedProperty) {
                if (entry.gd$extendedProperty[k].name == 'blogger.itemClass') {
                  comment.deleteclass += ' ' + entry.gd$extendedProperty[k].value;
                } else if (entry.gd$extendedProperty[k].name == 'blogger.displayTime') {
                  comment.displayTime = entry.gd$extendedProperty[k].value;
                }
              }
            }
            comments.push(comment);
          }
        }
        return comments;
      };

      var paginator = function(callback) {
        if (hasMore()) {
          var url = config.feed + '?alt=json&amp;v=2&amp;orderby=published&amp;reverse=false&amp;max-results=50';
          if (cursor) {
            url += '&amp;published-min=' + new Date(cursor).toISOString();
          }
          window.bloggercomments = function(data) {
            var parsed = parse(data);
            cursor = parsed.length &lt; 50 ? null
                : parseInt(parsed[parsed.length - 1].timestamp) + 1
            callback(parsed);
            window.bloggercomments = null;
          }
          url += '&amp;callback=bloggercomments';
          var script = document.createElement('script');
          script.type = 'text/javascript';
          script.src = url;
          document.getElementsByTagName('head')[0].appendChild(script);
        }
      };
      var hasMore = function() {
        return !!cursor;
      };
      var getMeta = function(key, comment) {
        if ('iswriter' == key) {
          var matches = !!comment.author
              &amp;&amp; comment.author.name == config.authorName
              &amp;&amp; comment.author.profileUrl == config.authorUrl;
          return matches ? 'true' : '';
        } else if ('deletelink' == key) {
          return config.baseUri + '/delete-comment.g?blogID='
               + config.blogId + '&amp;postID=' + comment.id;
        } else if ('deleteclass' == key) {
          return comment.deleteclass;
        }
        return '';
      };

      var replybox = null;
      var replyUrlParts = null;
      var replyParent = undefined;

      var onReply = function(commentId, domId) {
        if (replybox == null) {
          // lazily cache replybox, and adjust to suit this style:
          replybox = document.getElementById('comment-editor');
          if (replybox != null) {
            replybox.height = '250px';
            replybox.style.display = 'block';
            replyUrlParts = replybox.src.split('#');
          }
        }
        if (replybox &amp;&amp; (commentId !== replyParent)) {
          document.getElementById(domId).insertBefore(replybox, null);
          replybox.src = replyUrlParts[0]
              + (commentId ? '&amp;parentID=' + commentId : '')
              + '#' + replyUrlParts[1];
          replyParent = commentId;
        }
      };

      var hash = (window.location.hash || '#').substring(1);
      var startThread, targetComment;
      if (/^comment-form_/.test(hash)) {
        startThread = hash.substring('comment-form_'.length);
      } else if (/^c[0-9]+$/.test(hash)) {
        targetComment = hash.substring(1);
      }

      // Configure commenting API:
      var configJso = {
        'maxDepth': config.maxThreadDepth
      };
      var provider = {
        'id': config.postId,
        'data': items,
        'loadNext': paginator,
        'hasMore': hasMore,
        'getMeta': getMeta,
        'onReply': onReply,
        'rendered': true,
        'initComment': targetComment,
        'initReplyThread': startThread,
        'config': configJso,
        'messages': msgs
      };

      var render = function() {
        if (window.goog &amp;&amp; window.goog.comments) {
          var holder = document.getElementById('comment-holder');
          window.goog.comments.render(holder, provider);
        }
      };

      // render now, or queue to render when library loads:
      if (window.goog &amp;&amp; window.goog.comments) {
        render();
      } else {
        window.goog = window.goog || {};
        window.goog.comments = window.goog.comments || {};
        window.goog.comments.loadQueue = window.goog.comments.loadQueue || [];
        window.goog.comments.loadQueue.push(render);
      }
    })();
// ]]&gt;
  &lt;/script&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='threaded_comments' var='post'&gt;
  &lt;div class='comments' id='comments'&gt;
    &lt;a name='comments'/&gt;
    &lt;h4&gt;&lt;data:post.commentLabelFull/&gt;:&lt;/h4&gt;

    &lt;div class='comments-content'&gt;
      &lt;b:if cond='data:post.embedCommentForm'&gt;
        &lt;b:include data='post' name='threaded_comment_js'/&gt;
      &lt;/b:if&gt;
      &lt;div id='comment-holder'&gt;
         &lt;data:post.commentHtml/&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;p class='comment-footer'&gt;
      &lt;b:if cond='data:post.allowNewComments'&gt;
        &lt;b:include data='post' name='threaded-comment-form'/&gt;
      &lt;b:else/&gt;
        &lt;data:post.noNewCommentsText/&gt;
      &lt;/b:if&gt;
    &lt;/p&gt;

    &lt;b:if cond='data:showCmtPopup'&gt;
      &lt;div id='comment-popup'&gt;
        &lt;iframe allowtransparency='true' frameborder='0' id='comment-actions' name='comment-actions' scrolling='no'&gt;
        &lt;/iframe&gt;
      &lt;/div&gt;
    &lt;/b:if&gt;

    &lt;div id='backlinks-container'&gt;
    &lt;div expr:id='data:widget.instanceId + &amp;quot;_backlinks-container&amp;quot;'&gt;
       &lt;b:if cond='data:post.showBacklinks'&gt;
         &lt;b:include data='post' name='backlinks'/&gt;
       &lt;/b:if&gt;
    &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/b:includable&gt;
          &lt;/b:widget&gt;
        &lt;/b:section&gt;
      &lt;/div&gt;

      &lt;div id='sidebar-wrapper'&gt;
        &lt;b:section class='sidebar' id='sidebar' preferred='yes'&gt;
          &lt;b:widget id='Profile2' locked='false' title='Magamról' type='Profile'&gt;
            &lt;b:includable id='main'&gt;
    &lt;b:if cond='data:title != &amp;quot;&amp;quot;'&gt;
      &lt;h2&gt;&lt;data:title/&gt;&lt;/h2&gt;
    &lt;/b:if&gt;
    &lt;div class='widget-content'&gt;
    &lt;b:if cond='data:team == &amp;quot;true&amp;quot;'&gt; &lt;!-- team blog profile --&gt;
      &lt;ul&gt;
        &lt;b:loop values='data:authors' var='i'&gt;
          &lt;li&gt;&lt;a class='profile-name-link g-profile' expr:href='data:i.userUrl' expr:style='&amp;quot;background-image: url(&amp;quot; + data:i.profileLogo + &amp;quot;);&amp;quot;'&gt;&lt;data:i.display-name/&gt;&lt;/a&gt;&lt;/li&gt;
        &lt;/b:loop&gt;
      &lt;/ul&gt;

    &lt;b:else/&gt; &lt;!-- normal blog profile --&gt;

      &lt;b:if cond='data:photo.url != &amp;quot;&amp;quot;'&gt;
        &lt;a expr:href='data:userUrl'&gt;&lt;img class='profile-img' expr:alt='data:photo.alt' expr:height='data:photo.height' expr:src='data:photo.url' expr:width='data:photo.width'/&gt;&lt;/a&gt;
      &lt;/b:if&gt;

      &lt;dl class='profile-datablock'&gt;
        &lt;dt class='profile-data'&gt;
          &lt;a class='profile-name-link g-profile' expr:href='data:userUrl' expr:style='&amp;quot;background-image: url(&amp;quot; + data:profileLogo + &amp;quot;);&amp;quot;' rel='author'&gt;
            &lt;data:displayname/&gt;
          &lt;/a&gt;
          &lt;b:if cond='data:hasgoogleprofile'&gt;
            &lt;br/&gt;
            &lt;div class='g-follow' data-annotation='bubble' data-height='20' expr:data-href='data:userUrl'/&gt;
          &lt;/b:if&gt;
        &lt;/dt&gt;

        &lt;b:if cond='data:showlocation == &amp;quot;true&amp;quot;'&gt;
          &lt;dd class='profile-data'&gt;&lt;data:location/&gt;&lt;/dd&gt;
        &lt;/b:if&gt;

        &lt;b:if cond='data:aboutme != &amp;quot;&amp;quot;'&gt;&lt;dd class='profile-textblock'&gt;&lt;data:aboutme/&gt;&lt;/dd&gt;&lt;/b:if&gt;
      &lt;/dl&gt;
      &lt;a class='profile-link' expr:href='data:userUrl' rel='author'&gt;&lt;data:viewProfileMsg/&gt;&lt;/a&gt;
    &lt;/b:if&gt;

     &lt;b:include name='quickedit'/&gt;
    &lt;/div&gt;
  &lt;/b:includable&gt;
          &lt;/b:widget&gt;
          &lt;b:widget id='HTML3' locked='false' title='Elérhetőségek' type='HTML'&gt;
            &lt;b:includable id='main'&gt;
  &lt;!-- only display title if it's non-empty --&gt;
  &lt;b:if cond='data:title != &amp;quot;&amp;quot;'&gt;
    &lt;h2 class='title'&gt;&lt;data:title/&gt;&lt;/h2&gt;
  &lt;/b:if&gt;
  &lt;div class='widget-content'&gt;
    &lt;data:content/&gt;
  &lt;/div&gt;

  &lt;b:include name='quickedit'/&gt;
&lt;/b:includable&gt;
          &lt;/b:widget&gt;
          &lt;b:widget id='PageList1' locked='false' title='Oldalak' type='PageList'&gt;
            &lt;b:includable id='main'&gt;
  &lt;b:if cond='data:title'&gt;&lt;h2&gt;&lt;data:title/&gt;&lt;/h2&gt;&lt;/b:if&gt;
  &lt;div class='widget-content'&gt;
    &lt;b:if cond='data:mobile'&gt;
      &lt;select expr:id='data:widget.instanceId + &amp;quot;_select&amp;quot;'&gt;
        &lt;b:loop values='data:links' var='link'&gt;
          &lt;b:if cond='data:link.isCurrentPage'&gt;
            &lt;option expr:value='data:link.href' selected='selected'&gt;&lt;data:link.title/&gt;&lt;/option&gt;
          &lt;b:else/&gt;
            &lt;option expr:value='data:link.href'&gt;&lt;data:link.title/&gt;&lt;/option&gt;
          &lt;/b:if&gt;
        &lt;/b:loop&gt;
      &lt;/select&gt;
      &lt;span class='pagelist-arrow'&gt;&amp;amp;#9660;&lt;/span&gt;

    &lt;b:else/&gt;
      &lt;ul&gt;
        &lt;b:loop values='data:links' var='link'&gt;
          &lt;b:if cond='data:link.isCurrentPage'&gt;
            &lt;li class='selected'&gt;&lt;a expr:href='data:link.href'&gt;&lt;data:link.title/&gt;&lt;/a&gt;&lt;/li&gt;
          &lt;b:else/&gt;
            &lt;li&gt;&lt;a expr:href='data:link.href'&gt;&lt;data:link.title/&gt;&lt;/a&gt;&lt;/li&gt;
          &lt;/b:if&gt;
        &lt;/b:loop&gt;
      &lt;/ul&gt;
    &lt;/b:if&gt;
    &lt;b:include name='quickedit'/&gt;
  &lt;/div&gt;
&lt;/b:includable&gt;
          &lt;/b:widget&gt;
          &lt;b:widget id='HTML2' locked='false' title='Delicious' type='HTML'&gt;
            &lt;b:includable id='main'&gt;
  &lt;!-- only display title if it's non-empty --&gt;
  &lt;b:if cond='data:title != &amp;quot;&amp;quot;'&gt;
    &lt;h2 class='title'&gt;&lt;data:title/&gt;&lt;/h2&gt;
  &lt;/b:if&gt;
  &lt;div class='widget-content'&gt;
    &lt;data:content/&gt;
  &lt;/div&gt;

  &lt;b:include name='quickedit'/&gt;
&lt;/b:includable&gt;
          &lt;/b:widget&gt;
          &lt;b:widget id='Feed3' locked='false' title='JTechLog szösszenetek' type='Feed'&gt;
            &lt;b:includable id='main'&gt;
    &lt;h2&gt;&lt;data:title/&gt;&lt;/h2&gt;
    &lt;div class='widget-content' expr:id='data:widget.instanceId + &amp;quot;_feedItemListDisplay&amp;quot;'&gt;
      &lt;span style='filter: alpha(25); opacity: 0.25;'&gt;
        &lt;a expr:href='data:feedUrl'&gt;&lt;data:loadingMsg/&gt;&lt;/a&gt;
      &lt;/span&gt;
    &lt;/div&gt;
    &lt;b:include name='quickedit'/&gt;
  &lt;/b:includable&gt;
          &lt;/b:widget&gt;
          &lt;b:widget id='LinkList1' locked='false' title='Linkek' type='LinkList'&gt;
            &lt;b:includable id='main'&gt;

&lt;b:if cond='data:title'&gt;&lt;h2&gt;&lt;data:title/&gt;&lt;/h2&gt;&lt;/b:if&gt;
 &lt;div class='widget-content'&gt;
   &lt;ul&gt;
     &lt;b:loop values='data:links' var='link'&gt;
       &lt;li&gt;&lt;a expr:href='data:link.target'&gt;&lt;data:link.name/&gt;&lt;/a&gt;&lt;/li&gt;
     &lt;/b:loop&gt;
   &lt;/ul&gt;
   &lt;b:include name='quickedit'/&gt;
 &lt;/div&gt;
&lt;/b:includable&gt;
          &lt;/b:widget&gt;
          &lt;b:widget id='BlogArchive2' locked='false' title='Blogarchívum' type='BlogArchive'&gt;
            &lt;b:includable id='main'&gt;
  &lt;b:if cond='data:title'&gt;
    &lt;h2&gt;&lt;data:title/&gt;&lt;/h2&gt;
  &lt;/b:if&gt;
  &lt;div class='widget-content'&gt;
  &lt;div id='ArchiveList'&gt;
  &lt;div expr:id='data:widget.instanceId + &amp;quot;_ArchiveList&amp;quot;'&gt;
    &lt;b:if cond='data:style == &amp;quot;HIERARCHY&amp;quot;'&gt;
     &lt;b:include data='data' name='interval'/&gt;
    &lt;/b:if&gt;
    &lt;b:if cond='data:style == &amp;quot;FLAT&amp;quot;'&gt;
      &lt;b:include data='data' name='flat'/&gt;
    &lt;/b:if&gt;
    &lt;b:if cond='data:style == &amp;quot;MENU&amp;quot;'&gt;
      &lt;b:include data='data' name='menu'/&gt;
    &lt;/b:if&gt;
  &lt;/div&gt;
  &lt;/div&gt;
  &lt;b:include name='quickedit'/&gt;
  &lt;/div&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='flat' var='data'&gt;
  &lt;ul class='flat'&gt;
    &lt;b:loop values='data:data' var='i'&gt;
      &lt;li class='archivedate'&gt;
        &lt;a expr:href='data:i.url'&gt;&lt;data:i.name/&gt;&lt;/a&gt; (&lt;data:i.post-count/&gt;)
      &lt;/li&gt;
    &lt;/b:loop&gt;
  &lt;/ul&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='interval' var='intervalData'&gt;
  &lt;b:loop values='data:intervalData' var='i'&gt;
      &lt;ul class='hierarchy'&gt;
        &lt;li expr:class='&amp;quot;archivedate &amp;quot; + data:i.expclass'&gt;
          &lt;b:include data='i' name='toggle'/&gt;
          &lt;a class='post-count-link' expr:href='data:i.url'&gt;&lt;data:i.name/&gt;&lt;/a&gt;
            &lt;span class='post-count' dir='ltr'&gt;(&lt;data:i.post-count/&gt;)&lt;/span&gt;
          &lt;b:if cond='data:i.data'&gt;
            &lt;b:include data='i.data' name='interval'/&gt;
          &lt;/b:if&gt;
          &lt;b:if cond='data:i.posts'&gt;
            &lt;b:include data='i.posts' name='posts'/&gt;
          &lt;/b:if&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
  &lt;/b:loop&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='menu' var='data'&gt;
  &lt;select expr:id='data:widget.instanceId + &amp;quot;_ArchiveMenu&amp;quot;'&gt;
    &lt;option value=''&gt;&lt;data:title/&gt;&lt;/option&gt;
    &lt;b:loop values='data:data' var='i'&gt;
      &lt;option expr:value='data:i.url'&gt;&lt;data:i.name/&gt; (&lt;data:i.post-count/&gt;)&lt;/option&gt;
    &lt;/b:loop&gt;
  &lt;/select&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='posts' var='posts'&gt;
  &lt;ul class='posts'&gt;
    &lt;b:loop values='data:posts' var='i'&gt;
      &lt;li&gt;&lt;a expr:href='data:i.url'&gt;&lt;data:i.title/&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;/b:loop&gt;
  &lt;/ul&gt;
&lt;/b:includable&gt;
            &lt;b:includable id='toggle' var='interval'&gt;
  &lt;b:if cond='data:interval.toggleId'&gt;
  &lt;b:if cond='data:interval.expclass == &amp;quot;expanded&amp;quot;'&gt;
    &lt;a class='toggle' href='javascript:void(0)'&gt;
      &lt;span class='zippy toggle-open'&gt;&amp;#9660;&amp;#160;&lt;/span&gt;
    &lt;/a&gt;
  &lt;b:else/&gt;
    &lt;a class='toggle' href='javascript:void(0)'&gt;
      &lt;span class='zippy'&gt;
        &lt;b:if cond='data:blog.languageDirection == &amp;quot;rtl&amp;quot;'&gt;
          &amp;#9668;&amp;#160;
        &lt;b:else/&gt;
          &amp;#9658;&amp;#160;
        &lt;/b:if&gt;
      &lt;/span&gt;
    &lt;/a&gt;
  &lt;/b:if&gt;
 &lt;/b:if&gt;
&lt;/b:includable&gt;
          &lt;/b:widget&gt;
        &lt;/b:section&gt;
      &lt;/div&gt;

      &lt;!-- spacer for skins that want sidebar and main to be the same height--&gt;
      &lt;div class='clear'&gt;&amp;#160;&lt;/div&gt;

    &lt;/div&gt; &lt;!-- end content-wrapper --&gt;

    &lt;div id='footer-wrapper'&gt;
      &lt;b:section class='footer' id='footer'/&gt;
    &lt;/div&gt;

  &lt;/div&gt;&lt;/div&gt; &lt;!-- end outer-wrapper --&gt;

&lt;script type='text/javascript'&gt;
     SyntaxHighlighter.all()
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</content><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/7370998606556338092/template/default'/><link rel='self' type='application/atom+xml' href='http://www.blogger.com/feeds/7370998606556338092/template/default'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_PUBLISHING_MODE</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Az ehhez a bloghoz végrehajtott közzététel típusa.</title><content type='text'>PUBLISH_MODE_HOSTED</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_PUBLISHING_MODE'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_PUBLISHING_MODE'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_ADMIN_PERMISSION</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>A blog rendszergazdáinak e-mail címét tartalmazó lista.</title><content type='text'>viczian.istvan@gmail.com</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_ADMIN_PERMISSION'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_ADMIN_PERMISSION'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_ADULT_CONTENT</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Van-e a blogban csak 18 éven felülieknek szóló tartalom</title><content type='text'>false</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_ADULT_CONTENT'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_ADULT_CONTENT'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_ALTERNATE_JSRENDER_ALLOWED</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Engedélyezettek-e az alternatív JavaScript-megjelenítések</title><content type='text'>true</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_ALTERNATE_JSRENDER_ALLOWED'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_ALTERNATE_JSRENDER_ALLOWED'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_ANALYTICS_ACCOUNT_NUMBER</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>A blog Google Analytics-beli fiókszáma</title><content type='text'></content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_ANALYTICS_ACCOUNT_NUMBER'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_ANALYTICS_ACCOUNT_NUMBER'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_ARCHIVE_DATE_FORMAT</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Archívum tartalomjegyzékének dátumformátuma</title><content type='text'>9</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_ARCHIVE_DATE_FORMAT'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_ARCHIVE_DATE_FORMAT'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_ARCHIVE_FREQUENCY</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Milyen gyakran archiválja a rendszer ezt a blogot</title><content type='text'>MONTHLY</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_ARCHIVE_FREQUENCY'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_ARCHIVE_FREQUENCY'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_AUTHOR_PERMISSION</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Azon szerzők e-mail címének a listája, akik közzétételi engedéllyel rendelkeznek.</title><content type='text'></content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_AUTHOR_PERMISSION'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_AUTHOR_PERMISSION'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_BACKLINKS_ALLOWED</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Megjelenjenek-e megjegyzésekre visszamutató linkek a blogban</title><content type='text'>false</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_BACKLINKS_ALLOWED'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_BACKLINKS_ALLOWED'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_BY_POST_ARCHIVING</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Legyen-e minden bejegyzésnek külön archívumoldala</title><content type='text'>true</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_BY_POST_ARCHIVING'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_BY_POST_ARCHIVING'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_COMMENT_ACCESS</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Kik írhatnak megjegyzéseket</title><content type='text'>ANYONE</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENT_ACCESS'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENT_ACCESS'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_COMMENT_CAPTCHA</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>A megjegyzésíróknak ki kell-e tölteniük egy Captcha-tesztet</title><content type='text'>true</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENT_CAPTCHA'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENT_CAPTCHA'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_COMMENT_EMAIL</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Az új bejegyzésekről tájékoztató értesítések címzettjei</title><content type='text'>viczian.istvan@gmail.com</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENT_EMAIL'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENT_EMAIL'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_COMMENT_FEED</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>A blogmegjegyzésekhez biztosítandó feed típusa</title><content type='text'>FULL</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENT_FEED'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENT_FEED'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_COMMENT_FORM_LOCATION</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Blog megjegyzésűrlapjainak helye</title><content type='text'>EMBEDDED_IFRAME</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENT_FORM_LOCATION'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENT_FORM_LOCATION'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_COMMENT_MESSAGE</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Blogmegjegyzésről tájékoztató üzenet</title><content type='text'></content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENT_MESSAGE'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENT_MESSAGE'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_COMMENT_MODERATION</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Engedélyezett legyen-e a megjegyzések moderálása</title><content type='text'>DISABLED</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENT_MODERATION'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENT_MODERATION'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_COMMENT_MODERATION_DELAY</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Azon időszak (napban), amely után az új megjegyzések moderálhatók</title><content type='text'>14</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENT_MODERATION_DELAY'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENT_MODERATION_DELAY'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_COMMENT_MODERATION_EMAIL</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>A moderálásra szoruló új megjegyzésekről tájékoztató értesítések címzettje</title><content type='text'></content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENT_MODERATION_EMAIL'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENT_MODERATION_EMAIL'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_COMMENT_PROFILE_IMAGES</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Megjelenjenek-e profilképek a megjegyzésekben</title><content type='text'>true</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENT_PROFILE_IMAGES'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENT_PROFILE_IMAGES'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_COMMENTS_ALLOWED</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Megjelenjenek-e megjegyzések</title><content type='text'>true</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENTS_ALLOWED'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENTS_ALLOWED'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_COMMENTS_TIME_STAMP_FORMAT</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Megjegyzés időbélyegének számformátuma</title><content type='text'>29</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENTS_TIME_STAMP_FORMAT'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_COMMENTS_TIME_STAMP_FORMAT'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_CONVERT_LINE_BREAKS</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>A sortöréseket &lt;br /&gt; címkékké alakítsa-e a program a bejegyzésszerkesztőben</title><content type='text'>false</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_CONVERT_LINE_BREAKS'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_CONVERT_LINE_BREAKS'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_CUSTOM_PAGE_NOT_FOUND</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Megjelenített tartalom, ha a kért bejegyzés vagy oldal nem található.</title><content type='text'></content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_CUSTOM_PAGE_NOT_FOUND'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_CUSTOM_PAGE_NOT_FOUND'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_CUSTOM_ROBOTS_TXT</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>A blog egyéni robots.txt fájlbeli tartalma a keresőmotorok számára.</title><content type='text'></content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_CUSTOM_ROBOTS_TXT'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_CUSTOM_ROBOTS_TXT'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_CUSTOM_ROBOTS_TXT_ENABLED</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Ez a blog egyéni robots.txt fájlbeli tartalmat ad-e át a keresőmotoroknak.</title><content type='text'>false</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_CUSTOM_ROBOTS_TXT_ENABLED'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_CUSTOM_ROBOTS_TXT_ENABLED'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_DATE_FORMAT</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>A dátumfejléc formátuma</title><content type='text'>26</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_DATE_FORMAT'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_DATE_FORMAT'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_DEFAULT_BACKLINKS_MODE</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Bejegyzésekhez kapcsolódó visszamutató linkek alapértelmezett módja</title><content type='text'>DEFAULT_HAVE_BACKLINKS</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_DEFAULT_BACKLINKS_MODE'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_DEFAULT_BACKLINKS_MODE'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_DEFAULT_COMMENTS_MODE</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Bejegyzésekhez fűzött megjegyzések alapértelmezett módja</title><content type='text'>DEFAULT_HAVE_COMMENTS</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_DEFAULT_COMMENTS_MODE'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_DEFAULT_COMMENTS_MODE'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_DESCRIPTION</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>A blog leírása</title><content type='text'>Java blog</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_DESCRIPTION'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_DESCRIPTION'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_EMAIL_POST_LINKS</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Megjelenjen-e egy link a felhasználóknak a bejegyzések e-mailben való elküldéséhez</title><content type='text'>false</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_EMAIL_POST_LINKS'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_EMAIL_POST_LINKS'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_FEED_REDIRECT_URL</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Az az URL-cím, amelyre a bejegyzésfeedekre vonatkozó kéréseket a rendszer átirányítja</title><content type='text'>http://feeds2.feedburner.com/JTechLog</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_FEED_REDIRECT_URL'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_FEED_REDIRECT_URL'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_FLOAT_ALIGNMENT</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Engedélyezett-e a lebegő elrendezés a blogban</title><content type='text'>true</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_FLOAT_ALIGNMENT'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_FLOAT_ALIGNMENT'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_LOCALE</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>A blog nyelve</title><content type='text'>hu</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_LOCALE'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_LOCALE'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_M2B_WHITELIST_EMAIL</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Azon e-mail címek listája, amelyek e-mailben is közzétehetnek tartalmat a blogon.</title><content type='text'></content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_M2B_WHITELIST_EMAIL'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_M2B_WHITELIST_EMAIL'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_MAX_NUM</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>A főoldalon megjelenített elemek maximális száma"</title><content type='text'>7</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_MAX_NUM'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_MAX_NUM'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_MAX_UNIT</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>A főoldalon megjelenített elemek egysége</title><content type='text'>POSTS</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_MAX_UNIT'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_MAX_UNIT'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_META_DESCRIPTION</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>A keresőmotoroknak szolgáltatott blog metaleírása.</title><content type='text'></content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_META_DESCRIPTION'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_META_DESCRIPTION'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_META_DESCRIPTION_ENABLED</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Azt adja meg, hogy a bloghoz tartoznak-e metaleírások.</title><content type='text'>false</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_META_DESCRIPTION_ENABLED'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_META_DESCRIPTION_ENABLED'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_NAME</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>A blog neve</title><content type='text'>JTechLog</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_NAME'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_NAME'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_PER_POST_FEED</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>A bejegyzésenkénti megjegyzésekhez biztosítandó feed típusa</title><content type='text'>FULL</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_PER_POST_FEED'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_PER_POST_FEED'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_POST_FEED</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>A blogbejegyzésekhez biztosítandó feed típusa</title><content type='text'>FULL</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_POST_FEED'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_POST_FEED'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_POST_FEED_FOOTER</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>A bejegyzésfeed egyes elemeinek végéhez fűzött lábléc</title><content type='text'></content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_POST_FEED_FOOTER'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_POST_FEED_FOOTER'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_POST_TEMPLATE</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Blogbejegyzések sablonja</title><content type='text'></content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_POST_TEMPLATE'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_POST_TEMPLATE'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_PROMOTED</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Reklámozható-e a blog a Bloggerben</title><content type='text'>true</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_PROMOTED'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_PROMOTED'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_QUICK_EDITING</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Engedélyezett-e a gyorsszerkesztés</title><content type='text'>true</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_QUICK_EDITING'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_QUICK_EDITING'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_READ_ACCESS_MODE</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>A blog olvasóinak hozzáférési típusa.</title><content type='text'>PUBLIC</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_READ_ACCESS_MODE'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_READ_ACCESS_MODE'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_READER_PERMISSION</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Azon felhasználók e-mail címének a listája, akiknek engedélyük van a blog olvasására.</title><content type='text'></content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_READER_PERMISSION'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_READER_PERMISSION'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_SEARCHABLE</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Indexelhetik-e ezt a blogot a keresőmotorok</title><content type='text'>true</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_SEARCHABLE'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_SEARCHABLE'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_SEND_EMAIL</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Azon e-mail címek pontosvesszővel tagolt listája, ahová az új blogbejegyzéseket szeretnéd küldeni</title><content type='text'></content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_SEND_EMAIL'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_SEND_EMAIL'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_SHOW_TITLE</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Megjelenjen-e a címmező</title><content type='text'>true</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_SHOW_TITLE'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_SHOW_TITLE'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_SHOW_URL</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Megjelenjen-e egy kapcsolódó linkmező a bejegyzésszerkesztőben</title><content type='text'>false</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_SHOW_URL'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_SHOW_URL'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_TIME_STAMP_FORMAT</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Az időbélyeg formátuma</title><content type='text'>27</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_TIME_STAMP_FORMAT'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_TIME_STAMP_FORMAT'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_TIME_ZONE</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>A blog időzónája</title><content type='text'>Europe/Budapest</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_TIME_ZONE'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_TIME_ZONE'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.settings.BLOG_USE_LIGHTBOX</id><published>2008-11-24T19:57:10.369+01:00</published><updated>2015-01-03T16:04:40.258+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#settings'/><title type='text'>Annak beállítása, hogy a képek kattintásra átvilágítódoboz nézetben jelenjenek-e meg</title><content type='text'>true</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_USE_LIGHTBOX'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/settings/BLOG_USE_LIGHTBOX'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3454714244361191903</id><published>2015-01-03T16:04:00.000+01:00</published><updated>2015-01-03T16:04:40.275+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='security'/><category scheme='http://www.blogger.com/atom/ns#' term='Spring'/><title type='text'>Pre-Authentication Spring Security-vel</title><content type='html'>&lt;p&gt;Felhasznált technológiák: Spring Security 3.2.5, Jetty 9.1.0.v20131115&lt;/p&gt;

&lt;p&gt;Vannak olyan esetek, mikor ugyan Spring Security-t szeretnénk használni, azonban autentikációra meghagynánk a webkonténer, vagy az alkalmazásszerver mechanizmusát. Ilyen eset lehetséges, mikor alkalmazásszerverben van beállítva az X.509 tanúsítványok kezelése, vagy esetleg az SSO-val való integráció.&lt;/p&gt;

&lt;p&gt;Ebben az esetben az alkalmazásszerver végzi a bejelentkeztetést, esetleg még a jogosultságok kiosztását is, de a többit a Spring Security végzi. Az alkalmazásszerver a bejelentkeztetett felhasználót és jogosultságait a szabványos módon adja át, lekérdezni a Servlet API &lt;code&gt;HttpServletRequest&lt;/code&gt; példányának &lt;code&gt;getUserPrincipal()&lt;/code&gt; és &lt;code&gt;isUserInRole(java.lang.String role)&lt;/code&gt; metódusaival lehet. A Spring Security-t tehát arra kell rábeszélni, hogy a megfelelő esetekben ide delegálja a hívásait.&lt;/p&gt;

&lt;p&gt;A Spring Security használata azért lehet hasznos ebben az esetben is, mert a Servlet API-hoz képest rengeteg plusz funkciót ad, mint pl. URL-ek védelme, amihez a jogosultságokat bonyolult kifejezésekkel adhatjuk meg. Vagy pl. az annotáció alapú deklaratív jogosultságkezelés, stb. A Spring Security-ről bővebben egy &lt;a href="/2010/01/spring-security.html"&gt;előző posztomban&lt;/a&gt; olvashatsz, melyet ismét frissítettem, hogy a legfrissebb verziókat tartalmazza. &lt;/p&gt;

&lt;p&gt;Jelenlegi poszthoz egy példaprogram is &lt;a href="https://github.com/vicziani/jtechlog-spring-security-container"&gt;letölthető a GitHub-ról&lt;/a&gt;. Az &lt;code&gt;mvn jetty:run&lt;/code&gt; paranccsal indítható. Bejelentkezni az &lt;code&gt;admin1&lt;/code&gt;/&lt;code&gt;admin1&lt;/code&gt; és a &lt;code&gt;user1&lt;/code&gt;/&lt;code&gt;user1&lt;/code&gt; felhasználónév jelszó párosokkal lehetséges. és Egy Jetty beépített webkonténert tartalmaz, melybe fel vannak véve a felhasználók, és a hozzá tartozó szerepkörök. Első körben a Jetty Maven pluginnak kell megmondani, hogy hol található a Jetty-hez tartozó konfigurációs állomány.&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="tag"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;org.eclipse.jetty&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;jetty-maven-plugin&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;9.1.0.v20131115&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;webAppXml&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;src/main/webapp/WEB-INF/jetty.xml&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/webAppXml&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Amennyiben ez megvan, az &lt;code&gt;src/main/webapp/WEB-INF/jetty.xml&lt;/code&gt; konfigurációs állományban kell megadni, hogy mely állomány tartalmazza a felhasználókat és szerepköröket.&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="pun"&gt;&amp;lt;?&lt;/span&gt;&lt;span class="pln"&gt;xml version&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="str"&gt;"1.0"&lt;/span&gt;&lt;span class="pln"&gt; encoding&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="str"&gt;"ISO-8859-1"&lt;/span&gt;&lt;span class="pun"&gt;?&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="dec"&gt;&amp;lt;!DOCTYPE Configure PUBLIC "-//Jetty//Configure//EN" "http://www.eclipse.org/jetty/configure.dtd"&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;Configure&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;class&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"org.eclipse.jetty.webapp.WebAppContext"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;Get&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"securityHandler"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;Set&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"loginService"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;New&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;class&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"org.eclipse.jetty.security.HashLoginService"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
                &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;Set&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"name"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;UserRealm&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/Set&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
                &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;Set&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"config"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
                    src/main/webapp/WEB-INF/jetty-realm.properties&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/Set&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
                &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;Call&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"start"&lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/New&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/Set&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;Set&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"checkWelcomeFiles"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;true&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/Set&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/Get&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/Configure&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;src/main/webapp/WEB-INF/jetty-realm.properties&lt;/code&gt; egy elég egyszerű állomány, elöl a felhasználónév, majd a jelszó (plain-text-ben), majd a szerepkör. Teszteléshez tökéletes.&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code&gt;&lt;span class="pln"&gt;admin1&lt;/span&gt;&lt;span class="pun"&gt;:&lt;/span&gt;&lt;span class="pln"&gt; admin1&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt;admin
user1&lt;/span&gt;&lt;span class="pun"&gt;:&lt;/span&gt;&lt;span class="pln"&gt; user1&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt;user&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Majd megadjuk a &lt;code&gt;web.xml&lt;/code&gt;-ben, hogy Basic autentikációt használjon. Ilyenkor a böngésző feldob egy ablakot, és az autentikációs információk a HTTP kérés fejlécében utaznak, plain textben. Ez már szabványos Servlet API megoldás.&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="tag"&gt;&amp;lt;security-constraint&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;web-resource-collection&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;web-resource-name&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;allwebresource&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/web-resource-name&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;/*&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/web-resource-collection&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;auth-constraint&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;role-name&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;user&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/role-name&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;role-name&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;admin&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/role-name&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/auth-constraint&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/security-constraint&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;

&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;login-config&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;auth-method&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;BASIC&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/auth-method&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;realm-name&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;UserRealm&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/realm-name&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/login-config&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;

&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;security-role&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;role-name&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;user&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/role-name&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/security-role&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;

&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;security-role&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;role-name&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;admin&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/role-name&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/security-role&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ezután már csak a Spring Security-t konfiguráltam be az &lt;code&gt;applicationContext-security.xml&lt;/code&gt; állományban, hogy a web konténertől vegye át a felhasználót és a hozzá tartozó szerepköröket. Nézzük az ehhez tartozó konfigurációt.&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="tag"&gt;&amp;lt;http&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;entry-point-ref&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"entryPoint"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;auto-config&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"false"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;intercept-url&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;pattern&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"/index.html"&lt;/span&gt;&lt;span class="pln"&gt; 
            &lt;/span&gt;&lt;span class="atn"&gt;access&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"IS_AUTHENTICATED_ANONYMOUSLY"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;intercept-url&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;pattern&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"/user.html"&lt;/span&gt;&lt;span class="pln"&gt; 
            &lt;/span&gt;&lt;span class="atn"&gt;access&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"ROLE_USER,ROLE_ADMIN"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;intercept-url&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;pattern&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"/admin.html"&lt;/span&gt;&lt;span class="pln"&gt; 
            &lt;/span&gt;&lt;span class="atn"&gt;access&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"ROLE_ADMIN"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;custom-filter&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;position&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"PRE_AUTH_FILTER"&lt;/span&gt;&lt;span class="pln"&gt; 
            &lt;/span&gt;&lt;span class="atn"&gt;ref&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"preAuthFilter"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/http&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;

&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;authentication-manager&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;alias&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"authenticationManager"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;authentication-provider&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;ref&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"authenticationProvider"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/authentication-manager&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;

&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;beans:bean&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;id&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"entryPoint"&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="atn"&gt;class&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"org.springframework.security.web.authentication.Http403ForbiddenEntryPoint"&lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;

&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;beans:bean&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;id&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"authenticationProvider"&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="atn"&gt;class&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationProvider"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;beans:property&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"preAuthenticatedUserDetailsService"&lt;/span&gt;&lt;span class="pln"&gt; 
        &lt;/span&gt;&lt;span class="atn"&gt;ref&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"userDetailsService"&lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/beans:bean&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;

&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;beans:bean&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;id&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"userDetailsService"&lt;/span&gt;&lt;span class="pln"&gt; 
    &lt;/span&gt;&lt;span class="atn"&gt;class&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"jtechlog.springsecurity.service.JpaAuthenticationUserDetailsService"&lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;

&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;beans:bean&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;id&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"preAuthFilter"&lt;/span&gt;&lt;span class="pln"&gt; 
        &lt;/span&gt;&lt;span class="atn"&gt;class&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"org.springframework.security.web.authentication.preauth.j2ee.J2eePreAuthenticatedProcessingFilter"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;beans:property&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"authenticationManager"&lt;/span&gt;&lt;span class="pln"&gt; 
        &lt;/span&gt;&lt;span class="atn"&gt;ref&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"authenticationManager"&lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;beans:property&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"authenticationDetailsSource"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;beans:bean&lt;/span&gt;&lt;span class="pln"&gt; 
                &lt;/span&gt;&lt;span class="atn"&gt;class&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"org.springframework.security.web.authentication.preauth.j2ee.J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;beans:property&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"mappableRolesRetriever"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
                &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;beans:bean&lt;/span&gt;&lt;span class="pln"&gt; 
                    &lt;/span&gt;&lt;span class="atn"&gt;class&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"org.springframework.security.web.authentication.preauth.j2ee.WebXmlMappableAttributesRetriever"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/beans:property&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;beans:property&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"userRoles2GrantedAuthoritiesMapper"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
                &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;beans:bean&lt;/span&gt;&lt;span class="pln"&gt; 
                        &lt;/span&gt;&lt;span class="atn"&gt;class&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"org.springframework.security.core.authority.mapping.SimpleAttributes2GrantedAuthoritiesMapper"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
                    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;beans:property&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"convertAttributeToUpperCase"&lt;/span&gt;&lt;span class="pln"&gt; 
                        &lt;/span&gt;&lt;span class="atn"&gt;value&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"true"&lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
                &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/beans:bean&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/beans:property&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/beans:bean&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/beans:property&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/beans:bean&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ez talán már igényelhet némi magyarázatot. Az &lt;code&gt;entryPoint&lt;/code&gt; bean mondja meg, hogy a konténerre van bízva az autentikáció. Az &lt;code&gt;authenticationProvider&lt;/code&gt; mondja meg, hogy honnan kell a felhasználót feltölteni. Itt egy &lt;code&gt;PreAuthenticatedAuthenticationProvider&lt;/code&gt; példányt használunk, ami azt mondja, hogy az autentikációt már elvégezte a konténer, és ennek eredménye alapján tölthetünk be saját &lt;code&gt;User&lt;/code&gt; példányt. Ezt a saját &lt;code&gt;JpaAuthenticationUserDetailsService&lt;/code&gt; példányunk teszi, adatbázisból a felhasználónév alapján JPA technológiával. A &lt;code&gt;preAuthFilter&lt;/code&gt; bean a &lt;code&gt;web.xml&lt;/code&gt;-ben talált szerepköröket mappeli át Spring Security-sra, nagybetűsít, és alapértelmezetten hozzáfűzi a &lt;code&gt;ROLE_&lt;/code&gt; prefixet. tehát az &lt;code&gt;admin&lt;/code&gt; és a &lt;code&gt;user&lt;/code&gt; szerepkörből csinál &lt;code&gt;ROLE_ADMIN&lt;/code&gt; és &lt;code&gt;ROLE_USER&lt;/code&gt; szerepköröket, vagy ahogy a Spring Security hívja, granted authority-ket.&lt;/p&gt;

&lt;p&gt;A saját &lt;code&gt;JpaAuthenticationUserDetailsService&lt;/code&gt; lényeg része a következőképp néz ki.&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code&gt;&lt;span class="lit"&gt;@Override&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;UserDetails&lt;/span&gt;&lt;span class="pln"&gt; 
        loadUserDetails&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;PreAuthenticatedAuthenticationToken&lt;/span&gt;&lt;span class="pln"&gt; token&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; 
        &lt;/span&gt;&lt;span class="kwd"&gt;throws&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;UsernameNotFoundException&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="kwd"&gt;try&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;        
        &lt;/span&gt;&lt;span class="typ"&gt;User&lt;/span&gt;&lt;span class="pln"&gt; user &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; entityManager
            &lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;createQuery&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"select u from User u where u.username = :username"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;User&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="kwd"&gt;class&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;setParameter&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"username"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; token&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getName&lt;/span&gt;&lt;span class="pun"&gt;())&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getSingleResult&lt;/span&gt;&lt;span class="pun"&gt;();&lt;/span&gt;&lt;span class="pln"&gt;

        &lt;/span&gt;&lt;span class="typ"&gt;PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails&lt;/span&gt;&lt;span class="pln"&gt; details &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; token&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getDetails&lt;/span&gt;&lt;span class="pun"&gt;();&lt;/span&gt;&lt;span class="pln"&gt;

        user&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;setAuthorities&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;details&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getGrantedAuthorities&lt;/span&gt;&lt;span class="pun"&gt;());&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="kwd"&gt;return&lt;/span&gt;&lt;span class="pln"&gt; user&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;catch&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;NoResultException&lt;/span&gt;&lt;span class="pln"&gt; nre&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="kwd"&gt;throw&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;new&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;UsernameNotFoundException&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"A felhasználó a megadott felhasználónévvel nem található: "&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;+&lt;/span&gt;&lt;span class="pln"&gt; token&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getName&lt;/span&gt;&lt;span class="pun"&gt;(),&lt;/span&gt;&lt;span class="pln"&gt; nre&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A paraméterként kapott &lt;code&gt;token&lt;/code&gt; már tartalmazza az alkalmazásszerver által meghatározott felhasználónév és szerepkör információkat, ez alapján betöltjük adatbázisból a felhasználót, és beállítjuk a szintén megkapott szerepköröket.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/3454714244361191903/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2015/01/pre-authentication-spring-security-vel.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3454714244361191903'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3454714244361191903'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2015/01/pre-authentication-spring-security-vel.html' title='Pre-Authentication Spring Security-vel'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5333547079656484912</id><published>2014-11-13T23:40:00.000+01:00</published><updated>2014-11-14T19:55:10.895+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Community'/><title type='text'>Java ki kicsoda</title><content type='html'>&lt;p&gt;Ezzel a poszttal azokat az embereket szeretném bemutatni, akiket érdemes követni Java programozóként, hiszen sokat tesznek a közösségért, vagy meghatározó/érdekes gondolataik vannak ebben a témában. Természetesen a lista nem teljes, ezért amennyiben valakit kihagyok, nyugodtan írjátok meg commentben.&lt;/p&gt;

&lt;h3&gt;James Gosling&lt;/h3&gt;

&lt;p&gt;&lt;a href="//3.bp.blogspot.com/-uc3GCEsrI1U/VGUuOAA2w6I/AAAAAAAANEE/o5MzyBBm9zw/s1600/james_gosling.jpg" imageanchor="1" &gt;&lt;img border="0" src="//3.bp.blogspot.com/-uc3GCEsrI1U/VGUuOAA2w6I/AAAAAAAANEE/o5MzyBBm9zw/s200/james_gosling.jpg" style="float:right; margin-right:10px;"/&gt;&lt;/a&gt;
 Amennyiben történeti sorrendben akarunk haladni, az ő nevét kell először megemlíteni. A Sun alkalmazottjaként alkotta meg a Java nyelvet, és implementálta az első fordítót és virtuális gépet. Mikor a Sunt megvásárolta az Oracle, kicsit ott dolgozott, majd átment a Google-höz, és most a &lt;a href="http://liquidr.com/"&gt;Liquid Roboticsnál&lt;/a&gt; van, ahol óceánjáró robothajókkal foglalkozik. Konferenciákon sztárelőadónak hívják meg, munkája miatt főleg a beágyazott eszközök, IoT, Raspberry Pi témakörök érdeklik, de lelkes használója és evangelistája a NetBeans IDE-nek és a JavaFX-nek.&lt;/p&gt;

&lt;p&gt;&lt;a href="nighthacks.com/roller/jag/"&gt;Blog&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Jaroslav Tulach&lt;/h3&gt;

&lt;p&gt;&lt;a href="//1.bp.blogspot.com/-9-AtRDuP5N0/VGUu6fDRbSI/AAAAAAAANEM/CU0DXPvNXdA/s1600/jaroslav_tulach.jpg" imageanchor="1"&gt;&lt;img border="0" src="//1.bp.blogspot.com/-9-AtRDuP5N0/VGUu6fDRbSI/AAAAAAAANEM/CU0DXPvNXdA/s200/jaroslav_tulach.jpg" style="float:left; margin-right:10px;" /&gt;&lt;/a&gt;Ha már Oracle és NetBeans, akkor legyen ő a következő a sorban. A NetBeans egyik alapítója, jelenleg architect az Oracle-nél. Ő az írója a &lt;a href="http://wiki.apidesign.org]"&gt;Practical API Design&lt;/a&gt; könyvnek, mely a NetBeans Platform API-jának kialakítása közben szerzett tapasztalatokat összegzi, alapmű a témában. Legújabb dobása a &lt;a href="http://dukescript.com/"&gt;DukeScript&lt;/a&gt;, mely egy olyan új technológia, mely használatával Javaban írt alkalmazásokat lehet több mobil platformon, vastag kliensként és böngészőben is futtatni.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://www.java.net/blogs/jst"&gt;Blog&lt;/a&gt;
&lt;a href="https://twitter.com/JaroslavTulach"&gt;Twitter&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Geertjan Wielenga&lt;/h3&gt;

&lt;p&gt;&lt;a href="//3.bp.blogspot.com/-xFRzIPRolKk/VGUvOey-yoI/AAAAAAAANEU/_kAyTiz9AQ4/s1600/geertjan_wielenga.png" imageanchor="1"&gt;&lt;img border="0" src="//3.bp.blogspot.com/-xFRzIPRolKk/VGUvOey-yoI/AAAAAAAANEU/_kAyTiz9AQ4/s200/geertjan_wielenga.png" style="float:right; margin-right:10px;"/&gt;&lt;/a&gt;Az Oracle és NetBeans íven haladva következzen ő. Product Manager az Oracle-nél, és a NetBeanssel foglalkozik. Rettentő sokat bloggol és twitterezik a témában. Nagyon közvetlen személyiség, válaszol a megkeresésekre, minden érdekli, ami a NetBeansszel kapcsolatos. Prágában kezdett el vele foglalkozni, ahonnan a NetBeans is származik, először mint technical writer. Aki NetBeansszel kicsit is komolyan foglalkozik, biztos futott már bele cikkébe, tutorialjába, ha máshol nem, akkor a helpben.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://blogs.oracle.com/geertjan/"&gt;Blog&lt;/a&gt;
&lt;a href="https://twitter.com/GeertjanW"&gt;Twitter&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Simon Ritter&lt;/h3&gt;

&lt;p&gt;&lt;a href="//3.bp.blogspot.com/-86FzF99fCdw/VGUvmGH-hvI/AAAAAAAANEc/SCn1v5VNins/s1600/simon_ritter.jpg" imageanchor="1" &gt;&lt;img border="0" src="//3.bp.blogspot.com/-86FzF99fCdw/VGUvmGH-hvI/AAAAAAAANEc/SCn1v5VNins/s200/simon_ritter.jpg" style="float:left; margin-right:10px;"/&gt;&lt;/a&gt;A Java evangelisták vezetője az Oracle-nél. Minden konferencián ott van, Magyarországon is volt a Java konferencián, mikor még nagy Sunos rendezvény volt. Irigyelni való figura, az a dolga, hogy játszik, mindig menő dolgokról beszél, mindent kipróbál és bejárja a világot. &lt;a href="http://www.lego.com/en-us/mindstorms"&gt;Lego Mindstorms&lt;/a&gt;, Raspberry Pi, &lt;a href="https://minecraft.net/"&gt;Minecraft&lt;/a&gt;, robotika, a legújabb API-k, stb.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://twitter.com/speakjava"&gt;Twitter&lt;/a&gt;&lt;/p&gt;

&lt;div style="clear:both; padding-top:20px;"&gt;
&lt;h3&gt;Kohsuke Kawaguchi&lt;/h3&gt;

&lt;p&gt;&lt;a href="//1.bp.blogspot.com/-hZR1ohinAbc/VGUwYCxmt2I/AAAAAAAANEk/OXF9BGNb9OU/s1600/kohsuke_kawaguchi.jpg" imageanchor="1" &gt;&lt;img border="0" src="//1.bp.blogspot.com/-hZR1ohinAbc/VGUwYCxmt2I/AAAAAAAANEk/OXF9BGNb9OU/s200/kohsuke_kawaguchi.jpg" style="float:right; margin-left:10px;"/&gt;&lt;/a&gt;Ha már játék és Oracle, az ő nevét sem hagyhatjuk ki. Szintén a Sunnál emelkedett ki mint ifjú titán, még a JAX-WS RI forrásában találkozhattunk a nevével, de igazán a Hudson, illetve Jenkins megalkotásával vált híressé. Rettentő sok energiával rendelkezik, iszonyat gyorsan adott ki új verziókat, foglalkozik mindennel, ami érdekes, hímzéstől kezdve a legózáson át az összes érdekes Java technológiával. Jelenleg CTO a &lt;a href="http://www.cloudbees.com/"&gt;CloudBees&lt;/a&gt; cégnél, mely a Jenkisre alapozva próbál üzleti modellt építeni.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://kohsuke.org/"&gt;Blog&lt;/a&gt;
&lt;a href="http://twitter.com/kohsukekawa"&gt;Twitter&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h3&gt;Joshua Bloch&lt;/h3&gt;

&lt;p&gt;&lt;a href="//4.bp.blogspot.com/-alAfslhePW8/VGUwg8YkgII/AAAAAAAANEs/FC2-6cTrPo8/s1600/joshua_bloch.jpg" imageanchor="1" &gt;&lt;img border="0" src="//4.bp.blogspot.com/-alAfslhePW8/VGUwg8YkgII/AAAAAAAANEs/FC2-6cTrPo8/s200/joshua_bloch.jpg" style="float:left; margin-right:10px;" /&gt;&lt;/a&gt;Az API vonalon maradva ismerkedjünk meg vele. A Java nyelv és API bizonyos részeinek kidolgozásával foglalkozott a Sunnál, leghíresebb munkája a Java Collections Framework, melyet minden Java fejlesztő ismer, és a mai napig időtálló. Írója a magyar nyelvre is lefordított &lt;a href="http://www.amazon.com/Effective-Java-Edition-Joshua-Bloch/dp/0321356683"&gt;Effective Java&lt;/a&gt; könyvnek (Hatékony Java), és társszerzője a szintén magyarul is megjelent &lt;a href="http://www.javapuzzlers.com/]"&gt;Java Puzzlers&lt;/a&gt; (Java-fejtörők) és a &lt;a href="http://jcip.net/"&gt;Java Concurrency in Practice&lt;/a&gt; (Párhuzamos Java-programozás a gyakorlatban) könyveknek. Egyetemen tanít, Java vezető architect volt a Google-nél.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://twitter.com/joshbloch"&gt;Twitter&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Doug Lea&lt;/h3&gt;

&lt;p&gt;&lt;a href="//4.bp.blogspot.com/-X0-DuNx7sfY/VGUwlj_6dCI/AAAAAAAANE0/Nuh_-urR224/s1600/doug_lea.jpg" imageanchor="1" &gt;&lt;img border="0" src="//4.bp.blogspot.com/-X0-DuNx7sfY/VGUwlj_6dCI/AAAAAAAANE0/Nuh_-urR224/s200/doug_lea.jpg" style="float:right; margin-left:10px;"/&gt;&lt;/a&gt;A fentebb említett Java Concurrency in Practice könyv társszerzője, a téma egyik legnagyobb szakértője, egyetemi tanár. A &lt;a href="https://jcp.org"&gt;Java Community Process&lt;/a&gt; tagjaként vezetője volt a &lt;a href="https://www.jcp.org/en/jsr/detail?id=166"&gt;JSR 166: Concurrency Utilities&lt;/a&gt; szabványnak, mely a Java 5 egyik legnagyobb újdonsága.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://g.oswego.edu/"&gt;Homepage&lt;/a&gt;&lt;/p&gt;

&lt;div style="clear:both; padding-top:20px;"&gt;
&lt;h3&gt;Adam Bien&lt;/h3&gt;

&lt;p&gt;&lt;a href="//1.bp.blogspot.com/-DVXCS1vTymY/VGUwqER7oJI/AAAAAAAANE8/RL2XXKz0Eu0/s1600/adam_bien.png" imageanchor="1" &gt;&lt;img border="0" src="//1.bp.blogspot.com/-DVXCS1vTymY/VGUwqER7oJI/AAAAAAAANE8/RL2XXKz0Eu0/s200/adam_bien.png" style="float:left; margin-right:10px;"/&gt;&lt;/a&gt;Szabadúszó Java fejlesztő és architect a kezdetektől. A &lt;a href="http://realworldpatterns.com/"&gt;Real World Java EE Patterns—Rethinking Best Practices&lt;/a&gt; és &lt;a href="http://press.adam-bien.com/real-world-java-ee-night-hacks-dissecting-the-business-tier.htm"&gt;Real World Java EE Night Hacks—Dissecting the Business Tier&lt;/a&gt; könyvek szerzője. Főleg Java EE témakörben tart előadásokat és ír, aktív tagja a JCP-nek ezen témákban. A Java EE technológiát gyakorlati oldalról közelíti meg, és alkalmazza rá a modern megközelítéseket, mint pl. a microservices, anélkül, hogy bedőlne a hype-oknak. Elismerendő, hogy a régóta elavult &lt;a href="http://www.corej2eepatterns.com"&gt;J2EE Patternöket&lt;/a&gt; újra feldolgozta a Java EE-nek megfelelően, és nem félt akár ki is dobálni az elavultakat. Akit érdekel a stílusa, javaslom &lt;a href="https://www.youtube.com/watch?v=0g_VwojiENY"&gt;ezt a videót&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://www.adam-bien.com/roller/abien/"&gt;Blog&lt;/a&gt;
&lt;a href="http://twitter.com/AdamBien"&gt;Twitter&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h3&gt;Arun Gupta&lt;/h3&gt;

&lt;p&gt;&lt;a href="//3.bp.blogspot.com/-vlzaI3E9Nsw/VGUwudnl86I/AAAAAAAANFE/nqkzAQChbTM/s1600/arun_gupta.jpg" imageanchor="1" &gt;&lt;img border="0" src="//3.bp.blogspot.com/-vlzaI3E9Nsw/VGUwudnl86I/AAAAAAAANFE/nqkzAQChbTM/s200/arun_gupta.jpg" style="float:right; margin-left:10px;"/&gt;&lt;/a&gt;Az Oracle-nél volt Java EE evangelista, a Glassfish hívő, és nagy felbolydulást keltett, mikor 2013 októberében átment a RedHathez, mikor az Oracle bejelentette a Glassfish támogatásának megszüntetését. Azóta fő érdeklődési területe a JBoss és a WildFly. Mostanában a WebSocket Java EE támogatásával foglalkozik, szívesen nyúl bele a Minecraftba, és foglalkozik azzal is, hogy gyerekek figyelmét hívja fel a programozásra. Több könyvet írt Java EE témában.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://blog.arungupta.me/"&gt;Blog&lt;/a&gt;
&lt;a href="https://twitter.com/arungupta"&gt;Twitter&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Rod Johnson&lt;/h3&gt;

&lt;p&gt;&lt;a href="//3.bp.blogspot.com/-DNd7sraKz-0/VGUwxcfB57I/AAAAAAAANFM/_b5Tflo8uq8/s1600/rod_johnson.jpg" imageanchor="1" &gt;&lt;img border="0" src="//3.bp.blogspot.com/-DNd7sraKz-0/VGUwxcfB57I/AAAAAAAANFM/_b5Tflo8uq8/s200/rod_johnson.jpg" style="float:left; margin-right:10px;"/&gt;&lt;/a&gt;Most menjünk el kicsit a keretrendszerek irányába. Ő a Spring Framework megalkotója. Ő írta a &lt;a href="http://www.wrox.com/WileyCDA/WroxTitle/productCd-0764543857.html"&gt;Expert One-on-One J2EE Design and Development&lt;/a&gt; könyvet, mely arra fókuszál, hogy milyen hibákat követtünk el a J2EE technológia használatakor, és gyakorlati megoldásokat adott, hogyan kellett volna ezeket elkerülni. Következő könyvében, &lt;a href="http://eu.wiley.com/WileyCDA/WileyTitle/productCd-0764558315.html"&gt;Expert One-on-One J2EE Development without EJB&lt;/a&gt; címmel már arról írt, hogy ne használjuk az EJB technológiát, hanem helyette valami pehelysúlyúbb eszközöket, mint pl. a Spring vagy a Hibernate. Jelenleg olyan cégek és szervezetek működésében vesz rész, mint a Typesafe, mely a Scala, a Play Framework és az Akka mögött áll, vagy a Neo4J, az elasticsearch, a Hazelcast vagy a &lt;a href="https://www.meteor.com/"&gt;Meteor&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://twitter.com/springrod"&gt;Twitter&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Juergen Hoeller&lt;/h3&gt;

&lt;p&gt;&lt;a href="//2.bp.blogspot.com/-pwDRIfw6zx4/VGUw1uhgLzI/AAAAAAAANFU/OIsvzfrt8oU/s1600/juergen_hoeller.jpg" imageanchor="1" &gt;&lt;img border="0" src="//2.bp.blogspot.com/-pwDRIfw6zx4/VGUw1uhgLzI/AAAAAAAANFU/OIsvzfrt8oU/s200/juergen_hoeller.jpg" style="float:right; margin-left:10px;"/&gt;&lt;/a&gt;Szintén Spring alapító, de ő még mindig ott van. Időközben a Springet felvásárolta a VMware, mely EMC Corporation tulajdon. Az EMC és a General Electric alapította a Pivotalt, mely egy olyan cég mely szoftverkomponenseket fejleszt és szolgáltatásokat biztosít adatközpontú és adatelemző egyedi szoftverek agilis fejlesztésére felhő-alapú technológiákra építve. A Springen kívül olyan cuccokat pakoltak még bele, mint a Cloud Foundry, a Redis, a RabbitMQ, a Grails, a Groovy, a Hadoop, stb.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://twitter.com/springjuergen"&gt;Twitter&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Jason Van Zyl&lt;/h3&gt;

&lt;p&gt;&lt;a href="//2.bp.blogspot.com/-I7VR2rKubx8/VGUw56o_uyI/AAAAAAAANFc/Ieso73o0jgU/s1600/jason_van_zyl.jpg" imageanchor="1" &gt;&lt;img border="0" src="//2.bp.blogspot.com/-I7VR2rKubx8/VGUw56o_uyI/AAAAAAAANFc/Ieso73o0jgU/s200/jason_van_zyl.jpg" style="float:left; margin-right:10px;"/&gt;&lt;/a&gt;A Maven megalkotója, kezdetben a &lt;a href="http://www.sonatype.com/"&gt;Sonatype-nál&lt;/a&gt; dolgozott, mely a Nexus repository manager gyártója. Mivel itt kicsit eltávolodott a fő csapásiránytól, kilépett, és megalkotta a saját cégét &lt;a href="http://takari.io/"&gt;Takari&lt;/a&gt; néven, mely Maven oktatással, tanácsadással foglalkozik. Jelenlegi projektjei miatt igen nagyszabású fejlesztéssel foglalkozik, képessé akarja tenni a Mavent arra, hogy beilleszthető legyen a continuous delivery-be. Ennek első megnyilvánulás a &lt;a href="http://takari.io/book/04-lifecycle.html#toc_0]"&gt;The Takari Lifecycle&lt;/a&gt;, mely egy plugin, mely teljesen lecseréli a meglévő Maven core plugineket. &lt;/p&gt;

&lt;p&gt;&lt;a href="https://twitter.com/jvanzyl"&gt;Twitter&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Ceki Gülcü&lt;/h3&gt;

&lt;p&gt;&lt;a href="//1.bp.blogspot.com/-Qx4kCqM-8Mg/VGUw9yKlPnI/AAAAAAAANFk/WuLs4dqRWBc/s1600/ceki_gulcu.jpg" imageanchor="1" &gt;&lt;img border="0" src="//1.bp.blogspot.com/-Qx4kCqM-8Mg/VGUw9yKlPnI/AAAAAAAANFk/WuLs4dqRWBc/s200/ceki_gulcu.jpg" style="float:right; margin-left:10px;"/&gt;&lt;/a&gt;Független fejlesztő, az The Apache Software Foundation tagja, a Log4j, SLF4J és a Logback megalkotója, valamint írója a &lt;a href="http://www.qos.ch/shop/products/log4jManual"&gt;The complete log4j manual&lt;/a&gt; könyvnek.&lt;/p&gt;

&lt;div style="clear:both; padding-top:20px;"&gt;
&lt;h3&gt;John Ferguson Smart&lt;/h3&gt;

&lt;p&gt;&lt;a href="//3.bp.blogspot.com/-gt5mvvKAM9M/VGUxCa7fgdI/AAAAAAAANFs/9TnVn8uzUq4/s1600/john_ferguson_smart.jpg" imageanchor="1" &gt;&lt;img border="0" src="//3.bp.blogspot.com/-gt5mvvKAM9M/VGUxCa7fgdI/AAAAAAAANFs/9TnVn8uzUq4/s200/john_ferguson_smart.jpg" style="float:left; margin-right:10px;"/&gt;&lt;/a&gt;Független fejlesztő, majd megalapította a saját cégét &lt;a href="http://www.wakaleo.com"&gt;Wakaleo Consulting&lt;/a&gt; néven. Mindig sikerült meglovagolnia az aktuális hullámokat, úgymint Maven, continuous integration and delivery, TDD, BDD, agilis fejlesztés. Ezekkel kapcsolatban három könyvet is írt &lt;a href="http://www.manning.com/smart"&gt;BDD in Action&lt;/a&gt;, &lt;a href="http://www.wakaleo.com/books/jenkins-the-definitive-guide"&gt;Jenkins: The Definitive Guide&lt;/a&gt;, &lt;a href="http://www.wakaleo.com/java-power-tools"&gt;Java Power Tools&lt;/a&gt;, mind rettentő gyakorlatias jellegű. Ezekben a témákban rengeteget publikál, és konferenciákon beszél.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://www.java.net/blog/johnsmart"&gt;Blog&lt;/a&gt;
&lt;a href="https://twitter.com/wakaleo"&gt;Twitter&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;div style="clear:both; padding-top:20px;"&gt;
&lt;h3&gt;Bruce Eckel&lt;/h3&gt;

&lt;p&gt;&lt;a href="//1.bp.blogspot.com/-l3VRePbAzCg/VGUxGzj4JDI/AAAAAAAANF0/CuW_RDpLqIc/s1600/bruce_eckel.jpg" imageanchor="1" &gt;&lt;img border="0" src="//1.bp.blogspot.com/-l3VRePbAzCg/VGUxGzj4JDI/AAAAAAAANF0/CuW_RDpLqIc/s200/bruce_eckel.jpg" style="float:right; margin-left:10px;"/&gt;&lt;/a&gt;Igazi polyglot programozó, otthonosan mozog Scala, Python, Java, C++, stb. nyelvek területén. Azért jegyzem meg itt, mert ő írta a Thinking in Java című könyvet, mely sokáig kötelező olvasmány volt, és ingyenesen letölthető. A &lt;a href="http://mindview.net/Books/TIJ4"&gt;4. kiadást&lt;/a&gt; azonban már meg kell vásárolni.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://www.artima.com/weblogs/index.jsp?blogger=beckel"&gt;Blog&lt;/a&gt;
&lt;a href="https://twitter.com/BruceEckel"&gt;Twitter&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;div style="clear:both; padding-top:20px;"&gt;
&lt;h3&gt;Kent Beck&lt;/h3&gt;

&lt;p&gt;&lt;a href="//2.bp.blogspot.com/-1o-wJiOSbYY/VGUxLPfdI6I/AAAAAAAANF8/0UyEk5PLTZk/s1600/kent_beck.jpg" imageanchor="1" &gt;&lt;img border="0" src="//2.bp.blogspot.com/-1o-wJiOSbYY/VGUxLPfdI6I/AAAAAAAANF8/0UyEk5PLTZk/s200/kent_beck.jpg" style="float:left; margin-right:10px;"/&gt;&lt;/a&gt;A Extreme Programming és Test Driven Development metodológiák megalkotója, Erich Gammával (igen-igen, a Tervezési minták könyv egyik szerzője, a Gang of Four tagja, az Eclipse régebbi vezető tervezője, jelenleg a Microsoftnál vezető Microsoft Visual Studio témában) együtt fejlesztették a JUnit keretrendszert, mely de facto standard a unit tesztelés területén. Először használta az agilis szoftverfejlesztés kifejezést, és egyik aláírója az &lt;a href="http://agilemanifesto.org/"&gt;Agile Manifestonak&lt;/a&gt;, többek között Martin Fowler és Robert C. Martin (“Uncle Bob”) mellett. Jelenleg sok egyéb mellett a Facebooknál dolgozik.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://twitter.com/kentbeck"&gt;Twitter&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;h3&gt;Matt Raible&lt;/h3&gt;

&lt;p&gt;&lt;a href="//4.bp.blogspot.com/-66DzP8IZ2bU/VGUxPjt2kmI/AAAAAAAANGE/LI2Y5Ey3yj0/s1600/matt_raible.jpg" imageanchor="1" &gt;&lt;img border="0" src="//4.bp.blogspot.com/-66DzP8IZ2bU/VGUxPjt2kmI/AAAAAAAANGE/LI2Y5Ey3yj0/s200/matt_raible.jpg" style="float:right; margin-left:10px;"/&gt;&lt;/a&gt;Webes fejlesztéssel foglalkozó szakember, dolgozott a LinkedInnél, mint UI architect, most saját cégét viszi &lt;a href="http://raibledesigns.com/"&gt;Raible Designs&lt;/a&gt; néven. Őt onnan lehet ismerni, hogy nagyon sok konferencián megjelenik, ahol rettentő jó összehasonlító elemzéseket végez UI framework témakörökben. Saját projektje az &lt;a href="http://appfuse.org"&gt;AppFuse&lt;/a&gt;, mely egy induló projekt, melyben olyan technológiákat pakolt össze, mint Bootstrap, jQuery, Spring, Hibernate, Maven és választható web keretrendszerek, úgymint JSF, Struts 2, Spring MVC, Tapestry 5 vagy Wicket. Mindenképp érdemes elolvasni a &lt;a href="http://raibledesigns.com/rd/page/publications"&gt;prezentációit&lt;/a&gt; pl. a legfrissebbet az Angular.JS-ről, összehasonlító elemzését a JVM alapú webes keretrendszerekről, vagy a Play és Grails összehasonlítását.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://raibledesigns.com/rd/category/Java"&gt;Blog&lt;/a&gt;
&lt;a href="https://twitter.com/mraible"&gt;Twitter&lt;/a&gt;&lt;/p&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/5333547079656484912/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2014/11/java-ki-kicsoda.html#comment-form' title='4 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/5333547079656484912'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/5333547079656484912'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/11/java-ki-kicsoda.html' title='Java ki kicsoda'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>4</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1280144521518162844</id><published>2014-10-04T23:48:00.001+02:00</published><updated>2014-11-08T17:41:19.671+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Modularizáció'/><category scheme='http://www.blogger.com/atom/ns#' term='Módszertan'/><category scheme='http://www.blogger.com/atom/ns#' term='könyv'/><title type='text'>Java Application Architecture</title><content type='html'>&lt;p&gt;Már régóta hajtottam a &lt;a href="http://www.amazon.com/gp/product/0321247132"&gt;Kirk Knoernschild: Java Application Architecture&lt;/a&gt; könyvet, végre hozzájutottam, és nem is csalódtam benne. Mostanában érdekel a modularizáció, különösen Java környezetben, és kíváncsi voltam, hogy elméleti szinten mit tudnak erről írni. Bár a könyv alcíme “Modularity Patterns with Examples Using OSGi”, senki ne rettenjen meg, akit nem érdekel az OSGi, éppen csak érinti, a könyv OSGi ismeretek nélkül is kitűnő olvasmány.&lt;/p&gt;

&lt;p&gt;A könyv a Robert C. Martin sorozatban jelent meg, az előszót is ő (“Uncle Bob”) írta. Talán ezért is kerül szóba olyan hamar a &lt;a href="http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29"&gt;SOLID&lt;/a&gt; fogalma, mely az öt alapvető szoftverfejlesztési elv rövidítéseinek mozaikszava. A könyv egyetlen melléklete is ezek kifejtését tartalmazza.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://2.bp.blogspot.com/-7YSdUiG6dqk/VDBpgTbA3oI/AAAAAAAANDM/wXxZNJqQp9I/s1600/java_application_architecture.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-7YSdUiG6dqk/VDBpgTbA3oI/AAAAAAAANDM/wXxZNJqQp9I/s320/java_application_architecture.jpg" /&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;Nekem már a könyv felütése is tetszik, hogy rengeteget foglalkozunk a logikai tervezéssel, mikor is OOP elvek mentén interfészeket, osztályokat alakítunk ki (pl. akár az UML nyelv használatával). Szintén sok energiát szoktunk fektetni abba is, különösen a SOA elterjedésével, hogy szolgáltatásokat alakítsunk ki, interfészeket tervezzünk, és erre alakítsunk ki egy architektúrát. Ezek hatalmas irodalommal is rendelkeznek. De közöttük hiányzik valami.&lt;/p&gt;

&lt;p&gt;Ugyanez a felhasználhatóság, újrafelhasználhatóság terén is. Az interfészek, osztályok egy finom szemcsézettséget (fine grained/granularity) adnak. Az újrafelhasználhatóságuk nagyon magas, hiszen minden nap használunk &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;ArrayList&lt;/code&gt;, stb. osztályokat, viszont a használhatóságuk nehézsége magas, ugyanis tapasztalt fejlesztőnek kell lenni, az API ismeretével. Ezen pehelysúlyú komponensek újrafelhasználhatósága azért is magas, mert kevesebb a függőségük, nem függnek a környezetüktől. Azonban a SOA szerinti szolgáltatások a durva szemcsézettségűek (coarse grained), használatuk viszonylag egyszerű az általuk biztosított interfész (pl. WSDL) alapján, de nehéz őket újra felhasználni. Így ismét egy ugrás található. Nincs meg az a szint, mely az optimális könnyű használatot, és az újrafelhasználhatóságot is biztosítja.&lt;/p&gt;

&lt;p&gt;Ebből egy olyan triviális állítás is kiesik, hogy ahogy növeljük az újrafelhasználhatóságot, úgy lesz nehezebb használni. Másképp megfogalmazva a flexibilitásával nő a komplexitása.&lt;/p&gt;

&lt;p&gt;A könyv szerint a keresett szint nem más, mint a modul szint. Ő ezt fizikai tervezésnek nevezi. A könyv a modulok kialakítására vonatkozóan fogalmaz meg tervezési mintákat. De nézzük, hogy hogyan is definiálja a modul fogalmát:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Deployable (külön telepíthető)&lt;/li&gt;
&lt;li&gt;Manageable (külön indítható, leállítható)&lt;/li&gt;
&lt;li&gt;Natively reusable (metódushívással)&lt;/li&gt;
&lt;li&gt;Composable (több modulból egy modul hozható létre)&lt;/li&gt;
&lt;li&gt;Stateless unit (nem példányosítható, egy verzióból egy és csakis egy létezik)&lt;/li&gt;
&lt;li&gt;Concise interface (tömör interfész a használói számára)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A Java világban ezek nem mások, mint JAR állományok.&lt;/p&gt;

&lt;p&gt;A modularizációt két szempontból vizsgálja. Egyrészt futásközben, másrészt fejlesztés közben. Futás közben nyilván kell egy futtató környezet, mely a modulokat kezeli (Runtime model). Fejlesztés közben két kérdéskörrel kell foglalkozni. Egyrészt hogyan történik az interakció a futtató környezettel (Programming model). A modern környezetek már nem látszanak a modulok számára. A másik kérdés, hogy hogyan alakítsuk ki a modulokat (Design paradigm)? Milyen modulokat kell kialakítani, ezek milyen méretűek legyenek, hogyan viszonyuljanak egymáshoz, stb. A könyvben szereplő tervezési minták ezen kérdésekre adnak választ.&lt;/p&gt;

&lt;p&gt;És itt jön be egy kicsit az OSGi, hogy mik azok az elvárások, melyeket alapból nem tud a Java teljesíteni. Egyrészt nem lehet korlátozni JAR szinten, hogy mely csomagok legyenek csak elérhetőek más JAR-okból (export package). Nem lehet futásidőben JAR-t cserélni (dynamic deployment). Nem élhet ugyanazon osztály két különböző verziója egymás mellett (versioning). Valamint nincs függőségkezelés (dependency management).&lt;/p&gt;

&lt;p&gt;Sajnos a szoftver architektúra nem egyértelműen definiált. Olyanokat lehet mondani, hogy döntések, elvek és útmutatások a rendszer felépítésével kapcsolatban. Definiálja a rendszert statikus vonatkozásban (elemek, komponensek és a köztük lévő kapcsolatok), és dinamikus vonatkozásban is (együttműködések). Szerinte a modularizálás közelebb hozza a fejlesztőket és architecteket. Az architect tipikusan a szolgáltatás, modul és maximum a csomagszintet látja, míg a fejlesztők a modul, csomag, osztály és metódus szintet. Így van egy közös halmaz, mely megértése mindkét fél számára hasznos.&lt;/p&gt;

&lt;p&gt;A könyv első részének végén van egy példa is, mely egy monolitikus rendszerrel indít és ezt tördeli modulokra, természetesen a később kifejtett tervezési mintákat használva. A példa szintén nem tartalmaz OSGi-t. A könyvhöz tartozó példakód &lt;a href="https://code.google.com/p/kcode/"&gt;letölthető a Google Code-ról&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A könyv második része tartalmazza a tervezési mintákat. Mintánként tartalmazza a minta nevét, egy rövid leírást, egy UML diagramot (rettentő hasznos, segítségével azonnal meglehet érteni a mintát), implementációs megközelítéseket, a minta használatának következményeit, példát, és egy rövid összefoglalást. &lt;/p&gt;

&lt;p&gt;A mintákat nem sorolnám itt fel, hanem készítettem egy mindmapet a &lt;a href="http://freemind.sourceforge.net"&gt;FreeMind&lt;/a&gt; szoftverrel. A mindmap forrása megtalálható a &lt;a href="https://github.com/vicziani/jtechlog-modules"&gt;GitHubon&lt;/a&gt;, és &lt;a href="http://about.jtechlog.hu/jtechlog-modules/modul-tervezesi-mintak.html"&gt;itt kattinthatóan is elérhető&lt;/a&gt;, de lejjebb találtok egy nagyítható képet is. Próbáltam a mintákat lefordítani, de nem szó szerint, hanem a célja alapján.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://1.bp.blogspot.com/-f0soBrl9lEE/VDBp9q_nnvI/AAAAAAAANDU/Aonah1pGanA/s1600/modul-tervezesi-mintak.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-f0soBrl9lEE/VDBp9q_nnvI/AAAAAAAANDU/Aonah1pGanA/s320/modul-tervezesi-mintak.png" /&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;A könyvhöz tartozó &lt;a href="http://www.kirkk.com/modularity/about/"&gt;weboldal&lt;/a&gt; is felsorolja a mintákat, és rövid leírásukat, valamint mintánként egy ábrát. Jó a hozzá készült &lt;a href="http://refcardz.dzone.com/refcardz/patterns-modular-architecture"&gt;refcard&lt;/a&gt; is, mely letölthető PDF-ben.&lt;/p&gt;

&lt;p&gt;A könyv harmadik része szól az OSGi-ról, ami éppen annyira tömör, hogy felkelti a figyelmet az említett technológiára, és tisztázza az alapfogalmakat.&lt;/p&gt;

&lt;p&gt;Mint látható, a könyv nagyon tetszett, szerintem hiánypótló írás. Az olvasása közben többször elgondolkodtam, hogy mi az, amit akár a futó projektjeimen használni tudnék, mit kéne másképp csinálni. Persze a legtöbb mintát az ember már ismeri, de mégis ez a könyv foglalja rendszerbe, és elemzi ki több oldalról is. Úgy érzem, hogy olyan könyv, amit érdemes többször levenni a polcról, és néha-néha újra kinyitni. Bár 2012-es, még egyáltalán nem elavult, szemben más technológiai könyvekkel, és egy darabig még nem is lesz. És talán az OSGi-hez is kedvet kapunk.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/1280144521518162844/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2014/10/java-application-architecture.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1280144521518162844'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1280144521518162844'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/10/java-application-architecture.html' title='Java Application Architecture'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://2.bp.blogspot.com/-7YSdUiG6dqk/VDBpgTbA3oI/AAAAAAAANDM/wXxZNJqQp9I/s72-c/java_application_architecture.jpg' height='72' width='72'/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6953946366148996566</id><published>2014-10-02T21:57:00.001+02:00</published><updated>2014-10-02T22:03:44.187+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Spring'/><category scheme='http://www.blogger.com/atom/ns#' term='Community'/><title type='text'>HOUG Szakmai nap 2014 diák</title><content type='html'>&lt;p&gt;A "A Spring Framework 4.0 és 4.1 verzióinak újdonságai" címmel megtartott előadás diái &lt;a href="http://about.jtechlog.hu/artifacts/2014-10_spring_4/2014-10_spring_4.html"&gt;innen letölthetőek&lt;/a&gt;. Ha érdekelnek az érdekesebb újdonságok összegyűjtve, lapozd végig őket.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/6953946366148996566/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2014/10/houg-szakmai-nap-2014-diak.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6953946366148996566'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6953946366148996566'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/10/houg-szakmai-nap-2014-diak.html' title='HOUG Szakmai nap 2014 diák'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7261816863885621281</id><published>2014-09-28T17:09:00.000+02:00</published><updated>2014-09-28T17:09:03.245+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><title type='text'>HOUG Szakmai nap 2014</title><content type='html'>&lt;p&gt;A HOUG 2014. október 2-án, csütörtökön egy 
&lt;a href="http://houg.hu/pls/apex/f?p=houg:4001:0"&gt;szakmai napot&lt;/a&gt; rendez Budapesten a 
Magyar Telekom Székházban (1013 Budapest, Krisztina körút 55.). Lesz 
egy egész napos Java szekció is, melyben olyan érdekes témákról hallhattok 
előadásokat, mint a Java SE 8 és 9, a Java EE 7 újdonságai, hírek a Sonatype 
Nexusról, stb. Én is előadok 12:00 - 12:30 között, a Spring Framework 4.0 és 4.1 
verzióinak újdonságairól.&lt;/p&gt;

&lt;p&gt;A szakmai napon a részvétel ingyenes, de előzetes 
&lt;a href="http://www.houg.hu/pls/apex/f?p=houg:4010:0"&gt;regisztrációhoz&lt;/a&gt; kötött!&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/7261816863885621281/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2014/09/houg-szakmai-nap-2014.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7261816863885621281'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7261816863885621281'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/09/houg-szakmai-nap-2014.html' title='HOUG Szakmai nap 2014'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7077911891492137156</id><published>2014-08-16T21:58:00.000+02:00</published><updated>2014-08-16T21:58:23.382+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Tesztelés'/><title type='text'>Spring TestExecutionListener</title><content type='html'>&lt;p&gt;Használt technológiák: Spring Framework 4.0.4, Joda-Time 2.3, Hamcrest  &lt;br&gt;
Date 1.0.1&lt;/p&gt;

&lt;p&gt;Ebben a posztban három library három apró de érdekes képességét szeretném bemutatni, és hogy hogyan tudnak ezek együttműködni. A poszthoz tartozó  mintakód megtalálható a &lt;a href="https://github.com/vicziani/jtechlog-spring-listener"&gt;GitHubon&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Nálunk gyakran van szükség arra, hogy a teszt esetek különböző dátumokkal dolgozzanak. Mivel van, hogy a tesztelendő funkció a mai napot veszi alapul, jól jön egy olyan lehetőség, hogy az aktuális időt be tudjuk állítani, és utána már könnyebb az asserteket megfogalmazni. Időgépnek nevezzük, mellyel ide-oda lehet ugrálni az időben.&lt;/p&gt;

&lt;p&gt;A Java &lt;code&gt;Date&lt;/code&gt; magában nem alkalmas erre, általában egy factory metódust szoktunk létrehozni, mely lekéri az aktuális időt. Ilyenkor figyelni kell arra, hogy csak ezen metódus meghívásával hozzunk létre dátumot, ne használjuk a &lt;code&gt;Date&lt;/code&gt; konstruktorát.&lt;/p&gt;

&lt;p&gt;Azonban a &lt;a href="http://www.joda.org/joda-time/"&gt;Joda-Time&lt;/a&gt;, mely kibővíti a Java szerény dátumkezelési képességeit, tartalmaz ilyen lehetőséget.&lt;/p&gt;

&lt;p&gt;Amennyiben a &lt;code&gt;DateTimeUtils&lt;/code&gt; &lt;code&gt;setCurrentMillisOffset&lt;/code&gt; metódusát hívjuk, a rendszeridőhöz mindig hozzáad annyi ezredmásodpercet, mint amennyit paraméterként megadtunk. Így nem mindig egy fix időt ad vissza, hanem az időugrás után gyakorlatilag tovább “jár” az óra. Mivel pl. a &lt;code&gt;DateTime&lt;/code&gt; létrehozásakor is a &lt;code&gt;DateTimeUtils&lt;/code&gt; &lt;code&gt;currentTimeMillis&lt;/code&gt; metódusát használja, annak példányosításakor is már a módosított időt kapjuk. Nézzük tehát, hogy hogy lehet az időugrást elvégezni.&lt;/p&gt;&lt;div class="se-section-delimiter"&gt;&lt;/div&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="kwd"&gt;private&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;void&lt;/span&gt;&lt;span class="pln"&gt; engage&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;DateTime&lt;/span&gt;&lt;span class="pln"&gt; targetTime&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="typ"&gt;DateTime&lt;/span&gt;&lt;span class="pln"&gt; realTime &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;new&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;DateTime&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="kwd"&gt;new&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;Date&lt;/span&gt;&lt;span class="pun"&gt;());&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="kwd"&gt;long&lt;/span&gt;&lt;span class="pln"&gt; offset &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; targetTime&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getMillis&lt;/span&gt;&lt;span class="pun"&gt;()&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;-&lt;/span&gt;&lt;span class="pln"&gt; realTime&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getMillis&lt;/span&gt;&lt;span class="pun"&gt;();&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="typ"&gt;DateTimeUtils&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;setCurrentMillisOffset&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;offset&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Valahol láttam, és megtetszett, hogy JUnit teszt esetre vonatkozó állításokat deklaratív módon, annotációkkal fogalmaztak meg. Kíváncsi voltam, hogy lehet ezt megvalósítani Spring Framework használatakor.&lt;/p&gt;

&lt;p&gt;A megoldás, hogy egy &lt;code&gt;TestExecutionListener&lt;/code&gt; kell implementálni. Ez deklarál különböző metódusokat, callbackeket, melyek különböző eseményekkor lefutnak, pl. teszt osztály/metódus előtt/után, stb. Létezik egy &lt;code&gt;AbstractTestExecutionListener&lt;/code&gt; absztrakt osztály is, mely az interfész minden metódusát üres implementációval valósít meg, és a leszármazott osztályunknak csak a megfelelő metódust kell felülírnia.&lt;/p&gt;

&lt;p&gt;Azt szeretném tehát, ha annotációval tudnám megadni, hogy a teszt eset futtatásakor mennyi legyen az idő. Pl. a következő kódrészlettel:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="lit"&gt;@Test&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="lit"&gt;@TimeMachine&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;targetDate &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="str"&gt;"2014-01-01 10:00"&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;void&lt;/span&gt;&lt;span class="pln"&gt; travelToPast&lt;/span&gt;&lt;span class="pun"&gt;()&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="com"&gt;// ...&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ehhez implementáljuk a megfelelő listenert. A &lt;code&gt;beforeTestMethod&lt;/code&gt; metódust írjuk felül, hogy minden teszt metódus futtatása előtt ellenőrizze, hogy a metóduson van-e &lt;code&gt;@TimeMachine&lt;/code&gt; annotáció.&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;class&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;TimeMachineTestExecutionListener&lt;/span&gt;&lt;span class="pln"&gt; 
    &lt;/span&gt;&lt;span class="kwd"&gt;extends&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;AbstractTestExecutionListener&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;

    &lt;/span&gt;&lt;span class="lit"&gt;@Override&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;void&lt;/span&gt;&lt;span class="pln"&gt; beforeTestMethod&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;TestContext&lt;/span&gt;&lt;span class="pln"&gt; testContext&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; 
            &lt;/span&gt;&lt;span class="kwd"&gt;throws&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;Exception&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="typ"&gt;TimeMachine&lt;/span&gt;&lt;span class="pln"&gt; timeMachine &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; testContext&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getTestMethod&lt;/span&gt;&lt;span class="pun"&gt;()&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getAnnotation&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;TimeMachine&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="kwd"&gt;class&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;span class="pln"&gt;

        &lt;/span&gt;&lt;span class="kwd"&gt;if&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;timeMachine &lt;/span&gt;&lt;span class="pun"&gt;!=&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;null&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="typ"&gt;DateTimeFormatter&lt;/span&gt;&lt;span class="pln"&gt; formatter &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; 
                &lt;/span&gt;&lt;span class="typ"&gt;DateTimeFormat&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;forPattern&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"yyyy-MM-dd hh:mm"&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="typ"&gt;DateTime&lt;/span&gt;&lt;span class="pln"&gt; targetTime &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; formatter
                &lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;parseDateTime&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;timeMachine&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;targetDate&lt;/span&gt;&lt;span class="pun"&gt;());&lt;/span&gt;&lt;span class="pln"&gt;
            engage&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;targetTime&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ezen kívül már csak annyit kell tennünk, hogy a teszt osztályunkra rá kell tenni a &lt;code&gt;@TestExecutionListeners&lt;/code&gt; annotációt.&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="lit"&gt;@RunWith&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;SpringJUnit4ClassRunner&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="kwd"&gt;class&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="lit"&gt;@ContextConfiguration&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="lit"&gt;@TestExecutionListeners&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;TimeMachineTestExecutionListener&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="kwd"&gt;class&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;class&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;TimeMachineTest&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="com"&gt;// ...&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most már csak annyit szeretnék, hogy letesztelni, hogy működik-e az időgép. Írtam már a &lt;a href="/2014/05/hamcrest.html"&gt;Hamcrestről&lt;/a&gt;, így Hamcrest matchert kerestem, és meg is találtam a &lt;a href="https://github.com/eXparity/hamcrest-date"&gt;Hamcrest Date&lt;/a&gt; projektet, mellyel hatékonyan tudunk dátumokat összehasonlítani.&lt;/p&gt;

&lt;p&gt;Nézzük meg, hogy hogyan is néz ki a teszt metódus, azon belül is koncentráljunk az assertre.&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="lit"&gt;@Test&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="lit"&gt;@TimeMachine&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;targetDate &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="str"&gt;"2014-01-01 10:00"&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;void&lt;/span&gt;&lt;span class="pln"&gt; travelToPast&lt;/span&gt;&lt;span class="pun"&gt;()&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="com"&gt;// When&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="typ"&gt;DateTime&lt;/span&gt;&lt;span class="pln"&gt; now &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;new&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;DateTime&lt;/span&gt;&lt;span class="pun"&gt;();&lt;/span&gt;&lt;span class="pln"&gt;

    &lt;/span&gt;&lt;span class="com"&gt;// Then&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="typ"&gt;DateTime&lt;/span&gt;&lt;span class="pln"&gt; expected &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;new&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;DateTime&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="lit"&gt;2014&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="lit"&gt;1&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="lit"&gt;1&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="lit"&gt;10&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="lit"&gt;0&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;span class="pln"&gt;
    assertThat&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;now&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;toDate&lt;/span&gt;&lt;span class="pun"&gt;(),&lt;/span&gt;&lt;span class="pln"&gt; 
        within&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="lit"&gt;5&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;TimeUnit&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;SECONDS&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; expected&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;toDate&lt;/span&gt;&lt;span class="pun"&gt;()));&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;DateMatchers&lt;/code&gt; &lt;code&gt;within&lt;/code&gt; metódusát használva ellenőrizhetjük, hogy két dátum között mennyi a differencia, itt most max. 5 másodpercet adtunk meg, feltételezve, hogy ennyi idő alatt biztos lefut a teszteset.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/7077911891492137156/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2014/08/spring-testexecutionlistener.html#comment-form' title='1 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7077911891492137156'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7077911891492137156'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/08/spring-testexecutionlistener.html' title='Spring TestExecutionListener'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3715503487373710542</id><published>2014-07-26T01:36:00.000+02:00</published><updated>2014-09-17T22:27:05.652+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='open source'/><category scheme='http://www.blogger.com/atom/ns#' term='Library'/><category scheme='http://www.blogger.com/atom/ns#' term='Módszertan'/><category scheme='http://www.blogger.com/atom/ns#' term='Workflow'/><category scheme='http://www.blogger.com/atom/ns#' term='Spring'/><title type='text'>Pehelysúlyú workflow Activitivel</title><content type='html'>&lt;p&gt;Használt technológiák: Activiti 5.15.1&lt;/p&gt;

&lt;p&gt;Ismét egy olyan 3rd party library kerül terítékre, mellyel kapcsolatban szkeptikus voltam. A nagy SOA divat tetőpontján a workflow engine fogalma számomra egyet jelentett egy külön infrastruktúrán külön alkalmazásként futó, nehézsúlyú, nehezen fejleszthető, üzemeltethető és használható eszközzel. Főleg dedikált alkalmazásszervereken futó BPEL engine-t használtunk, melyre a fejlesztés BPEL nyelven történt, általában valami modellező eszközben. Akkor még nem gondoltam, hogy másképp is lehet csinálni.&lt;/p&gt;

&lt;p&gt;Ezzel szemben az Activiti egy pehelysúlyú, az alkalmazás memóriájában embedded módon is futtatható workflow engine, mely a BPMN 2 standard workflow leíró nyelvet képes értelmezni. Nyílt forráskódú, könnyen integrálható a Spring keretrendszerrel. Kompatibilis a H2 in-memory módban is futtatható adatbázissal, ez is egy oka annak, hogy nagyszerűen integrációs tesztelhető. Bekapcsolható az audit naplózás, könnyen lehet a historikus adatokat kezelni. Nagyon jó &lt;a href="http://activiti.org/userguide/index.html"&gt;dokumentációval&lt;/a&gt; rendelkezik, és teszt esetekkel is le van fedve. Sőt, már több könyv is megjelent róla, pl. az &lt;a href="http://www.amazon.com/Activiti-Action-Executable-business-processes/dp/1617290122"&gt;Activiti in Action&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A BPMN 2 egy XML alapú, az OMG szervezet által karbantartott, technológiától független modellező nyelv, üzleti folyamatok modellezésére, mely kifejezetten alkalmas grafikus ábrázolásra. (Hiszen egy irányított gráfról beszélünk.) Standard, tehát akár különböző motorok is képesek végrehajtani, de kiterjeszthető, ahogy ezt valamennyire az Activiti is teszi. Nem csak fejlesztők, de üzleti elemzők számára is értelmezhető és használható. Folyamatábra alapú, alapvetően taskokból (activity-kből) áll, melyek egymásutániságát lehet definiálni. Különböző taskok lehetnek, pl. human task, Java komponenst, webszolgáltatást, szabálymotort, szkriptet hívó task, e-mail küldés, stb. Lehetőség van különböző vezérlőelemek megadására, mint elágazás, párhuzamos végrehajtás, stb. Lehet benne különböző eseményeket definiálni, melyekkel pl. megoldható az ütemezett végrehajtás, hibakezelés. Lehet beágyazott munkafolyamatokat definiálni, mely munkafolyamat részletek így újrafelhasználhatóak.&lt;/p&gt;

&lt;p&gt;Egy kicsit a történeti hátterét is érdemes megismerni. A JBossnál fejlesztették a jBPM motort. Először ezzel kezdtem el ismerkedni, de számomra szegényes volt a dokumentációja, és a Spring integráció sem sikerült azonnal. Ekkor kerestem egy másik motort, és így találtam az Activitire. Mint később kiderült, a jBPM fejlesztői jöttek el a JBosstól és az ott szerzett tapasztalatok alapján kezdték el fejleszteni az Activitit (amúgy főleg az Alfresco támogatásával). Azóta egy kisebb vihar is kialakult körülötte, a Camunda cég, mely BPMN szolgáltatásokat nyújtott, és fejlesztői kontributáltak rendesen az Activitibe, fogták magukat, és minden indok nélkül elforkoltak, és megalapították a szintén nyílt forráskódú Camunda Process Engine-t, melyet többen &lt;a href="http://www.jorambarrez.be/blog/2013/03/18/a-sad-day-for-open-source-camunda-decides-to-fork-activiti/"&gt;nem néztek jó szemmel&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Az ezzel kapcsolatos tapasztalataimról a &lt;a href="http://wiki.javaforum.hu/display/JAVAFORUM/JUM1209"&gt;2012 szeptemberi JUM-on&lt;/a&gt; előadást is tartottam, melyről &lt;a href="https://www.youtube.com/watch?v=66FavTUB7AM"&gt;videó&lt;/a&gt; is készült, és a diái is &lt;a href="http://about.jtechlog.hu/artifacts/2012-09_workflow.pdf"&gt;letölthetőek&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A poszthoz szokás szerint &lt;a href="https://github.com/vicziani/jtechlog-activiti"&gt;példaprojektet is találsz a GitHub-on&lt;/a&gt;. Egy egyszerű munkafolyamatot implementáltam, mely során egy szabadságigényt kell jóváhagyni. Ezt először ábrázoljuk UML activity diagramon.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://2.bp.blogspot.com/-Qk0h0wtjid8/U9LoRXXBhuI/AAAAAAAALVY/EodbdlsXPfM/s1600/activity_diagram_1.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img src="http://2.bp.blogspot.com/-Qk0h0wtjid8/U9LoRXXBhuI/AAAAAAAALVY/EodbdlsXPfM/s320/activity_diagram_1.png" border="0"&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;A workflow motorral járó kockázatokat úgy próbáltam csökkenteni, hogy a vele kapcsolatos műveleteket egy interfész mögé próbáltam elrejteni, hogy az implementáció később bármikor cserélhető legyen, akár később natívan, Javaban is le tudjam programozni. Szerencsére erre nem került sor, azonban az architektúra tisztasága miatt ez a döntés később is jónak bizonyult.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://3.bp.blogspot.com/-16G0tmIeRBU/U9LoRTU3xLI/AAAAAAAALVU/m0vjJY1IysA/s1600/class_diagram_1.png" imageanchor="1"&gt;&lt;img src="http://3.bp.blogspot.com/-16G0tmIeRBU/U9LoRTU3xLI/AAAAAAAALVU/m0vjJY1IysA/s320/class_diagram_1.png" border="0"&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;A példa projekten is tehát definiáltam egy &lt;code&gt;TimeOffRequest&lt;/code&gt; osztályt, mely a jóváhagyandó szabadság kérelmet reprezentálja, valamint egy &lt;code&gt;Workflow&lt;/code&gt; interfészt. A &lt;code&gt;requestTimeOff&lt;/code&gt; elindítja a workflow-t, a &lt;code&gt;listTimeOffRequests&lt;/code&gt; metódus az éppen futó workflow-kat listázza ki, míg a &lt;code&gt;approve&lt;/code&gt; metódus pedig a jóváhagyást végzi el. Nézzük hát ennek az implementációját.&lt;/p&gt;

&lt;p&gt;Először rajzoljuk meg a workflow-t. Ehhez az Activiti Eclipse Designert kell használnunk. Ez gyakorlatilag egy egyszerűen telepíthető Eclipse plugin. Feltelepítése után New Activiti Diagram. Látható, hogy a diagramon egy start event, egy end event, és köztük egy user task. (Egy egyszerű IDEA plugin is létezik már.)&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://2.bp.blogspot.com/-rJzrWg38Ilc/U9LoRT-FdmI/AAAAAAAALVg/GotVf7Dk4AE/s1600/activiti_eclipse_designer.png" imageanchor="1"&gt;&lt;img src="http://2.bp.blogspot.com/-rJzrWg38Ilc/U9LoRT-FdmI/AAAAAAAALVg/GotVf7Dk4AE/s320/activiti_eclipse_designer.png" border="0"&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;Ennek XML ábrázolása is nagyon egyszerű, semmi rémisztő nincs benne, akár kézzel is szerkeszthető.&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="tag"&gt;&amp;lt;definitions&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
  &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;process&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;id&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"timeoffrequest"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"Time off request"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;isExecutable&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"true"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;startEvent&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;id&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"startevent"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"Start"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&amp;lt;/startEvent&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;endEvent&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;id&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"endevent"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"End"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&amp;lt;/endEvent&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;userTask&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;id&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"approve"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"Approve"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&amp;lt;/userTask&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;sequenceFlow&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;id&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"flow1"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;sourceRef&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"startevent"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;targetRef&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"approve"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/sequenceFlow&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;sequenceFlow&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;id&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"flow2"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;sourceRef&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"approve"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;targetRef&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"endevent"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/sequenceFlow&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
  &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/process&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
  &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;bpmndi:BPMNDiagram&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;id&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"BPMNDiagram_timeoffrequest"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="com"&gt;&amp;lt;!-- Itt van a diagram grafikus leírása, az alakzatok 
         koordinátáival. --&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
  &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/bpmndi:BPMNDiagram&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/definitions&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ha ez megvan, akkor ezt tegyük a classpath-ra, hogy egyszerű legyen betölteni. A következő lépés az Activiti függőség deklarálása a &lt;code&gt;pom.xml&lt;/code&gt;-ben, szerencsére fenn van a central repository-ban.&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="tag"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;org.activiti&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;activiti-spring&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;5.15.1&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Amennyiben Springben deklarálva van &lt;code&gt;dataSource&lt;/code&gt; és &lt;code&gt;transactionManager&lt;/code&gt;, definiálhatjuk az un. &lt;em&gt;process engine&lt;/em&gt;-t. &lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="tag"&gt;&amp;lt;bean&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;id&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"processEngineConfiguration"&lt;/span&gt;&lt;span class="pln"&gt; 
        &lt;/span&gt;&lt;span class="atn"&gt;class&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"org.activiti.spring.SpringProcessEngineConfiguration"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;property&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"dataSource"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;ref&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"dataSource"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;property&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"transactionManager"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;ref&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"transactionManager"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;property&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"databaseSchemaUpdate"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;value&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"true"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;

&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;bean&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;id&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"processEngine"&lt;/span&gt;&lt;span class="pln"&gt; 
        &lt;/span&gt;&lt;span class="atn"&gt;class&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"org.activiti.spring.ProcessEngineFactoryBean"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;property&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"processEngineConfiguration"&lt;/span&gt;&lt;span class="pln"&gt; 
            &lt;/span&gt;&lt;span class="atn"&gt;ref&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"processEngineConfiguration"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Azt is beállítjuk, hogy a tábláit maga hozza létre. Itt lehetne megadni a deploy-olandó workflow-t, azonban egy trükk miatt nem itt teszem. Ugyanis integrációs teszteket akarok futtatni, és akkor szeretném mindig újrainicializálni az Activiti-t. Ezt a legegyszerűbben úgy tehetem, hogy mindig kitörlöm a &lt;em&gt;workflow definitiont&lt;/em&gt;, és cascade módban törli a hozzá tartozó &lt;em&gt;process instance&lt;/em&gt;-eket, majd újra deploy-olom a definitiont.&lt;/p&gt;

&lt;p&gt;Az Activiti API használatához definiálni kell egy csomó service-t. Pl. a &lt;code&gt;repositoryService&lt;/code&gt; felelős a workflow definitionök karbantartásáért, a &lt;code&gt;runtimeService&lt;/code&gt; segítségével lehet pl. process instance-t indítani, és a &lt;code&gt;taskService&lt;/code&gt; segítségével lehet lekérdezni az elvégzendő feladatokat. Van még egy pár, úgymint &lt;code&gt;managementService&lt;/code&gt;, &lt;code&gt;identityService&lt;/code&gt;, &lt;code&gt;historyService&lt;/code&gt; és &lt;code&gt;FormService&lt;/code&gt;.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://activiti.org/userguide/images/api.services.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img src="http://activiti.org/userguide/images/api.services.png" border="0"&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;Definiáljuk tehát őket.&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="tag"&gt;&amp;lt;bean&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;id&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"repositoryService"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;factory-bean&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"processEngine"&lt;/span&gt;&lt;span class="pln"&gt; 
        &lt;/span&gt;&lt;span class="atn"&gt;factory-method&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"getRepositoryService"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;bean&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;id&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"runtimeService"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;factory-bean&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"processEngine"&lt;/span&gt;&lt;span class="pln"&gt; 
        &lt;/span&gt;&lt;span class="atn"&gt;factory-method&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"getRuntimeService"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;bean&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;id&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"taskService"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;factory-bean&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"processEngine"&lt;/span&gt;&lt;span class="pln"&gt; 
        &lt;/span&gt;&lt;span class="atn"&gt;factory-method&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"getTaskService"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Implementáljuk tehát a metódusokat. A &lt;code&gt;requestTimeOff&lt;/code&gt; indít egy új process instance-t. Érdekessége, hogy lehet neki megadni un. paramétereket, melyeket lement. (Komplex objektumok esetén blobba az adatbázisba, szerializálva, ezért ezt nem is javaslom, elégedjünk meg az egyszerű típusokkal.)&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;void&lt;/span&gt;&lt;span class="pln"&gt; requestTimeOff&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;TimeOffRequest&lt;/span&gt;&lt;span class="pln"&gt; timeOffRequest&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="typ"&gt;Map&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;Object&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; parameters &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;new&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;HashMap&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;span class="pln"&gt;
    parameters&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;put&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;PROCESS_VARIABLE_TIME_OFF_REQUEST&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; timeOffRequest&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;span class="pln"&gt;
    runtimeService&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;startProcessInstanceByKey&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;DEPLOYMENT_NAME&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt;
        timeOffRequest&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getId&lt;/span&gt;&lt;span class="pun"&gt;(),&lt;/span&gt;&lt;span class="pln"&gt; parameters&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A feladatok lekérdezése nagyon egyszerű. Látható, hogy az Activiti a lekérdezésre fluent API-t bocsájt a rendelkezésünkre. A trükk az, hogy lekérdezzük a feladatokat, és a feladatokhoz tartozó process instance-okban futó un. &lt;em&gt;process variable&lt;/em&gt;-öket is.&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;List&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&lt;/span&gt;&lt;span class="typ"&gt;TimeOffRequest&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; listTimeOffRequests&lt;/span&gt;&lt;span class="pun"&gt;()&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="typ"&gt;List&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&lt;/span&gt;&lt;span class="typ"&gt;TimeOffRequest&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; requests &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;new&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;ArrayList&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="typ"&gt;List&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&lt;/span&gt;&lt;span class="typ"&gt;Task&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; tasks &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; taskService&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;createTaskQuery&lt;/span&gt;&lt;span class="pun"&gt;()&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;orderByTaskCreateTime&lt;/span&gt;&lt;span class="pun"&gt;().&lt;/span&gt;&lt;span class="pln"&gt;includeProcessVariables&lt;/span&gt;&lt;span class="pun"&gt;()&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;desc&lt;/span&gt;&lt;span class="pun"&gt;().&lt;/span&gt;&lt;span class="pln"&gt;list&lt;/span&gt;&lt;span class="pun"&gt;();&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="kwd"&gt;for&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;Task&lt;/span&gt;&lt;span class="pln"&gt; task&lt;/span&gt;&lt;span class="pun"&gt;:&lt;/span&gt;&lt;span class="pln"&gt; tasks&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
        requests&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;add&lt;/span&gt;&lt;span class="pun"&gt;((&lt;/span&gt;&lt;span class="typ"&gt;TimeOffRequest&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; task&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getProcessVariables&lt;/span&gt;&lt;span class="pun"&gt;()&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;get&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;PROCESS_VARIABLE_TIME_OFF_REQUEST&lt;/span&gt;&lt;span class="pun"&gt;));&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="kwd"&gt;return&lt;/span&gt;&lt;span class="pln"&gt; requests&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A jóváhagyás a &lt;code&gt;taskService&lt;/code&gt; &lt;code&gt;complete&lt;/code&gt; metódusával történik. Minden egyes process instance-nak kell egy egyedi azonosítót adni, amivel később hivatkozhatunk rá. Most én az e-mail cím, és a kezdő dátumot adtam. Mindenképpen érdemes valami olvashatót választani, és nem egy generált számot.&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;void&lt;/span&gt;&lt;span class="pln"&gt; approve&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;TimeOffRequest&lt;/span&gt;&lt;span class="pln"&gt; timeOffRequest&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="typ"&gt;List&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&lt;/span&gt;&lt;span class="typ"&gt;Task&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; tasks &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; taskService&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;createTaskQuery&lt;/span&gt;&lt;span class="pun"&gt;()&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;processInstanceBusinessKey&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;timeOffRequest&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getId&lt;/span&gt;&lt;span class="pun"&gt;()).&lt;/span&gt;&lt;span class="pln"&gt;list&lt;/span&gt;&lt;span class="pun"&gt;();&lt;/span&gt;&lt;span class="pln"&gt;
    taskService&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;complete&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;tasks&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;iterator&lt;/span&gt;&lt;span class="pun"&gt;().&lt;/span&gt;&lt;span class="pln"&gt;next&lt;/span&gt;&lt;span class="pun"&gt;().&lt;/span&gt;&lt;span class="pln"&gt;getId&lt;/span&gt;&lt;span class="pun"&gt;());&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ezt lehet két lépésben is csinálni, mikor a feladatot először a felhasználó magához rendeli (&lt;code&gt;claim&lt;/code&gt;), dolgozik rajta, és csak később fejezi be. Ekkor más már nem tudja a feladatot magához rendelni.&lt;/p&gt;

&lt;p&gt;Nézzük, hogy a teszteléskor hogyan adjuk meg a deploy-olandó BPMN 2.0 fájlt.&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="kwd"&gt;private&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;void&lt;/span&gt;&lt;span class="pln"&gt; deploy&lt;/span&gt;&lt;span class="pun"&gt;()&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
    repositoryService&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;createDeployment&lt;/span&gt;&lt;span class="pun"&gt;()&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"timeoffrequest"&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;addInputStream&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"timeoff.bpmn"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;WorkflowIntegrationTest&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="kwd"&gt;class&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getResourceAsStream&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"/timeoff.bpmn"&lt;/span&gt;&lt;span class="pun"&gt;))&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;deploy&lt;/span&gt;&lt;span class="pun"&gt;();&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Utána nincs más dolgunk, mint az interfészünkön keresztül tesztelni a folyamatunkat. A példa érdekessége, hogy nem is használtunk saját entitást, hanem a szükséges adatokat a process instance-ben tároltuk. Persze érdemes saját entitásokat használni, és itt csak az id-kat tárolni.&lt;/p&gt;

&lt;p&gt;Most bonyolítsuk annyival a feladatot, hogy ne csak mi hívjuk a workflow-t, hanem a workflow is hívjon ki. Pl. a szabadság jóváhagyása nem minden esetben szükséges, amennyiben kellően távol van, automatikusan jóváhagyásra kerül. Ezzel egy elágazást is teszünk azonnal a workflow-ba. A feltételt egy Java metódusban implementáljuk. Tapasztalat szerint az is jó rossz irány, hogy azokat a műveleteket is, melyeket a workflow hív, kitenni egy külön interfészbe, így jól mockolható is. Valamint érdemes egy darab ilyen interfészt kialakítani, a Facade tervezési mintának megfelelően.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://1.bp.blogspot.com/-X9Weoz5SfaI/U9LoR2rK3eI/AAAAAAAALVk/KjkZ0f7YGDI/s1600/timeoff_2.png" imageanchor="1"&gt;&lt;img src="http://1.bp.blogspot.com/-X9Weoz5SfaI/U9LoR2rK3eI/AAAAAAAALVk/KjkZ0f7YGDI/s320/timeoff_2.png" border="0"&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;Legyen ez pl. a &lt;code&gt;WorkflowSupport&lt;/code&gt; interfész, benne a &lt;code&gt;shouldApprove&lt;/code&gt; metódussal.&lt;/p&gt;

&lt;p&gt;A BPMN állományba egy &lt;em&gt;service taskot&lt;/em&gt; kell tenni, ahol expressionnek megadható a hívás.&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="pln"&gt;#{workflowSupport.shouldApprove()}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ekkor a Spring application contextben lévő &lt;code&gt;workflowSupport&lt;/code&gt; bean &lt;code&gt;shouldApprove()&lt;/code&gt; metódusát fogja meghívni. Ha van visszatérési értéke, megadható, hogy milyen változóba tegye, legyen ez a &lt;code&gt;shouldApproveResult&lt;/code&gt;. Az elágazás egy &lt;em&gt;exclusive gateway&lt;/em&gt;, melyből kivezető élnek a következő feltételt adhatjuk meg:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="pln"&gt;${!shouldApproveResult}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Az Activiti ennél sokkal többet tud, pl. felhasználókezelés, teljeskörű audit naplózás, listenerek kezelése (, melyek különböző workflow eseményeket figyelnek), egyszerű űrlapok definiálása, e-mail küldés, stb., melyek alkalmassá teszik egy teljes értékű workflow motornak.&lt;/p&gt;

&lt;p&gt;Összességében elmondható, hogy az Activiti egy pehelysúlyú, nagyon könnyen használható, és a Springhez nagyon jól illeszthető workflow engine. Annyit azonban meg kell jegyezni, hogy az üzleti folyamatok ilyen fajta ábrázolása egy kötöttséget ad, nincs akkora szabadságunk, mintha csak státuszokat állítgatnánk. Ebből következik, hogy nem annyira egyszerű a táblaszerkezete, így nem olyan könnyű adatbázisba hátulról belenyúlni. Viszont egy folyamatosan naprakész dokumentációt kapunk az üzleti folyamatokról, ami biztos, hogy nem avul el. Valamint biztosítja, hogy ne legyenek elvarratlan szálak, nem maradhat ki &lt;em&gt;else&lt;/em&gt; ág.&lt;/p&gt;

&lt;p&gt;Ami még elég macerás, az a migráció. Az Activiti verziózva tárolja a workflow definitionöket. Lehet új verziót deploy-olni, de minden process instance azzal a verzióval fut végig, amivel elindult. Lehet migrálni, de az nagyon fájdalmas, ha lehet, kerüljük azzal, hogy végigvisszük új verzió kiadása előtt a process instance-eket.&lt;/p&gt;

&lt;p&gt;Az Activiti Engine és Designer komponenseken kívül más komponensek is vannak. Van pl. a Modeller, mellyel webes felületen tudjuk szerkeszteni a workflow-kat. Van a Activiti Explorer, mely szintén webes, és workflow definitionöket lehet deploy-olni, azokat futtatni, rendelkezik valamiféle felhasználókezeléssel, és ad felületet a taskok kezelésére, sőt grafikusan mutatja, hogy hol állnak a process instance-ek. Az Activiti REST API-n keresztül is elérhető.&lt;/p&gt;

&lt;p&gt;Azt még külön kiemelném, hogy bár a munkafolyamatok tervezéséhez nem kell fejlesztői tudás, ez nem jelenti azt, hogy egyszerű. Teljesen másképp kell gondolkodni, másképp kell az ügyféllel egyeztetni. Vannak itt is legjobb gyakorlatok, érdemes konvenciókat alkalmazni. Egy külön tudomány, melyhez rengeteg jó könyv is elérhető.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/3715503487373710542/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2014/07/pehelysulyu-workflow-activitivel.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3715503487373710542'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3715503487373710542'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/07/pehelysulyu-workflow-activitivel.html' title='Pehelysúlyú workflow Activitivel'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://2.bp.blogspot.com/-Qk0h0wtjid8/U9LoRXXBhuI/AAAAAAAALVY/EodbdlsXPfM/s72-c/activity_diagram_1.png' height='72' width='72'/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2322684734980758092</id><published>2014-07-12T16:22:00.000+02:00</published><updated>2014-09-17T22:28:11.266+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Spring'/><category scheme='http://www.blogger.com/atom/ns#' term='JPA'/><title type='text'>Spring Data</title><content type='html'>&lt;p&gt;Használt technológiák: Spring Data 1.6&lt;/p&gt;

&lt;p&gt;Be kell vallanom, első körben meglehetősen szkeptikus voltam a Spring Data projekttel kapcsolatban, és nem hittem, hogy bármi pluszt képes nyújtani a Spring JPA integrációjához képest, de kipróbálva hamar kiderült, hogy hasznos lenne alkalmazni. Amennyiben a projektedben találsz olyan (absztrakt) ősosztály(oka)t, melyek feladata tipikus CRUD műveletek végrehajtása, esetleg típus biztosan, hogy ne kelljen azokat újra implementálni, akkor a Spring Data neked is tetszeni fog.&lt;/p&gt;

&lt;p&gt;A poszthoz egyszerű &lt;a href="https://github.com/vicziani/jtechlog-spring-data"&gt;példaprojektet&lt;/a&gt; is találsz a GitHub-on, valamint egy &lt;a href="http://about.jtechlog.hu/artifacts/2014-06_spring_data/2014-06_spring_data.html"&gt;prezentációt&lt;/a&gt;, amit nyugodtan felhasználhatsz arra, hogy meggyőzz másokat is.&lt;/p&gt;

&lt;p&gt;A Spring Data alapvetően egy Spring Frameworkre épülő projekt, és segít abban, hogy egyszerűbben implementálhassuk alkalmazásaink perzisztens rétegét. Egy olyan projekt, mely több projektet is tartalmaz, ugyanis különböző perzisztens technológiákra implementálták, úgymint JPA, JDBC, REST, de olyan NoSQL megoldásokra is van implementációja, mint MongoDB, Neo4j, Redis, Hadoop, stb.&lt;/p&gt;

&lt;p&gt;A Spring szóhasználatban &lt;em&gt;repository&lt;/em&gt;-k megvalósítására való, és tipikus CRUD műveleteket lehet definiálni, ráadásul az olyan gyakori igények figyelembe vételével, mint a rendezés vagy a lapozás.&lt;/p&gt;

&lt;p&gt;Az érdekessége, hogy egyszerűbb esetben nem nekünk kell implementálni a metódusokat. Nekünk elég az interfészben különböző névkonvenciók alapján definiálni a metódusokat, és a Spring Data implementálja azokat. A leggyakoribb metódusokat még definiálni sem kell, elég interfészünknek valamely már létező interfészből leszármaznia. Amennyiben azonban nem elegendő a Spring Data tudása, természetesen mi is implementálhatunk saját metódusokat.&lt;/p&gt;

&lt;p&gt;A Spring Data projekt része a Spring Data JPA, mely a már meglévő Spring JPA integrációra épül rá. Ugyanúgy deklarálnunk kell a &lt;code&gt;DataSource&lt;/code&gt;-t, &lt;code&gt;EntityManagerFactory&lt;/code&gt;-t, &lt;code&gt;TransactionManager&lt;/code&gt;-t és a JPA annotációkkal ellátott entitásokat. Eztán a következőket kell elvégeznünk. Maven használata esetén először definiáljuk a Spring Data JPA függőséget.&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="tag"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;org.springframework.data&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;spring-data-jpa&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;1.6.0.RELEASE&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Amennyiben ez megvan, az application config xml állományban definiáljuk, hogy mely csomagban találhatóak a repository-k. (Természetesen lehetőség van Java Configban való megadásra is az &lt;code&gt;@EnableJpaRepositories&lt;/code&gt; annotáció használatával.)&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="tag"&gt;&amp;lt;jpa:repositories&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;base-package&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"jtechlog.springdata"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Eztán elegendő az interfészt definiálni. Leszármazhat a &lt;code&gt;Repository&lt;/code&gt; interfészből, de mivel ennek nincs semmilyen előre definiált metódusa, használjuk inkább a &lt;code&gt;CrudRepository&lt;/code&gt; interfészt ősnek, ami a következő metódusokat definiálja: &lt;code&gt;save(Employee)&lt;/code&gt;, &lt;code&gt;save(Iterable&amp;lt;Employee&amp;gt;)&lt;/code&gt;, &lt;code&gt;findOne(Long)&lt;/code&gt;, &lt;code&gt;exists(Long)&lt;/code&gt;, &lt;code&gt;findAll()&lt;/code&gt;, &lt;code&gt;findAll(Iterable&amp;lt;Long&amp;gt;)&lt;/code&gt;, &lt;code&gt;count()&lt;/code&gt;, &lt;code&gt;delete(Long)&lt;/code&gt;, &lt;code&gt;delete(Employee)&lt;/code&gt;, &lt;code&gt;deleteAll()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Interfészünk tehát:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="kwd"&gt;import&lt;/span&gt;&lt;span class="pln"&gt; org&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;springframework&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;data&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;repository&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="typ"&gt;CrudRepository&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;

&lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; interface &lt;/span&gt;&lt;span class="typ"&gt;EmployeeRepository&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;extends&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;CrudRepository&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&lt;/span&gt;&lt;span class="typ"&gt;Employee&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;Long&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Eztán már azonnal használatba is vehetjük, hiszen ahogy említettem az implementációt a Spring Data JPA fogja elkészíteni. Tehát a teszt eset:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="lit"&gt;@Test&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;void&lt;/span&gt;&lt;span class="pln"&gt; testSave_findAllShouldReturnOne&lt;/span&gt;&lt;span class="pun"&gt;()&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
    employeeRepository&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;save&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="kwd"&gt;new&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;Employee&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"John Doe"&lt;/span&gt;&lt;span class="pun"&gt;));&lt;/span&gt;&lt;span class="pln"&gt;

    assertThat&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;employeeRepository&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;findAll&lt;/span&gt;&lt;span class="pun"&gt;(),&lt;/span&gt;&lt;span class="pln"&gt; 
        contains&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;hasName&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;equalTo&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"John Doe"&lt;/span&gt;&lt;span class="pun"&gt;))));&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ehhez új metódusokat adhatunk hozzá, melyhez a &lt;a href="http://docs.spring.io/spring-data/jpa/docs/1.6.0.RELEASE/reference/html/jpa.repositories.html#jpa.query-methods.query-creation"&gt;névkonvenció&lt;/a&gt; alapján automatikusan implementációt fog gyártani a Spring Data JPA.&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="typ"&gt;Iterable&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&lt;/span&gt;&lt;span class="typ"&gt;Employee&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; findByNameStartingWith&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pln"&gt; namePrefix&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Amennyiben ez nem megfelelő, saját JPA query-t is definiálhatunk, a &lt;code&gt;@Query&lt;/code&gt; annotáció használatával.&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="lit"&gt;@Query&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"select e from Employee e where length(e.name) = :nameLength"&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="typ"&gt;Iterable&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&lt;/span&gt;&lt;span class="typ"&gt;Employee&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; findByNameLength&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="lit"&gt;@Param&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"nameLength"&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;int&lt;/span&gt;&lt;span class="pln"&gt; nameLength&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Amennyiben egy metódushoz saját implementációt akarunk rendelni, akkor a metódust egy külön interfészbe definiáljuk, ami szintén őse legyen a repository interfészünknek, és adjuk meg hozzá az implementációt is a klasszikus JPA módon.&lt;/p&gt;

&lt;p&gt;Saját interfész:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; interface &lt;/span&gt;&lt;span class="typ"&gt;EmployeeRepositoryCustom&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;

    &lt;/span&gt;&lt;span class="typ"&gt;List&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&lt;/span&gt;&lt;span class="typ"&gt;Employee&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; findByNameStartingWithAsList&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pln"&gt; namePrefix&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Saját implementáció:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;class&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;EmployeeRepositoryImpl&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;implements&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;EmployeeRepositoryCustom&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;

    &lt;/span&gt;&lt;span class="lit"&gt;@Autowired&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="kwd"&gt;private&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;EntityManager&lt;/span&gt;&lt;span class="pln"&gt; entityManager&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;

    &lt;/span&gt;&lt;span class="lit"&gt;@Override&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;List&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&lt;/span&gt;&lt;span class="typ"&gt;Employee&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; findByNameStartingWithAsList&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pln"&gt; namePrefix&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="kwd"&gt;return&lt;/span&gt;&lt;span class="pln"&gt; entityManager
            &lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;createQuery&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;
                &lt;/span&gt;&lt;span class="str"&gt;"select e from Employee e where e.name like :namePrefix"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; 
                &lt;/span&gt;&lt;span class="typ"&gt;Employee&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="kwd"&gt;class&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;setParameter&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"namePrefix"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; namePrefix &lt;/span&gt;&lt;span class="pun"&gt;+&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="str"&gt;"%"&lt;/span&gt;&lt;span class="pun"&gt;).&lt;/span&gt;&lt;span class="pln"&gt;getResultList&lt;/span&gt;&lt;span class="pun"&gt;();&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;És a repository interfész:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; interface &lt;/span&gt;&lt;span class="typ"&gt;EmployeeRepository&lt;/span&gt;&lt;span class="pln"&gt; 
    &lt;/span&gt;&lt;span class="kwd"&gt;extends&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;CrudRepository&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&lt;/span&gt;&lt;span class="typ"&gt;Employee&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;Long&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;EmployeeRepositoryCustom&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="com"&gt;// ...&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ha rendezni akarunk, akkor definiálhatjuk a metódus nevében:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="typ"&gt;Iterable&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&lt;/span&gt;&lt;span class="typ"&gt;Employee&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; findByNameStartingWithOrderByNameAsc&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pln"&gt; namePrefix&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vagy ha ennél dinamikusabb megoldás akarunk, akkor használjuk a &lt;code&gt;Sort&lt;/code&gt; típust paraméterként.&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="typ"&gt;Iterable&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&lt;/span&gt;&lt;span class="typ"&gt;Employee&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; findByNameStartingWith&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pln"&gt; namePrefix&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;Sort&lt;/span&gt;&lt;span class="pln"&gt; sort&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mely így használható:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="pln"&gt;employeeRepository&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;findByNameStartingWith&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"J"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; 
    &lt;/span&gt;&lt;span class="kwd"&gt;new&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;Sort&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="kwd"&gt;new&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;Sort&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="typ"&gt;Order&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;Sort&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="typ"&gt;Direction&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;ASC&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="str"&gt;"name"&lt;/span&gt;&lt;span class="pun"&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ha lapozást is akarunk, akkor a &lt;code&gt;Pageable&lt;/code&gt; használandó:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="typ"&gt;Page&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&lt;/span&gt;&lt;span class="typ"&gt;Employee&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; findByNameStartingWith&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pln"&gt; namePrefix&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;Pageable&lt;/span&gt;&lt;span class="pln"&gt; page&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Melyet a következő módon tudunk hívni:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="typ"&gt;Page&lt;/span&gt;&lt;span class="pln"&gt; page &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; employeeRepository&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;findByNameStartingWith&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"J"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; 
    &lt;/span&gt;&lt;span class="kwd"&gt;new&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;PageRequest&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="lit"&gt;3&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="lit"&gt;3&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;new&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;Sort&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="kwd"&gt;new&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;Sort&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="typ"&gt;Order&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;Sort&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="typ"&gt;Direction&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;ASC&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="str"&gt;"name"&lt;/span&gt;&lt;span class="pun"&gt;))));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;Page&lt;/code&gt; tartalmazza a lekérdezés eredményét, és a lapozáshoz szükséges többi információt is.&lt;/p&gt;

&lt;p&gt;Látható, hogy a Spring Data használata rendkívül egyszerű, sok boilerplate kódtól szabadulhatunk meg. Nekem az is tetszik, hogy így metódusainknak szabványos nevet adhatunk meg. Fokozatosan lehet bevezetni a projektjeinkbe, akár DAO-nként állhatunk át, és az egyre bonyolultabb funkcióit is folyamatosan vehetjük használatba.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/2322684734980758092/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2014/07/spring-data.html#comment-form' title='4 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2322684734980758092'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2322684734980758092'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/07/spring-data.html' title='Spring Data'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>4</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8068058210754324386</id><published>2014-06-26T11:35:00.000+02:00</published><updated>2014-06-26T11:35:09.160+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Community'/><title type='text'>budapest.scala meetup</title><content type='html'>&lt;p&gt;A nyár közepén, 2014. július 1-én, kedden, 19:00-tól &lt;a href="http://www.meetup.com/budapest-scala/"&gt;budapest.scala meetup&lt;/a&gt; lesz, melyen én is előadok Maven témakörben. Helyszín a Ustream HQ (Budapest, Andrássy út 39.). Főleg a Maven lesz a téma programozási nyelvtől függetlenül, így érdekes lehet nem Scala programozóként is, valamint egy kis betekintést nyerhetsz a Scala-ba és találkozhatsz a magyar Scala közösség tagjaival is. (Valamint a helyszín miatt is érdemes eljönni!)&lt;/p&gt;

&lt;p&gt;Szó lesz a Maven alapjairól, fogalmairól, valamint arról, hogy miért szeretjük. Elhangzik, hogy mennyire illeszthető a Continuous Integrationbe, Continuous Deliverybe. Hallhattok az alternatív lehetőségekről, sőt a Maven árnyoldalairól is.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/8068058210754324386/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2014/06/budapest-scala-meetup.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/8068058210754324386'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/8068058210754324386'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/06/budapest-scala-meetup.html' title='budapest.scala meetup'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1065281452235807034</id><published>2014-05-26T22:24:00.000+02:00</published><updated>2014-05-27T09:54:48.265+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Tesztelés'/><title type='text'>Hamcrest</title><content type='html'>&lt;p&gt;Technológiák: JUnit 4.11, Hamcrest 1.3&lt;/p&gt;

&lt;h3 id="bevezetés"&gt;Bevezetés&lt;/h3&gt;

&lt;p&gt;Ahogy egyre többet írok unit teszteket, így foglalkoztat a gondolat, hogyan lehet minél hatékonyabb asserteket írni. Elvárásaim ezekkel kapcsolatban a következők. Rövidek legyenek, azaz gyorsan, gond nélkül lehessen ezeket megírni. Más számára is könnyen olvashatóak legyenek. Amennyiben elbuknak, értelmes hibaüzeneteket adjanak. És össze lehessen fűzni akár őket.&lt;/p&gt;

&lt;p&gt;Köszönet Lontay Gábornak, aki sokat segített a Hamcrest megértésében.&lt;/p&gt;

&lt;p&gt;A poszthoz készült példaprogram &lt;a href="https://github.com/vicziani/jtechlog-hamcrest"&gt;elérhető a GitHub-on&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A Wikipedia &lt;a href="http://en.wikipedia.org/wiki/Hamcrest"&gt;szerint&lt;/a&gt; az asserteknek már a harmadik generációjánál járunk. Kezdetben az assert csak egy logikai kifejezést várt, ami ha a kiértékelés során hamisat adott vissza, a teszt elbukott. (Üzenetet ennek is lehetett paraméterül adni.) A második generációs assertek azonban külön várták az aktuális és az elvárt eredményt, így az üzenetben ki tudták írni, hogy pontosan mik nem stimmeltek.&lt;/p&gt;

&lt;p&gt;A harmadik generációs assertek azonban támogatják az &lt;code&gt;assertThat&lt;/code&gt; kifejezést, mely várja az aktuális értéket, valamint egy un. &lt;code&gt;Matcher&lt;/code&gt; objektumot.&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="pln"&gt;assertThat&lt;/span&gt;&lt;span class="pun"&gt;([&lt;/span&gt;&lt;span class="pln"&gt;ellen&lt;/span&gt;&lt;span class="pun"&gt;ő&lt;/span&gt;&lt;span class="pln"&gt;rizend&lt;/span&gt;&lt;span class="pun"&gt;ő&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;é&lt;/span&gt;&lt;span class="pln"&gt;rt&lt;/span&gt;&lt;span class="pun"&gt;é&lt;/span&gt;&lt;span class="pln"&gt;k&lt;/span&gt;&lt;span class="pun"&gt;],&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;[&lt;/span&gt;&lt;span class="pln"&gt;matcher&lt;/span&gt;&lt;span class="pun"&gt;]);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Egy példával talán érthetőbb: &lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="pln"&gt;assertThat&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;bank&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getName&lt;/span&gt;&lt;span class="pun"&gt;(),&lt;/span&gt;&lt;span class="pln"&gt; either&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;containsString&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"CIB"&lt;/span&gt;&lt;span class="pun"&gt;)).&lt;/span&gt;&lt;span class="pln"&gt;or&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;containsString&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"BANK"&lt;/span&gt;&lt;span class="pun"&gt;)));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ebből az látszik, hogy fluent interfésszel rendelkezik, és primitív matcherekből különböző konstrukciókkal, pl. logikai műveletekkel, bonyolultabbakat lehet összerakni. Gyakorlatilag ezzel egy &lt;a href="http://en.wikipedia.org/wiki/Domain-specific_language"&gt;DSL-t&lt;/a&gt;, azaz egy primitív saját nyelvet rakhatunk össze objektumok (egyezőségének) vizsgálatára, ami inkább deklaratív, mint procedurális. Sőt, a hibaüzenetek is olvashatóak maradnak.&lt;/p&gt;

&lt;p&gt;Ehhez képzeljük el, hogy nem csak szöveges összehasonlítások vannak, hanem pl. collectionök kezelésére való mûveletek is, pl. olyan feltételeket tudunk szabni, hogy egy vagy több elem benne van-e a collectionben, megfelelő sorrendben-e, stb. Ezen kívül még saját matchereket is lehet implementálni.&lt;/p&gt;

&lt;h3 id="hamcrest-1"&gt;Hamcrest&lt;/h3&gt;

&lt;p&gt;Javaban erre a &lt;a href="http://hamcrest.org/JavaHamcrest"&gt;Hamcrest&lt;/a&gt; könyvtár használható (, ami a matchers anagrammája). Ezt az eszközt Joe Walnes fejlesztette ki a &lt;a href="http://jmock.org/"&gt;jMock&lt;/a&gt; mock keretrendszer részeként, majd kiszervezte és a Hamcrest nevet adta neki. &lt;/p&gt;

&lt;p&gt;A Hamcrest &lt;a href="http://code.google.com/p/hamcrest/wiki/HamcrestDistributables"&gt;két rétegből&lt;/a&gt; áll, egyrészt a &lt;code&gt;core&lt;/code&gt;, mely stabil, osztályai nem változnak, valamint a &lt;code&gt;library&lt;/code&gt;, mely collectionök, stringek, JavaBeanek, stb. kezelésére való matchereket tartalmaz, és megjelenhetnek újabb és újabb matcherek. Ennek megfelelően érdemes mindkettőt használni, és a &lt;code&gt;org.hamcrest.CoreMatchers&lt;/code&gt; osztály helyett a &lt;code&gt;org.hamcrest.Matchers&lt;/code&gt; osztály metódusait statikusan importálni.&lt;/p&gt;

&lt;p&gt;Ha már az olvashatóság az egyik legnagyobb előny, nézzük, hogy mi történik klasszikus esetben, és mi az &lt;code&gt;assertThat&lt;/code&gt;-tel. A JUnit még tartja magát.&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code&gt;&lt;span class="kwd"&gt;assert&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;bank&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getName&lt;/span&gt;&lt;span class="pun"&gt;().&lt;/span&gt;&lt;span class="pln"&gt;equals&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"CIB BANK"&lt;/span&gt;&lt;span class="pun"&gt;));&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="com"&gt;// ==&amp;gt; hibaüzenet: &lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="com"&gt;// java.lang.AssertionError&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="com"&gt;// ... stacktrace&lt;/span&gt;&lt;span class="pln"&gt;

assertEquals&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"CIB BANK"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; bank&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getName&lt;/span&gt;&lt;span class="pun"&gt;());&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="com"&gt;// org.junit.ComparisonFailure: expected:&amp;lt;C[IB BA]NK&amp;gt; but was:&amp;lt;C[B B]NK&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="com"&gt;// ... stacktrace&lt;/span&gt;&lt;span class="pln"&gt;

assertThat&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;bank&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getName&lt;/span&gt;&lt;span class="pun"&gt;(),&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;is&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;equalTo&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"CIB BANK"&lt;/span&gt;&lt;span class="pun"&gt;)));&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="com"&gt;// java.lang.AssertionError:&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="com"&gt;// Expected: is "CIB BANK"&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="com"&gt;//     but: was "CB BNK"&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="com"&gt;// ... stacktrace&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;És nézzünk egy bonyolultabb feltételt:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code&gt;&lt;span class="pln"&gt;assertTrue&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;bank&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getName&lt;/span&gt;&lt;span class="pun"&gt;().&lt;/span&gt;&lt;span class="pln"&gt;contains&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"CIB"&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;||&lt;/span&gt;&lt;span class="pln"&gt; bank&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getName&lt;/span&gt;&lt;span class="pun"&gt;().&lt;/span&gt;&lt;span class="pln"&gt;contains&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"BANK"&lt;/span&gt;&lt;span class="pun"&gt;));&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="com"&gt;// java.lang.AssertionError&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="com"&gt;// ... stacktrace&lt;/span&gt;&lt;span class="pln"&gt;

assertThat&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;bank&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getName&lt;/span&gt;&lt;span class="pun"&gt;(),&lt;/span&gt;&lt;span class="pln"&gt; either&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;containsString&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"CIB"&lt;/span&gt;&lt;span class="pun"&gt;)).&lt;/span&gt;&lt;span class="kwd"&gt;or&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;containsString&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"BANK"&lt;/span&gt;&lt;span class="pun"&gt;)));&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="com"&gt;// java.lang.AssertionError: &lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="com"&gt;// Expected: (a string containing "CIB" or a string containing "BANK")&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="com"&gt;//     but: was "CB BNK"&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="com"&gt;// ... stacktrace&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sőt, az &lt;code&gt;assertThat&lt;/code&gt; egy override-olt metódusa &lt;code&gt;String&lt;/code&gt;-et is elfogad.&lt;/p&gt;&lt;div class="se-section-delimiter"&gt;&lt;/div&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code&gt;&lt;span class="pln"&gt;assertThat&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"name"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; bank&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getName&lt;/span&gt;&lt;span class="pun"&gt;(),&lt;/span&gt;&lt;span class="pln"&gt; either&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;containsString&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"CIB"&lt;/span&gt;&lt;span class="pun"&gt;)).&lt;/span&gt;&lt;span class="kwd"&gt;or&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;containsString&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"BANK"&lt;/span&gt;&lt;span class="pun"&gt;)));&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="com"&gt;// java.lang.AssertionError: name&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="com"&gt;// Expected: (a string containing "CIB" or a string containing "BANK")&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="com"&gt;//     but: was "CB BNK"&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="com"&gt;// ... stacktrace&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ahogy a &lt;a href="http://code.google.com/p/hamcrest/wiki/Tutorial"&gt;tutorial&lt;/a&gt; is írja, rengeteg core matcher jön a Hamcresttel, erről egy jó kis egy oldalas &lt;a href="http://www.marcphilipp.de/downloads/posts/2013-01-02-hamcrest-quick-reference/Hamcrest-1.3.pdf"&gt;referencia PDF&lt;/a&gt; is található. &lt;/p&gt;

&lt;p&gt;Nyilván vannak általános célú matcherek, mint egyenlőség ellenőrzés, relációk ellenőrzése, null ellenőrzés, &lt;code&gt;String&lt;/code&gt;-ek összehasonlítása, stb. Érdemes &lt;a href="http://edgibbs.com/junit-4-with-hamcrest/"&gt;ezt a cikket&lt;/a&gt; is elolvasni. Ami talán érdekesebb az a JavaBeanek és a kollekciók kezelése.&lt;/p&gt;&lt;div class="se-section-delimiter"&gt;&lt;/div&gt;

&lt;h3 id="hasproperty"&gt;HasProperty&lt;/h3&gt;

&lt;p&gt;A &lt;code&gt;hasProperty&lt;/code&gt; metódussal azt nézhetjük meg, hogy egy adott objektumnak a megadott property-je nekünk megfelelő-e.&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="pln"&gt;assertThat&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;bank&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; hasProperty&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"name"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; equalTo&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"CIB BANK"&lt;/span&gt;&lt;span class="pun"&gt;)));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="collections"&gt;Collections&lt;/h3&gt;

&lt;p&gt;A collectionök összehasonlítására a leggyakrabban használt metódusok a &lt;code&gt;contains&lt;/code&gt;, &lt;code&gt;containsInAnyOrder&lt;/code&gt;, &lt;code&gt;hasItem&lt;/code&gt;, &lt;code&gt;hasItems&lt;/code&gt; és &lt;code&gt;isIn&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;contains&lt;/code&gt; elnevezése nagyon megtévesztő, itt ugyanis a két collection pontos egyezőségét várja el, a sorrendet is beleértve.&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="pln"&gt;assertThat&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;bank&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getCards&lt;/span&gt;&lt;span class="pun"&gt;(),&lt;/span&gt;&lt;span class="pln"&gt; contains&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"CIB VISA Inspire"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="str"&gt;"CIB MasterCard Gold"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="str"&gt;"CIB Visa Internetkártya"&lt;/span&gt;&lt;span class="pun"&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Más sorrendben adva meg az értékeket, a teszt elbukik, akárcsak akkor, ha egyet kihagyunk. Ekkor szép hibaüzenetet is kapunk:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code&gt;&lt;span class="pln"&gt;java&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;lang&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="typ"&gt;AssertionError&lt;/span&gt;&lt;span class="pun"&gt;:&lt;/span&gt;&lt;span class="pln"&gt; 
&lt;/span&gt;&lt;span class="typ"&gt;Expected&lt;/span&gt;&lt;span class="pun"&gt;:&lt;/span&gt;&lt;span class="pln"&gt; iterable containing &lt;/span&gt;&lt;span class="pun"&gt;[&lt;/span&gt;&lt;span class="str"&gt;"CIB VISA Inspire"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="str"&gt;"CIB MasterCard Gold"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="str"&gt;"CIB Vis Internetkártya"&lt;/span&gt;&lt;span class="pun"&gt;]&lt;/span&gt;&lt;span class="pln"&gt;
     but&lt;/span&gt;&lt;span class="pun"&gt;:&lt;/span&gt;&lt;span class="pln"&gt; item &lt;/span&gt;&lt;span class="lit"&gt;2&lt;/span&gt;&lt;span class="pun"&gt;:&lt;/span&gt;&lt;span class="pln"&gt; was &lt;/span&gt;&lt;span class="str"&gt;"CIB Visa Internetkártya"&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="pun"&gt;...&lt;/span&gt;&lt;span class="pln"&gt; stacktrace&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;hasItem&lt;/code&gt;, &lt;code&gt;hasItems&lt;/code&gt; már az elnevezésének megfelelően működik, itt ugyanis tényleg azt nézi, hogy ténylegesen szerepel-e az elem(ek) a collectionben.&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="pln"&gt;assertThat&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;bank&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getCards&lt;/span&gt;&lt;span class="pun"&gt;(),&lt;/span&gt;&lt;span class="pln"&gt; hasItem&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"CIB MasterCard Gold"&lt;/span&gt;&lt;span class="pun"&gt;));&lt;/span&gt;&lt;span class="pln"&gt;

assertThat&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;bank&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getCards&lt;/span&gt;&lt;span class="pun"&gt;(),&lt;/span&gt;&lt;span class="pln"&gt; hasItems&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"CIB VISA Inspire"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="str"&gt;"CIB MasterCard Gold"&lt;/span&gt;&lt;span class="pun"&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Az &lt;code&gt;isIn&lt;/code&gt; metódussal fordítva adhatjuk meg:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="pln"&gt;assertThat&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"CIB MasterCard Gold"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; isIn&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;bank&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getCards&lt;/span&gt;&lt;span class="pun"&gt;()));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ha a &lt;code&gt;hasItem&lt;/code&gt; metódusnak matchert akarunk paraméterül átadni, hamar meglepetés érhet. A következő kód ugyanis &lt;a href="https://weblogs.java.net/blog/johnsmart/archive/2008/04/on_the_subtle_u.html"&gt;nem működik&lt;/a&gt;:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="pln"&gt;assertThat&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;bank&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getAddresses&lt;/span&gt;&lt;span class="pun"&gt;(),&lt;/span&gt;&lt;span class="pln"&gt; hasItem&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;hasProperty&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"zip"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; equalTo&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"5600"&lt;/span&gt;&lt;span class="pun"&gt;))));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Helyette a következő &lt;em&gt;trükköt&lt;/em&gt; kell alkalmaznunk:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="pln"&gt;assertThat&lt;/span&gt;&lt;span class="pun"&gt;((&lt;/span&gt;&lt;span class="typ"&gt;List&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&lt;/span&gt;&lt;span class="typ"&gt;Object&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;)(&lt;/span&gt;&lt;span class="typ"&gt;List&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt;bank&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getAddresses&lt;/span&gt;&lt;span class="pun"&gt;(),&lt;/span&gt;&lt;span class="pln"&gt; hasItem&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;hasProperty&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"zip"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; equalTo&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"5600"&lt;/span&gt;&lt;span class="pun"&gt;))));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Érdekessége, hogy míg a csak &lt;code&gt;List&lt;/code&gt;-té castolást az IDEA/Eclipse elfogadja, parancssori fordításkor elszáll, így kell a &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;-té castolás is.&lt;/p&gt;

&lt;h3 id="saját-matcher-implementálása"&gt;Saját Matcher implementálása&lt;/h3&gt;

&lt;p&gt;A matcherek a &lt;code&gt;Matcher&lt;/code&gt; interfészt implementálják, de mi ne ezt implementáljuk, hanem induljunk ki valami speciális implementáló osztályból, melyből leszármaztathatunk. Amennyiben egy objektum egy értékét akarjuk hasonlítani, akkor &lt;a href="http://www.higherorderlogic.com/2012/09/on-the-composeability-of-hamcrest-matchers/"&gt;használjuk&lt;/a&gt; a &lt;code&gt;FeatureMatcher&lt;/code&gt; osztályt. ennek &lt;code&gt;featureValueOf&lt;/code&gt; metódusa adja vissza a kívánt értéket.&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;class&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;HasNameMatcher&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;extends&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;FeatureMatcher&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&lt;/span&gt;&lt;span class="typ"&gt;Bank&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;

    &lt;/span&gt;&lt;span class="lit"&gt;@Factory&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;static&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;HasNameMatcher&lt;/span&gt;&lt;span class="pln"&gt; hasName&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;Matcher&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;?&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;super&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; matcher&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="kwd"&gt;return&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;new&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;HasNameMatcher&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;matcher&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="str"&gt;"name"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="str"&gt;"name"&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;

    &lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;HasNameMatcher&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;Matcher&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;?&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;super&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; subMatcher&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pln"&gt; featureDescription&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pln"&gt; featureName&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="kwd"&gt;super&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;subMatcher&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; featureDescription&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; featureName&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;

    &lt;/span&gt;&lt;span class="lit"&gt;@Override&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="kwd"&gt;protected&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pln"&gt; featureValueOf&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;Bank&lt;/span&gt;&lt;span class="pln"&gt; bank&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="kwd"&gt;return&lt;/span&gt;&lt;span class="pln"&gt; bank&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getName&lt;/span&gt;&lt;span class="pun"&gt;();&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;És ezt a következőképpen használhatjuk fel:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="pln"&gt;assertThat&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;bank&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; hasName&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;equalTo&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"CIB BANK"&lt;/span&gt;&lt;span class="pun"&gt;)));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vagy hasonlóan egy másik &lt;code&gt;FeatureMatcher&lt;/code&gt; implementációt, de már collectionre:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="pln"&gt;assertThat&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;bank&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getAddresses&lt;/span&gt;&lt;span class="pun"&gt;(),&lt;/span&gt;&lt;span class="pln"&gt; hasItem&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;hasZip&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;equalTo&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"5600"&lt;/span&gt;&lt;span class="pun"&gt;))));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ha még ennél is messzebb akarunk menni, akkor egy &lt;code&gt;TypeSafeDiagnosingMatcher&lt;/code&gt; leszármazottat érdemes készítenünk (, ez amúgy mely a &lt;code&gt;FeatureMatcher&lt;/code&gt; őse).&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;class&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;HasAddressWithZip&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;extends&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;TypeSafeDiagnosingMatcher&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&lt;/span&gt;&lt;span class="typ"&gt;Bank&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;

    &lt;/span&gt;&lt;span class="lit"&gt;@Factory&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;static&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;HasAddressWithZip&lt;/span&gt;&lt;span class="pln"&gt; hasAddressWithZip&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;Matcher&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;?&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;super&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; valueMatcher&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="kwd"&gt;return&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;new&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;HasAddressWithZip&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;valueMatcher&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;

    &lt;/span&gt;&lt;span class="kwd"&gt;private&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;Matcher&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;?&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;super&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; valueMatcher&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;


    &lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;HasAddressWithZip&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;Matcher&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;?&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;super&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; valueMatcher&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="kwd"&gt;this&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;valueMatcher &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; valueMatcher&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;

    &lt;/span&gt;&lt;span class="lit"&gt;@Override&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="kwd"&gt;protected&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;boolean&lt;/span&gt;&lt;span class="pln"&gt; matchesSafely&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;Bank&lt;/span&gt;&lt;span class="pln"&gt; bank&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;Description&lt;/span&gt;&lt;span class="pln"&gt; description&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="typ"&gt;List&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; zips &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;new&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;ArrayList&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&amp;gt;();&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="kwd"&gt;for&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;Address&lt;/span&gt;&lt;span class="pln"&gt; address&lt;/span&gt;&lt;span class="pun"&gt;:&lt;/span&gt;&lt;span class="pln"&gt; bank&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getAddresses&lt;/span&gt;&lt;span class="pun"&gt;())&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="kwd"&gt;if&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;valueMatcher&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;matches&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;address&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getZip&lt;/span&gt;&lt;span class="pun"&gt;()))&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
                &lt;/span&gt;&lt;span class="kwd"&gt;return&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;true&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;
            zips&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;add&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;address&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getZip&lt;/span&gt;&lt;span class="pun"&gt;());&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;
        description&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;appendText&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;" zip codes found: "&lt;/span&gt;&lt;span class="pun"&gt;).&lt;/span&gt;&lt;span class="pln"&gt;appendValueList&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"["&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="str"&gt;","&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="str"&gt;"]"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; zips&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="kwd"&gt;return&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;false&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;

    &lt;/span&gt;&lt;span class="lit"&gt;@Override&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;void&lt;/span&gt;&lt;span class="pln"&gt; describeTo&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;Description&lt;/span&gt;&lt;span class="pln"&gt; description&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
        description&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;appendText&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;" address with zip code "&lt;/span&gt;&lt;span class="pun"&gt;).&lt;/span&gt;&lt;span class="pln"&gt;appendDescriptionOf&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;valueMatcher&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;És a használata:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="pln"&gt;assertThat&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;bank&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; hasAddressWithZip&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;equalTo&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"5600"&lt;/span&gt;&lt;span class="pun"&gt;)));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ha ez sem elég, akkor használjuk a &lt;code&gt;BaseMatcher&lt;/code&gt; osztályt, ennek leszármazottja a &lt;code&gt;TypeSafeDiagnosingMatcher&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A példákban látható, hogy factory metódusokat alkalmaztunk, mely lehetővé teszi a könnyebb olvashatóságot az &lt;code&gt;assertThat&lt;/code&gt; metódus paraméterként. Valamint elláttuk a &lt;code&gt;@Factory&lt;/code&gt; metódussal. Ez arra való, hogy a Hamcrestben van egy &lt;em&gt;generátor&lt;/em&gt;, mely képes kigyűjteni ezen metódusokat egy osztályba, így nem kell minden osztályt importálnunk. A &lt;code&gt;org.hamcrest.Matchers&lt;/code&gt; oszály is így készül.&lt;/p&gt;

&lt;h3 id="jó-tanácsok"&gt;Jó tanácsok&lt;/h3&gt;

&lt;p&gt;Amennyiben matchereket használ vagy ír az ember, először mindenképp próbáljuk ki a negatív ágat, hogy használható hibaüzenetet ír-e ki.&lt;/p&gt;

&lt;p&gt;Megoszlanak arról a vélemények, hogy egy teszt esetben egy assertet lehet-e csak használni. Én nem vagyok ennyire szigorú, szimpatikus a &lt;a href="http://www.owenpellegrin.com/blog/testing/how-do-you-solve-multiple-asserts/comment-page-1/#comment-6469"&gt;következő megfogalmazás&lt;/a&gt;: “test one logical CONCEPT per test”. Ez általában akkor teljesül, ha ugyanazon az objektumon végzel assertet, logikailag összetartozó feltételeket adsz meg. Gyakran egyszerűbb kifejezni és olvasni, ha több assert kifejezést használsz.&lt;/p&gt;

&lt;h3 id="történeti-háttér"&gt;Történeti háttér&lt;/h3&gt;

&lt;p&gt;A &lt;a href="https://github.com/junit-team/junit"&gt;JUnit&lt;/a&gt; fejlesztői úgy &lt;a href="https://github.com/junit-team/junit/wiki/Matchers-and-assertthat"&gt;döntöttek&lt;/a&gt;, hogy a JUnit részévé teszik. A &lt;a href="http://junit.sourceforge.net/doc/ReleaseNotes4.4.html"&gt;4.4 verzióban&lt;/a&gt; jelent meg, gyakorlatilag a &lt;code&gt;hamcrest-core&lt;/code&gt; projekt osztályait a JUnitba másolták. Ez volt az első alkalom, hogy egy third-party library bekerült a JUnitba, ami kifejezetten híres volt arról, hogy nem akart plusz függőségeket. Persze a régi assert metódusok, pl. &lt;code&gt;assertEquals&lt;/code&gt;, &lt;code&gt;assertTrue&lt;/code&gt;, stb. megmaradtak. Megjelent tehát a &lt;code&gt;org.hamcrest&lt;/code&gt; csomag, benne a &lt;code&gt;CoreMatchers&lt;/code&gt; osztály, valamint az &lt;code&gt;org.junit.matchers&lt;/code&gt; csomagban a &lt;code&gt;JUnitMatchers&lt;/code&gt; osztály. Mindez 2007-ben történt.&lt;/p&gt;

&lt;p&gt;Sajnos azonban hoztak egy Mavennel szemben álló döntést, ezeket a class-okat elhelyezték a &lt;code&gt;junit-4.4.jar&lt;/code&gt; artifact-ba. A JUnit csak a &lt;code&gt;core&lt;/code&gt; osztályait tartalmazta. Ha viszont a library osztályaira is szükség volt, és az ember csak berakta a JUnit mellé, és nem volt megfelelő a jar fájlok sorrendje a classpath-on, &lt;a href="http://marxsoftware.blogspot.hu/2012/06/moving-beyond-core-hamcrest-in-junit.html"&gt;elég nagy galibát tudott okozni&lt;/a&gt;. Ennek megoldására jelent meg a &lt;a href="http://search.maven.org/#artifactdetails%7Cjunit%7Cjunit-dep%7C4.4%7Cjar"&gt;junit-dep&lt;/a&gt; artifact, mely nem tartalmazza a Hamcrestes osztályokat, viszont van dependency a &lt;code&gt;hamcrest-core-ra&lt;/code&gt;. Ezt csak a &lt;a href="https://github.com/junit-team/junit/blob/master/doc/ReleaseNotes4.11.md"&gt;JUnit 4.11-ben&lt;/a&gt; javították, ahol a &lt;code&gt;junit&lt;/code&gt; artifact végre nem tartalmazza a Hamcrestes osztályokat, hanem egy tranzitív függőség van a &lt;code&gt;hamcrest-core&lt;/code&gt; 1.3 (jelenleg legfrissebb) verziójára. Így mindenképpen ezt javaslom használni. A &lt;code&gt;JUnitMatchers&lt;/code&gt; osztály metódusai deprecated-ek lettek, helyette a &lt;code&gt;org.hamcrest.CoreMatchers&lt;/code&gt; metódusai használandók.&lt;/p&gt;

&lt;p&gt;Azért is érdemes a legutolsó JUnit-ot használni, mert korábbi verzióban az &lt;code&gt;org.junit.Assert.assertThat&lt;/code&gt; nem használta az un. mismatch descriptiont, így a hibaüzenetek nem lettek olyan beszédesek, és figyelni kellett, hogy &lt;code&gt;MatcherAssert.assertThat&lt;/code&gt; legyen használva. Szerencsére a JUnt 4.11 verziójában ezt már javították.&lt;/p&gt;

&lt;p&gt;Úgy látszik, hogy ebben a körben nagyon népszerű a különböző library-k összecsomagolása. A Mockito esetén is van egy &lt;code&gt;mockito-all&lt;/code&gt; &lt;a href="https://code.google.com/p/mockito/wiki/DeclaringMockitoDependency"&gt;artifact&lt;/a&gt;, mely a Hamcrest és az &lt;a href="https://code.google.com/p/objenesis/"&gt;Objenesis&lt;/a&gt; osztályait csomagolja egybe. Ez akkor okoz kellemetlen meglepetést, mikor a Hamcrest egy újabb verzióját akarjuk használni, és nem tűnik fel, hogy a régebbi verzió osztályai már ott vannak a classpath-on.&lt;/p&gt;

&lt;h3 id="egyebek"&gt;Egyebek&lt;/h3&gt;

&lt;p&gt;Persze lehet rengeteg matchert találni a neten is, pl. &lt;a href="http://code.google.com/p/hamcrest-text-patterns/"&gt;szövegre&lt;/a&gt;, &lt;a href="https://github.com/modularit/hamcrest-date"&gt;dátumra&lt;/a&gt;, &lt;a href="https://github.com/tobyweston/simple-excel"&gt;Excel&lt;/a&gt;, &lt;a href="https://github.com/hertzsprung/hamcrest-json"&gt;JSON&lt;/a&gt; és &lt;a href="https://code.google.com/p/xml-matchers/"&gt;XML&lt;/a&gt; formátumokra is, stb.&lt;/p&gt;

&lt;p&gt;Megjegyzendő, hogy a Hamcrest nem csak JUnittal együtt hasznos, hanem &lt;a href="http://code.google.com/p/hamcrest/wiki/UsesOfHamcrest"&gt;más eszközök is használják&lt;/a&gt;. Több nyelvre is portolták, mint &lt;a href="http://github.com/hamcrest/PyHamcrest"&gt;Python&lt;/a&gt;, &lt;a href="http://github.com/hamcrest/ramcrest"&gt;Ruby&lt;/a&gt;, &lt;a href="http://github.com/hamcrest/OCHamcrest"&gt;Objective C&lt;/a&gt;, &lt;a href="http://code.google.com/p/hamcrest/downloads/list?q=label:PHP"&gt;PHP&lt;/a&gt;, &lt;a href="http://github.com/hyperthunk/hamcrest-erlang"&gt;Erlang&lt;/a&gt;, &lt;a href="https://github.com/drewbourne/hamcrest-as3"&gt;ActionScript&lt;/a&gt;.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/1065281452235807034/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2014/05/hamcrest.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1065281452235807034'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1065281452235807034'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/05/hamcrest.html' title='Hamcrest'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4869583495293648195</id><published>2014-05-17T14:44:00.001+02:00</published><updated>2014-05-18T13:08:16.668+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Módszertan'/><title type='text'>Az ideális dokumentum-előállítási eszközkészlet</title><content type='html'>&lt;p&gt;Mindenkinek van egy vagy több olyan terület, melyen a tökéleteset keresi, és nem sikerül megtalálnia. A &lt;a href="http://hetimeteor.hu/"&gt;Heti Meteor&lt;/a&gt; hallgatása közben gondolkoztam el azon, hogy nekem ilyen a dokumentum-előállítási eszközkészletem, mely már ezen a blogon is többször megjelent.&lt;/p&gt;

&lt;p&gt;Már korán rájöttem arra, hogy a Word nem az az eszköz, melyet nekem találtak ki. Egy ajánlat írásának végén egy éjszakán keresztül néztem, ahogy az ajánlati dokumentumot több órán keresztül formázzák. Talán nem is kell mondanom, hogy mennyire elveszett és másodrendű volt a tartalom.&lt;/p&gt;

&lt;p&gt;Egy olyan eszközt akartam, ahol a tartalom és a forma tökéletesen különválik, és csak a jelentést hordozó karakterekre kell koncentrálnom.&lt;/p&gt;

&lt;p&gt;Biztos mindenki ismeri az Word állományokhoz kötődő munkafolyamatot is, mely során különböző verziójú állományok utaznak e-mail csatolmányként, külön életet élnek, és folyamatosan távolodnak attól a lehetőségtől, hogy fájdalommentesen össze lehessen fésülni őket. Ezen talán a Microsoft SharePoint lenne képes segíteni, de ettől mindenki retteg.&lt;/p&gt;

&lt;p&gt;Sajnos ez a helyzet az OpenOffice/LibreOffice vonallal is, nem old meg problémákat, csak újakat vezet be. Minden évben kipróbálom, és egy nap után otthagyom.&lt;/p&gt;

&lt;p&gt;Amikor megismertem a &lt;a href="http://www.w3.org/TR/html4/"&gt;HTML&lt;/a&gt; nyelvet, azonnal elgondolkoztam, hogy talán ez lesz a megoldás. Szétválik a tartalom és a forma (Cascading Style Sheets - CSS), és alapvetően támogatja a linkek készítését is. Sőt, még a csoportmunkára is kitaláltak egy megoldást, melyet &lt;a href="http://en.wikipedia.org/wiki/WebDAV"&gt;WebDAV&lt;/a&gt; néven ismerhetünk. Sajnos láthatjuk, hogy hova jutott a HTML. Bár a neve a HyperText Markup Language, manapság gyakorlatilag platformként használjuk interaktív alkalmazások fejlesztésére, a JavaScript és az AJAX térnyerésével. A formátumot nem egyszerű írni, a WYSIWYG eszközök is gyengén sikerültek, más formátumokba konvertálás is nehézkes, ne is beszéljünk a kompatibilitási problémáiról. A WebDAV sem volt képes elterjedni, a megvalósítások is &lt;a href="http://www.jtechlog.hu/2009/02/webdav-tapasztalatok.html"&gt;hagytak kívánni valót maguk után&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Amikor megjelent a wiki, ismét láttam, hogy valami alakul. A Wikipedia bár beépült a mindennapjainkba, a mögötte álló formátum és munkafolyamat mégsem hozta el az áttörést. Írtunk egyik kereskedelmi megvalósításával (&lt;a href="https://www.atlassian.com/software/confluence"&gt;Atlassian Confluence&lt;/a&gt;) rendszerterveket, és Word sablon alapján generáltuk ki. De sajnos rossz irányba halad, a formázást kezdi el a középpontba helyezni. Bár a mai napig előszeretettel használom egy nyílt forráskódú megvalósítását (&lt;a href="http://www.redmine.org/"&gt;RedMine&lt;/a&gt;), valami még mindig hiányzik.&lt;/p&gt;

&lt;p&gt;Közben próbálkoztam egyéb formátumokkal is. Még az egyetemen találkoztam a &lt;a href="http://www.latex-project.org/"&gt;LaTeX&lt;/a&gt; formátumban, melyben folyamatosan bíztam, de képtelen volt kitörni a tudományos világból. Tény, hogy ott gyakorlatilag egyeduralkodó.&lt;/p&gt;

&lt;p&gt;Másik &lt;a href="http://www.jtechlog.hu/2009/07/rendszerterv-generalas-java-kodbol.html"&gt;próbálkozásom&lt;/a&gt; a &lt;a href="http://www.docbook.org/"&gt;DocBook&lt;/a&gt;. Szintén remek kezdeményezés, de sajnos XML alapú, emiatt itt is megjelenik a tagekkel járó zavaró tényezők. Valamint sikerült elbonyolítani, nézzük csak végig a referenciát, és a transzformáció más formátumokba is horror.&lt;/p&gt;

&lt;p&gt;A Google docs valahogy sosem győzött meg. A párhuzamos szerkesztés tényleg egyedülálló, de nem tudtam annyira kihasználni a képességeit, hogy minden területen bevált volna. Betöltöttem sok dokumentumot, és valahogy mindig egy kellemetlen érzést éreztem, mikor meg kellett nyitnom egyet-egyet.&lt;/p&gt;

&lt;p&gt;Rengetegféle tartalmat gyártok nap mint nap. Publikálok a blogon, a forráskódok mellé magyarázó szövegeket, architektúrális leírásokat  kell elhelyezni, stb.  Fejlesztő vagyok, tehát alapvetően sokat kell forráskódot tartalmazó dokumentációt is készítenem. És e mellé még vegyük hozzá, hogy oktatok, ahol ismét nagy mennyiségű dokumentum készül el, prezentációk, feladatleírások, tesztek, stb. Konferenciákra a prezentációk készítése is mindig problémát okozott. A PowerPoint ismét nem a tartalomra összpontosít, és a forráskód beillesztési lehetőség is határos. A Prezi szintén nem az az eszköz, mellyel gyorsan lehet haladni.&lt;/p&gt;

&lt;p&gt;És ekkor ismertem meg a &lt;a href="http://daringfireball.net/projects/markdown/"&gt;Markdown&lt;/a&gt; nyelvet. Szöveges formátum, mely könnyen olvasható egy egyszerű szövegszerkesztővel is, de a minimális alkalmazott szabály miatt könnyen lehet más formátumokba is konvertálni, tipikusan HTML-be. A nyelvet John Gruber találta ki. Igen, a &lt;a href="http://daringfireball.net/"&gt;Daring Fireball&lt;/a&gt; blog írója, Apple megszállott.&lt;/p&gt;

&lt;p&gt;Először a GitHub-on &lt;a href="http://www.jtechlog.hu/2012/09/github-pages.html"&gt;találkoztam&lt;/a&gt; vele, ezzel tudunk a projektjeink mellé viszonylag egyszerűen dokumentációt írni, de akár teljes oldalakat, blogokat megvalósítani. Így a verziókezelővel egybeépítve már a csoportmunka is megoldott. Ezt mára szinte mindegyik hasonló szolgáltatás átvette. Később találkoztam egy nagyszerű online szövegszerkesztővel, a &lt;a href="http://stackedit.io"&gt;StackEdittel&lt;/a&gt;, melyben ez a cikk is készül. Támogatja a syntax highlightot, mutatja a renderelt HTML kimenetet, amit le is lehet tölteni. Ezen kívül képes menteni Google Drive-ra, Dropboxra, Bloggerre, Tumblrre, WordPressre, GitHubra, SSH-ra. Ezzel a csoportmunka platformja is választható, én a Dropbox mellett tettem le a voksom. Ment PDF formátumban. És GitHubról letölthető a forrása.&lt;/p&gt;

&lt;p&gt;És ami megdöbbentő, hogy tökéletesen alkalmas prezentációk készítésére is, érdemes megnézni a &lt;a href="http://remarkjs.com"&gt;Remark&lt;/a&gt; projektet. Milyen egyszerűen szúrhatók be forráskód részletek is. Valamint ott van a &lt;a href="http://johnmacfarlane.net/pandoc/"&gt;Pandoc&lt;/a&gt; projekt is, mellyel parancssorból lehet formátumok között konvertálni. Tökéletesen működik a Markdownról minden egyéb formátumra történő konvertálás, akár úgy is, hogy saját stylesheetet, vagy template-t lehet megadni.&lt;/p&gt;

&lt;p&gt;Ezen kívül létezik a &lt;a href="http://www.gitbook.io/"&gt;GitBook&lt;/a&gt; projekt is, mellyel interaktív könyveket is írhatunk, az oldalán fenn van már elég sok példa is.&lt;/p&gt;

&lt;p&gt;Amennyiben ismersz jó Markdown felhasználási módokat, írd ide a megjegyzések közé!&lt;/p&gt;

&lt;p&gt;Sajnos ennek is már minden fajta elfajzása látható, létrejöttek olyan változatai, mellyel ismét a formátumra lehet hatni.&lt;/p&gt;

&lt;p&gt;Én bízom a Markdown minél szélesebb körben való alkalmazásában. Szeretem, hogy csak a natív szövegre koncentrálhatok, minden zavaró tényező kiiktatásával. Szeretem, hogy bármely szövegszerkesztőben (aktívan a Notepad++ és Geditet használom) meg tudom nyitni.&lt;/p&gt;

&lt;p&gt;Koncentrálj te is a szövegre, az képvisel értéket. Minden egyes perc, mely formázással telik, elpazarolt idő.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/4869583495293648195/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2014/05/az-idealis-dokumentum-eloallitasi.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4869583495293648195'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4869583495293648195'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/05/az-idealis-dokumentum-eloallitasi.html' title='Az ideális dokumentum-előállítási eszközkészlet'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8396345615099149715</id><published>2014-04-03T22:19:00.001+02:00</published><updated>2014-07-26T23:09:10.733+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='python'/><category scheme='http://www.blogger.com/atom/ns#' term='nosql'/><category scheme='http://www.blogger.com/atom/ns#' term='Oktatás'/><title type='text'>MongoDB</title><content type='html'>&lt;p&gt;Régóta keresem a kapcsolatot a NoSQL adatbázisokkal. Ezek közül az egyik legelterjedtebb a MongoDB, a hírekben is erről hallani a legtöbbet. Rengeteg energiát fordítanak a népszerűsítésére, remek dokumentációja van, sok videót lehet találni, konferenciákat szerveznek, neves előadókat beszéltetnek különböző felhasználási területekről, sikersztorikról. Ennek a stratégiának a része a &lt;a href="https://university.mongodb.com/"&gt;MongoDB University&lt;/a&gt; is, ahol különböző online tanfolyamokon lehet részt venni. A dolog szépsége, hogy a tanfolyamok teljesen ingyenesek, de ennek ellenére rendkívül igényesen ki vannak dolgozva. Van kurzus Java, Python és Node.JS fejlesztőknek, de van egy külön DBA-knak tartott tanfolyam is. Mivel már régóta &lt;a href="http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html"&gt;második nyelvként&lt;/a&gt; a Python-t használom, a &lt;a href="https://university.mongodb.com/courses/10gen/M101P/2014_April/about"&gt;M101P: MongoDB for Developers&lt;/a&gt; tanfolyamot végeztem el, melynek során a programozási példák Pythonban voltak, és ezen a nyelven kellett megírni a gyakorlati feladatokat is. Külön meglepetés volt, hogy kaptunk egy Pycharm 90 napos licencet is, mely a JetBrains IDE-je, nem kevésbé kitűnő szoftver, mint az IDEA, melyről csak szuperlatívuszokban tudok beszélni.&lt;/p&gt;

&lt;p&gt;Maga a tanfolyam egy 7 hetes képzés volt, hetente új tananyaggal. Az első hét az alapfogalmakat tisztázta, és segített a környezet beüzemelésében. A fejlesztés a Bottle pehelysúlyú webes keretrendszerrel és a Pymongo klienssel történt, sokak bánatára még csak Python 2.7-ben. Külön érdekes volt a &lt;a href="http://bottlepy.org/docs/dev/index.html"&gt;Bottle&lt;/a&gt; megismerése, mellyel hatékonyan tudunk egyszerű webes alkalmazásokat összedobni. Az első héten elmagyarázták a JSON rejtelmeit is, hiszen a MongoDB natívan JSON dokumentumokat kezel, de valójában minden JSON-ben van, pl. egy explain plan, vagy egy belső statisztika is JSON-ben jön vissza. A konzolja maga egy JavaScript interpreter, nagyon tetszett, hogy pl. a következő utasítással lehet gyorsan teszt adatokat generálni.&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-JavaScript"&gt;&lt;span class="kwd"&gt;for&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="kwd"&gt;var&lt;/span&gt;&lt;span class="pln"&gt; i &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="lit"&gt;1&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt; i &lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="lit"&gt;25&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt; i&lt;/span&gt;&lt;span class="pun"&gt;++)&lt;/span&gt;&lt;span class="pln"&gt; db&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;testData&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;insert&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt; x &lt;/span&gt;&lt;span class="pun"&gt;:&lt;/span&gt;&lt;span class="pln"&gt; i &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Majd egy utasítással lekérdezzük a generált adatokat.&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-JavaScript"&gt;&lt;span class="pln"&gt;db&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;testData&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;find&lt;/span&gt;&lt;span class="pun"&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A második hét szólt a CRUD műveletekről, a harmadik a séma tervezésről. A következő három hét volt az izgalmasabb, amikor is először a teljesítményről volt szó, azaz az indexek használatáról, majd az aggregation frameworkről, mellyel, mint a neve is mutatja komplex lekérdezéseket tudunk futtatni. Eztán következett a replikáció és a sharding. Az utolsó hét laza volt, ekkor két esettanulmány hangzott el.&lt;/p&gt;

&lt;p&gt;Egy hét úgy telt, hogy hét elején elérhetővé váltak a videók, kb. hetente 1-2,5 órányi terjedelemben, de fel voltak vágva apró darabokra, jellemzően 3-6 perces részekre. Mindegyik videó után volt egy egyszerű kis teszt, mely ellenőrizte, hogy megértetted-e az elhangzottakat. Majd mindegyik hét végén volt házi feladat, 3 - 5 feladattal, melyek általában gyakorlati példák voltak. Vagy programot kellett írni, vagy egy bonyolultabb lekérdezést. Van, hogy adták az adatbázis tartalmat, melyet be kellett tölteni. Volt egy példa alkalmazás, egy blog motor, melynek a perzisztens rétegét kellett megírni, bár jellemzően eléggé ki volt preparálva, csak egy-két sort kellett bele írni. A feladat ellenőrzése úgy történt, hogy vagy az eredményt kellett beírni, vagy tesztkérdések közül kiválasztani, vagy lefuttatni egy programot, melynek eredményét kellett elküldeni. (Pl. webes klienst szimulálva teszt eseteket futtatott, és ha sikeres volt, akkor adott egy számot, amit el kellett küldeni.) A megoldásokat a következő hét elejéig kellett beküldeni.&lt;/p&gt;

&lt;p&gt;A hetedik héten kellett megoldani a vizsgafeladatokat, szám szerint tízet. Ebben volt teszt és gyakorlati példa is. Volt egyszerűbb, de volt olyan is, melyen sokat kellett gondolkozni, és a videókat is visszanézni, hogy biztos legyél a dolgodban. Az volt az érdekessége, hogy itt nem kaptál visszajelzést, hogy jó-e a válasz.&lt;/p&gt;

&lt;p&gt;A végén az értékelés úgy történt, hogy a legrosszabb hetet kivéve fogták a heti házi feladatok, és a vizsga átlagát, és ha 60% felett voltál, még egy bizonyítványt is kaptál (PDF-ben, egyedi azonosítóval, mely ellenőrizhető).&lt;/p&gt;

&lt;p&gt;A tanfolyam alatt végig működött egy fórum és egy wiki, a videók még mindig elérhetőek.&lt;/p&gt;

&lt;p&gt;Be kell vallanom, nagyon tetszett ez a fajta tanulási mód. Hetente kb. 5-6 órát kellett vele foglalkoznom. Bár hiszek abban, hogyha valamit alaposan meg kell tanulni, akkor könyvből és netes forrásokból hatékonyabb, itt viszont az volt a cél, hogy egy benyomást, és áttekintő képet kapjak. Erre tökéletes volt, hiszen folyamatosan de nem túl nagy adagban jött az új anyag, és érdekes feladatok is voltak. Én még annyival megtoldottam, hogy egy nagyon egyszerű kis &lt;a href="http://ext.jtechlog.hu/2014/03/openbadges.html"&gt;hobbi projektet (Badges)&lt;/a&gt; implementáltam vele, így még jobban rögzültek az ismeretek.&lt;/p&gt;

&lt;p&gt;A MongoDB-ről is alapban jó tapasztalataim voltak, bár a 32-bites rendszeren megszenvedtem vele. Az a tooling, ami mögötte van, nagyon korszerű, és nagyon kézre áll, rendkívül gyorsan lehet eredményeket elérni, egy agilis projektben, egy startup mögé ideális választás. Persze hallani rossz tapasztalatokat is, hogy baj van a performanciával, és a séma nélküliség, a redundancia is okozhat gondot, így nagyon oda kell figyelni, hogy mikor használjuk. Viszont nagyon szeretnék egy olyan SQL adatbázist, ami ennyire kézre áll, gyors, skálázható, és az, hogy a konzolja egy imperatív programozási nyelv interpreterje, és nem csak egy SQL értelmező, rettentő sokat hozzáad az élményhez.&lt;/p&gt;

&lt;p&gt;Érdekességként annyit, hogy 6 312-an kezdték, és 1 141 hallgató végezte el sikeresen. Javaslom mindenkinek, hogy akit érdekel, próbálja meg. Azonban ha azonnal indul a projekt, melyben Mongo-t kell használni, akkor inkább valami intenzívebb módját javasolom a tanulásnak.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://1.bp.blogspot.com/-gdY7szTUjj8/Uz3Bg9LjwGI/AAAAAAAALR8/9T7Z4piJ22Y/s1600/mongo_cert.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-gdY7szTUjj8/Uz3Bg9LjwGI/AAAAAAAALR8/9T7Z4piJ22Y/s320/mongo_cert.png" /&gt;&lt;/a&gt;&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/8396345615099149715/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2014/04/mongodb.html#comment-form' title='3 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/8396345615099149715'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/8396345615099149715'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/04/mongodb.html' title='MongoDB'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://1.bp.blogspot.com/-gdY7szTUjj8/Uz3Bg9LjwGI/AAAAAAAALR8/9T7Z4piJ22Y/s72-c/mongo_cert.png' height='72' width='72'/><thr:total>3</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2794618715046353814</id><published>2014-03-16T14:08:00.001+01:00</published><updated>2014-04-03T21:23:14.476+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Community'/><title type='text'>HOUG 2014</title><content type='html'>&lt;p&gt;Frissítve: 2014. április 3. - felkerültek a képek&lt;/p&gt;

&lt;p&gt;A HOUG ismét megrendezi a &lt;a href="http://konferenciak.advalorem.hu/houg-2014/program"&gt;Magyarországi Oracle Felhasználók Konferenciáját&lt;/a&gt; 2014 március 24 és 26 között Siófokon. Érdekessége, hogy a konferencia nulladik napja egy &lt;emp&gt;ingyenes&lt;/emp&gt; Java konferencia is, melyet a HOUG.j, a HOUG Java Szakosztálya szervez. Akik remek meetupot is hosztolnak &lt;a href="http://www.meetup.com/bpjavabar/"&gt;DPC-HOUG.j JavaBar&lt;/a&gt; néven. Idén én is adok elő 16:00 - 16:30 között "Continuous Delivery: Problémák és megoldások" címmel. Alább az előadásom bevezetőjét olvashatjátok.&lt;/p&gt;

&lt;blockquote&gt;A Continuous Delivery bevezetése nagyvállalati Java környezetben fejlesztett, több modulból álló alkalmazás esetén nagy kihívást
jelenthet. Gondoljunk csak a branchek használatára, az Ant korlátolt képességeire, a Maven SNAPSHOT és repository kezelésére, a release pluginra, az adatbázis séma verziózására, vagy akár az integrációs teszt esetek sebességére. Előadásomban ezen problémás részeket igyekszem azonosítani, és alternatív megoldási javaslatokat adni. Nincsenek általános igazságok, a Continuous Delivery egy szemléletmód, folyamatos tanulás és fejlődés.&lt;/blockquote&gt;

&lt;p&gt;A következő előadásokat hallgathatjátok meg 14:00-tól:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JavaEE Application Security - Minden, amit az alkalmazásbiztonságról a fejlesztőknek érdemes tudni. – Schaffer Krisztián, security analyst, Cloudbreaker Company&lt;/li&gt;
&lt;li&gt;JavaSE 8 újdonságok – Elek Márton, DPC Consulting Kft&lt;/li&gt;
&lt;li&gt;JavaEE 7 újdonságok – Varga Péter, tanácsadó, DPC Consulting Kft.&lt;/li&gt;
&lt;li&gt;Az Apache Maven élete és halála – Cservenák Tamás, Sonatype // Nexus fejlesztő&lt;/li&gt;
&lt;li&gt;Continuous Delivery: Problémák és megoldások – Viczián István, vezető fejlesztő, IP Systems&lt;/li&gt;
&lt;li&gt;Android és JavaEE: légy REST! – Auth Gábor, senior architect&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Jelentkezni &lt;a href="http://konferenciak.advalorem.hu/houg-2014/jelentkezes"&gt;itt&lt;/a&gt; lehet.&lt;/p&gt;

&lt;p&gt;Közben véget ért a konferencia, &lt;a href="http://konferenciak.advalorem.hu/houg-2014/gallery"&gt;készültek képek&lt;/a&gt;, ide is teszek egyet, amin nagyon magyarázok.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://2.bp.blogspot.com/--sDWFzifh7w/Uz21CvgYB9I/AAAAAAAALRs/fyh6RKx-kZE/s1600/403.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/--sDWFzifh7w/Uz21CvgYB9I/AAAAAAAALRs/fyh6RKx-kZE/s320/403.jpg" /&gt;&lt;/a&gt;&lt;/div&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/2794618715046353814/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2014/03/houg-2014.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2794618715046353814'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2794618715046353814'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/03/houg-2014.html' title='HOUG 2014'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://2.bp.blogspot.com/--sDWFzifh7w/Uz21CvgYB9I/AAAAAAAALRs/fyh6RKx-kZE/s72-c/403.jpg' height='72' width='72'/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8443530112508871347</id><published>2014-01-22T00:25:00.001+01:00</published><updated>2014-02-03T21:13:12.325+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Maven'/><title type='text'>A Maven feltámadása</title><content type='html'>&lt;p&gt;Frissítés: A videó is megtekinthető a &lt;a href="http://www.youtube.com/watch?v=UGUC5utrEEM"&gt;YouTube&lt;/a&gt;-on, és egy &lt;a href="http://takari.io/2014/02/03/maven-speed.html"&gt;blog poszt&lt;/a&gt; is megjelent azóta.&lt;/p&gt;

&lt;p&gt;A mai napon Jason van Zyl, a Maven alkotója egy prezentációt tartott arról, hogy milyen tervei vannak a jövővel kapcsolatban, ezt szeretném összefoglalni ebben a posztban.&lt;/p&gt;

&lt;p&gt;Jason eddig a Sonatype-nál volt, aminek a nevéhez fűződik a Nexus repository manager alkalmazás, valamint a remek Mavennel foglalkozó, ingyenesen letölthető &lt;a href="http://www.sonatype.com/resources/books"&gt;könyvek&lt;/a&gt;. Azonban mostanában főleg a biztonsággal kapcsolatban lehetett róluk hallani, pontosabban a nyílt forráskódú library-k használatának biztonsági kockázatának minimalizálását tűzték ki célul.&lt;/p&gt;

&lt;p&gt;Jason fő területe azonban a Maven, és továbbra is ezzel szeretne foglalkozni, így megalapította a &lt;a href="http://takari.io"&gt;Takari&lt;/a&gt; céget, mely Maven oktatással, tanácsadással foglalkozik, erősen támaszkodva a nyílt forráskódú közösségre.&lt;/p&gt;

&lt;p&gt;Az utóbbi hónapokban több cégnél dolgozott azon, hogy a JVM alapú alkalmazások életciklusa gyorsabb legyen, gyorsabban lehessen szállítani az ügyfélnek. Persze ez több tényezőn múlik, nyilván a Maven közeli dolgokra koncentráltak, a fejlesztés és a build gyorsítására. Több eredményt is sikerült elérni, melyből már van, amit publikáltak, és van amit a közeljövőben szeretnének nyílt forráskódúvá tenni.&lt;/p&gt;

&lt;p&gt;Sebességgel kapcsolatos fejlesztések:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Inkrementális fordítás&lt;/li&gt;
&lt;li&gt;További párhuzamos működés bevezetése (aggressive parallelization)&lt;/li&gt;
&lt;li&gt;Generációk (generations)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ezek mellett egyéb érdekes dolgokat is csináltak:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Projekt leírása más nyelveken (polyglot support)&lt;/li&gt;
&lt;li&gt;Konzolban futó shell eszköz&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Az összes témakör nagyon érdekes, és előremutató, érdemes ezeket bővebben kifejteni. Az biztosan látszik, hogy nem öncélú fejlesztés történik, hanem a fejlesztők leggyakoribb problémáit igyekszik megoldani. Az is látható, hogy még szorosabb lesz a kapcsolat az IDE, a Maven és a repository között. Azonban az újdonságok parancssorból is kihasználhatóak majd.&lt;/p&gt;

&lt;p&gt;Az inkrementális fordítás alapvetően az Eclipse beépített inkrementális fordítójára, a &lt;a href="http://www.eclipse.org/jdt/core/"&gt;JDT&lt;/a&gt;-re épül. Már az &lt;a href="http://www.eclipse.org/m2e/"&gt;m2eclipse&lt;/a&gt; Maven-t támogató Eclipse plugin is képes egy önálló erőforrást egy önálló MOJO (Maven plugin)-n keresztül hívni. Ez lett API-ként bevezetve, ez elég durva módosítást eredményezett, hiszen, hozzá kellett nyúlni az életciklusokhoz, a fordítóhoz, és a megfelelő pluginekhez. A függőségek feltérképezésével igen bonyolult impact analyzis végezhető, mit kell újragenerálni, újrafordítani. Konfiguráció változásnál pl. érdemes újra elvégezni. De akár el lehet menni addig, hogy milyen teszt eseteket érdemes újrafuttatni.&lt;/p&gt;

&lt;p&gt;Párhuzamos fordítás a Maven 3-ban &lt;a href="https://cwiki.apache.org/confluence/display/MAVEN/Parallel+builds+in+Maven+3"&gt;jelent meg&lt;/a&gt;, mely feltérképezi a függőségi struktúrát, szinteket alkot, és ezeket a szinteken lévő projekteket buildeli párhuzamosan. Az aggressive parallelization használatával további gyorsulást sikerült elérni. Ennek az az alapja, hogy egy sorba dobálja be azokat a projekteket, melyeknek már elkészült a függősége, és ezeket sorba veszi attól függően, hogy hány szál van, stb. Kiderült, hogy létezik egy critical path mely az a függőségi ág, mely fordítása a legtöbb időt veszi igénybe. Igazából úgy kell ütemezni a többi fordítást, hogy e mellett párhuzamosan egyenletesen elosztva menjen. Így érdemes pl. ezt a critical path hosszát is csökkenteni.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://1.bp.blogspot.com/-mMzkx4w4BVM/UuAudvDQ9YI/AAAAAAAALM0/y8asYE6oF_4/s1600/2014-01-parallel.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-mMzkx4w4BVM/UuAudvDQ9YI/AAAAAAAALM0/y8asYE6oF_4/s320/2014-01-parallel.png" /&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;Annak azonban, aki már küzdött azzal, hogy a Mavent Continuous Delivery (CD) környezetben használja, a legérdekesebb újdonság a generációk bevezetése lesz. Ennek használatával ugyanis az artifactok egy számot kapnak. Hatalmas előnye, hogy multi module project artifaktjai is ugyanazt a számot kapják. Ez a szám a verziókezelő revision és branch vonatkozásában egyedi. Ez rengeteg problémát megold. Egyrészt nem kell innentől SNAPSHOT, azzal amúgy is volt olyan baj, hogy a multimodule projektek más számot kaptak, és nem lehetett egymáshoz rendelni őket. Nem kell ezek után használni sokunk ellenségét, a release plugint. Nem kell release-elni, nem kell újra buildelni, nem kell a verziókezelővel játszani, ugyanaz az artifact kerülhet ki.&lt;/p&gt;

&lt;p&gt;Ezzel egy időben még azt is kitalálták, hogyan legyen az új artifactok repository-ba juttatása, és onnan terítése még gyorsabb és hatékonyabb. Erre egy delta protocol került kialakításra (JSON alapú). Nevéből adódóan az az alapja, hogy csak a különbség utazik, és tárolva sem lesznek az azonos artifactok, hanem egy operációs rendszerbeli hardlink készül.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://2.bp.blogspot.com/-tRwx99yxp9c/UuAuWHyO2SI/AAAAAAAALMs/Y6ZVgZI3p9k/s1600/2014-01-gen-collab.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-tRwx99yxp9c/UuAuWHyO2SI/AAAAAAAALMs/Y6ZVgZI3p9k/s320/2014-01-gen-collab.png" /&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;A polygot támogatás lehetővé teszi a pom (Project Object Model) más nyelvekben való meghatározását, pl. Ruby, Groovy, Scala, stb. Az említett három nyelv érdekessége, hogy inline lehet plugineket megvalósítani az adott nyelven.&lt;/p&gt;

&lt;p&gt;A parancssoros konzol Tesla shell néven szintén nagyon érdekes dolog, rengeteg jó ötlet van benne. Ebből láttunk egy élő demót is. El kell indítani, és folyamatosan fut, így a memóriában marad, ami megtakarítja a JVM állandó indítgatását. Gyakorlatilag az m2eclipse-el közös alapokkal fog rendelkezni, az inkrementális forráskód generálást és fordítást támogatni fogja. Alapból támogatja a GitHub-ot, ha olyan könyvtárba lépünk, ahol git repository van, azonnal jelzi. Egy pufferben tárolja az előző parancs kimenetét, amit a következő parancsban fel tudunk használni. A demóban azt láttuk, hogy lefordított egy projektet, a kimenetét Gist-ként feltette GitHubra, majd megnyitotta böngészőben. Egy parancsból létrehozott egy GitHub issue-t. Parancsokat tartalmaz a pom kezelésére, pl. Java verzió állítás, új függőség felvétele, erőforrások filterelése (ezen parancsok hatására átírta a pom.xml-t). És nem utolsó sorban szép színes!&lt;/p&gt;

&lt;p&gt;Az itt ismertetett összes funkciót nyílttá teszik a GitHub-on, és utána kerülhet a Maven-be. A legtöbb újdonsággal az elkövetkezendő két-három hónapban fognak kijönni. A polygot támogatás már letölthető a GitHubról &lt;a href="https://github.com/tesla/tesla-polyglot"&gt;tesla-polyglott&lt;/a&gt; néven. Egyelőre elég nagy a disztibúció, mert az összes nyelvhez tartozó library-t tartalmazza, ezen majd javítanak, hogy csak azt töltse le, amire szüksége van. A &lt;code&gt;translate&lt;/code&gt; parancsot kiadva lehet a pom.xml-ünket átkonvertálni más nyelvre. Ki is &lt;a href="https://gist.github.com/vicziani/8527744"&gt;próbáltam&lt;/a&gt; gyorsan, egy egyszerű Spring Security-s projekt pom.xml-jét konvertáltam Groovy-ba. A Tesla shellt már egy héten belül megkaphatjuk, még elég kísérleti változatot. (A Tesla névvel még lesznek licensz gondok.)&lt;/p&gt;

&lt;p&gt;A fáma alapvetően az Eclipse és m2eclipse-ről szól, de később integrálható a többi IDE-hez is, hiszen az API elérhető lesz azokból is.&lt;/p&gt;

&lt;p&gt;Az előadás alapján én nagyon bizakodó vagyok, ugyanis nem apró, szükségtelen funkciók kerültek bele, hanem felismerték a valós igényeket, a valós használati eseteket, elismerték a Maven hibáit (SNAPSHOT-kezelés), és nem féltek hozzányúlni az alapjaihoz, hogy kijavítsák.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/8443530112508871347/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2014/01/maven-feltamadasa.html#comment-form' title='5 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/8443530112508871347'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/8443530112508871347'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/01/maven-feltamadasa.html' title='A Maven feltámadása'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://1.bp.blogspot.com/-mMzkx4w4BVM/UuAudvDQ9YI/AAAAAAAALM0/y8asYE6oF_4/s72-c/2014-01-parallel.png' height='72' width='72'/><thr:total>5</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5773820276886795280</id><published>2014-01-20T00:23:00.000+01:00</published><updated>2014-07-26T23:30:33.262+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='xml'/><category scheme='http://www.blogger.com/atom/ns#' term='Tesztelés'/><title type='text'>Java és az XML</title><content type='html'>&lt;p&gt;Felhasznált technológiák: Java 7, JUnit 4.11, XmlUnit 1.5, Hamcrest 1.3, xml-matchers 1.0-RC1, Maven 3.0.3&lt;/p&gt;

&lt;p&gt;Van pár régebbi anyagom, melyet szeretnék publikálni, mielőtt új témákba kezdenék bele. Ebből egyik a Java XML kezeléséről szól, ami ugyan nem a legforróbb terület manapság, azonban mégsem árthat egy kis összefoglaló.&lt;/p&gt;

&lt;p&gt;Ehhez poszthoz is található egy &lt;a href="https://github.com/vicziani/jtechlog-xml"&gt;projekt a GitHub-on&lt;/a&gt;, melyben rengeteg példa van.&lt;/p&gt;

&lt;p&gt;Maga a Java SE is meglehetősen komplex &lt;a href="http://docs.oracle.com/javase/7/docs/technotes/guides/xml/index.html"&gt;XML támogatást tartalmaz&lt;/a&gt;, méghozzá a The Java™ API For XML Processing (JAXP), The Java Architecture For XML Binding (JAXB) és The Java API for XML Web Services (JAX-WS) specifikációk formájában. Az &lt;a href="http://docs.oracle.com/javase/7/docs/technotes/guides/xml/jaxp/index.html"&gt;JAXP&lt;/a&gt; egyszerű alap XML feldolgozást támogat, ide tartozik pl. a SAX, DOM, validáció, XPath, transzformáció, stb. A &lt;a href="http://docs.oracle.com/javase/7/docs/technotes/guides/xml/jaxb/index.html"&gt;JAXB&lt;/a&gt; egy binding megoldás, mellyel Java objektumokat tudunk XML dokumentumohoz rendelni. És végül a &lt;a href="http://docs.oracle.com/javase/7/docs/technotes/guides/xml/jax-ws/index.html"&gt;JAX-WS&lt;/a&gt;, mellyel webszolgáltatásokat tudunk hívni, és implementálni.&lt;/p&gt;

&lt;p&gt;Természetesen a JAXP maga is egy specifikáció, &lt;a href="https://www.jcp.org/en/jsr/detail?id=206"&gt;JSR-206&lt;/a&gt;. Itt az is látható, hogy melyik Java verzióban ennek melyik verziója szerepel:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JAXP 1.6: Java Platform, Standard Edition 8&lt;/li&gt;
&lt;li&gt;JAXP 1.5: Java Platform, Standard Edition 7u40&lt;/li&gt;
&lt;li&gt;JAXP 1.4.5: Java Platform, Standard Edition 7&lt;/li&gt;
&lt;li&gt;JAXP 1.4: Java Platform, Standard Edition 6&lt;/li&gt;
&lt;li&gt;JAXP 1.3: Java Platform, Standard Edition 5&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Az 1.4-es újdonsága a Streaming API for XML (StAX), míg az 1.5 bizonyos biztonsági funkciókkal egészítette ki az előző verziót. A JAXP 1.5 2013 augusztus 30-án jött ki, és a következő szabványokat támogatja:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SAX 2.0.2&lt;/li&gt;
&lt;li&gt;StAX 1.2, JSR 173&lt;/li&gt;
&lt;li&gt;XML 1.0, XML 1.1&lt;/li&gt;
&lt;li&gt;XInclude 1.0&lt;/li&gt;
&lt;li&gt;DOM Level 3 Core, DOM Level 3 Load and Save&lt;/li&gt;
&lt;li&gt;W3C XML Schema 1.0 &lt;/li&gt;
&lt;li&gt;XSLT 1.0&lt;/li&gt;
&lt;li&gt;XPath 1.0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A JAXP-hez is tartozik referencia implementáció, mely frappánsan a &lt;a href="https://jaxp.java.net/"&gt;JAXP reference implementation&lt;/a&gt; nevet kapta. Alapvetően két Apache-s projekttől forkolt el, az egyikt az XML parse-olást végző &lt;a href="http://xerces.apache.org/xerces2-j/"&gt;Xerces2&lt;/a&gt;, a másik az XML transzformációt végző &lt;a href="http://xml.apache.org/xalan-j/"&gt;Xalan-Java&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Gyakorlatilag annyi történt, hogy a csomag neve elé még betették a com.sun.org előtagot. Bármikor megtudhatjuk, hogy az aktuális JDK-ban hanyas Xerces és Xalan található:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="typ"&gt;System&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;out&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;println&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;com&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;sun&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;org&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;apache&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;xerces&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;internal&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;impl&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="typ"&gt;Version&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getVersion&lt;/span&gt;&lt;span class="pun"&gt;());&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="typ"&gt;System&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;out&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;println&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;com&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;sun&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;org&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;apache&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;xalan&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;internal&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="typ"&gt;Version&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getVersion&lt;/span&gt;&lt;span class="pun"&gt;());&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ez nekem a JDK 1.7.0_51 esetén a következőt írja ki:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-text"&gt;Xerces-J 2.7.1
Xalan Java 2.7.0&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A cikk írásának pillanatában mindkettőből van frissebb verzió, a Xerces-ből 2.11.0, a Xalan-ból a 2.7.1.&lt;/p&gt;

&lt;p&gt;Mivel a JAXP csak egy API, könnyen lehet az implementációt is cserélni alatta. Ennek mikéntje a Java API &lt;a href="http://docs.oracle.com/javase/7/docs/api/javax/xml/parsers/DocumentBuilderFactory.html"&gt;DocumentBuilderFactory&lt;/a&gt; osztályánál van leírva.&lt;/p&gt;

&lt;p&gt;Ha nem tudjuk, hogy éppen melyik verziót használjuk (mert pl. a classpath-on szerepel egy más implementáció, ami alkalmazásszerverek használata esetén is gyakori), akkor a következőképpen állapíthatjuk meg azt:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="typ"&gt;System&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;out&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;println&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;getJaxpImplementationInfo&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"DocumentBuilderFactory"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; 
    &lt;/span&gt;&lt;span class="typ"&gt;DocumentBuilderFactory&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;newInstance&lt;/span&gt;&lt;span class="pun"&gt;().&lt;/span&gt;&lt;span class="pln"&gt;getClass&lt;/span&gt;&lt;span class="pun"&gt;()));&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="typ"&gt;System&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;out&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;println&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;getJaxpImplementationInfo&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"XPathFactory"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; 
    &lt;/span&gt;&lt;span class="typ"&gt;XPathFactory&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;newInstance&lt;/span&gt;&lt;span class="pun"&gt;().&lt;/span&gt;&lt;span class="pln"&gt;getClass&lt;/span&gt;&lt;span class="pun"&gt;()));&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="typ"&gt;System&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;out&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;println&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;getJaxpImplementationInfo&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"TransformerFactory"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; 
    &lt;/span&gt;&lt;span class="typ"&gt;TransformerFactory&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;newInstance&lt;/span&gt;&lt;span class="pun"&gt;().&lt;/span&gt;&lt;span class="pln"&gt;getClass&lt;/span&gt;&lt;span class="pun"&gt;()));&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="typ"&gt;System&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;out&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;println&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;getJaxpImplementationInfo&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"SAXParserFactory"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="typ"&gt;SAXParserFactory&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;newInstance&lt;/span&gt;&lt;span class="pun"&gt;().&lt;/span&gt;&lt;span class="pln"&gt;getClass&lt;/span&gt;&lt;span class="pun"&gt;()));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ez amúgy a példaprojektben is kijött, ugyanis az xml-matchers berántotta a Xerces újabb, 2.8.0 verzióját, ami az egyik XML-t más formátumban írta ki (az &lt;code&gt;mvn dependency:tree&lt;/code&gt; paranccsal ellenőrizhető).&lt;/p&gt;

&lt;p&gt;A JAXP-hez remek &lt;a href="http://docs.oracle.com/javase/tutorial/jaxp/"&gt;tutorial&lt;/a&gt; is található az Oracle oldalán.&lt;/p&gt;

&lt;p&gt;A JAXP-ben három parser található. A Simple API for XML (SAX), Document Object Model (DOM) és a Streaming API for XML (StAX). A &lt;a href="http://www.saxproject.org/"&gt;SAX&lt;/a&gt; (mely egy de facto szabvány) egy push parser, a &lt;a href="http://www.w3.org/DOM/"&gt;DOM&lt;/a&gt;  (mely egy W3C szabvány) memóriában felépíti a teljes fát és a StAX pedig egy pull parser, és önmagán belül is még két lehetőséget tartalmaz parse-olásra. Mindegyikre található példa a példa alkalmazásban, és a StAX-ról régebben egy &lt;a href="http://jtechlog.blogspot.hu/2009/11/stax.html"&gt;posztot is írtam&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;TransformerFactory&lt;/code&gt; és &lt;code&gt;Transformer&lt;/code&gt; osztályok használatával lehet XML transzformációkat végezni.&lt;/p&gt;

&lt;p&gt;XML séma alapján validálni a &lt;code&gt;Validator&lt;/code&gt; osztállyal lehetséges, a &lt;code&gt;Schema&lt;/code&gt; betöltése &lt;code&gt;SchemaFactory&lt;/code&gt;-val történik. DTD alapján nem tud validálni, ha mégis ilyent szeretnénk, akkor a parsernél kell a validációt beállítani.&lt;/p&gt;

&lt;p&gt;A JAXP XPath kiértékelési lehetőségeit a &lt;code&gt;XPathFactory&lt;/code&gt; osztályon és &lt;code&gt;XPath&lt;/code&gt; interfészen keresztül lehet kihasználni. &lt;/p&gt;

&lt;p&gt;A JAXP minden része fel van szerelve névterek kezelésére is.&lt;/p&gt;

&lt;p&gt;Az XML funkciók unit tesztelésére több könyvtár is rendelkezésünkre áll (mindegyikre található példa a példa projektben). Az &lt;a href="http://xmlunit.sourceforge.net/"&gt;XMLUnit&lt;/a&gt; alkalmas XML összehasonlításra (nem szöveg összehasonlítás), XPath kifejezések futtatására, validációra és transzformációk ellenőrzésére. A Hamcrest is tartalmaz egy HasXPath osztályt, azonban ha komolyabb dolgokra van szükségünk, javasolt az &lt;a href="https://code.google.com/p/xml-matchers/"&gt;xml-matchers&lt;/a&gt; használata, ami szintén Hamcrest matchereket tartalmaz.&lt;/p&gt;

&lt;p&gt;Az XML kezeléshez tartozó következő API a JAXB, melyről már írtam a &lt;a href="http://jtechlog.blogspot.hu/2009/07/jaxb.html"&gt;JAXB&lt;/a&gt; és &lt;a href="http://jtechlog.blogspot.hu/2009/07/jaxb-trukkok.html"&gt;JAXB trükkök&lt;/a&gt; cikkben.&lt;/p&gt;

&lt;p&gt;A JAX-WS-ről írtam a &lt;a href="http://jtechlog.blogspot.hu/2009/11/jax-ws-melyviz.html"&gt;JAX-WS mélyvíz&lt;/a&gt; posztban, tesztelésükről a &lt;a href="http://jtechlog.blogspot.hu/2012/08/soapui-junit-teszteles.html"&gt;Webszolgáltatások integrációs tesztelése soapUI és JUnit használatával&lt;/a&gt; posztban. Könyvről a &lt;a href="http://jtechlog.blogspot.hu/2012/08/soa-using-java-web-services.html"&gt;SOA Using Java Web Services&lt;/a&gt; posztban, és vizsgáról a &lt;a href="http://jtechlog.blogspot.hu/2012/12/oracle-certified-expert-java-ee-6-web.html"&gt;Oracle Certified Expert, Java EE 6 Web Services Developer&lt;/a&gt; posztban.&lt;/p&gt;

&lt;p&gt;Az XML-lel kapcsolatban még érdemes megjegyezni, hogy a properties állományokat is lehet XML formában tárolni, ekkor a &lt;code&gt;Properties&lt;/code&gt; osztály &lt;code&gt;loadFromXML&lt;/code&gt; metódusát kell meghívni.&lt;/p&gt;

&lt;p&gt;Nagyon egyszerű esetben, amennyiben JavaBean-eket akarunk kiírni, majd visszaolvasni, és nem számít az XML felépítése, használhatjuk a Java &lt;code&gt;XMLEncoder&lt;/code&gt; és &lt;code&gt;XMLDecoder&lt;/code&gt; osztályát.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;javax.xml.soap&lt;/code&gt; csomag felelős a SOAP üzenetek alacsony szintű feldolgozásáért.&lt;/p&gt;

&lt;p&gt;A két legelterjedtebb nyílt forráskódú XML feldolgozást végző XML library a &lt;a href="http://www.jdom.org/"&gt;JDOM&lt;/a&gt; és &lt;a href="http://dom4j.sourceforge.net/"&gt;dom4j&lt;/a&gt;. Alternatív binding könyvtár a &lt;a href="http://castor.codehaus.org/"&gt;Castor&lt;/a&gt;. Alternatív JAXB implementáció az &lt;a href="http://www.eclipse.org/eclipselink/moxy.php"&gt;EclipseLink MOXy&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A témával kapcsolatban két könyvet ajánlok. Az egyik a &lt;a href="http://www.amazon.com/Java-XML-Brett-McLaughlin/dp/059610149X/ref=sr_1_1?ie=UTF8&amp;amp;qid=1390171771&amp;amp;sr=8-1&amp;amp;keywords=java+xml"&gt;Brett McLaughlin, Justin Edelson: Java and XML&lt;/a&gt;, a másik a  &lt;br&gt;
&lt;a href="http://www.amazon.com/Pro-XML-Development-Java-Technology/dp/1590597060/ref=sr_1_3?ie=UTF8&amp;amp;qid=1390171885&amp;amp;sr=8-3&amp;amp;keywords=java+xml"&gt;Ajay Vohra: Pro XML Development with Java Technology Paperback&lt;/a&gt;.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/5773820276886795280/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2014/01/java-es-az-xml.html#comment-form' title='1 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/5773820276886795280'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/5773820276886795280'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/01/java-es-az-xml.html' title='Java és az XML'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3812191713339137641</id><published>2014-01-06T21:32:00.000+01:00</published><updated>2014-01-06T21:32:07.838+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Community'/><title type='text'>Források</title><content type='html'>&lt;p&gt;A hírek jelenleg két forrásból esnek be hozzám. Az egyik a Twitter, a másik a Feedly, mely egy online RSS olvasó. A Feedlyből kigyűjtöttem, hogy milyen Javaval kapcsolatos portálokat, blogokat olvasok, kidobáltam azokat, melyek tavaly nem frissültek, és most megtaláljátok a &lt;a href="http://jtechlog.blogspot.hu/p/forrasok.html"&gt;Források&lt;/a&gt; oldalon. Két kategóriában, ábécé sorrendben szerepelnek a magyar és angol nyelvű tartalmak.&lt;/p&gt;

&lt;p&gt;Kérlek titeket, hogy nézzétek meg, hogy miket követtek, és amennyiben nem szerepelnek a fenti listában, szúrjátok be ide a megjegyzések közé.&lt;/p&gt;

&lt;p&gt;Az oldalt próbálom rendszeres időközönként frissíteni.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/3812191713339137641/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2014/01/forrasok.html#comment-form' title='3 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3812191713339137641'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3812191713339137641'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/01/forrasok.html' title='Források'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>3</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3812297852319041819</id><published>2013-12-27T16:50:00.000+01:00</published><updated>2014-01-02T16:45:03.269+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='PDF'/><category scheme='http://www.blogger.com/atom/ns#' term='open source'/><category scheme='http://www.blogger.com/atom/ns#' term='PKI'/><category scheme='http://www.blogger.com/atom/ns#' term='Library'/><title type='text'>PDF elektronikus aláírása és időbélyegzése nyílt forráskódú eszközökkel</title><content type='html'>&lt;p&gt;Felhasznált technológiák: JDK 7, Maven 3, JUnit 4.11, iText 5.4.5, Apache PDFBox 1.8.3, Bouncy Castle 1.49, 1.50&lt;/p&gt;

&lt;p&gt;A PDF formátum egy olyan dokumentumleíró formátum, mely képes az elektronikus aláírást is tárolni. Így nincs szükség külön fájlra mely az aláírást tartalmazza, ezáltal könnyebben kezelhető, és azonnal megnyitható akár olvasásra, akár az elektronikus aláírás ellenőrzésére. A PDF törzsrésze un. objektumokat tartalmaz, melyek különböző típusúak lehetnek, pl. logikai, szám, szöveges, stream, szótár, stb. Az elektronikus aláírást egy un. signature directory tartalmazza, mely része a tanúsítvány, a dokumentum aláírt hash-e, időbélyeg, vagy akár az aláírás valamilyen vizuális megjelenése.&lt;/p&gt;

&lt;p&gt;Az aláírás folyamata nagy vonalakban a következőképpen zajlik. Először vesszük a dokumentum hasznos részét, az hash-elésre kerül, pl. SHA-256 algoritmussal, majd ez lesz az aláíró privát kulcsával titkosítva (pl. RSA algoritmussal), és egy hexadecimálisan kódolt PKCS#7 tárolóba rakva. Ezután mehet az időbélyeg. Minden aláíráshoz egy un. handler tartozik, az Adobe.PPKLite handler azt jelenti, hogy az aláírás a PKI infrastruktúrán (publikus/privát kulcs) alapul. Akit ennél részletesebben érdekel, olvassa el az Adobe &lt;a href="http://www.adobe.com/devnet-docs/acrobatetk/tools/DigSig/Acrobat_DigitalSignatures_in_PDF.pdf"&gt;Digital Signatures in a PDF&lt;/a&gt; dokumentumát.&lt;/p&gt;

&lt;p&gt;Akit érdekel az elektronikus aláírás témaköre, olvassa el korábbi posztjaimat is, melyeket pár napja frissítettem, hogy naprakész információkat tartalmazzanak:  &lt;a href="http://jtechlog.blogspot.hu/2011/02/elektronikus-alairas-es-alkalmazasa.html"&gt;Elektronikus aláírás és alkalmazása Java-ban, kulcskezelés&lt;/a&gt;,  &lt;a href="http://jtechlog.blogspot.hu/2008/12/minstett-elektronikus-alrs.html"&gt;Minősített elektronikus aláírás&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Valamint érdekelt, hogy a különböző szolgáltatók, mint pl. Elmű, Főgáz, Tigáz, stb. az elektronikusan kiadott számláikat milyen módon írják alá, ennek összesítése megtalálható egy &lt;a href="https://docs.google.com/spreadsheet/ccc?key=0Avxdl4mpIvJEdGZuVHJaMWtTbmlwNkdVWS0wYUd4VlE&amp;usp=sharing"&gt;Google Drive Táblázatban&lt;/a&gt;. Örülnék, ha ki tudnátok egészíteni más szolgáltatókkal is.&lt;/p&gt;

&lt;p&gt;Először az iText jutott eszembe, de annak a 4.x verziója lett kiadva MPL és LGPL licensz alatt, míg az 5.x sorozatért keményen fizetnünk kell, ha zárt forráskódú kereskedelmi alkalmazásban akarjuk használni (AGPL). A 4.x sorozattal azonban két baj is van. Egyrészt az iText megalkotója Bruno Lowagie maga figyelmeztette a felhasználókat, hogy a 4.x sorozat tartalmazhat olyan kódrészleteket, melyek nem szabályosan vannak LGPL licensz alatt. Technikaibb jellegű, hogy csak a 1.38-as Bouncy Castle Java crypto könyvtárra tartalmaz függőséget. Ez azonban az időbélyeg kérésére beépítetten SHA-1 algoritmust használ, ami elavult, minimum SHA-256 hash-t kéne használni. A BC 1.49 verziójában jelent meg, hogy a TSP API SHA-1 hash-en kívül mást is tudjon használni (lsd. &lt;a href="http://www.bouncycastle.org/releasenotes.html"&gt;release notes&lt;/a&gt;). A BC verzióját feljebb emelni nem sikerült, nem visszafele kompatibilis az API. Ezért alternatív megoldás után néztem.&lt;/p&gt;

&lt;p&gt;Legelterjedtebb nyílt forráskódú PDF library Java nyelven az &lt;a href="http://pdfbox.apache.org/"&gt;Apache PDFBox&lt;/a&gt;, melyre már több más projekt is átállt. Közel sem olyan jól dokumentált, mint az iText, melyhez már könyv is van (&lt;a href="http://www.amazon.com/iText-Action-Bruno-Lowagie/dp/1935182617/ref=sr_1_1?ie=UTF8&amp;qid=1388156044&amp;sr=8-1&amp;keywords=itext"&gt;iText in Action&lt;/a&gt;), valamint egy &lt;a href="http://itextpdf.com/book/digitalsignatures/"&gt;ingyenes whitepaper is letölthető&lt;/a&gt; az elektronikus aláírásról. A PDFBox példaprogramjai között is csak elektronikus aláírásra van példa, az időbélyegzésre nincs.&lt;/p&gt;

&lt;p&gt;Fontos megjegyezni, hogy minősített elektronikus aláírás esetén magát az aláíró szoftvert is minősíttetni kell, mint az a korábbi posztomban már megemlítettem.&lt;/p&gt;

&lt;p&gt;A már említett poszt alapján e-mailben kértem egy NetLock teszt tanúsítványt, valamint a UnlimitedJCEPolicyJDK7.zip tartalmát is elhelyeztem az SDK-ban a megfelelő helyen, enélkül ugyanis a következő kivételt kaptam:&lt;/p&gt;

&lt;pre&gt;
java.io.IOException: exception unwrapping private key 
  - java.security.InvalidKeyException: Illegal key size
&lt;/pre&gt;

&lt;p&gt;A NetLock-tól megkaptam teszteléshez a fokozott (joghatással nem rendelkező) időbélyeg url-jét (http://www.netlock.hu/timestamp.cgi), mely autentikációt nem igényel. Ezúton köszönöm Varga Viktornak, a NetLock Kft. Üzemeltetési és Vevőszolgálati Vezetőjének a cikk megírásához nyújtott segítséget.&lt;/p&gt;

&lt;p&gt;Eztán elkészítettem a példaprogramot, mely &lt;a href="https://github.com/vicziani/jtechlog-signpdf"&gt;elérhető a GitHub-on&lt;/a&gt;. Itt megtalálható az iText-es megoldás is, mely &lt;a href="https://github.com/vicziani/jtechlog-signpdf/blob/master/jtechlog-signpdf-itext/src/main/java/jtechlog/signpdf/PdfSigner.java"&gt;láthatóan sokkal egyszerűbb&lt;/a&gt;, mint a &lt;a href="https://github.com/vicziani/jtechlog-signpdf/blob/master/jtechlog-signpdf-pdfbox/src/main/java/jtechlog/signpdf/PdfSigner.java"&gt;PDFBox-os társa&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Alapvetően mindkét helyen a Bouncy Castle crypto API-t használom. Mindkét esetben ugyanolyan módon kell betölteni a tanúsítványokat, valamint a titkos kulcsot a PKCS#12 tanúsítványtárból, melyben az összes böngészőből ki lehet exportálni ezeket. Az iText teljesen elfedi, hogy mi történik a háttérben, a MakeSignature signDetached metódusát kell hívni, valamint időbélyegzéshez át kell adni egy TSAClient implementációt is.&lt;/p&gt;

&lt;p&gt;A PDFBox esetén viszont teljesen kezünkben van a vezérlés. A SignatureInterface sign metódusát kell implementálnunk. Az aláírás Cryptographic Message Syntax (CMS - &lt;a href="http://tools.ietf.org/html/rfc5652"&gt;RFC 5652&lt;/a&gt;) tárolóban tárolt a PDF-en belül, mely a PKCS#7 szabványon alapul. A CMS az ASN.1 standard formátumot használja az adatok ábrázolásra. Ennek kezelésére a Bouncy Castle CMSSignedDataGenerator osztálya való. Hash SHA256, titkosítási algoritmus RSA.&lt;/p&gt;

&lt;p&gt;Az időbélyegzés kicsit trükkösebb. Ugyanis időbélyegezni az aláírást kell. Tehát csak aláírás után lehetséges, ezért egy lépéssel később történik. (Mint arra a &lt;a href="http://bouncy-castle.1462172.n4.nabble.com/Insert-Time-stamp-into-CMS-Signed-Data-td1464065.html"&gt;Bouncy Castle levelezési listán&lt;/a&gt; rámutatnak. Amúgy nagyon készségesek, kérdésemre is nagyon hamar válaszoltak.) Az aláírást kell hash-elni, majd elküldeni az időbélyegző szolgáltatónak az RFC 3161 szabvány szerint. Ezt a Bouncy Castle tsp csomagja implementálja. Kód a &lt;a href="https://github.com/vicziani/jtechlog-signpdf/blob/master/jtechlog-signpdf-pdfbox/src/main/java/jtechlog/signpdf/TimeStampClient.java"&gt;TimeStampClient&lt;/a&gt; osztályban. Arra kell nagyon vigyázni, hogy a TimeStampResponse.getTimeStampToken().getEncoded() byte tömb kerüljön a PDF-be. A timestamp formátumát az &lt;a href="http://tools.ietf.org/html/rfc5544"&gt;RFC 5544&lt;/a&gt; írja le, szintén CMS-re építve.&lt;/p&gt;

&lt;p&gt;Még egy problémám akadt. Míg így már az Adobe Acrobat Reader már tökéletesen megjeleníti az aláírást és időbélyeget is, a Foxit Reader nem. Ennek oka, hogy a Bouncy Castle BER kódolást használ, azonban a Foxit csak a DER kódolást tudja olvasni. Levél ment a supportra, nagyon segítőkészek. Azonban a Bouncy Castle képes BER-ből DER-be konvertálni, ez szintén megtalálható a példaprogramban. Az időbélyegzés megjelenítése sincs benne a Foxit Reader-ben, erre is kaptam ígéretet.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/3812297852319041819/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2013/12/pdf-elektronikus-alairasa-es.html#comment-form' title='4 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3812297852319041819'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3812297852319041819'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/12/pdf-elektronikus-alairasa-es.html' title='PDF elektronikus aláírása és időbélyegzése nyílt forráskódú eszközökkel'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>4</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8235707600371192448</id><published>2013-11-17T16:47:00.002+01:00</published><updated>2013-12-25T20:33:36.897+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Servlet'/><category scheme='http://www.blogger.com/atom/ns#' term='JSP'/><category scheme='http://www.blogger.com/atom/ns#' term='vizsga'/><category scheme='http://www.blogger.com/atom/ns#' term='Java EE'/><category scheme='http://www.blogger.com/atom/ns#' term='könyv'/><title type='text'>Web Component Developer</title><content type='html'>&lt;p&gt;Ebben a hónapban tettem le a &lt;a href="http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=5001&amp;get_params=p_exam_id:1Z0-899&amp;p_org_id=&amp;lang="&gt;Java EE 6 Web Component Developer Certified Expert Exam (1Z0-899)&lt;/a&gt; vizsgát, mely alapvetően a Java EE 6 szabványon belül a Servlet és JSP technológiára koncentrált. Ahhoz képest, hogy napi életben ezt használom a legtöbbet, ez volt az eddigiek közül (Java SE, EJB, JPA, Web Services) a legnehezebb, annak ellenére, hogy 40 órát biztos készültem rá.&lt;/p&gt;

&lt;p&gt;A vizsga a szokásos, 140 perc, 57 kérdés, tesztek, ahol előre megmondják a jó válaszok számát. Sikeres vizsgához 64% kell, ami egyáltalán nem tűnik soknak. Az egész körítés nem változott a legutóbbi &lt;a href="http://jtechlog.blogspot.hu/2012/12/oracle-certified-expert-java-ee-6-web.html"&gt;Web Services vizsgám&lt;/a&gt; óta, bővebb információk ott.&lt;/p&gt;

&lt;p&gt;A témakörök a következők voltak:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Web alkalmazások tervezése, protokollok, technológiák, komponensek: 5 kérdés&lt;/li&gt;
  &lt;li&gt;Controller fejlesztése a navigáció implementálásához: 5 kérdés&lt;/li&gt;
  &lt;li&gt;Biztonság: 7 kérdés&lt;/li&gt;
  &lt;li&gt;Hibák kezelése: 4 kérdés&lt;/li&gt;
  &lt;li&gt;JSP és JSTL: 12 kérdés&lt;/li&gt;
  &lt;li&gt;Model, View és Controller tervezési minta használata: 5 kérdés&lt;/li&gt;
  &lt;li&gt;Alkalmazás és felhasználó állapotának kezelése: 6 kérdés&lt;/li&gt;
  &lt;li&gt;Kérés és válasz kezelése servletekkel: 6 kérdés&lt;/li&gt;
  &lt;li&gt;Tesztelés, csomagolás és telepítés: 7 kérdés&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A technológiák közül érintett volt a Servlet, JSP, JSTL, EL. És a Servlet API 3.0-ás verziójára is vonatkoztak kérdések, mint később látni fogjuk.&lt;/p&gt;

&lt;p&gt;Felkészüléshez a &lt;a href="http://www.amazon.com/dp/0955160340"&gt;OCEJWCD Study Companion: Certified Expert Java EE 6 Web Component Developer (Oracle Exam 1Z0-899)&lt;/a&gt; könyvet választottam. Másik lehetőség a &lt;a href="http://www.amazon.com/Head-First-Servlets-Bert-Bates-ebook/dp/B006ORP9DQ/"&gt;Head First Servlets and JSP&lt;/a&gt; lett volna, ami szintén azt hirdeti magáról, hogy a vizsgára készít fel. Én az előbbit választottam, hiszen hivatalosabbnak tűnt, gondoltam jobban ismeri, hogy a vizsga mire koncentrál, jobban érzi a hangsúlyokat. Valamint a Head First könyvek jók valamilyen technológiát megismerni, de ha az ember már évek óta használja, akkor inkább a referencia jellegű könyv a jobb. Harmadrészt a Head First könyv nem tartalmazza a Servlet 3.0 újdonságait, SWCD exam for J2EE 1.4-re készít fel. Sajnos a könyv választással alapvetően tévedtem, az első könyv ugyanis abszolút nem arra koncentrált, amit a vizsgán kérdeztek. Vizsgára felkészítő könyvhöz képest is túl száraz volt. Tele volt hibákkal, amiknek egy része van a honlapján feltüntetve. Sajnos ezek nagy része az ellenőrző kérdésekben és megoldásokban van. Van egy fejezet, ahova nem tettek be kódrészletet, hanem a netről letöltendő példa alkalmazásokban kellett turkálni. Azért a teszteket érdemes belőle megnézegetni, de semmiképp nem javaslom egyedüli felkészítő anyagnak. Szemben pl. az OCJP könyvvel. Érződik, hogy a Servlet 3.0 részeket is utólag belegányolták, nem integráns része, nem illeszkedik bele a könyv egészébe. A neten található bónusz kérdéssor sem tartalmaz ezzel kapcsolatban kérdéseket.&lt;/p&gt;

&lt;p&gt;A kiinduló oldal, ahonnan még érdemes információkat beszerezni, az a JavaRanch &lt;a href="http://www.coderanch.com/how-to/java/ScwcdLinks"&gt;OCEJWCD&lt;/a&gt; vizsgával kapcsolatos oldala, valamint egy csomó példa kérdéssor található mock examra keresve &lt;a href="http://nikojava.wordpress.com"&gt;itt&lt;/a&gt;, &lt;a href="http://exam.piotrnowicki.com/viewQuestion.xhtml?q=Q67"&gt;itt&lt;/a&gt;, &lt;a href="http://www.javaranch.com/carl/scwcd/scwcd_mock_logo.jsp"&gt;itt&lt;/a&gt; és &lt;a href="http://www.cafe4java.com/mockexams/scwcd/mock1/q1.php"&gt;itt&lt;/a&gt;. Sokan javasolják a &lt;a href="http://enthuware.com/index.php/mock-exams/oracle-certified-expert/oce-jsp-servlet-mock-questions"&gt;Enthuware&lt;/a&gt; programját is, én erre nem költöttem, de ma már másképp tennék.&lt;/p&gt;

&lt;p&gt;És akkor konkrétan a kérdésekről. Több kérdés volt a HTTP metódusokról, külön kérdés a DELETE-ről is. Egy kérdés, hogyha formon nem írsz ki metódust, akkor az defultban POST-e? Ha egy JSP egy JS fájlt szolgál ki, de JSP kiterjesztéssel, headerben be kell-e állítani a content-type-ot? Ismerni kell a Last-Modified headert.&lt;/p&gt;

&lt;p&gt;Nagyon fontos a Dispatcher include és forward ismerete, az include direktíva és az import jsp tag, és az ezek közötti különbségek, valamint mikor mit lehet csinálni, mikor van commit, mikor van IllegalStateException. Ismerni kell mindegyik paraméterezését, mert hát nyilván eltérnek. Ismerni kell az url rewrite-ot is.&lt;/p&gt;

&lt;p&gt;Volt kérdés a role-link deployment descriptor elemről. A security annotációk szintakszisát fejből kell ismerni.&lt;/p&gt;

&lt;p&gt;Számomra a legérdekesebb, és legkevésbé ismert rész a hibakezelés volt. Pl. ha az adatbázis 5 perccel később indul el, mint az alkalmazás, akkor mit kell csinálni. Servlet init-ben várni rá, vagy hibát dobni? Mi van, ha megbízhatatlan az adatbázis, többször elvesztjük a kapcsolatot, ez hogyan kell kezelni? Erősen kell ismerni, hogy mi a különbség a ServletException és a UnavailableException között. Deployment descriptor-ban milyen exception-öket lehet megadni, Throwable, Error, IOException? Sorrend számít, lehet többet megadni?&lt;/p&gt;

&lt;p&gt;Volt jsp documenttel kapcsolatos kérdés is. Mivel én kizárólag scriptless JSP-ket írok, megdöbbentett a nagyon sok useBean és getProperty és setProperty-s kérdés. A legapróbb részletekig tisztában kell lenni velük. Ismerni kell a JSTL tag-ek nevét és paraméterezését. Amin meglepődtem, hogy saját tag-ek írása alap szinten volt. Én legtöbb energiát ebbe öltem, mert ritkán kell ilyen, és nagyon bonyolult a szintakszisa, és nem egyszerű megtanulni, az összes interfésszel, telepítési leíróval. Egy nagyon alap dolgot kérdeztek, ami kitalálható. A kedvencem az volt, hogy a taglib-nek prefixként meg lehet-e adni a java szót, és érzékeny-e a kis és nagybetűre.&lt;/p&gt;

&lt;p&gt;Ismerni kell a session metódusokat: getCreationTime, getLastAccessedTime, és hogy ezek miket adnak vissza (long).&lt;/p&gt;

&lt;p&gt;EL szinten nagyon ráment a típuskonverzióra, van-e String konkatenáció, és fejből kell tudni a precedenciát. Több kérdésben is rákérdezett, hogy a pont és szögletes zárójel operátort jól tudod-e használni, pl. map-ek, bean-ek esetén.&lt;/p&gt; 

&lt;p&gt;Kérdés, hogy Servlet 3.0 esetén az injection az init után van vagy előtt? Volt pár listeneres kérdés, pl. a getSession melyik listener eventjében van. Több kérdés is volt a web fragmentekről, különösen az orderingre szerettek rákérdezni. Érdekes kérdés, hogy vajon a web.xml vagy a fragment filtere fut-e előbb? Sok filteres és egy wrapperes kérdés volt. Filterből vajon hány példányt hoz létre a konténer? @Multipart annotáció paramétereit is ismerni kell. Egy asynccontext-es kérdés volt, kitalálható. Design patternnel foglalkozó kérdés nálam nem volt.&lt;/p&gt;

&lt;p&gt;Ahhoz képest, hogy ennél a vizsgánál tanultam direkt vizsgára felkészítő könyvből, és a legtöbb anyag erről van fenn a neten, ez volt a legnehezebb vizsga, itt ért a legtöbb meglepetés a kérdésekkel kapcsolatban, hogy olyan dologra kérdezett rá, mely egyik felkészítő anyagban sem volt, és a mock vizsgákban sem.&lt;/p&gt;

&lt;p&gt;Végül álljon itt egy &lt;a href="https://dl.dropboxusercontent.com/u/7683931/jtechlog/ocejwcd.txt"&gt;letölthető szöveges állomány&lt;/a&gt;, mely a vizsgára készülés során összeszedett dolgokat tartalmazza. Aki erre a vizsgára készül, annak hasznos lehet, ha felkészülés gyanánt átfutja.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/8235707600371192448/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2013/11/web-component-developer.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/8235707600371192448'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/8235707600371192448'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/11/web-component-developer.html' title='Web Component Developer'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-501890045491464373</id><published>2013-11-11T00:20:00.000+01:00</published><updated>2013-11-14T10:50:19.024+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='web framework'/><category scheme='http://www.blogger.com/atom/ns#' term='user interface'/><title type='text'>Milyen GUI keretrendszert szeretnék?</title><content type='html'>&lt;p&gt;Egy &lt;a href="https://twitter.com/vicziani/status/398190693123768320"&gt;Twitter bejegyzésben&lt;/a&gt; elindított gondolatmenetnek szeretnék most a végére járni. Alapvetően a Java nyelvet nem tartom alkalmasnak arra, hogy üzleti alkalmazások grafikus felületét fejlesszünk vele. De akkor mi lehet a megfelelő technológia? Sok cikk hasonlítja össze a jelenlegi keretrendszereket, kihangsúlyozva azok erősségeit. Ezek közül a legjobbak közé tartozik a JRebelt gyártó &lt;a href="http://zeroturnaround.com/rebellabs/the-curious-coders-java-web-frameworks-comparison-spring-mvc-grails-vaadin-gwt-wicket-play-struts-and-jsf/"&gt;RebelLabs cikke&lt;/a&gt;, valamint Matt Raible &lt;a href="http://raibledesigns.com/rd/page/publications"&gt;sorozatosan ad ki&lt;/a&gt; ilyen cikkeket és prezentációkat, és Martin Fowler cégének, a ThoughtWorks-nek a &lt;a href="http://www.thoughtworks.com/radar"&gt;Tech Radarja&lt;/a&gt; is jó olvasmány. Én most megpróbálok a jelenlegi technológiai megszorításoktól elszakadni, és kifejteni, hogy milyen legyen egy jó GUI keretrendszer, és a most létezők miért nem azok. Figyelem, a következő bekezdések a nyugalom megzavarására alkalmasak, nem mély szakmai jellegűek, és erősen szubjektív véleményemet tükrözik a témával kapcsolatban. Egyfajta referenciának is készíteném, mert sokakkal beszélgetek erről, és nincs mindig idő kifejteni. Így most megteszem itt. Vigyázat, gigaposzt. Természetesen tévedéseket is tartalmazhat, a helyreigazításokat szívesen várom a hozzászólások között.&lt;/p&gt;

&lt;p&gt;Először is definiálni kell, hogy mit tartok GUI keretrendszernek. Egy olyan szoftver köztes réteget, mely a programozók számára egy API-t biztosít, hogy annak használatával hatékonyan képesek legyenek konzisztens felhasználói felületeket összeállítani. Jelen posztomban kizárólag üzleti alkalmazások grafikus felületére szeretnék koncentrálni, és nem általános célú alkalmazásokról írok. Sokan összekeverik az elvárásokat, és mindenre ugyanazt az eszközt alkalmazni. Egy intraneten használt bonyolult üzleti folyamatokat lefedő alkalmazást kis felhasználószámmal sok képernyővel teljesen másképp és más technológiával kell megvalósítani, mint egy világ összes internethasználója számára fejlesztett közösségi szolgáltatást. Persze lehetne egymáshoz közelíteni a kettőt, de az vállalhatatlan plusz költségekkel járna. Nézzük tehát, hogy mit nevezek jelen posztomban üzleti alkalmazásnak. Alapvetően kontrollált, számos megszorítással rendelkező környezetben futó alkalmazásról van szó. Biztos sokan találkoztatok pl. intranetes banki rendszerekkel (IE6 böngészőkkel), az ottani szabályokkal, korlátokkal. A felhasználószám nem szükségképpen nagy, persze egy multi esetén azért elég nagyra nőhet. Akár több száz képernyőt is tartalmazhat, melyek között vannak hasonlóak. Bonyolult képernyőket tartalmazhat bonyolult és sok komponenssel, gridekkel, nagyobb adattömeggel. A fejlesztők nem minden esetben tíz éves tapasztalattal rendelkező senior fejlesztők, akik képben vannak a legfrissebb technológiákkal, elég nagy lehet a szórás a csapat tudásában. Egy idő után sok erőforrás megy el hibajavításra, követésre, és már nem feltétlenül nyújt technológiai kihívásokat. Alapvetően egyedi fejlesztésekre gondolok, a dobozos termékekkel kapcsolatban megint mások lehetnek az elvárások.&lt;/p&gt;

&lt;p&gt;Mi az, ami nem jellemző rá? Ezért meg fogtok kövezni, de nem akkora elvárás a válaszidő, ami ha 300 ms felett van, a felhasználó el fog klikkelni. Persze az egész rendszer megítéléséhez hozzájárul, de nem fogtok annyi erőforrást az optimalizálásra költeni, máshol vannak a súlyok. Az ügyfél is elégedettebb, ha egy használhatóbb vagy egy új üzleti funkcionalitást kap, mintha ezredmásodperceket optimalizáltok. Nagyrészt nem kell platformfüggetlennek lennie kliens oldalon. Gondolok itt nem csak az operációs rendszerre, futtató környezetre, hanem magára az eszközre is, tablet és mobil nem elvárás. (Ebbe nem megyek bele, külön posztot érne, de nem hiszek az újrafelhasználható felületekben, és mindkét típusú eszközt kiszolgálni képes technológiákban üzleti alkalmazások esetén. Az Atlassian-os Rich Manalang sokat emlegetett &lt;a href="http://blogs.atlassian.com/2012/01/modern-principles-in-web-development/"&gt;Modern Principles in Web Development&lt;/a&gt; cikke itt nem áll.)&lt;/p&gt; 

&lt;p&gt;Eddig szándékosan kerültem a webes keretrendszer megnevezést. Ugyanis üzleti alkalmazások fejlesztésére alkalmatlannak tartom a webet. Emlékezzetek vissza, a HTML egy hipertext dokumentum leíró nyelv. A HTTP egy szöveges, állapotmentes kérés-válasz alapú protokoll. Mennyi és mennyi probléma származik abból, hogy erre a modellre akarunk alkalmazásokat ráerőltetni. Vegyük sorra.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Platformfüggetlenség - bár ez üzleti alkalmazások fejlesztésénél nem probléma, hiszen sok helyen láttam, hogy csak egy böngészőn kellett mennie. De láttam már olyant is, hogy a header-öket nem megfelelően értelmező tűzfal, azaz köztes aktív elem okozta a problémát, milyen jó is, hogy a protokoll elemezhető.&lt;/li&gt;
 &lt;li&gt;Lassabb válaszidő pl. oldal váltásakor, hálózati kommunikáció, oldal kliens oldali lerenderelése, latency.&lt;/li&gt;
 &lt;li&gt;Minden erőforrás lekérése új TCP/IP kapcsolat. Vagy problémák a keep-alive beállításokkal. Ezek mennyire terhelik a szerver oldalt? Egy host-ra csak párhuzamosan hány kérést lehet indítani?&lt;/li&gt;
 &lt;li&gt;Egy ideig nem lehetett oldalváltás nélkül a szerverrel kommunikálni.&lt;/li&gt;
 &lt;li&gt;Böngésző korlátjai. Találkoztatok már olyan ügyféllel, aki levetette volna a címsort, a vissza gombot? Aki funkcióbillentyűket akart?&lt;/li&gt;
 &lt;li&gt;Szerver oldali üzenetküldés, vagy akár a kliensek közötti kommunikáció, broadcast üzenetek.&lt;/li&gt;
 &lt;li&gt;Dátumbeviteli komponens, maszkolt mezők, gridek.&lt;/li&gt;
 &lt;li&gt;CSS-ben változók, mixinek, kifejezések.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vannak ezekre megoldások? Vannak. De nem konzisztensek, nem teljes körűek, nem érzem, hogy a technológia szerves részét adnák. Csupán workarundok, régi protokollok, formátumok visszafele kompatibilitást megőrizendő tákolásai.&lt;/p&gt;

&lt;p&gt;Rugaszkodjunk el a földtől, és nézzük, mik lennének az elvárásaim egy képzeletbeli GUI keretrendszerrel kapcsolatban.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Technológiailag jó iránynak tartom az interfészt leíró nyelv, a megjelenést és a logikát hordozó nyelv különválasztását. Pl. HTML+CSS/JavaScript, MXML+CSS/ActionScript, FXML+CSS/Java. Nagyon alkalmas interfész fejlesztésre az event-ek használata, és a (lehetőleg kétirányú) bind.&lt;/li&gt;
 &lt;li&gt;A dinamikus nyelv legyen, minden földi jóval, különösen lambda függvényekkel. Leírhatatlan ebben a környezetben egy Python vagy Groovy előnye, de akár JavaScript vagy ActionScript.&lt;/li&gt;
 &lt;li&gt;Tesztelhető legyen (unit és integrációs), az eszközöket maga a keretrendszer adja.&lt;/li&gt;
 &lt;li&gt;Ne akarja rám erőltetni a teljes stacket. Van egy jól bevált Java üzleti és perzisztens rétegem, akár Spring, akár EJB vonalon. A Java nyelv oo mivolta, platformfüggetlensége, biztonsága miatt erre a legalkalmasabb. Rengeteg Java fejlesztő van. Hiszek a backend által nyújtott szépen megfogalmazott, akár RESTful API-ban.&lt;/li&gt;
 &lt;li&gt;A módosítást azonnal ki tudjam próbálni. Lehetőleg úgy, hogy az adott képernyőről se kelljen elnavigálnom. Valljuk be, Java fejlesztőként van annak egy varázsa, mikor a böngészőben frissítést nyomva tesztelhetem a funkciót. (Az sem baj, ha már az első indítás is gyors.)&lt;/li&gt;
 &lt;li&gt;Adjon nekem architektúrát, ami egységes, kompakt legyen. Egy technológiát kelljen megtanulnom. Ne nekem összelegóznom, ne csak a lehetőséget adja, hanem best practice-eket. Mondja meg, hogy ha MVC, akkor hogyan kell a rétegeket megírnom. Sajnos a Java világban az MVC egyeduralkodó, de vizsgáljuk meg az MVVM (Model-View-ViewModel) és MVP (Model-View-Presenter) irányokat is. Ezáltal meg is akadályozza az elbonyolítást.&lt;/li&gt;
 &lt;li&gt;Convention over configuration. Egyszerűen, alapbeállításokkal működjön, de személyre szabhassam. Ne kelljen felesleges, technológiához kötődő kódot írni.&lt;/li&gt;
 &lt;li&gt;Beépítetten tartalmazzon támogatást a modularizációra.&lt;/li&gt;
 &lt;li&gt;Komponensekből tudjak építkezni. Saját komponenseket tudjak írni. Ez azért is nagyon fontos, mert láttam sok fejlesztőt, aki az adott keretrendszerekből ugyan nem sokat értettek, de egy minta alapján bármennyi képernyőt össze tudtak rakni. Igen, ezt a módot is támogatnia kell, a 150. képernyőt már nem az architect fogja elkészíteni. Komponens fejlesztésnél akár én akarom a vonalakat megrajzolni, natívan. Ezeket a komponenseket akár külső forrásból is be tudjam szerezni, vagy sajátomat terjeszteni.&lt;/li&gt;
 &lt;li&gt;Magas szintű komponensek. Dátumbeviteli mezők. Gridek. Erre külön kitérnék, ez sokszor előjött. Rendezhető (több oszlop szerint), lapozható, szerkeszthető. Követi az ablak, vagy a befoglaló panel átméretezéseit. Görgetés közben dinamikusan legyen képes adatokat letölteni. Oszlopokat át lehessen rendezni, méretezni. Szerkesztéskor a cellákban különböző beviteli komponensek jelenhessenek meg. Ne csak szöveget legyen képes megjeleníteni.&lt;/li&gt;
 &lt;li&gt;Legyen egyszerű, könnyen tanulható. Könnyen lehet demó alkalmazásokat összerakni, prototyping. Mélyebben megismerni csak a haladó funkciók eléréséhez kelljen. És mivel a backend Java, a Java fejlesztéshez közel álljon. Itt egy szintén külön posztot érdemlő téma. Legyen-e külön backend és frontend fejlesztő, vagy sem? Én jelen pillanatban amellett teszem le a voksom, ugyanaz a fejlesztő értsen a backendhez és a frontendhez is, nyilván nem olyan mélyen.&lt;/li&gt;
 &lt;li&gt;Szégyelem ezt a szót leírni, de szexinek kell lennie. A fejlesztőknek szeretniük kell. Ez csak akkor valósul meg, ha pörög, ha van mögötte hype, ha jól mutat az önéletrajzban. Ez sok helyen materializálódik: fejlesztők száma, állásajánlatok száma, LinkedIn, levlista, issue tracker, könyvek, tutorialok, blog bejegyzések, release-ek száma, Stack Overflow.&lt;/li&gt;
 &lt;li&gt;Jól nézzen ki. A honlapja is.&lt;/li&gt;
 &lt;li&gt;Jó fejlesztőeszköz támogatás, WYSIWYG szerkesztő. Emlékezzünk vissza a Delphi-re, meg lehetett azt csinálni normálisan. A JDeveloper, a NetBeans is viszonylag emészthető Swing kódot generált, ha odafigyeltünk pár alapszabályra a szerkesztéskor. Én ezekkel szerettem dolgozni, jobban, mint XML-ben rakni össze a teljes GUI-t. Persze a kettő között váltogatni lehessen, és szinkronizáljon.&lt;/li&gt;
 &lt;li&gt;Adja meg a projektstruktúrát, mit hova kell tennem. Legyen standard csomagolása, támogassák a build rendszerek, lehetőleg egy fájlba, egy artifactként össze lehessen állítani.&lt;/li&gt;
 &lt;li&gt;Nyílt forráskód.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sajnos azt nem írhatom hozzá, hogy legyen jövőképe, jövője. Ahol az Adobe egyik pillanatról a másikra úgy dönt, hogy kihátrál a Flex mögül és az Apache-nak adja, abban a környezetben, ahol az Oracle egyik pillanatról a másikra megszünteti a GlassFish támogatását, vagy a JavaFX-ből kidobja a Java FX Script-et és a mobil támogatást. Ahol a keretrendszerek platform támogatásait megszüntetik, nem lehet biztos jövőről beszélni. Technológiától függetlenül, ha nem hoz elegendő bevételt, halálra van ítélve.&lt;/p&gt;

&lt;p&gt;Mit szeretnék? Valaki merjen nagyot álmodni, és elfelejteni azt a posványt, amiben most vagyunk, és életre kelteni egy ilyen keretrendszert. Sok cégnek lenne rá erőforrása, Google nyithatna ebbe az irányba, Adobe, Oracle, SpringSource, JetBrains, stb. A piaci rés adott, csak ki kéne használni.&lt;/p&gt;

&lt;p&gt;No és akkor jöjjön a feketeleves. Vigyázat, sarkítok! Kezdjük a legnagyobb hypeként kezelt HTML5, CSS3, JavaScript kombinációt. Mikor lett a HTML 5 szabvány? Mennyi idő kellett a HTML 4-nek, hogy teljes körűen és ugyanúgy támogassák a böngészők? A technológiai korlátokat már kifejtettem. Érdekes, hogy a HTML-hez képtelenek voltak egy széles körben elterjedt, használható WYSIWYG editort írni. A platform töredezettségét nagyon jól jellemzi a &lt;a href="http://todomvc.com/"&gt;TodoMVC&lt;/a&gt;, ami ettől függetlenül egy hatalmas ötlet. Ugyanaz az alkalmazás megírva a legtöbb keretrendszerben. A legtöbb MV* keretrendszer azonban egy személetet ad, nem ad teljes megoldást. Van, amelyikre még visszatérek.&lt;/p&gt;

&lt;p&gt;Szabványok terén a Java világban mindenképp a JSF technológia az, amit meg kell említeni. Persze nem önmagába, de valami komponens könyvtárral, pl. ICEFaces, PrimeFaces, RichFaces, stb. Ez a klasszikus szerver oldalon kigeneráljuk a HTML tartalmat megközelítés (hívjuk egyszerűen server side renderingnek). Ezzel kapcsolatban &lt;a href="https://blog.twitter.com/2012/improving-performance-twittercom"&gt;érdekes kijelentést tett&lt;/a&gt; a Twitter, a modernebb kliens oldali JavaScript helyett átállt server side renderingre, és jelentős sebességjavulást ért el. A JSF hátrányai a Java nyelvből erednek. A deploy fájdalmasabb folyamat, ugyanis az alkalmazásszerverek nem képesek újraolvasni csak a módosított class-okat, az egész alkalmazást kell, jobb esetben exploded formában. Ugyan a már említett fizetős JRebel képes arra, hogy alkalmazás deploy nélkül lehessen kitenni a változott class fájlokat. A Java és a Facelet nyelv nehézsége lehet gátló tényező, a viszonylag bonyolult architektúra (komoly állapotátmenetekkel rendelkezik), és a view hierarchia kliens és szerver oldalon történő tárolása, ezek közötti szinkronizáció keserítheti el az embert. Jó azonban a komponensszemlélet.&lt;/p&gt;

&lt;p&gt;Most haladjunk gyártónként. A Google-nek ugyan nem ez a profilja az üzleti alkalmazások fejlesztésének kiszolgálása, de az ott összejött szürkeállomány miatt kell megemlíteni. Ne nyelvet fejlesszen, mint a Go, vagy a Dart. Felejtsék el HTTP, HTML+CSS, JavaScript kötöttségeket, aminek workaroundjára jött létre a GWT. Ennek már a koncepciójával sem tudtam egyet érteni. Java-ban kell fejleszteni, melyet átfordít JavaScriptre. Ez nálam ott bukik el, hogy a JavaScript egy alkalmasabb nyelv GUI fejlesztésre. Azon Java imádók miatt fejlesztették ki, akik nem voltak hajlandóak megtanulni a JavaScript-et. Ráadásul a fejlesztés sem a legkényelmesebb az átfordítás szükségszerűsége miatt. Bár nem a Google terméke, ide sorolom a Vaadin-t is, hiszen GWT-re épül. Az látszik, hogy már a GWT mögül is sokan kihátrálnak a Google-nél, és mozdulnak az AngularJS felé. Az számomra még mindig kevés, nem komplett megoldást ad.&lt;/p&gt;

&lt;p&gt;Az Adobe-nak is nagy tapasztalata van, de a zárt Flash mindig ellenérzést fog kiváltani. Sajnos azon Apple vezetője tette tönkre közvetve a Flex-et, amely még a legelvakultabb követői szerint sem ért a webhez, szemben az Adobe-val. A Flex alapjában véve egy &lt;a href="http://jtechlog.blogspot.hu/2013/02/az-apache-flex-multja-jelene-jovoje.html"&gt;jó konstrukció volt&lt;/a&gt;, de az Adobe kihátrálása tönkretette. Várok még a feltámadásában, de sajnos ennek esélye egyre kevesebb. Sajnos a közösség is rossz irányba tart, felesleges erőforrásokat ölnek abba, hogy JavaScript legyen képes futtatni. Komponensei jók, de félbemaradt a MX-es komponensekről a Spark-os komponensekre való átállás, és sok komponense bugos, ez megkeseríti az ember mindennapjait. Nagy hátránya még a fordító lassú sebessége, Javaban implementált ugyan, de ez még nem mentség. Sajnos a Java ekoszisztémába sem illeszkedik nagyon, a Flexmojo Maven plugin körül is vannak problémák, az artifactok repositoryba töltésével is, és tapasztalatom szerint a GradleFX Gradle plugin sincs a helyzet magaslatán. De a legnagyobb probléma, hogy megszűnt a közösség, az eszköztámogatás. Pedig még az Adobe is ad hozzá fejlesztőeszközt.&lt;/p&gt;

&lt;p&gt;A SpringSource nagyon jó irányban lépeget előre, egyrészt a Groovy a lehető legjobb irány, a komponens alapú szemlélet kiváló (Framework, Security, Data, Batch, HATEOAS, stb. mind külön-külön), a Grails már a web megkötéseit hurcolja magával, és sajnos rám akarja kényszeríteni magát üzleti logika és perzisztens szinten is. Viszont a generálós RAD irányt el kéne felejteni (Spring Roo). Persze ott a Spring MVC is, mely gyakorlatilag a HTTP Request és Response-okat kezelő MVC framework. (Mellesleg a Grails is erre épül.) Nyoma sincs a komponenseknek, e mellé bőven be kell rakni a teljes HTML, CSS, JavaScript keretrendszer stack-et, önállóan nagyon kevés. Alapvetően a server side rendering iskola híve, így még egy template renszert is mellé kell tenni, tipikusan JSP. Itt említeném meg a Struts 2-őt is, ami nagyon hasonló. Lelkesek ugyan, régi motorosok, összeolvadtak a WebWork keretrendszerrel, de sajnos eljárt felettük az idő.&lt;/p&gt; 

&lt;p&gt;Az Oracle jól nyomja a JavaFX-et, de gyerekcipőben jár. Furcsa mód pl. nyomják az ARM irányt is, ahelyett, hogy a fizetés vállalati ügyfelekre koncentrálnának. Sajnos még fejlődő, nagyon ingoványos terület, mindig lehet változásra számítani. A hivatalos példák nekem elsőre leültették a gépemet, másodjára megnézve pl. már a fa komponensben is ugrálnak az elemek a különböző ágakat lenyitva. Nem a professzionalitás látszatát kelti. A JRE előfeltétele vállalati környezetben annyira nem fájó. Emellett nyomja az JPA/EJB/JSF technológiákra épülő, azokat tökéletesen integráló és kiegészítő ADF technológiáját, hátrányai is megegyeznek a JSF-fel. Itt említeném meg a JBoss SeamFrameworköt is, pont ugyanezen megközelítést alkalmazza.&lt;/p&gt;

&lt;p&gt;Versenyben marad még a hype-olt Play Framework, amiben egyre erősebben dominál a Scala, ezért vegyes fejlesztőgárdával nem mernék nekimenni. Régebbi versenyző a Wicket, gyönyörű komponens modelljével, de a Java és a server side rendering minden hátrányával.&lt;/p&gt;

&lt;p&gt;Akarok-e beszélni a vastag kliensről? Mindenképp. Már emlegettem a Delphit, hogy milyen jó emlékek fűződnek hozzá. Grafikus tervezője egyedülálló, és az, hogy szinte azonnal indult, feledhetetlen élmény. A Swinggel sem voltak rossz tapasztalataim, de hát Java, nincs különválasztva a leíró nyelv. MVC, eseménykezelés nem rossz. Sajnos a komponensei igen bugosak, és halott technológia, az energiákat inkább a JavaFX-be ölik. Aztán ott van a NetBeans Platform, és az Eclipse RCP, melyek bármelyik fentebb felsorolthoz képest pilótavizsgás.&lt;/p&gt;

&lt;p&gt;"Ó, mondd, te kit választanál?" Amíg lehet, egyelőre megfigyelő státuszban maradnék. Ha azonban a döntést nem lehetne tovább halogatni, két irányt vizsgálnék meg. Az első a Grails frontend Java backenddel. A választás a Groovy nyelv, és a körülötte lévő nagy mozgolódás miatt. A második a komplex JavaScript keretrendszerek, melyek teljes támogatást nyújtanak, és nem csak egy-egy részproblémát oldanak meg. Ilyen a Dojo, Kendo UI, Ext.js. A HTML 5, CSS 3, JavaScript irány megkerülhetetlen, de egységes GUI keretrendszert szeretnék, és nem darabokból szeretném összeállítani. Képzeljünk el egy gyakori, de teljesen differenciált összeállítást, ahol a server side rendering webes keretrendszer a Spring MVC, JSP és JSTL view réteggel, ahol a CSS LESS-el kerül előállításra, Bootstrap kiindulási alap, RequireJS module loader, jQuery és AngularJS MVC JavaScript framework, összeturkált komponensek, build folyamatba Wro4j beépítve. El tudok képzelni projektet, ahol megfelelő lehet, de az nem a fentebb vázolt jellemzőkkel rendelkezik.&lt;/p&gt;

&lt;p&gt;Ha idáig eljutottál, már ne hagyd comment nélkül.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/501890045491464373/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html#comment-form' title='14 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/501890045491464373'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/501890045491464373'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html' title='Milyen GUI keretrendszert szeretnék?'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>14</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3351568542494398544</id><published>2013-05-20T20:49:00.002+02:00</published><updated>2013-05-20T20:49:49.855+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Community'/><title type='text'>Út a szőlőbe</title><content type='html'>Biztosan sokan voltatok már úgy egy-egy éjszakába nyúló debugolás közben, hogy most leteszitek a billentyűzetet, és soha többet nem veszitek a kezetekbe. Esetleg &lt;a href="http://www.1000birka.hu"&gt;vesztek ezer birkát, és elmentek birkapásztornak Írországba.&lt;/a&gt; Legtöbbünknek ez azonban csak álom marad, és újra visszatérünk a fejlesztés néha egyhangú, néha azonban sok izgalmat kínáló világába. Viszont van közülünk, aki tényleg megtette, egy fiatal, nagyon tehetséges fejlesztő, egy ifjú titán, aki felhagyott eddigi életével, hivatásával, elköltözött Pestről a Balatonra, a Szent György-hegyre, hogy vidéki szőlész-borász legyen. Olvassátok szeretettel a &lt;a href="http://utaszolobe.blog.hu/"&gt;blogját&lt;/a&gt; erről az útról, és drukkoljunk együtt neki.</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/3351568542494398544/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2013/05/ut-szolobe.html#comment-form' title='4 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3351568542494398544'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3351568542494398544'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/05/ut-szolobe.html' title='Út a szőlőbe'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>4</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4483245304697303695</id><published>2013-03-25T22:03:00.002+01:00</published><updated>2013-03-25T22:03:55.597+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Community'/><title type='text'>Szuperdiák Verseny</title><content type='html'>A &lt;a href="http://markmyprofessor.com"&gt;Mark My Professzor&lt;/a&gt; oldal Szuperdiák Versenyt szervez olyan hallgatóknak, akik Javát tanulnak vagy tanultak. A jelentkezéshez mindössze egy önéletrajzot kell elküldeni. Ezután egy szakmai zsűri választja ki a döntőbe jutottakat, ahol Java programozással kapcsolatos feladatot kapnak. A legjobb diákokat Apple termékekkel díjazzák. A rendezvény helyszíne a Miskolci Egyetem, ahová a döntőbe jutott, nem miskolci diákok útiköltségét fedezik. A verseny jelentkezési határideje 2013. április 10., időpontja 2013. április 17., további információk a &lt;a href="http://markmyprofessor.com/szuperdiak.html"&gt;http://markmyprofessor.com/szuperdiak.html&lt;/a&gt; címen érhetőek el.</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/4483245304697303695/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2013/03/szuperdiak-verseny.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4483245304697303695'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4483245304697303695'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/03/szuperdiak-verseny.html' title='Szuperdiák Verseny'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4963379818802072423</id><published>2013-03-17T22:03:00.001+01:00</published><updated>2013-03-17T22:03:19.451+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='performance'/><category scheme='http://www.blogger.com/atom/ns#' term='Hibernate'/><category scheme='http://www.blogger.com/atom/ns#' term='JPA'/><title type='text'>JPA több one-to-many kapcsolat</title><content type='html'>&lt;p&gt;Felhasznált technológiák: Spring 3.2.2, Hibernate 4.1.10&lt;/p&gt;

&lt;p&gt;Már írtam egy &lt;a href="http://jtechlog.blogspot.hu/2012/04/jpa-lazy-loading.html"&gt;postot&lt;/a&gt; a JPA teljesítményhangolásával, valamint a lazy loadinggal kapcsolatban. Ott egy entitáshoz egy másik kapcsolódott, one-to-many kapcsolattal. Ott folytatom, ahol abbahagytam, de most egy entitáshoz két másik entitás kapcsolódik ugyanazon, one-to-many kapcsolattal. Egyrészt megvizsgálom a Hibernate egy jellegzetes hibaüzenetét, valamint elemzek több megoldást is performancia szempontból.&lt;/p&gt;

&lt;p&gt;Az adatmodell a következő osztálydiagramon látható. Egy Employee példányhoz több Phone és több Address példány kapcsolódik.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;a href="http://yuml.me/d2a0e90e" imageanchor="1" style="display: block; margin-left: auto; margin-right: auto;"&gt;&lt;img border="0" src="http://yuml.me/d2a0e90e" /&gt;&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;A posthoz tartozó példaprogram &lt;a href="https://github.com/vicziani/jtechlog-jpa-descartes"&gt;letölthető a GitHub-ról&lt;/a&gt;. A projekt letöltése után az 'mvn test' paranccsal futtatható a teszt eset. Ez egy JUnit teszt eset, mely felépíti a Spring contextet, elindít egy beépített HSQLDB adatbázis-kezelőt, létrehozza a táblákat, feltölti adatokkal, majd meghívja a service-t, mely JPA lekérdezéseket használ, és a visszatérési értéket Hamcresttel ellenőrzi. A projekt ebben a postban bemutatott legutolsó megoldást tartalmazza, de megjegyzésben ott van a többi megoldás is.&lt;/p&gt;

&lt;p&gt;Amennyiben elkészítjük a három entitást, és csak a kötelező annotációkkal látjuk el, és azok kötelező paramétereivel, a következő kivételt kapjuk: &lt;code&gt;"org.hibernate.LazyInitializationException: failed to lazily initialize a collection of role: jtechlog.descartes.Employee.phones, could not initialize proxy - no Session"&lt;/code&gt;. Az előző postból tudhatjuk, hogy ez azért van, mert a @OneToMany annotáció használatakor a kapcsolódó entitásokat csak akkor tölti be, mikor szükség van rá (default a lazy loading). De mivel a teszt eset kéri le először a kapcsolódó entitásokat, a persistence context már zárva, a session zárva, így a Hibernate ezeket már nem tudja lekérdezni.&lt;/p&gt;

&lt;p&gt;Első megoldás, mely eszünkbe juthat, hogy egészítsük ki a @OneToMany annotációkat a &lt;code&gt;fetch = FetchType.EAGER&lt;/code&gt; paraméterrel. Ekkor a következő kivételt kapjuk, már akkor, mikor elindul a Hibernate: &lt;code&gt;"Deploy time: Caused by: org.hibernate.loader.MultipleBagFetchException: cannot simultaneously fetch multiple bags"&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ennek az az oka, hogy a Hibernate ebben az esetben egy joint tartalmazó select utasítást ad ki, és nem tudja kiválasztani, hogy melyik rekord melyik entitáshoz tartozik. A select a következő.&lt;/p&gt;

&lt;pre class="brush: sql"&gt;
SELECT ...
FROM Employee employee0_
LEFT OUTER JOIN Address addresses1_ 
  ON employee0_.id = addresses1_.employee_id
LEFT OUTER JOIN Phone phones2_ 
  ON employee0_.id = phones2_.employee_id
WHERE employee0_.id = ?
&lt;/pre&gt;

&lt;p&gt;Ezen kivétel mögött igen nagy irodalom áll, és több megoldási javaslatot is találhatunk. Egyrészt használjuk a Hibernate &lt;code&gt;@IndexColumn&lt;/code&gt; annotációját, vagy ha nem akarunk provider függőek lenni, akkor a JPA 2.0-ban megjelent szabványos &lt;code&gt;@OrderColumn&lt;/code&gt; annotációt. Ezt a @OneToMany annotációk mellé kell tenni, valamint a phone és az address táblába kell egy-egy új mező, mely az adott entitás listában elfoglalt pozícióját jelzi, és a JPA provider automatikusan karbantartja (, ahogy a példaprogramban is látható).&lt;/p&gt;

&lt;p&gt;A másik megoldás, hogy mind a két esetben a &lt;code&gt;List&lt;/code&gt; típust átírjuk &lt;code&gt;Set&lt;/code&gt;-re. Az előbbi és ezen megoldás esetében is megmarad a join a lekérdezésben.&lt;/p&gt;

&lt;p&gt;Van még egy megoldás. A @OneToMany annotációk mellé Hibernate specifikus @Fetch annotációt helyezünk el. Ez azt mondja meg, hogy a kapcsolódó rekordokat hogyan töltse be. Paraméterként több módot is meg lehet adni, az alapértelmezett mód a fentebb leírt JOIN, de használhatunk SELECT vagy SUBSELECT értékeket is.&lt;/p&gt;

&lt;p&gt;Mindkettő használata esetén a persistence provider három select utasítást ad ki.&lt;/p&gt;

&lt;pre class="brush: sql"&gt;
select ... from Employee employee0_ where employee0_.id=?
select ... from Phone phones0_ where phones0_.employee_id=?
select ... from Address addresses0_ where addresses0_.employee_id=?
&lt;/pre&gt;

&lt;p&gt;Itt tehát a két mód között nem látszik különbség. Azonban ha azt a metódust nézzük, mely az összes Employee példányt visszaadja (findEmployees()), azonnal láthatjuk a különbséget. A SELECT mód esetén a phone és az address táblára annyi select utasítást ad ki, amennyi rekordot az employee tábla tartalmazott. A SUBSELECT mód esetén mindig három select utasítást futtat, méghozzá a következőket.&lt;/p&gt;

&lt;pre class="brush: sql"&gt;
select ... from Employee employee0_ order by employee0_.id
select ... from Phone phones0_ 
  where phones0_.employee_id 
    in (select employee0_.id from Employee employee0_ )
select ... from Address addresses0_ 
  where addresses0_.employee_id 
    in (select employee0_.id from Employee employee0_ )
&lt;/pre&gt;

&lt;p&gt;Láthattuk, hogy hogy működik az eager fetch esetén de én ezt nem szeretem használni, mert ilyenkor mindig eager jönnek le a kapcsolódó entitások, nem tudok választani. Viszont finomabban szabályozható, ha a lekérdezésben adom meg, hogy mit akarok betölteni. Erre a join fetch való. Írjuk is át a lekérdezést, hogy a következő lekérdezést használja:&lt;/p&gt;

&lt;pre class="brush: sql"&gt;
select distinct e from Employee e 
  join fetch e.phones 
  join fetch e.addresses where e.id = :id
&lt;/pre&gt;

&lt;p&gt;A helyzet ugyanaz, mint az eager fetch esetén, MultipleBagFetchException-t kapunk. Persze megint átállhatunk &lt;code&gt;Set&lt;/code&gt;-re, és ekkor ugyanoda lyukadunk, hogy joint tartalmazó select utasítást kapunk. Mi ezzel a probléma?&lt;/p&gt;

&lt;pre class="brush: sql"&gt;
select distinct ... from Employee employee0_ 
  inner join Phone phones1_ 
    on employee0_.id=phones1_.employee_id 
  inner join Address addresses2_ 
    on employee0_.id=addresses2_.employee_id 
  where employee0_.id=?
&lt;/pre&gt;

&lt;p&gt;Igen, jól látható, hogy a fenti select utasítás eredménye egy Descartes-szorzat. Azaz ha a phone táblában van tíz rekord, és a address táblában is van tíz rekord egy adott employee rekordhoz, a lekérdezés száz rekordot fog visszaadni. Ez a probléma az eager fetch-nél is fennáll JOIN mód esetén.&lt;/p&gt;

&lt;p&gt;Mi lehet erre a megoldás? Tudjuk azt, hogy amíg él a persistence context, addig a JPA provider a memóriában tárolja, hogy mik lettek betöltve, és azokat nem kéri be újra. Tehát egyrészt lekérdezzük az Employee entitást joinnal összekötve a Phone entitásokkal, majd egy külön lekérdezésben az Employee entitást joinnal összekötve az Adress entitásokkal. Ez a következőkben látszik.&lt;/p&gt;

&lt;pre class="brush: java"&gt;
@Transactional(readOnly = true)
public Employee findEmployeeById(long id) {
    em.createQuery("select e from Employee e " +
      "join fetch e.phones where e.id = :id", Employee.class)
        .setParameter("id", id)
        .getSingleResult();
    return em.createQuery("select e from Employee e " +
      "join fetch e.addresses where e.id = :id", Employee.class)
        .setParameter("id", id)
        .getSingleResult();
    }
&lt;/pre&gt;

&lt;p&gt;Megfigyelhetjük, hogy az első lekérdezés eredményével nem csinálunk semmit. Csupán csak arra való, hogy az Employee és a Phone entitásokat a persistence contextbe töltse. A második query igaz, hogy csak a Address entitásokat kéri le, de mivel a Phone entitások már a persistence contextben vannak, hozzáköti őket. Ehhez persze kell a @Transactional annotáció (&lt;code&gt;readOnly = true&lt;/code&gt; paraméterrel a sebesség érdekében), különben mindkét lekérdezéshez külön persistence contextet nyitna, így ugyanúgy LazyInitializationException lenne a jutalmunk. A lefuttatott két select utasítás a következő.&lt;/p&gt;

&lt;pre class="brush: sql"&gt;
select ... from Employee employee0_ 
  inner join Phone phones1_ 
    on employee0_.id=phones1_.employee_id where employee0_.id=?
select ... from Employee employee0_ 
  inner join Address addresses1_ 
    on employee0_.id=addresses1_.employee_id where employee0_.id=?
&lt;/pre&gt;

&lt;p&gt;Látható, hogy két select fut le, mindegyik eredménye tíz-tíz rekord, szemben a join változattal, ahogy egy select adott vissza száz rekordot.&lt;/p&gt;

&lt;p&gt;A performancia hangolás érdekében még jó tisztában lenni a kiadható hintekkel is, mely persistence providerenként más és más, &lt;a href="http://docs.jboss.org/hibernate/stable/entitymanager/reference/en/html/objectstate.html#d0e1215"&gt;Hibernate esetén&lt;/a&gt; hasznos lehet a "org.hibernate.fetchSize" hint, amivel azt állíthatjuk be, hogy hány rekordonként forduljon az adatbázishoz, azaz egyszerre mennyi rekord menjen át Java oldalra. Ennek használatával sikerült akár kétszeres sebességjavulást is elérnem.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/4963379818802072423/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2013/03/jpa-tobb-one-to-many-kapcsolat.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4963379818802072423'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4963379818802072423'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/03/jpa-tobb-one-to-many-kapcsolat.html' title='JPA több one-to-many kapcsolat'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6577035106335169594</id><published>2013-02-02T16:57:00.000+01:00</published><updated>2013-02-02T16:57:02.186+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='open source'/><category scheme='http://www.blogger.com/atom/ns#' term='Flex'/><category scheme='http://www.blogger.com/atom/ns#' term='user interface'/><category scheme='http://www.blogger.com/atom/ns#' term='Apache'/><title type='text'>Az Apache Flex múltja, jelene, jövője</title><content type='html'>&lt;p&gt;Technológiák: Apache Flex 4.9.0&lt;/p&gt;

&lt;p&gt;Sokakat megosztó témáról fogok írni, méghozzá a felhasználói felület technológiákat illetően. Ezeken belül is az &lt;a href="http://flex.apache.org/"&gt;Apache Flex&lt;/a&gt; a vizsgálat tárgya. Próbálok elfogulatlan maradni, de bizonyos kérdésekben óhatatlanul szubjektív leszek. Akár egyetértesz, akár nem, kérlek oszd meg a véleményedet a megjegyzések között.&lt;/p&gt;

&lt;p&gt;A post apropója, hogy az utóbbi pár évben több projektben is használnom kellett az Flexet, valamint érdekelnek és folyamatosan nyomon követem, hogy felhasználói felületek fejlesztésére milyen technológiák vannak, melyek könnyen illeszthetőek a Java platformhoz. A Flex 4.9.0 új verziója 2012. decemberében jelent meg. Ez már a második kiadás, mely új fejlesztéseket is tartalmaz. Az Adobe 2011 novemberében jelentette be, hogy az Apache közösségnek adja a Flex SDK forráskódját. A 4.8.0 verzió még Apache incubator projektként jött ki, az Apache Licence v2 alatt, és nagy újdonságot még nem tartalmazott, főleg az átadás lett formalizálva. Az új verzió azonban már un. top level projectként jött ki. Sőt a cikk írásának pillanatában &lt;a href="https://twitter.com/ApacheFlex/status/296909455612858368"&gt;élesítették az új oldalt is&lt;/a&gt;.

&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;a href="http://1.bp.blogspot.com/-qsxYbODPhgM/UQ02tBS5oTI/AAAAAAAAKSk/mYfUevB4aYY/s1600/logo_01_fullcolor_wb.png" imageanchor="1" style="margin-left:1em; margin-right:1em"&gt;&lt;img border="0" height="190" width="320" src="http://1.bp.blogspot.com/-qsxYbODPhgM/UQ02tBS5oTI/AAAAAAAAKSk/mYfUevB4aYY/s320/logo_01_fullcolor_wb.png" /&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;A Flex világra jöttét a RIA (Rich Internet Application) segítette, azaz a cégek olyan eszközöket próbáltak előállítani, melyekkel a desktop alkalmazásokhoz hasonló gazdag felhasználói élményt nyújtó webes alkalmazásokat lehetett készíteni. A Flex eredetileg a Macromedia terméke volt, melyet az Adobe megvásárolt. A Flex 1.0 és 1.5 még komoly szerver oldali komponensekkel járt, de már jelen volt a megjelenítést leíró MXML XML alapú nyelv (Macromedia vagy Magic XML?) és a model és a controller komponensek megírására való ActionScript. A Flex 2 esetén azonban az SDK ingyenesen letölthető volt, csupán a fejlesztőeszközért, a Flex Builder-ért kellett fizetni (, mely Eclipse alapokra épült). Ebben a verzióban már nem volt szükség szerver oldali komponensre, lokálisan buildelhető volt az SWF fájl. A Flex 2-ben került bevezetésre az ActionScript 3 nyelv. A futtatókörnyezete a Flash Player volt.&lt;/p&gt;

&lt;p&gt;A Flex 3 SDK már Mozilla Public License alatt jött ki, és itt jelent meg az AIR (Adobe Integrated Runtime) támogatása. Az AIR nem más, mint egy futtatókörnyezet, mely képes a Flash, Flex alkalmazásokat különböző operációs rendszereken futtatni, desktop alkalmazásként. Sőt, mobilra is elérhető. Az AIR-be telepített alkalmazások persze már több jogosultsággal rendelkeznek, mint a böngészőben futó társaik, pl. elérik a fájlrendszert, nyomtatót, vágólapot, stb. Rendelkezik egy beépített adatbázis kezelővel (SQLite), valamint egy WebKit alapú böngésző komponenssel is. 2010 márciusában jött ki a Flex 4, melynek fejlesztőkörnyezete már Flash Builder néven futott. Fő újítása, hogy megpróbálták közelebb hozni a designert és a fejlesztőt, hogy az előbbi által készített munkák újrafelhasználhatóak legyenek. Lehetővé tette a komponensek egyszerűbb skinezhetőségét is (megjelentek a Spark komponensek). A Flash Builder Premium verziójában már unit tesztelésre alkalmas eszköz is megjelent. A Flex 4.5 újításai a különböző mobil eszközökre való fejlesztést tették lehetővé (Android, BlackBerry Tablet OS és Apple iOS).&lt;/p&gt;

&lt;p&gt;A Flex tehát élt és virágzott, mikor az Adobe sokak meglepetésére az Apache-nak adta a Flex SDK-t. Az ok talán a HTML 5 térnyerése volt, melyet az Adobe is jó iránynak tart. Valamint a Flash platformot akarják speciálisabb irányba vinni, úgymint a játékok (3d támogatás), valamint a prémium kategóriás videólejátszás. Az Adobe azonban nem temeti a Flexet, a nagyvállalati alkalmazások elsődleges platformjaként gondol rá. A nagyvállalati alkalmazásfejlesztésben az érvek a Flex mellett a következők:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Gazdag felhasználói felület építhető, mely nem mellesleg tehermentesíti a szerver oldalt.&lt;/li&gt;
&lt;li&gt;Gazdag komponenskészlet, és a komponensek újrafelhasználhatósága a magas fejlesztői produktivitásért.&lt;/li&gt;
&lt;li&gt;Jó beépített és 3rd party komponensek: pl. charting, data visualization, dashboard, OLAP, stb.&lt;/li&gt;
&lt;li&gt;A MVC modell és a binding-ok miatt rendkívül alkalmas data driven alkalmazások kifejlesztésére.&lt;/li&gt;
&lt;li&gt;Modularizáció.&lt;/li&gt;
&lt;li&gt;Nagyvállalati fejlesztésre alkalmas ActionScript nyelv és egységes futtatókörnyezet.&lt;/li&gt;
&lt;li&gt;Nagyvállalati technológiákhoz, mint Java EE, .NET könnyen illeszthető.&lt;/li&gt;
&lt;li&gt;Kifinomult unit és integrációs teszt eszközök.&lt;/li&gt;
&lt;li&gt;Parancssori alkalmazások (fordító, parancssorból futtatható teszt framework) segítségével könnyen illeszthető continuous integration környezetbe.&lt;/li&gt;
&lt;li&gt;Fejlett fejlesztőeszközök (IDE kódszerkesztésre, debug, profile, test, stb.).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Talán érdemes egy kicsit azon elmerengeni, hogy miért is jó az ActionScript nyelv, és a sokak által szidott Flash Player vagy AIR környezet. Az ActionScript egy ECMAScript 262 Edition 4 (ES4) szabványon alapuló imperatív, biztonságos, szigorúan típusos, objektumorientált nyelv. Ennek az ECMAScript változat fejlesztése megszakadt, mindenféle csatározások miatt. A mostani böngészők által értelmezett JavaScript amúgy az Edition 5-nek felel meg, és talán már dolgoznak a következő változaton (Harmony). Fontos megjegyezeni, hogy az Adobe aktívan részt vett az ECMAScript szabványok specifikálásában. Az ActionScript ActionScript Byte Code-ra fordul (ABC). A lefordított ActionScript és MXML vagy SWC állományba állítható össze (ShockWave Component) - mely később az SWF-be építhető, vagy közvetlenül SWF állományba (ShockWave File). Ezeket a formátumokat az Open Screen Project keretében tette az Adobe &lt;a href="http://www.adobe.com/devnet/swf.html"&gt;nyílt formátummá&lt;/a&gt;). Ide tartozik még az AMF (Action Message Format) is, mely bináris formátum az ActionScript objektumok hálózaton átvitelére. A fordításkor nyert bájtkód azonban visszafejthető (decompile), obfuszkátorok használata jelenthet részleges megoldást. Ezt a bájtkódot futtatja a Flash Playerbe, vagy az AIR-be épített virtuális gép. Érdekesség, hogy ezekben két virtuális gép van. Az AVM1 az ActionScript 2, míg az AVM2 az ActionScript 3 forrásból fordított bájtkódot futtatja. Az AVM2-ből az Adobe a virtuális gépet, és a benne lévő JIT (Just in time compile-ert) 2006-ban a Mozilla Foundation számára átadta (Tamarin), így nyílt forráskódú. Modern VM-ről beszélünk, hiszen a JIT-tel (, ami futás közben az adott platform gépi kódjára fordít) hatalmas sebességnövekedést értek el (és bevezetésekor a JavaScript interpreterekbe még nem volt ilyen), valamint komplex szemétgyűjtővel is rendelkezik. Érdekes még a nyelvi szintű XML támogatás is, mely szintén szabványon alapul: ECMA-357, azaz ECMAScript for XML (E4X). A virtuális gép használatával nem kell a platformok különbségeivel foglalkozni, a kód hordozható marad közöttük.&lt;/p&gt;

&lt;p&gt;Az Adobe &lt;a href="http://www.adobe.com/devnet/flex/whitepapers/roadmap.html"&gt;közzétette a terveit&lt;/a&gt; a Flex jövőjével kapcsolatban. Továbbra is teljes állású fejlesztőket biztosít a Flex továbbfejlesztésére. Valamint a Flash Buildert továbbra is kereskedelmi termékként árulja, és frissíti, hogy együttműködjön az Apache Flexszel . Az Adobe ígéri, hogy a további öt évben megőrzi a Flash Player és az AIR visszafele kompatibilitását, azaz hogy továbbra is lehessen ezen futtatókörnyezetekben Flex alkalmazást futtatni. Azonban új funkciókat már nem tesz ezekbe a környezetekbe a Flex támogatására.&lt;/p&gt;

&lt;p&gt;(Zárójelben jegyzem meg, hogy érdemes elolvasni az &lt;a href="http://www.adobe.com/devnet/flashplatform/whitepapers/roadmap.html"&gt;Adobe terveit a Flash platformmal kapcsolatban&lt;/a&gt;, mely magában foglalja a Flash Playert és az AIR-t. Természetesen mindkettőt viszi tovább a Windows platformon, és sok ellentétes állítással szemben Apple OS X-en is. Sőt, Adobe AIR alkalmazásokat Mac App Store-on keresztül is lehet értékesíteni. A Linux már kényesebb terület. Az Adobe együtt dolgozik a Google-lel a &lt;a href="https://developers.google.com/native-client/"&gt;PPAPI - kódnevén "Pepper"&lt;/a&gt; kialakításán, mely egy közbülső réteg a böngésző és a különböző pluginok között. A Flash Player azon verzióját, mely ezen az API-n alapszik, a Google a Chrome-ba beágyazva terjeszti. A Google ezen technológiával sokkal biztosabb működést tud elérni, hiszen a plugin összeomlása nem vonja magával a böngésző összeomlását is. Az Adobe Linuxon a Flash Playert más formában nem fejleszti. Sőt, az AIR Linux-os fejlesztésével is leáll. Természetesen a mobil az továbbra is célterület, de kizárólag az Adobe AIR környezetben gondolkozik, de az összes fontosabb platformon - Android, iOS, Blackberry. Az Android browser plugint befejezi, szintén csak a Chrome-os megoldás marad.)&lt;/p&gt; 

&lt;p&gt;Nézzük merre tart az Apache fejlesztés. Az Adobe a következőket adta át:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A Flex SDK, mely legfőképp az osztálykönyvtárakat és a fordítót tartalmazza, valamint további eszközöket.&lt;/li&gt;
&lt;li&gt;A Falcon következő generációs ActionScript fordítót.&lt;/li&gt;
&lt;li&gt;A Falcon JS kísérleti fordítót, mely nem Adobe futtatókörnyezetre, hanem JavaScriptre fordít.&lt;/li&gt;
&lt;li&gt;A Mustella funkcionális tesztelésre szolgáló keretrendszert.&lt;/li&gt;
&lt;li&gt;Dolgoznak a BlazeDS átadásán is. Jelenleg a &lt;a href="http://sourceforge.net/adobe/blazeds/wiki/Home/"&gt;SourceForge-on elérhető&lt;/a&gt; LGPL alatt. A BlazeDS egy Java szerver oldali technológia, mely lehetővé teszi a Java szerver oldal és a Flex kliens oldal kommunikációját. Olyan kiváló képességekkel rendelkezik, mint különböző csatornák használata (http, https), Java és ActionScript objektumok automatikus mappelése, publish&amp;subscribe kliensek között, szerver által kezdeményezett kommunikáció, JMS támogatás, &lt;a href="http://www.springsource.org/spring-flex"&gt;Spring integráció&lt;/a&gt;. Úgy kell elképzelni, mint egy Flex-ből indított Java metódushívást. A kommunikáció a már említett AMF-ben történik. A BlazeDS korábban a Adobe LiveCycle Data Services ES része volt.&lt;/li&gt;
&lt;li&gt;Text Layout Framework 3.0.33&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A fejlesztés mögött a &lt;a href="http://www.spoon.as/"&gt;Open Spoon Foundation&lt;/a&gt; szervezet is ott áll. A 4.8.0-ban tehát eltávolításra kerültek a trademark bejegyzések, migrálva lett az Adobe issue trackerje &lt;a href="https://issues.apache.org/jira/browse/FLEX"&gt;JIRA-ra&lt;/a&gt;. A 4.9.0 SDK-t már Java 7-tel is lehet fordítani, és jelentős számú hibajavítást tartalmaz. A közösség nagyon pörög. Kijött az új weboldal, a &lt;a href="http://flex.apache.org/installer.html"&gt;Apache Flex SDK Installer 2.0&lt;/a&gt;. A dokumentáció &lt;a href="https://cwiki.apache.org/confluence/display/FLEX/Apache+Flex+Wiki"&gt;Confluence Wikiben&lt;/a&gt; olvasható. Az újdonságokat a &lt;a href="http://blogs.apache.org/flex/"&gt;blogon&lt;/a&gt; lehet követni. A &lt;a href="http://flex.apache.org/community-mailinglists.html"&gt;levelezési lista&lt;/a&gt; is nagyon aktív, a fejlesztői listán csak decemberben több, mint 1800 levél ment.&lt;/p&gt;

&lt;p&gt;Tervek között szerepel még a &lt;a href="http://flex.apache.org/dev-sourcecode.html"&gt;forráskód&lt;/a&gt; Subversion-ről GIT-re átállítása, Maven plugin fejlesztése, dolgoznak a Falcon és Falcon JS fordítón, új komponensek készülnek és fejlődik a tesztelés is.&lt;/p&gt;

&lt;p&gt;Időközben az Adobe is kijött a Flash Builder 4.7.0-val, mely Apache Flex 4.8.0 támogatást tartalmaz. Azonban a kompatibilitási problémák miatt kivették a Design View-t, Data Centric Development Toolst és a Flash Catalist Workflowt.&lt;/p&gt;

&lt;p&gt;Milyen más kliens oldali technológiák vannak, és mikor érdemes az Apache Flexet választani ezek közül? Az Oracle nyomul a JavaFX-szel, a Microsoftnak van egy próbálkozása a Silverlighttal, valamint ott a legnagyobb kihívó, a HTML5/CSS3/JavaScript (innentől csak HTML5-ként hivatkozok rá). A JavaFX még nem elég kiforrott technológia, nagyon változik, bizonytalan még a jövője. A Microsoft felől is ellentmondó hírek jönnek a Silverlighttal kapcsolatban, valamint a Java platformba nehezebben beilleszthető lenne. Versenyben marad tehát a HTML5 irány.&lt;/p&gt;

&lt;p&gt;Abban az esetben, ha speciális követelményeket nem támasztó webes alkalmazásról beszélünk (pl. a legtöbb Interneten megjelenő startup), vagy a fejlesztők már otthonosan mozognak a HTML5 világában, a HTML5 lehet a megfelelő irány. Azonban a Java platformon nevelkedett fejlesztők számára, valamint főként intranetes nagyvállalati vagy a speciális igényekkel rendelkező alkalmazások fejlesztésére (pl. videó, adatvizualizáció) a Flex lehet a legjobb irány.&lt;/p&gt;

&lt;p&gt;A Java fejlesztők számára sokkal egyszerűbb a Flex irányába továbblépni, mint a JavaScript felé. A szigorú típusosság, az objektumorientáltság, a komponensek használata mind e mellett szól. Aki ráadásul esetleg Swingezett is, még egyszerűbb az átállás. Azon keretrendszerekben, melyek Java technológiára épülnek, de HTML5 interfészt generálnak, nem nagyon hiszek. Ott van egy átfordítás, ráadásul két teljesen más célra kifejlesztett technológia között (ne feledjük a HTML dokumentumleíró nyelv!). A HTTP protokoll szintén hatalmas gát, a kérés-válasz alapúságával, a szöveges formátumával, a késleltetéseivel. A HTML 5 nagyon friss, nem hiszem, hogy nagyvállalati alkalmazások fejlesztésére már jó irány. Az Adobe irányt sokan gyűlölik, nagyrészt indokolatlanul. Benne van ebben az, hogy ez volt az első platform, melyben rettentő idegesítő reklámokat lehetett készíteni. A Flash Player stabilitásával is voltak/vannak gondok (tegyük hozzá, hogy bármiben lehet erőforrás pazarló alkalmazásokat fejleszteni). Steve Jobs is célként tűzte ki a Flash eltörlését, melyben szintén sok követője akadt. De azért nézzük végig ezt a fenti történetet. Az Adobe feltűnően sokat tett a nyílt forráskódért rajongó közösségért, valamint a szabványosítási folyamatokért. A technológiai választások is mind logikusak, ha megnézzük, sokban hasonlítanak a Java platformhoz.&lt;/p&gt;

&lt;p&gt;Összegezve úgy gondolom, hogy Java alapú nagyvállalati alkalmazások felhasználói felületének fejlesztésére az egyik leghatékonyabb, legkézenfekvőbb irány a Flex. De igen, benne van, hogy pár év múlva vagy egy nagy közösség által használt elterjedt technológia lesz, de az is lehet, hogy végleg eltűnik. De ez nincs másképp más UI technológiával sem, a verseny még tart, és az Apache Flexnek még vannak esélyei.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/6577035106335169594/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2013/02/az-apache-flex-multja-jelene-jovoje.html#comment-form' title='6 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6577035106335169594'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6577035106335169594'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/02/az-apache-flex-multja-jelene-jovoje.html' title='Az Apache Flex múltja, jelene, jövője'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://1.bp.blogspot.com/-qsxYbODPhgM/UQ02tBS5oTI/AAAAAAAAKSk/mYfUevB4aYY/s72-c/logo_01_fullcolor_wb.png' height='72' width='72'/><thr:total>6</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7792248082197894811</id><published>2012-12-26T01:14:00.000+01:00</published><updated>2013-01-02T16:14:48.060+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='JSR'/><category scheme='http://www.blogger.com/atom/ns#' term='JSON'/><category scheme='http://www.blogger.com/atom/ns#' term='Java EE'/><title type='text'>Java API for JSON processing</title><content type='html'>&lt;p&gt;Úgy tűnik, az Oracle eléggé felpörgeti a Java EE 7 (&lt;a href="http://jcp.org/en/jsr/detail?id=342"&gt;JSR 342&lt;/a&gt;) körüli munkálatokat, sorra &lt;a href="https://blogs.oracle.com/jcp/entry/jsr_updates_java_ee_7"&gt;jönnek ki a hírek&lt;/a&gt; az előrehaladásról. Erre szükség is van, hiszen bár a határidőt &lt;a href="http://jcp.org/en/jsr/detail?id=342#updates"&gt;eltolták&lt;/a&gt; 2012 harmadik negyedévéről 2013 első negyedévére, még elég sok specifikáció Early Draftban van.&lt;/p&gt;

&lt;p&gt;A Java EE 7 újdonságai a JCACHE Java Temporary Caching API (&lt;a href="http://jcp.org/en/jsr/detail?id=107"&gt;JSR 107&lt;/a&gt;), Concurrency Utilities for Java EE (&lt;a href="http://jcp.org/en/jsr/detail?id=236"&gt;JSR 236&lt;/a&gt;), Java API for JSON Processing (&lt;a href="http://jcp.org/en/jsr/detail?id=353"&gt;JSR 353&lt;/a&gt;), Java API for WebSocket (&lt;a href="http://jcp.org/en/jsr/detail?id=356"&gt;JSR 356&lt;/a&gt;) , és a &lt;a href="http://jtechlog.blogspot.hu/2012/12/batch-application-for-java-platform-jsr.html"&gt;már említett&lt;/a&gt; Batch Applications for the Java Platform (&lt;a href="http://jcp.org/en/jsr/detail?id=236"&gt;JSR 352&lt;/a&gt;). A többi specifikáció nem új, hanem csak egy új verzió jön ki belőlük.&lt;/p&gt;

&lt;p&gt;A mostani post témája a Java API for JSON Processing (&lt;a href="http://jcp.org/en/jsr/detail?id=353"&gt;JSR 353&lt;/a&gt;), melynek Public Review-ja 2012. december 22-től zajlik. Az JSR oldalán a megszokottakkal ellentétben semmilyen specifikáció nem olvasható, helyette csak az API-t lehet letölteni. Szerencsére a frissebb JCP-nek megfelelően a szabvány fejlesztése átlátható, minden információ megtalálható a projekt &lt;a href="http://json-processing-spec.java.net/"&gt;honlapján&lt;/a&gt;. Az API-t a Batch Applications for the Java Platform szabványhoz hasonlóan szintén újra feltalálták, méghozzá Jitendra Kotamraju (Oracle) vezetésével, bár a támogatók között van a FasterXML cég, mely a &lt;a href="http://jackson.codehaus.org/"&gt;Jackson streaming JSON parser&lt;/a&gt;-ért felelős, valamint Doug Crockford, kinek &lt;a href="http://json.org/"&gt;nagy szerepe volt&lt;/a&gt; a JSON elterjesztésében. Mivel specifikációról beszélünk, az implementációk cserélhetőek lesznek (plug-in provider), és külön &lt;a href="http://java.net/projects/jsonp/"&gt;referencia implementációval&lt;/a&gt; is rendelkezik.&lt;/p&gt;

&lt;p&gt;A JSON kezelés elég gyakori manapság, ezért kívánják szabványosítani a Java berkein belül. Azonban a JSON kezelést két részre kell felbontani. Az egyik a feldolgozás és parse-olás, a másik a binding, mely Java objektumokat feleltet meg JSON struktúrákkal. (Ez a kettősség fennáll az XML esetén is, az előbbire a JAXP, az utóbbira a JAXB ad megoldást.) A Java API for JSON processing csak az előbbivel foglalkozik, ráadásul kétféle módon. Egyrészt áll egy Streaming API-ból, mely a StAX API-hoz hasonlít, valamint egy Object model-ből, mely a DOM API-ra hajaz. A Streaming API csak olvasásra használatos, és a JsonParser interfész a kulcs, ami egy pull parser, azaz mi tudjuk irányítani a feldolgozást, pl. a next() metódus segítségével. Az Object model esetén a JsonReader és JsonWriter használandó, mellyel írni és olvasni is tudunk, és a DOM-hoz hasonlóan a teljes reprezentáció felépül a memóriában. Modern API-hoz méltóan hemzseg tervezési mintáktól. Ritkán fogunk vele közvetlenül találkozni, hiszen általában valamilyen binding megoldást használunk, de amennyiben mégis natívan akarunk JSON-t feldolgozni, a Java EE 7-től kezdődően már szabványos módon tehetjük.&lt;/p&gt;

</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/7792248082197894811/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2012/12/java-api-for-json-processing.html#comment-form' title='4 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7792248082197894811'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7792248082197894811'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/12/java-api-for-json-processing.html' title='Java API for JSON processing'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>4</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-310150438882392547</id><published>2012-12-22T17:31:00.000+01:00</published><updated>2012-12-23T22:08:45.713+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='SOA'/><category scheme='http://www.blogger.com/atom/ns#' term='JAX-WS'/><category scheme='http://www.blogger.com/atom/ns#' term='vizsga'/><category scheme='http://www.blogger.com/atom/ns#' term='JAX-RS'/><category scheme='http://www.blogger.com/atom/ns#' term='könyv'/><title type='text'>Oracle Certified Expert, Java EE 6 Web Services Developer</title><content type='html'>&lt;p&gt;2012. december 12-én tettem le a &lt;a href="http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=458&amp;amp;get_params=p_track_id:JEE6WSD"&gt;Oracle Certified Expert, Java EE 6 Web Services Developer&lt;/a&gt; (1Z0-897) vizsgát. Alapvetően a webszolgáltatások (mind SOAP, mind REST) alapfogalmaira, és a JAX-WS 2.2 és JAX-RS 1.1 specifikációkra koncentrál. Ahogy már &lt;a href="http://jtechlog.blogspot.hu/2012/09/oracle-java-vizsgak.html"&gt;korábban írtam róla&lt;/a&gt;, ez a Oracle Certified Professional, Java (SE 5, SE 6, vagy SE 7) Programmer vizsgára épül, de még a régebbi SCJP-vel is letehető.&lt;/p&gt;

&lt;p&gt;A vizsgát a &lt;a href="http://training360.com/"&gt;Training360-nál&lt;/a&gt; tettem, ők intézték a regisztrációt is. A változatosság kedvéért ez most Pearson VUE-nál történik, küldik is utána szépen a tudnivalókat és a számlát levélben. A vizsga ára jelenleg 63 185 Ft. Hogy ne legyen olyan egyszerű, a Pearson VUE-nál is kell regisztrálni, utána az &lt;a href="http://www.certview.oracle.com/"&gt;Oracle CertView programjában&lt;/a&gt; is, ugyanis csak ott tudom az eredményt megtekinteni.&lt;/p&gt;

&lt;p&gt;A vizsga menete alapvetően változatlan, készítenek rólad egy fényképet, beülsz egy terembe hatodmagaddal egy gép elé minden nélkül, és sorban válaszolsz a feltett kérdésekre. Teszt jellegű, 60 kérdés van, 90 perc alatt kell megoldani, és 60%-ot kell elérni. Bejelölhetők a kérdések, hogy még vissza akarsz rájuk később térni, és bármikor kérheted, hogy vigyen végig újra a bejelölt, vagy az összes kérdéseken. A 90 perc elegendő, belefért, hogy nagyon alaposan végigmenjek az összes kérdésen, majd a bejelölteken, majd gyorsan még átnéztem újra az összeset (a végén már pár kimaradt). Annyi változott mostanság, hogy nem ott nyomtatják ki az eredményt előtted, hanem e-mailben kapsz egy értesítést, és egy PDF-et tudsz letölteni a CertView oldaláról. Gyakorlatilag amint kijöttem, már kaptam az értesítést, annak ellenére, hogy 30 perc türelmet kértek.&lt;/p&gt;

&lt;p&gt;A vizsgára felkészülni az SCJP-hez képest sokkal nehezebb volt, hiszen az utóbbihoz rettentő mennyiségű anyag, mock exam, könyv áll rendelkezésre, itt gyakorlatilag csak egy &lt;a href="http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=609&amp;amp;p_org_id=8&amp;amp;lang=HU&amp;amp;get_params=dc:D65185GC10,p_preview:N"&gt;Oracle tanfolyam&lt;/a&gt; áll rendelkezésre, aminek nem is teljesen ugyanaz a tematikája, és el sem végeztem. Az eredményben azonban látható, hogy mely témakörben hány kérdést tettek fel, számomra kicsit meglepő:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Legjobb gyakorlatok: 9 kérdés&lt;/li&gt;
&lt;li&gt;RESTful webszolgáltatások: 5 kérdés&lt;/li&gt;
&lt;li&gt;RESTful webszolgáltatások megvalósítása EJB-kkel: 3 kérdés&lt;/li&gt;
&lt;li&gt;SOAP webszolgáltatások EJB-kkel: 4 kérdés&lt;/li&gt;
&lt;li&gt;SOAP webszolgáltatások: 4 kérdés&lt;/li&gt;
&lt;li&gt;Alacsony szintű SOAP webszolgáltatások (Dispatcher): 4 kérdés&lt;/li&gt;
&lt;li&gt;Kliensek implementálása: 4 kérdés&lt;/li&gt;
&lt;li&gt;Java EE webszolgáltatások konfigurációja, biztonság beállítása, telepítése: 8 kérdés&lt;/li&gt;
&lt;li&gt;SOAP üzenetszintű biztonság: 7 kérdés&lt;/li&gt;
&lt;li&gt;MTOM/MIME: 7 kérdés&lt;/li&gt;
&lt;li&gt;WS-Addressing: 7 kérdés&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A DOM, SAX, StaX technológiákról csak koncepcionális szinten esett szó, mikor melyiket kell használni, tudjunk a StaX pull parser-jéről. JAX-B kérdésre nem emlékszem. Számomra az volt meglepő, hogy érzésre rengeteg biztonsággal, MTOM-mal és WS-Addressing-gel kapcsolatos kérdés volt, amit ráadásul a különböző könyvek nem jól tárgyalnak. Övön alulinak éreztem a Jersey kliens használatára vonatkozó kérdést is, hiszen az meg nem a szabvány része.&lt;/p&gt;

&lt;p&gt;Felkészülésként mindenképpen érdemes felkeresni a JavaRanch &lt;a href="https://www.coderanch.com/how-to/java/ScdjwsLinks"&gt;ide vonatkozó oldalát&lt;/a&gt;, valamint Mikalai Zaikin &lt;a href="http://java.boot.by/ocewsd6-guide/"&gt;felkészítő anyagát&lt;/a&gt;, ami kicsit hiányos ugyan, de megéri elolvasni. Kereskedelmi felkészítő anyaga az EPractize-nak és a Whizlabs-nak van, én egyiket sem használtam.&lt;/p&gt;

&lt;p&gt;A következő könyvekből készültem: &lt;a href="http://jtechlog.blogspot.hu/2012/08/soa-using-java-web-services.html"&gt;már írtam&lt;/a&gt; Mark D. Hansen: SOA Using Java Web Services (Prentice Hall) könyvéről, mely egy jó kiinduló alap, bár talán a vizsgához nem elég mély. SOAP fronton ezen kívül a Martin Kalin: Java Web Services Up and Running (O'Reilly) könyvből készültem. Ez utóbbi egy rendkívül jó könyv, és bár sokan ezt mondják magukról, ez tényleg gyakorlatias. Már az elején elmondja, hogy hogyan kell debugolni, hogy lehet a dróton átmenő üzenettartalmaz kiíratni, amit még egy könyvben sem láttam ilyen részletesen kifejtve, különböző operációs rendszereken. A felépítése is ilyen, szóval nem a specifikáció alapján, hanem egy természetes íve van, ahogy kellenek az újabb és újabb feature-ök. A mintapéldák sem voltak annyira mondvacsináltak. Egyedül az nem tetszett, ahogy mind a két könyv a REST-ről beszél, feltehetőleg akkr még nem volt ekkora hype, így egyrészt keveset írnak róla, másrészt a JAX-WS specifikációval próbálják megugrani, ami erre alkalmatlan, pláne a JAX-RS-hez hasonlítva. Az utóbbi könyv említi ugyan a Jersey-t, de nagyon felületesen, ennél a vizsgára jóval több kell.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;a href="http://2.bp.blogspot.com/-jYtpOSmP_R8/UNYflaj0amI/AAAAAAAAJ4I/PC-wK8B2_tU/s1600/up_and_running.jpg" imageanchor="1" style="margin-left:1em; margin-right:1em"&gt;&lt;img border="0" height="320" width="244" src="http://2.bp.blogspot.com/-jYtpOSmP_R8/UNYflaj0amI/AAAAAAAAJ4I/PC-wK8B2_tU/s320/up_and_running.jpg" /&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;Ezen kívül a következő dokumentációkat érdemes elolvasni. A &lt;a href="http://metro.java.net/guide/ch01.html"&gt;Metro projekt dokumentációját&lt;/a&gt; mindenképp a security, MTOM, WSIT, WS-Addressing fejezetek miatt, máshol erre nem találunk jó dokumentációt. A &lt;a href="http://docs.oracle.com/javaee/6/tutorial/doc/bnayk.html"&gt;Java EE 6 tutorial&lt;/a&gt; ide vonatkozó fejezete is elég rövid ahhoz, hogy érdemes legyen átlapozni. A SAAJ-ról ugyan nem ír, de az &lt;a href="http://docs.oracle.com/javaee/5/tutorial/doc/bnbhf.html"&gt;előző verzió igen&lt;/a&gt;. Amennyiben nem tiszta, hogy mi a különbség az RPC/Literal, Document/Literal, Wrapped Document/Literal között, &lt;a href="http://www.ibm.com/developerworks/webservices/library/ws-whichwsdl/"&gt;itt egy gyakran idézett cikk&lt;/a&gt;. &lt;a href="https://blogs.oracle.com/artf/entry/using_jax_ws_2_1"&gt;Ez a bejegyzés&lt;/a&gt; pedig a WS-Addressing használatáról ír a JAX-WS 2.1-ben.&lt;/p&gt;

&lt;p&gt;A REST témával kapcsolatban a Bill Burke: RESTful Java with JAX-RS (O'Reilly) könyvet ajánlom. Kötelező olvasmány mindenkinek, aki JAX-RS-t fejleszt. Két részből áll. Az egyik leírja a teljes JAX-RS szabványt, 14 fejezetben, példákkal együtt, a másik pedig egy workbook, gyakorlatilag egy tutorial, 10 fejezeten keresztül. Olyan dolgokat mutatott be, melyek létezéséről nem is tudtam a JAX-RS-ben, mindezt példás részletességgel.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;a href="http://4.bp.blogspot.com/-Rh6fHLiDF-k/UNYftpuVQ_I/AAAAAAAAJ4U/DzKhJEA5208/s1600/restful_java.jpg" imageanchor="1" style="margin-left:1em; margin-right:1em"&gt;&lt;img border="0" height="320" width="244" src="http://4.bp.blogspot.com/-Rh6fHLiDF-k/UNYftpuVQ_I/AAAAAAAAJ4U/DzKhJEA5208/s320/restful_java.jpg" /&gt;&lt;/a&gt;&lt;/div&gt;



&lt;p&gt;Még egy kis magyarázkodás, hogy mi értelme is volt letenni a vizsgát, hiszen közvetlen előnye nincs. Egyrészt én oktatom ezt az anyagot, ezért kapóra jött, hogy egyúttal a vizsgát is leteszem. Másrészt nem árt egy kis vizsgadrukk, az ember munkakörnyezetben már ritkán kerül olyan helyzetbe, hogy egy nagyobb átfogó témakört ilyen alaposan fel kelljen dolgoznia, megtanulnia úgy, hogy még számonkérés is van, ezt a rutint sem szeretném elveszíteni. Persze a papírgyűjtés is motivál, újabb &lt;a href="http://en.wikipedia.org/wiki/Achievement_%28video_gaming%29"&gt;achivement&lt;/a&gt;. Ha a munkahely meg támogatja, akár a vizsgadíj megfizetésével, akár felkészülési idővel, egyszerűen bűn kihagyni.&lt;/p&gt;

&lt;p&gt;A további rész azoknak hasznos, akik vagy komolyan foglalkoznak a témával, vagy le akarják tenni a vizsgát. Megpróbáltam minden fogalmat összeszedni, nekem volt egy vázlat. Talán egy öntesztnek sem utolsó, hogy tényleg tisztában vagy-e mindennel.&lt;/p&gt;

&lt;p&gt;SOAP webszolgáltatások JAX-WS-sel&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Java EE 6 2009. dec. 10-én jött ki: JAX-WS 2.2 (JSR 224), JAX-RS 1.1, Web Services Metadata for the Java Platform 2.0 (JSR 181), SOAP with Attachments API for Java (SAAJ) 1.3&lt;/li&gt;
&lt;li&gt;MEP: Message Exchange Pattern, típusai: request/response, oneway, async callback, async polling&lt;/li&gt;
&lt;li&gt;SOAP: 1.2-től kezdve nem rövidítés&lt;/li&gt;
&lt;li&gt;WSDL felépítése: definitions, types: adattípusok definíciója, message: üzenetek defincíciója, message part-(ok)ból áll, portType: operációk halmaza, binding: protokoll és adatformátum specifikációk, pl. soap, ezen belül operáció, input-tal, output-tal, majd service, port: portType (interfész) és binding (implementáció összekapcsolása)&lt;/li&gt;
&lt;li&gt;WS-I: csak RPC/literal vagy document, de az utóbbinál body-n belül csak max egy elem lehet&lt;/li&gt;
&lt;li&gt;WS-I Basic Profile 1.1 egy dokumentum, mely a SOAP 1.1 és WSDL 1.1 szabványokat &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Style és encoding&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RPC/Literal
&lt;ul&gt;
&lt;li&gt;Paramétereket tartalmaz a híváshoz&lt;/li&gt;
&lt;li&gt;Mindig wrapped&lt;/li&gt;
&lt;li&gt;Wrapper element az operation neve&lt;/li&gt;
&lt;li&gt;Állhat több part-ból az input message&lt;/li&gt;
&lt;li&gt;Part mindig type attribútummal van deklarálva (szemben a document element-tel)&lt;/li&gt;
&lt;li&gt;csak a part-ok vannak a types részben leírva&lt;/li&gt;
&lt;li&gt;Part-nak megfelelő elemek névtér nélkül&lt;/li&gt;
&lt;li&gt;Válasz neve nem deklarált&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Document/Literal
&lt;ul&gt;
&lt;li&gt;Dokumentumot tartalmaz a híváshoz&lt;/li&gt;
&lt;li&gt;Lehet több part&lt;/li&gt;
&lt;li&gt;Part mindig element-tel van megadva&lt;/li&gt;
&lt;li&gt;A teljes body tartama a sémában van definiálva&lt;/li&gt;
&lt;li&gt;Operation neve nem szerepel a soap üzenetben&lt;/li&gt;
&lt;li&gt;Part-ok közvetlenül a body-ban vannak, nincs wrapper, névtérrel ellátottak&lt;/li&gt;
&lt;li&gt;Response ugyanígy&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
Document/Literal wrapped
&lt;ul&gt;
&lt;li&gt;input message-nek csak egy gyereke van, a wrapper&lt;/li&gt;
&lt;li&gt;element-ként leírva, sémával meghatározva&lt;/li&gt;
&lt;li&gt;konvenció szerint operation neve = wrapper neve&lt;/li&gt;
&lt;li&gt;ugyanígy a response-nál is, konvenció szerint a wrapper neve az operation neve + "Response"&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JAX-WS&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SEI&lt;/li&gt;
&lt;li&gt;Kötelező: SIB&lt;/li&gt;
&lt;li&gt;Nem muszáj a SIB-nek implementálnia a SEI-t, megadható az annotációban is, csak nem biztonságos -&gt; futás idejű hiba&lt;/li&gt;
&lt;li&gt;Ha annotációban sincs megadva, implicit SEI&lt;/li&gt;
&lt;li&gt;Opcionális: SEI, WSDL, webservices.xml&lt;/li&gt;
&lt;li&gt;Osztály, public, nem lehet final vagy abstract&lt;/li&gt;
&lt;li&gt;Default public constructor-nak lennie kell, nem lehet finalize, nem tárolhat állapotot&lt;/li&gt;
&lt;li&gt;Metódusai nem lehetnek static vagy final&lt;/li&gt;
&lt;li&gt;Wsgen, wsimport&lt;/li&gt;
&lt;li&gt;A JAX-WS 2.1.6-tól változott az implicit esetén, több esetben lesz kiajánlva a metódus&lt;/li&gt;
&lt;li&gt;Explicit sei esetén az összes publikus metódust kiajánlja, a WebMethod csak további konfigurációkra való&lt;/li&gt;
&lt;li&gt;A wsimport generál: SEI, service, fault-hoz tartozó osztályt, ha kell; paraméter osztályokat, ha kell; Async Reponse Bean, ha kell&lt;/li&gt;
&lt;li&gt;external/embedded binding declaration: sei, exception, service neve, package neve, wrapper style&lt;/li&gt;
&lt;li&gt;JAXB: sémában annotation/appinfo tag-en belül&lt;/li&gt;
&lt;li&gt;JAX-WS kliens: Service.create(url, qname); service.getPort(SEI.class);&lt;/li&gt;
&lt;li&gt;Deploy JDK-ban: Endpoint.publish, egyszálú&lt;/li&gt;
&lt;li&gt;Default: Wrapped Document/Literal, RPC: @SOAPBinding(style = Style.RPC)&lt;/li&gt;
&lt;li&gt;@WebService annotáció targetNamespace attribútuma adja meg a névteret, amúgy a package alapján&lt;/li&gt;
&lt;li&gt;@RequestWrapper, @ResponseWrapper&lt;/li&gt;
&lt;li&gt;WebParam.Mode.OUT, Holder&lt;/li&gt;
&lt;li&gt;Ne wrapper-ek legyenek: customized binding, enableWrapperStyle&lt;/li&gt;
&lt;li&gt;@SoapBinding(parameterStyle = SOAPBinding.ParameterStyle.BARE)&lt;/li&gt;
&lt;li&gt;Ha aszinkron klienst akarunk, akkor ismét customized binding: enableAsyncMapping&lt;/li&gt;
&lt;li&gt;AsyncHandler&lt;/li&gt;
&lt;li&gt;Response&lt;/li&gt;
&lt;li&gt;wsimport -extension: SOAP 1.2 esetén&lt;/li&gt;
&lt;li&gt;Overload-olt metódusok esetén problémás&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dynamic Invocation Interface (DII)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dispatcher, Provider&lt;/li&gt;
&lt;li&gt;@WebServiceProvider&lt;/li&gt;
&lt;li&gt;public Source invoke(Source)&lt;/li&gt;
&lt;li&gt;@ServiceMode: PAYLOAD - csak a tartalom, MESSAGE - az egész http kérés, fejlécestől&lt;/li&gt;
&lt;li&gt;@BindingType() - http&lt;/li&gt;
&lt;li&gt;Dispatch - Service.createDispatch&lt;/li&gt;
&lt;li&gt;Https: HttpsURLConnection, HttpsServer&lt;/li&gt;
&lt;li&gt;@WebService-t felismeri a Glassfish, de a @WebServiceProvider-t nem&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Handler&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Chain of responsibility tervezési minta&lt;/li&gt;
&lt;li&gt;Logical handler: Source, JAXB - protokollfüggetlen - csak a payload-hoz tud hozzáférni&lt;/li&gt;
&lt;li&gt;SOAP/protocol handler: SOAP, SAAJ, hozzáfér a teljes envelope-hoz&lt;/li&gt;
&lt;li&gt;Kliens oldalon a handler chain-ben nem csak a konfig sorrend dönt, hanem előbb futnak le a logical handler-ek, és csak utána a soap handler-ek&lt;/li&gt;
&lt;li&gt;Programozottan handler hozzáadása: HandlerResolver&lt;/li&gt;
&lt;li&gt;SOAPFaultException&lt;/li&gt;
&lt;li&gt;SOAP 1.2: BindingType annotáció&lt;/li&gt;
&lt;li&gt;SOAP 1.2: mustUnderstand&lt;/li&gt;
&lt;li&gt;Szerver oldalon: WebServiceContext.getMessageContext -&gt; hozzáférés a context-hez (map), és abból a http header-ökhöz&lt;/li&gt;
&lt;li&gt;Kliens oldalon: a port BindingProvider-ré cast-olható, van getRequestContext metódusa&lt;/li&gt;
&lt;li&gt;Dependency injection: WebServiceContext&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MTOM&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MTOM: XSD, @BindingType, publikálásnál: ((SOAPBinding) endpoint.getBinding()).setMTOMEnabled(true); &lt;/li&gt;
&lt;li&gt;Kliens: activation.DataHandler&lt;/li&gt;
&lt;li&gt;Kliens file küldés: ((SOAPBinding)((BindingProvider) port).getBinding()).setMTOMEnabled(true);&lt;/li&gt;
&lt;li&gt;@MTOM annotáció&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;WSIT&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Metro: azon része mely az MS-sel való együttműködés: WSIT - Webservice Interoperability Technologies - Security, Reliability, Transaction, bootstrapping, optimalization (régen project Tango)&lt;/li&gt;
&lt;li&gt;Bootstrapping: WS-MetadataExchange&lt;/li&gt;
&lt;li&gt;Reliable messaging: egyszeri, pontosan egyszeri üzenettovábbítás - acknowledge-al, sorrend (opcionálisan bekapcsolható)&lt;/li&gt;
&lt;li&gt;Atomic: AtomicTransaction, Coordination&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Security&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;XML and WebServices Security Project (XWSS)&lt;/li&gt;
&lt;li&gt;WS-Security: message content integrity and confidentality, Prompter, Verifier implements CallbackHandler&lt;/li&gt;
&lt;li&gt;WS-Security (x) felett: WS-Policy felette WS-SecurityPolicy (x), WS-PolicyAttachment (x), WS-Trust (x), WS-Privacy, afelett WS-Secure Conversation (x), WS-Federation, WS-Authorization&lt;/li&gt;
&lt;li&gt;WS-Secure conversation - shared security context, több kérés/válasz esetén nem kell mindig az összes security információt küldeni - new security token type&lt;/li&gt;
&lt;li&gt;Trust: security token&lt;/li&gt;
&lt;li&gt;SecurityPolicy, mely a Policy-ra épül: security követelmények és tulajdonságok leírására&lt;/li&gt;
&lt;li&gt;WS-Trust: security token, Security Token Service - STS, az STS SAML tokent küld a kliensnek&lt;/li&gt;
&lt;li&gt;Signing and encription: WSDL-be plusz tag-ek&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;WS-Addressing&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;WS-Addressing: protokollfüggetlen címzés&lt;/li&gt;
&lt;li&gt;Kettő spec van: W3C WS-Addressing, Member Submission WS-Addressing, a Metro mindkettőt támogatja&lt;/li&gt;
&lt;li&gt;Standard tag-ek: To, From, ReplyTo, FaultTo, MessageID, Action, RealtesTo&lt;/li&gt;
&lt;li&gt;Végpont referencia: EPR&lt;/li&gt;
&lt;li&gt;MI header: message information&lt;/li&gt;
&lt;li&gt;Message Addressing Properties (MAPs) &lt;/li&gt;
&lt;li&gt;Anonymous uri: nem címezhető, pl. request/response request párja&lt;/li&gt;
&lt;li&gt;Annotáció: @javax.xml.ws.soap.Addressing, @Action, @FaultAction&lt;/li&gt;
&lt;li&gt;WSDL-ben: wsdl11:port vagy wsdl11:binding tag-be új tag&lt;/li&gt;
&lt;li&gt;Kliens oldal: WebServiceFeature -&gt; AddressingFeature&lt;/li&gt;
&lt;li&gt;BindingProvider.SOAPACTION_URI_PROPERTY-t kell kliens oldalon beállítani&lt;/li&gt;
&lt;li&gt;Két paraméter: enabled, required&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SAAJ&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Új SOAPMessage létrehozásánál létrehozza a Part-ot, Envelope-ot és Header-t&lt;/li&gt;
&lt;li&gt;Attachment Part, mime headers, Content&lt;/li&gt;
&lt;li&gt;SOAPConnection&lt;/li&gt;
&lt;li&gt;Attachment: Content-Type, -Id, -Location&lt;/li&gt;
&lt;li&gt;Attachment setContent: String, stream, javax.xml.transform.Source vagy javax.activation.DataHandler&lt;/li&gt;
&lt;li&gt;A SOAP 1.1 specifikáció közvetlenül a header-ben csak a következő attribútumokat engedi: actor and mustUnderstand&lt;/li&gt;
&lt;li&gt;A SOAP 1.2 spec. ellenben: role (actor új neve), mustUnderstand, és relay&lt;/li&gt;
&lt;li&gt;Ha van SOAPFault a Body-n belül, nem lehet más&lt;/li&gt;
&lt;li&gt;code, string kötelező, lehet actor, SOAP 1.2-nél code, role, reasonText (locale-lal)&lt;/li&gt;
&lt;li&gt;A kódok QName-ek - SOAP specifikáció definiálja&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;RESTful&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Roy Fielding: Architectural Styles and the Design of Network-based Software Architectures, 2000 (HTTP specifikáció egyik írója), Apache Software Foundation egyik alapítója&lt;/li&gt;
&lt;li&gt;Egyedileg címezhető erőforrások: resource, URI&lt;/li&gt;
&lt;li&gt;Uniform, constrained interface for manipulate resources&lt;/li&gt;
&lt;li&gt;Representation-oriented, content negotiation&lt;/li&gt;
&lt;li&gt;Stateless&lt;/li&gt;
&lt;li&gt;Hypermedia As The Engine Of Application State (HATEOAS): embedded links&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JAX-RS&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JAX-RS 1.1 (JSR 311)&lt;/li&gt;
&lt;li&gt;Referencia implementáció: Jersey&lt;/li&gt;
&lt;li&gt;POJO, annotation alapú&lt;/li&gt;
&lt;li&gt;Annotációk öröklése: super-class előnyt élvez az interfészen lévővel szemben&lt;/li&gt;
&lt;li&gt;Ha az implementáción van annotáció, akkor a többi helyen lévő annotációt nem veszi figyelembe&lt;/li&gt;
&lt;li&gt;Application osztály, kiterjeszteni kell, osztályokat ad vissza, melyet a provider példányosít, illetve példányokat, melyeket singleton-ként használ. Mindkettőn elvégzi az injection-t. &lt;/li&gt;
&lt;li&gt;Application erőforrásokat (@Path annotációval ellátott osztályokat), és provider-eket adhat vissza&lt;/li&gt;
&lt;li&gt;A JAX-RS provider cserélhető, erre van a RuntimeDelegate, saját alkalmazásban nem kell használni&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Provider&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A provider, melyen rajta van a @Provider annotáció, és valamilyen JAX-WS interfészt implementál&lt;/li&gt;
&lt;li&gt;Kell minimum egy publikus konstruktor, akár paraméterezett. Mindig a legtöbb paraméterrel rendelkező konstruktort választja&lt;/li&gt;
&lt;li&gt;Provider pl. a MessageBodyReader, Writer&lt;/li&gt;
&lt;li&gt;Provider pl. a ContextResolver, mellyel saját Context, pl. JAXBContext példányosítható&lt;/li&gt;
&lt;li&gt;ExceptionMapper-ek is provider-ek&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Context&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Per request esetén nincs párhuzamossági probléma&lt;/li&gt;
&lt;li&gt;Per request esetén attribútum is injektálható&lt;/li&gt;
&lt;li&gt;Konstruktor paraméter mindig injektálható&lt;/li&gt;
&lt;li&gt;A három első olvasó, aki ide eljut, vendégem egy sörre a következő JUM-on. Dobj egy e-mailt!&lt;/li&gt;
&lt;li&gt;@Context annotációval injektálunk&lt;/li&gt;
&lt;li&gt;A következőkbe injektálhatók: resource, provider, Application leszármazott&lt;/li&gt;
&lt;li&gt;A következők injektálhatók: Application (önmagába nem), UriInfo, HttpHeaders, Request, SecurityContext, Providers&lt;/li&gt;
&lt;li&gt;A Providers-en keresztül hozzá tudunk férni a MessageBodyReader, Writer-ekhez, ContextResolver-hez, ExceptionMapper-hez, azaz amit a Provider annotációval elláthatunk&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Erőforrások&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@Path&lt;/li&gt;
&lt;li&gt;Root resource class: vagy @Path-tal annotált, vagy van legalább egy Path-tal vagy request method designatorral (@GET, stb.) annotált metódusa&lt;/li&gt;
&lt;li&gt;Request method: request method designator-ral annotált metódus&lt;/li&gt;
&lt;li&gt;Egy metóduson csak egy @GET, @PUT, stb. annotáció lehet, különben deployment error&lt;/li&gt;
&lt;li&gt;A @HttpMethod annotáció egy metaannotáció, mely rajta van a @GET, stb. metódusokon&lt;/li&gt;
&lt;li&gt;HEAD kérés esetén először @HEAD metódust keres, ha nincs, akkor a @GET-et hívja, csak nem ad Response-t&lt;/li&gt;
&lt;li&gt;OPTIONS kérés először @OPTIONS metódust keres, ha nincs választ generál az annotációk alapján -&gt; WADL&lt;/li&gt;
&lt;li&gt;@ApplicationPath globális url megadásra, ehhez jön hozzá a resource-onkénti&lt;/li&gt;
&lt;li&gt;A /{foo} path-ra nem illeszkedik a /foo/bar, de a /{foo: .+} path-ra igen (lásd perjelek értelmezése)&lt;/li&gt;
&lt;li&gt;Amennyiben egy url több path-ra is illeszkedik, a provider a legpontosabbra próbálja illeszteni. Van egy nem minden esetet lefedő precedencia szabály, mely általában jó. Először a literálok számát nézi, majd a template-ek számát, majd a reguláris kifejezésekkel ellátott template-ek számát.&lt;/li&gt;
&lt;li&gt;Nem minden karakter megengedett az uri-ban, valamint van, aminek speciális jelentése van. A többit escape-elni kell. A @Path annotációban nem kötelező escape-elni.&lt;/li&gt;
&lt;li&gt;A subresource olyan POJO, melyhez egy resource POJO továbbítja a kiszolgálást. Nem kell rá @Path annotáció, hiszen nem a root uri-hoz képest figyel, valamint nem kell az Application osztályban regisztrálni.&lt;/li&gt;
&lt;li&gt;Ha az illeszkedő path-ban két mátrix paraméter ugyanazon a néven szerepel, akkor PathSegment-et kell használni, mert nem egyértelmű a @MatrixParam injection. @PathParam List &amp;lt;PathSegment&amp;gt; formában&lt;/li&gt;
&lt;li&gt;@FormParam esetén implicit dekódolás van, @Consumes("application/x-www-form-urlencoded")&lt;/li&gt;
&lt;li&gt;Primitív típus, String mappelésén kívül minden olyan típust mappel, melynek van String paramétert váró konstruktora, vagy statikus valueOf metódusa String paraméterrel&lt;/li&gt;
&lt;li&gt;Van automatikus collection konverzió&lt;/li&gt;
&lt;li&gt;@HeaderParam, @CookieParam mappelési hiba esetén 400-as hiba, amúgy 404&lt;/li&gt;
&lt;li&gt;@DefaultValue annotációval adhatjuk meg az alapértelmezett értékeket&lt;/li&gt;
&lt;li&gt;@Encoded annotációval adhatjuk meg, hogy mi akarjuk dekódolni, tehát azt kapjuk, amit a HTTP ad, dekódolás nélkül&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Content Handlers&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A következő típusokat standard MessageBodyReader-ek és Writer-ek kezelik, ezek entity provider-ek&lt;/li&gt;
&lt;li&gt;StreamingInput, StreamingOutput - callback model, általában performancia okokból jobb, ha a provider hív vissza (pl. lehet, hogy új szálon), valamint illeszkedik az aszinkron modellbe.&lt;/li&gt;
&lt;li&gt;InputStream, Reader&lt;/li&gt;
&lt;li&gt;File, byte[], String, char[] is használható input/output paraméterként&lt;/li&gt;
&lt;li&gt;Activation DataSource is kezelendő&lt;/li&gt;
&lt;li&gt;MultivaluedMap&amp;lt;String, String&amp;gt; form értékekhez, dekódolja a provider, használható az @Encoded annotáció&lt;/li&gt;
&lt;li&gt;javax.xml.transform.Source, a Document-et nem definiálja a specifikáció&lt;/li&gt;
&lt;li&gt;JAXB: XmlRootElement, XmlType annotációval jelölt osztályok és JAXBElement példányba burkolt objektumok leképzését is támogatja&lt;/li&gt;
&lt;li&gt;JAXBContext-et tud példányosítani, de felüldefiniálhatjuk ContextResolver&amp;lt;JAXBContext&amp;gt;-ben (pluggable factories), amit az Application-ben definiálhatunk&lt;/li&gt;
&lt;li&gt;JSON-höz nem kell speciális kezelés, egyedül a mime type-ot kell application/json-ként jelölni&lt;/li&gt;
&lt;li&gt;Saját marshallinghoz: MessageBodyWriter, sorbarendezés, legjobb illesztés a mime type-ra, @Provider annotáció, @Produces annotáció&lt;/li&gt;
&lt;li&gt;MessageBodyReader, @Provider, @Consumes annotáció&lt;/li&gt;
&lt;li&gt;isWritable, isReadable - a paraméterként adott objektumot tudja-e kezelni (+generikus típus, annotáció, media type)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Response code, response, exception&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ResponseBuilder-rel előállítható a Response&lt;/li&gt;
&lt;li&gt;WebApplicationException saját kivétel&lt;/li&gt;
&lt;li&gt;Megadható benne saját Response&lt;/li&gt;
&lt;li&gt;Error vagy unchecked exception megy a konténer felé, a többit viszont be kell csomagolni, és úgy megy a konténer felé&lt;/li&gt;
&lt;li&gt;ExceptionMapper a kivételek kezelésére, generikussal paraméterezhető, mindig a kivételre legjobban illeszkedőt keresi&lt;/li&gt;
&lt;li&gt;ExceptionMapper-t a @Provider annotációval kell ellátni&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Content Negotiation&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@Produces, @Consumes, tehető resource-ra, metódusra, és a content handler-re is&lt;/li&gt;
&lt;li&gt;Variant: media type, language, encoding&lt;/li&gt;
&lt;li&gt;VariantListBuilder: builder&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HATEOAS&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UriBuilder URI-k összeállítására, template paraméter is használható&lt;/li&gt;
&lt;li&gt;Az UriBuilder egy resource osztályt kapva parmaéterként is képes összeállítani az URI-t&lt;/li&gt;
&lt;li&gt;UriInfo-val is létrehozható UriBuilder, ekkor adott a séma, szerver, port, context&lt;/li&gt;
&lt;li&gt;Cache-elés a CacheControl osztályon keresztül, nincs rá annotáció&lt;/li&gt;
&lt;li&gt;EntityTag osztály az ETag kezelésére&lt;/li&gt;
&lt;li&gt;Szerver oldalon kezelni a If-Modified-Since vagy ETag header-eket: Request interfész (injektálható) evaluatePreconditions metódusai.&lt;/li&gt;
&lt;li&gt;Nem csak cache-elésre használható, hanem konkurrencia kezelésre is, hogy csak akkor történjen a módosítás, ha nem változott az erőforrás&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Deploy&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Deploy: JAX-RS unaware konténerben egy servlet-et, és annak int-param-ként kell megadni az Application-t, aware konténerben az Application tehető közvetlenül a web.xml-be. Java EE 6-nál nem kell semmi az xml-be, classpath-t bejárja, és nézi az annotációkat.&lt;/li&gt;
&lt;li&gt;@Context annotációval a ServletContext és a ServletConfig injektálható&lt;/li&gt;
&lt;li&gt;Java EE 6 konténerben a szokásos dolgok injektálhatók: @Resource,  @PersistenceContext,  @PersistenceUnit, és  @EJB, támogatja Java EE 6-ban a JSR-299 szabványt.&lt;/li&gt;
&lt;li&gt;Java EE konténer által biztosított autentikáció és authorizáció adott. Programozott esetben a SecurityContext @Context annotációval injektálható&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Kliens&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Szabvány nem szól róla&lt;/li&gt;
&lt;li&gt;Legegyszerűbb esetben HttpURLConnection&lt;/li&gt;
&lt;li&gt;setDoOutput - request body-ba is lehet írni&lt;/li&gt;
&lt;li&gt;Jersey Client API&lt;/li&gt;
&lt;/ul&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/310150438882392547/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2012/12/oracle-certified-expert-java-ee-6-web.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/310150438882392547'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/310150438882392547'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/12/oracle-certified-expert-java-ee-6-web.html' title='Oracle Certified Expert, Java EE 6 Web Services Developer'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://2.bp.blogspot.com/-jYtpOSmP_R8/UNYflaj0amI/AAAAAAAAJ4I/PC-wK8B2_tU/s72-c/up_and_running.jpg' height='72' width='72'/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7947881624525191071</id><published>2012-12-22T02:03:00.000+01:00</published><updated>2012-12-22T02:03:30.125+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='JSR'/><category scheme='http://www.blogger.com/atom/ns#' term='batch'/><category scheme='http://www.blogger.com/atom/ns#' term='Java SE'/><category scheme='http://www.blogger.com/atom/ns#' term='Java EE'/><category scheme='http://www.blogger.com/atom/ns#' term='Community'/><title type='text'>Batch Application for the Java Platform (JSR 352)</title><content type='html'>&lt;p&gt;A Java EE 7 szabványba &lt;a href="https://blogs.oracle.com/arungupta/entry/java_ee_7_key_features"&gt;tervezik beletenni&lt;/a&gt; a Batch Application for the Java Platform (&lt;a href="http://jcp.org/en/jsr/detail?id=352"&gt;JSR 352&lt;/a&gt;) szabványt is. Egy kicsit csúszásban vannak, 2012 első negyedévére tervezték a Public Review-t, de csak novemberre sikerült eljutni idáig, és nemrég, december 4-én lett elfogadva.&lt;/p&gt;

&lt;p&gt;A szabvány a Java azon hiányosságát próbálja pótolni, hogy nem nyújtott egységes fogalomrendszert, modellt, leíró nyelvet és környezetet batch alkalmazások fejlesztésére, habár nagyvállalati környezetben az alkalmazások nagy része ilyen jellegű, és a technológia sem friss, hiszen ez a megállapítás már a Cobol alkalmazásokra is igaz volt, és már ott kialakultak az egységes fogalmak, best practice-ek. A batch feldolgozás általában nagy tömegű adattal dolgozó és/vagy számításigényes, nem interaktív, háttérben futó folyamat. Vagy az egész, vagy csak bizonyos részei párhuzamosíthatóak. Gyakori követelmények között szerepel a újraindíthatóság, checkpoint kezelés (leállás esetén honnan lehet újraindulni), párhuzamosság, naplózás, management. A specifikáció erre próbál standard megoldást adni, mind a Java, mind a Java EE környezetben, javax.batch csomagban lévő API-val. A negyedik fejezetben definiálja a fogalmakat, mely egy az egyben a Spring Batch felhasználói kézikönyvének &lt;a href="http://static.springsource.org/spring-batch/reference/html/domain.html"&gt;idevágó fejezete&lt;/a&gt;. A Spring Batch egyedül itt van megemlítve hivatkozásképp.&lt;/p&gt;

&lt;p&gt;A dolog érdekessége éppen ez. A specifikációt &lt;a href="https://sites.google.com/site/chrisvignola/"&gt;Chris Vignola&lt;/a&gt; készítette, aki az IBM színeiben versenyez, és &lt;a href="http://www.ibm.com/developerworks/websphere/techjournal/0801_vignola/0801_vignola.html"&gt;ismeri annak technológiáját&lt;/a&gt;, mely a WebSphere Extended Deployment Compute Grid névet viseli. Azonban megvizsgálta a Spring Batch-t is, és arra jutott, hogy inkább azt veszi alapul. Azonban nem teljes mértékben, hanem bizonyos dolgokat átalakítva, átnevezve (pl. tasklet -&gt; batchlet), bizonyos dolgokat elhagyva, és pár dolgot az IBM megoldásából beemelve. A vicces még az, hogy a referencia implementációt és a TCK-t is az IBM kívánja elkészíteni. Az IBM XML leírója (Job Specification Language) ebben a témában az xJCL nyelv, mely a régi JCL nyelv XML reinkarnációja, és elég egyszerűnek tűnik a Spring leírója mellett. A szabvány számomra meglehetősen szegényes a Spring Batch dokumentációjához képest. A csapatban amúgy szerepel képviselő a Spring oldaláról is.&lt;/p&gt;

&lt;p&gt;Az elfogadás körül is voltak problémák, ugyanis az első verziót azért nem fogadta el két szereplő (London Java Community, Twitter, Inc.), mert nem felelt meg a JCP akkori (2.8) kívánalmainak, miszerint a JSR készítése legyen teljesen átlátható. A specifikáció körüli megbeszélések ugyanis privát levelezési listákon folytak. Ezt javították azzal, hogy a projekt &lt;a href="http://java.net/projects/jbatch"&gt;immár követhető a Java.net&lt;/a&gt;-en. Most már el is lett fogadva a Public Review azzal a feltétellel, hogy az annotációk használatát a végleges verzióban közelíteni kell a Java EE konvenciókhoz, hiszen most jelentősen eltér attól. (A Java EE szerint minden konfigurálható annotációval és XML-lel is, amennyiben mindkettő meg van adva, az XML megadási mód nyer.)&lt;/p&gt;

&lt;p&gt;Véleményem szerint teljesen logikátlan lépés az IBM ilyen erős jelenléte ebben a specifikációban, ha már a Spring Batch lett véve alapul. Érdekes, hogy erről alapvetően nem is lehet olvasni, a fórumon lehet egy két üzenetváltásból elcsípni, hogy a szerző tényleg mindkét megoldást alaposan megvizsgálta. Persze érthető, hogy az IBM-nek ebben a témában sokkal nagyobb a múltja és a részesedése is a rengeteg legacy rendszer miatt. Amennyiben azonban a közösség nem áll a specifikáció mögé, megy a Sun/Oracle többi elfelejtett próbálkozása közé (lásd pl. JDO).&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/7947881624525191071/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2012/12/batch-application-for-java-platform-jsr.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7947881624525191071'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7947881624525191071'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/12/batch-application-for-java-platform-jsr.html' title='Batch Application for the Java Platform (JSR 352)'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6087464391832021768</id><published>2012-11-02T23:38:00.001+01:00</published><updated>2012-11-02T23:38:56.048+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='JMX'/><title type='text'>JMX példaprogram</title><content type='html'>&lt;p&gt;A &lt;a href="http://jtechlog.blogspot.hu/2009/09/java-monitorozas-es-menedzsment.html"&gt;JMX-ről szóló postomhoz&lt;/a&gt; felkerült egy kis példaprogram a &lt;a href="https://github.com/vicziani/jtechlog-jmx"&gt;https://github.com/vicziani/jtechlog-jmx&lt;/a&gt; címre. Maven-nel build-elhető, és a letöltést követően a 'mvn jetty:run' paranccsal futtatható.&lt;/p&gt;
</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/6087464391832021768/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2012/11/jmx-peldaprogram.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6087464391832021768'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6087464391832021768'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/11/jmx-peldaprogram.html' title='JMX példaprogram'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2324167374630342322</id><published>2012-10-14T23:54:00.001+02:00</published><updated>2012-11-02T22:20:13.018+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Design Patterns'/><category scheme='http://www.blogger.com/atom/ns#' term='Ajax'/><category scheme='http://www.blogger.com/atom/ns#' term='Spring'/><title type='text'>Eseményküldés szerver oldalról</title><content type='html'>&lt;p&gt;Technológiák: Spring 3.1.1, DWR 3.0, Guava 13.0.1&lt;/p&gt;

&lt;p&gt;Egy projektben olyan webes keretrendszert használtam, mely képes volt szerver oldalról üzeneteket küldeni a kliens oldal felé. Ezt ugyan a klasszikus http nem teszi lehetővé, hiszen az egy kérés-válasz alapú kommunikációs mód, ahol mindig a kliens kérdez, azonban vannak kerülő megoldások, melyekről később lesz szó. Az első probléma ugyanis nem itt, hanem korábban jelentkezett, méghozzá hogyan lehet egy n-rétegű alkalmazást felkészíteni erre a kommunikációs formára, anélkül, hogy megzavarnánk az eddig kialakult architektúrát és szabályokat. A postban írok ennek a megoldásáról, de két Springes érdekesség is bemutatásra kerül, a contextek hierarchiája, a beépített eseménykezelés, szó lesz a Guava Event Busról is, valamint hogyan lehet &lt;a href="http://directwebremoting.org/dwr/index.html"&gt;Direct Web Remoting&lt;/a&gt; (DWR) használatával a kliens oldalt értesíteni.&lt;/p&gt;

&lt;p&gt;Az alapvető probléma az, hogy ez ellentmond a legtipikusabb esetnek, mikor van egy webes komponensünk, mely behív az üzleti logikába. Középen helyezkedik el ugyanis az üzleti logika réteg, és arra épül rá a webes réteg. A webes réteg az üzleti logikát egy API-n keresztül éri el, viszont jobb esetben erről az üzleti logika nem tud, ő csak az alatt lévő réteget (perzisztens) réteget hívja. Itt viszont pont az ellentettjére van szükségünk, mikor az üzleti logika hív ki a webes rétegbe. Hogy is oldjuk fel az itt lévő ellentmondást?&lt;/p&gt;

&lt;p&gt;Egy megoldás lehet az Observer tervezési minta használata. Gyakori tervezési minta, főleg felhasználói felületeknél használatos, pl. ez húzódik meg az (MVC) Model-View-Controller mögött is, valamint ismerős lehet, ha már használtunk eseménykezelőket, listenereket. Az alapprobléma, hogy van egy objektumunk, és annak állapotának változása esetén egy másik objektumnak el kell valamit végeznie. Ez történhetne úgy is, hogy az egyik objektum közvetlenül hívja a másik objektumot, azonban ennek több hátránya is. Egyrészt szoros kapcsolat van a két objektum között, melyet nem szeretünk, valamint amennyiben újabb és újabb műveleteket kellene elvégeznünk, mindig bővítenünk kell a hívást is. Erre megoldás az, hogy az érdekes állapot változással rendelkező objektumot kinevezzük megfigyeltnek (Observable), és definiálunk egy interfészt, melyeket a megfigyelők implementálnak (Observer). Az Observable objektumon bármennyi Observer implementációt lehet regisztrálni, és amennyiben bekövetkezik az állapotváltozás, az végighívja az összes megfigyelőt. Ezzel megszüntettük a szoros kapcsolatot, a plusz interfész bevezetésével, valamint bármennyi megfigyelőt hozzáadhatunk anélkül, hogy a megfigyeltet módosítani kéne.&lt;/p&gt;

&lt;p&gt;Természetesen jelen példánkban a megfigyelt az üzleti logika, és a megfigyelő pedig a webes rétegben egy olyan komponens, mely a böngészőt tudja értesíteni. Több megoldást is meg fogok mutatni, melyek közül az igényeknek megfelelően lehet választani, és tetszőlegesen személyre szabni.&lt;p&gt;

&lt;p&gt;Példaprogram is született, mely &lt;a href="https://github.com/vicziani/jtechlog-event"&gt;itt elérhető a GitHub-on.&lt;/a&gt; A következő három példát lehet itt találni:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;jtechlog-event-eo: java.util.EventObject használatával&lt;/li&gt;
&lt;li&gt;jtechlog-event-ae: Spring ApplicationEvent küldése&lt;/li&gt;
&lt;li&gt;jtechlog-event-geb: Guava Event Busszal&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mindhárom példa Maven-nel buildelhető, és a letöltést követően a 'mvn jetty:run' paranccsal futtatható.&lt;/p&gt;

&lt;p&gt;Az alkalmazás a következőképp működik. Be kell hívni egy vagy több böngészőben/böngészőablakban az alkalmazást, majd a szövegbeviteli mezőbe beírni egy szöveget. Ennek a szövegnek az összes kliensen meg kell jelennie.&lt;/p&gt;

&lt;p&gt;A választott webes keretrendszer, mely képes kliens oldalra hívni a DWR. A post végén kitérek ennek mikéntjére, de most minket az érdekel, hogy üzleti oldalról hogy jut el az esemény a DWR-ig. A jtechlog-event-eo projektben erre a standard Java megoldást használom, ahogy az AWT eseménykezelés is működik.&lt;/p&gt;

&lt;p&gt;A service rétegben lévő StatusService osztály fogadja a felhasználó felől az interakciót, és szeretné ezt a többi webes kliensnek továbbítani. Az első példában (jtechlog-event-eo) a service rétegben deklarálok egy StatusEvent esemény osztályt, mely a Javas EventObject osztály leszármazottja. Valamint egy StatusEventListener interfészt, mely a java.util.EventListener leszármazottja. Ezt implementálja webes rétegben a StatusEventSender osztály, mely a böngészőnek továbbítja az eseményt, az implementált onStatusEvent metódusban:&lt;/p&gt;

&lt;pre class="brush: java"&gt;
@Service
public class StatusEventSender implements StatusEventListener {

    @Override
    public void onStatusEvent(StatusEvent statusEvent) {
   // Küldés a böngésző felé, lásd később
    }
}
&lt;/pre&gt;

&lt;p&gt;A StatusService ilyen Listenereket képes regisztrálni, és állapotváltozás esetén hívni. Először egy Spring-es trükköt próbáltam elkövetni, méghozzá az Autowired annotációval automatikusan beállítani ezeket a Listenereket:&lt;/p&gt;

&lt;pre class="brush: java"&gt;
@Service
public class StatusService {

  private List&amp;lt;StatusEventListener&amp;gt; statusEventListeners 
    = new ArrayList&amp;lt;StatusEventListener&amp;gt;();

  public void postStatus(String status) {
    for (StatusEventListener statusEventListener: 
      statusEventListeners) {
        statusEventListener.onStatusEvent(
          new StatusEvent(this, status));
      }
  }

  @Autowired
  public void setStatusEventListeners(List&amp;lt;StatusEventListener&amp;gt; 
      statusEventListeners) {
    this.statusEventListeners = statusEventListeners;
  }
}
&lt;/pre&gt;

&lt;p&gt;A Spring ezt alapból tudná, ugyanis amennyiben az Autowired annotáció rajta van a metóduson, próbálja begyűjteni az összes StatusEventListener interfészt implementáló osztályt, és azt tenni a listába, és azt értékül adni az attribútumnak. A szép elképzelést azonban a Spring context kezelése meghiúsította. Röviden a web contextben lévő beanek nem látszanak a service contextben lévő beanek számára. (Ez alapjában véve elfogadható. A Spring context hierarchia kezeléséről amúgy kevés dokumentáció van, itt található &lt;a href="http://techo-ecco.com/blog/spring-application-context-hierarchy-and-contextsingletonbeanfactorylocator/"&gt;egy kis kivétel&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;Amennyiben a StatusEventSendert átmozgatjuk a service-ek közé, a probléma megoldódik. De amennyiben a klasszikus modellnél akarunk maradni, nekünk kell gondoskodnunk a listenerek regisztrációjáról. Egyrészt így módosul a StatusService:&lt;/p&gt;

&lt;pre class="brush: java"&gt;
@Service
public class StatusService {

  private List&amp;lt;StatusEventListener&amp;gt; statusEventListeners 
    = new ArrayList&amp;lt;StatusEventListener&amp;gt;();

  public void postStatus(String status) {
    for (StatusEventListener statusEventListener: 
        statusEventListeners) {
      statusEventListener.onStatusEvent(new StatusEvent(this, status));
    }
  }

  public void addStatusEventListener(
      StatusEventListener statusEventListener) {
    statusEventListeners.add(statusEventListener);
  }
}
&lt;/pre&gt;

&lt;p&gt;Másrészt a StatusEventSendert kell kiegészíteni a regisztráció hívásával. Gyakorlatilag a bean elkészítése után értesítjük a StatusServicet a meglétéről.&lt;/p&gt;

&lt;pre class="brush: java"&gt;
@Service
public class StatusEventSender implements StatusEventListener {

    @Autowired
    private StatusService statusService;

    @PostConstruct
    private void register() {
        statusService.addStatusEventListener(this);
    }

    @Override
    public void onStatusEvent(StatusEvent statusEvent) {
   // Kliens értesítése
    }
}
&lt;/pre&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;a href="http://3.bp.blogspot.com/-WsVLmQnVWaA/UHszMAPNQEI/AAAAAAAAJXA/QXlIncO4R_s/s1600/event-osztalydiagram.png" imageanchor="1" style="margin-left:1em; margin-right:1em"&gt;&lt;img border="0" height="155" width="320" src="http://3.bp.blogspot.com/-WsVLmQnVWaA/UHszMAPNQEI/AAAAAAAAJXA/QXlIncO4R_s/s320/event-osztalydiagram.png" /&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;Ezzel már teljesítettük a feladatot, a StatusService lazán csatolt a StatusEventSenderrel, hiszen nincs rá referenciája, de mégis értesíti azt az állapotváltozásáról.&lt;/p&gt;

&lt;p&gt;A második példában (jtechlog-event-ae) a Spring beépített eseménykezelését szeretném bemutatni. A Springben bármilyen beanből eseményt lehet küldeni, amit más beanek fogadni tudnak. Először megcsináljuk az Eventünket, mely a org.springframework.context.ApplicationEvent leszármazottja.&lt;/p&gt;

&lt;pre class="brush: java"&gt;
public class StatusEvent extends ApplicationEvent {

    private String status;

    public StatusEvent(Object source, String status) {
        super(source);
        this.status = status;
    }

    public String getStatus() {
        return status;
    }
}
&lt;/pre&gt;

&lt;p&gt;Utána a StatusServicet implementáljuk, mely az eseményt elküldi. Ehhez egy ApplicationEventPublisher-re van szükségünk, melyhez a ApplicationEventPublisherAware használatával lehet hozzáférni. Aztán a publishEvent metódussal tudunk eseményt küldeni.&lt;/p&gt;

&lt;pre class="brush: java"&gt;
@Service
public class StatusService implements ApplicationEventPublisherAware {

  private ApplicationEventPublisher applicationEventPublisher;

  public void postStatus(String status) {
    applicationEventPublisher
        .publishEvent(new StatusEvent(this, status));
  }

  public void setApplicationEventPublisher(ApplicationEventPublisher 
      applicationEventPublisher) {
    this.applicationEventPublisher = applicationEventPublisher;
  }
}
&lt;/pre&gt;

&lt;p&gt;Utána a StatusEventSendert írjuk meg, mely fogadja az eseményt, és értesíti a böngészőt. Implementálja az ApplicationListener interfészt, az onApplicationEvent metódussal.&lt;/p&gt;

&lt;pre class="brush: java"&gt;
@Service
public class StatusEventSender implements 
    ApplicationListener&amp;lt;StatusEvent&amp;gt; {

  @Override
  public void onApplicationEvent(StatusEvent statusEvent) {
    // Böngésző hívása
  }
}
&lt;/pre&gt;

&lt;p&gt;A megoldással pontosan az a baj, melybe az előbbi esetben is belefutottunk, méghozzá a service contextben lévő beanek nem dobhatnak üzenetet a web contextben lévő beaneknek, csupán fordítva. Azaz itt is igaz az állítás, hogy a service réteg nem tudhat a web rétegből. Az a megoldás, hogy a StatusEventSendert áttesszük a service-ek közé, ismét működik.&lt;/p&gt;

&lt;p&gt;Amennyiben komolyabb megoldásra van szükségünk, használhatjuk a Guava könyvtár (Google core Java libraryje, collection komponensekkel, cache-eléssel, párhuzamosságot, Stringeket és fájlokat kezelő segédosztályokkal) Guava EventBus komponensét. A &lt;a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/eventbus/package-summary.html"&gt;csomag leírásában van egy nagyon jó dokumentáció&lt;/a&gt;, hogy miért jobb, mint a Java beépített eseménykezelése, ezért erre most nem térnék ki.&lt;/p&gt;

&lt;p&gt;Először a Springben definiálni kell az EventBust, majd definiálni kell egy POJO eseményt. Az EventBushoz dependency injectionnel hozzá lehet férni.&lt;/p&gt;

&lt;pre class="brush: java"&gt;
@Service
public class StatusService {

    @Autowired
    private EventBus eventBus;

    public void postStatus(String status) {
        eventBus.post(new StatusEvent(status));
    }
}
&lt;/pre&gt;

&lt;p&gt;Az EventBusra regisztrálni kell, és eseményt fogadni a @Subscribe annotáció használatával lehet.&lt;/p&gt;

&lt;pre class="brush: java"&gt;
@Service
public class StatusEventSender {

    @Autowired
    private EventBus eventBus;

    @PostConstruct
    private void register() {
        eventBus.register(this);
    }

    @Subscribe
    public void onStatusEvent(StatusEvent statusEvent) {
   // Küldés kliens felé
    }
}
&lt;/pre&gt;

&lt;p&gt;A Spring integrációhoz jól jöhet a &lt;a href="https://github.com/armsargis/guava-eventbus-spring"&gt;guava-eventbus-spring&lt;/a&gt; projekt is, de mivel nincs fenn a központi Maven repositoryban, én nem használtam. Ez definiál Spring névteret, így sokkal könnyebben lehet az EventBust konfigurálni, valamint annotáció alapján automatikusan képes beregisztrálni a subscribereket, nem kell nekünk ezt manuálisan megtennünk.&lt;/p&gt;

&lt;p&gt;Most már csak azt az adósságomat kell törleszteni, hogy hogyan lehet DWR-ben a kliens oldal felé üzenetet küldeni. Erre egy nagyon hatékony megoldás áll a rendelkezésünkre: szerver oldali Javaból tudunk JavaScript függvényt hívni! Hogy ez a HTTP-n hogyan történik, a DWR &lt;a href="http://directwebremoting.org/dwr/documentation/reverse-ajax/index.html"&gt;három lehetőséget biztosít&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Polling: nem kell magyarázni, szabványos időközönként megkérdezi a szervert, hogy van-e függvényhívás&lt;/li&gt;
&lt;li&gt;Comet: nyit egy HTTP kérést, és az addig blokkolódik, míg nem történik valami, vagy timeout&lt;/li&gt;
&lt;li&gt;Piggyback: ha történik amúgy is egy szerver oldali kérés, abban adott válaszban küldi vissza a DWR a függényhívás tényét is&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mindegyiknek megvan az előnye és hátránya. Alapban csak a Piggyback van bekapcsolva, a web.xml-ben, valamint a JavaScriptben kell kavarni a Reverse Ajax bekapcsolásához.&lt;/p&gt;

&lt;p&gt;Nézzük a JavaScript oldalt:&lt;/p&gt;

&lt;pre class="brush: js"&gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
 // http://docs.jquery.com/Using_jQuery_with_Other_Libraries
 $j(function () {
  dwr.engine.setActiveReverseAjax(true);
  $j(&amp;quot;#statusForm&amp;quot;).submit(function () {
   statusDwrService.postStatus($j(&amp;quot;#statusInput&amp;quot;).val());
   return false;
  });
 });

 function showStatus(status) {
  $j(&amp;quot;#statusDiv&amp;quot;).html(status);
 }
&amp;lt;/script&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Egyrészt bekapcsolja a Reverse Ajaxot. Valamint a statusForm HTML form kitöltésekor meghívja a szerver oldali postStatus metódust. Valamint definiál egy showStatus metódust, melyet meghívva megjelenik a szerver oldalról érező üzenet. Mindez JQuery használatával.&lt;/p&gt;

&lt;p&gt;A szerver oldali hívás a következőképp néz ki:&lt;/p&gt;

&lt;pre class="brush: java"&gt;
    public void onStatusEvent(StatusEvent statusEvent) {
        ScriptBuffer scriptBuffer = new ScriptBuffer();
        scriptBuffer.appendCall("showStatus", statusEvent.getStatus());
        WebContext webContext = WebContextFactory.get();
        String currentPage = webContext.getCurrentPage();
        Collection sessions = 
          webContext.getScriptSessionsByPage(currentPage);
        for (Iterator i = sessions.iterator(); i.hasNext(); ) {
            ScriptSession session = (ScriptSession) i.next();
            session.addScript(scriptBuffer);
        }
    }
&lt;/pre&gt;

&lt;p&gt;Ez hívja meg a kliens oldalon a showStatus JavaScript metódust.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/2324167374630342322/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2012/10/esemenykuldes-szerver-oldalrol.html#comment-form' title='3 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2324167374630342322'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2324167374630342322'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/10/esemenykuldes-szerver-oldalrol.html' title='Eseményküldés szerver oldalról'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://3.bp.blogspot.com/-WsVLmQnVWaA/UHszMAPNQEI/AAAAAAAAJXA/QXlIncO4R_s/s72-c/event-osztalydiagram.png' height='72' width='72'/><thr:total>3</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1914186509497168462</id><published>2012-09-25T22:09:00.001+02:00</published><updated>2012-09-25T22:09:43.159+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='GitHub'/><title type='text'>GitHub Pages</title><content type='html'>&lt;p&gt;Az egyetemi szerveren lévő honlapom a diploma megszerzése után tizenegy évvel egyik napról a másikra leállt. Így másik megoldás után kellett néznem. A legkézenfekvőbb választásnak a &lt;a href="http://pages.github.com/"&gt;GitHub Pages&lt;/a&gt; tűnt, hiszen egyre többet használom, ráadásul ingyenes. Azért tetszik különösen, mert egyrészt egyszerre meg van oldva az oldalam verziókezelése és publikálása. Valamint sablonokon alapul, így megvalósítható a különböző oldalrészek újrafelhasználása, azaz a fejlécet, menüt és láblécet csak egyszer kell definiálni, ez különösen jól jön karbantartáskor. Az első lépések megtételében segít a kellően részletes &lt;a href="https://help.github.com/categories/20/articles"&gt;dokumentáció&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Az új oldal tehát elérhető a &lt;a href="http://vicziani.github.com/"&gt;http://vicziani.github.com/&lt;/a&gt; címen, valamint a forrása is böngészhető a &lt;a href="https://github.com/vicziani/vicziani.github.com"&gt;https://github.com/vicziani/vicziani.github.com&lt;/a&gt; címen.&lt;/p&gt;

&lt;p&gt;Eddig elég manuális megoldást használtam, &lt;a href="http://jtechlog.blogspot.hu/2009/03/szoveg-generalas.html"&gt;Ant-ból hívtam Apache Texen-t&lt;/a&gt;, mely a háttérben Velocity-t használ. A GitHub megoldása ennél sokkal jobban kézre esik.&lt;/p&gt;

&lt;p&gt;Amennyiben statikus html oldalakat akarunk kirakni, nagyon egyszerű a használata, létre kell hozni egy username.github.com publikus repository-t, ahol értelemszerűen a username a felhasználónevünk. Kizárólag ezt a címet foglalhatjuk le, más névvel nem működik. Generálhatunk oldalt az automatikus generátor segítségével is, ekkor egy témát kell kiválasztanunk, és a &lt;a href="http://daringfireball.net/projects/markdown/syntax"&gt;Markdown&lt;/a&gt; leíró nyelvvel leírni. Én a manuális utat választottam, mikor is a html-t én írom meg. Parancssori klienst használok, a repository-t ugyanúgy kell kezelni, mint bármely mást. Létre kell hozni a könyvtárat, elhelyezni benne az állományainkat, majd kiadni a következő parancsokat (természetesen a felhasználónevet lecserélve):&lt;/p&gt;

&lt;pre&gt;
git init
git add .
git commit -m "First commit"
git remote add origin https://github.com/vicziani/vicziani.github.com.git
git push -u origin master
&lt;/pre&gt;

&lt;p&gt;Ezen parancsokat kiadva rövidesen egy e-mailt kapunk, hogy az oldalunk sikeresen legyártásra került, kicsit várjunk, de a további módosításainkat már azonnal érvénybe lépteti.&lt;/p&gt;

&lt;pre&gt;
From: GitHub noreply@github.com
Subject: Page build successful

Your page has been built. If this is the first time you've pushed, it may take 
a few minutes to appear, otherwise your changes should appear immediately.
&lt;/pre&gt;

&lt;p&gt;Amennyiben kicsit bonyolultabb dolgokra van szükségünk, használhatjuk a Ruby-ban implementált &lt;a href="https://github.com/mojombo/jekyll"&gt;Jekyll&lt;/a&gt; generátort. Ennek használatával valamilyen leíró nyelven meg kell adnunk a tartalmat (HTML, Textile, Markdown, Liquid), és ebből előállítja a HTML kimenetet, melyet bárhová kirakhatunk statikus tartalomként. A Jekyll segítségével akár blogot is írhatunk, amikor csak a blogbejegyzéseket kell megszerkeszteni, hozzá a körítést a Jekyll legenerálja. Könnyebbség ráadásul, hogy nem nekünk kell a generálást meghívni, hanem a push után automatikusan a GitHub szerverein történik, így azonnal láthatjuk az eredményt.&lt;/p&gt;

&lt;p&gt;Nézzünk is egy egyszerű példát. A könyvtárstruktúra kötött, a főkönyvtárba opcionálisan elhelyezhető a _config.yml állomány, mellyel a generálást lehet konfigurálni. Az _includes könyvtár tartalmazhatja az újrafelhasználható oldalelemeket ({% include file.ext %} szintakszissal használandóak), míg a _layouts könyvtár az oldal sablonokat. A _layouts könyvtárba helyezzük el ennek alapján a default.html állományt:&lt;/p&gt;

&lt;pre class="brush: xml"&gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

{{ content }}

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Valamint a főkönyvtárba az index.html állományt:&lt;/p&gt;

&lt;pre class="brush: xml"&gt;
---
layout: default
---

Hello GitHub Pages!
&lt;/pre&gt;

&lt;p&gt;Ahogy az várható, a Jekyll végigmegy azokon az állományokon, mely elején a három kötőjelet találja (vigyázzunk, ne szerepeljen a file elején a &lt;a href="http://en.wikipedia.org/wiki/Byte_order_mark"&gt;BOM&lt;/a&gt;, és a sablonban a {{ content }} helyére beszúrja a fájl tartalmát. Persze ezt tovább bonyolíthatjuk, ha pl. oldalanként külön címet akarunk, akkor definiáljunk egy változót a sablonban (default.html):&lt;/p&gt;

&lt;pre class="brush: xml"&gt;
...
&amp;lt;title&amp;gt;{{ page.title }}&amp;lt;/title&amp;gt;
...
&lt;/pre&gt;

&lt;p&gt;Majd állítsuk be az értékét a konkrét oldalon (index.html):&lt;/p&gt;

&lt;pre class="brush: xml"&gt;
---
layout: default
title: GitHub pages
---

Hello GitHub Pages!
&lt;/pre&gt;

&lt;p&gt;A Jekyll a &lt;a href="http://liquidmarkup.org/"&gt;Liquid&lt;/a&gt; template engine-t használja. A standard Liquid &lt;a href="http://liquid.rubyforge.org/classes/Liquid/StandardFilters.html"&gt;filtereket&lt;/a&gt; a Jekyll &lt;a href="https://github.com/mojombo/jekyll/wiki/liquid-extensions"&gt;továbbiakkal egészítette ki&lt;/a&gt;. Például régóta szerettem volna, hogyha generáláskor bekerül az aktuális dátum a Date html meta tag-be. Ráadásul nem is akárhogyan, henm a HTML szabvány által ajánlott ISO 8601 formátumban (pl. 2012-09-25). Ehhez a következőt kellett csinálni:&lt;/p&gt;

&lt;pre class="brush: xml"&gt;
&amp;lt;meta name=&amp;quot;Date&amp;quot; lang=&amp;quot;hu&amp;quot; content=&amp;quot;{{ site.time | date: '%Y-%m-%d' }}&amp;quot;/&amp;gt;
&lt;/pre&gt;

&lt;p&gt;A Jekyll &lt;a href="https://github.com/mojombo/jekyll/wiki/template-data"&gt;adja&lt;/a&gt; a site.time adatot, és ez a date filterrel formázott.&lt;/p&gt;

&lt;p&gt;Persze jöttek nehézségek is, pl. a title változóba szerettem volna kettőspontot elhelyezni. Ekkor a következő hibaüzenet fogadott:&lt;/p&gt;

&lt;pre&gt;
Building site: /cygdrive/d/download/qqqq -&gt; /cygdrive/d/download/qqqq/_site
/usr/lib/ruby/1.9.1/psych.rb:203:in `parse': (&lt;unknown&gt;): mapping values are not allowed in this context at line 3 column 20 (Psych::SyntaxError)
        from /usr/lib/ruby/1.9.1/psych.rb:203:in `parse_stream'
&lt;/pre&gt;

&lt;p&gt;Megoldásként a címet idézőjelek közé kell tenni:&lt;/p&gt;

&lt;pre class="brush: xml"&gt;
title: "GitHub: pages"
&lt;/pre&gt;

&lt;p&gt;Ahhoz, hogy ne csak élesben tudjam kipróbálni a generálást, fel szerettem volna tenni a Jekyllt saját gépre is. (Van olyan lehetőség is, hogy a Jekyll egy web szervert futtat, és úgy lehet kipróbálni a tartalmat.) Linuxon ez valószínűleg egy egyszerűbb művelet, én Windowsra próbáltam, Cygwin környezettel. Ez már varázslás kategória, &lt;a href="http://matt.scharley.me/2012/03/10/windows-cygwin-and-jekyll.html"&gt;ebből a cikkből&lt;/a&gt; indultam ki. (Közben próbálkoztam Python megvalósítással is, létezik az is, &lt;a href="http://obraz.pirx.ru/"&gt;Obraz&lt;/a&gt; néven, de az a &lt;a href="http://jinja.pocoo.org/"&gt;Jinja2&lt;/a&gt; Python-ban implementált template engine-t használja, és vannak ugyan átfedések, de inkompatibilitás is bőven, a fentebb említett filterek például különböznek.&lt;/p&gt;

&lt;p&gt;Ezt feltéve újabb probléma fogadott, nem sikerült a generálás, és a következő jelent meg a konzolon:&lt;/p&gt;

&lt;pre&gt;
Liquid Exception: incompatible character encodings: UTF-8 and CP852 in default
&lt;/pre&gt;

&lt;p&gt;Erre is volt megoldás, természetesen a karakterkódolással volt a probléma, ezt a következőképp lehet orvosolni:&lt;/p&gt;

&lt;pre&gt;
set LC_ALL=en_US.UTF-8
set LANG=en_US.UTF-8
&lt;/pre&gt;

&lt;p&gt;Ezzel tökéletesen tesztelhető lokálisan a Jekyll generálás, így bízhatunk, hogy a Github Pages is ugyanígy fog működni. Nem csak magunknak, hanem egy szervezetnek, és a projektjeinknek is tudunk így oldalakat készíteni. Java projekteknél pl. a mvn site parancs kimenetét lehet így feltenni, sőt akár Maven repository-ként is használhatjuk.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/1914186509497168462/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2012/09/github-pages.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1914186509497168462'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1914186509497168462'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/09/github-pages.html' title='GitHub Pages'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-761129547306460114</id><published>2012-09-16T23:49:00.000+02:00</published><updated>2012-10-03T11:52:23.474+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='vizsga'/><title type='text'>Oracle Java vizsgák</title><content type='html'>&lt;p&gt;Mióta letettem a 6-os Javahoz tartozó &lt;a href="http://jtechlog.blogspot.hu/2009/10/scjp.html"&gt;SCJP&lt;/a&gt; vizsgát, elég sok minden változott, így érdemes még egyszer rátekinteni. Egyrészt az Oracle felvásárolta a Sunt, és ez a vizsgáknál is látszik, próbálja idomítani a jelenlegi Associate, Professional, Master vonalba. Az Sun Certified Java Programmer, majd későbbi nevén az Oracle Certified Professional Java SE Programmer helyét most két vizsga vette át. Egyrészt &lt;a href="http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=41&amp;p_org_id=&amp;lang=&amp;p_exam_id=1Z0_803"&gt;1Z0-803 - Java SE 7 Programmer I&lt;/a&gt;, valamint a &lt;a href="http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=41&amp;p_org_id=&amp;lang=&amp;p_exam_id=1Z0_804"&gt;1Z0-804 - Java SE 7 Programmer II&lt;/a&gt;. Az előbbi alap Java programozói tudást tesztel, tisztában kell lenni a Java alapjaival, valamint az objektumorientáltság alapfogalmaival. Ez kicsit több, mint a Sun Certified Java Associate, mely nem követelt meg ekkora programozói tudást, inkább egy áttekintő képet próbált adni a Java platformmal kapcsolatban, így egy kicsit a webes technológiákat, mobil programozást és az UML-t is érintette. A Java SE 7 Programmer I ezzel szemben kizárólag a Java programozási nyelvre megy rá. A Java SE 7 Programmer II már sokkal mélyebben kérdez bele az objektumorientált fogalmakba és konstrukciókba és kivételekbe, valamint új téma a generikusok, Collections Framework, String műveletek, Java I/O, Java File I/O (NIO.2), szálak, lokalizáció és nem is az Oracle lenne, ha nem került volna bele a JDBC. Ez az Oracle kommunikációja szerint komolyabb, mint az SCJP volt. A második vizsgának előfeltétele az első vizsga. Akinek SCJA vagy OCJA 5/6 vizsgája van, az sajnos semmit nem ér, újra kell tennie a Java SE 7 Programmer I vizsgát. Szerencsére az Oracle eddigi gyakorlatával szakítva nem kötelező az Oracle tanfolyamok elvégzése, csak erősen ajánlott. (Ezen tanfolyamok elérhetőek a vizsgák oldalairól.) Persze akinek már megvan az SCJP vagy az OCPJP, az se szomorkodjon, ugyanis létezik egy upgrade vizsga &lt;a href="http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=41&amp;p_org_id=&amp;lang=&amp;p_exam_id=1Z0_805"&gt;1Z0-805 - Upgrade to Java SE 7 Programmer&lt;/a&gt; néven. Itt a témakörök: Java 7 nyelvi újdonságai, tervezési minták, JDBC, párhuzamos programozás új elemei, lokalizáció és a Java File I/O (NIO.2).&lt;/p&gt;

&lt;p&gt;A többi dolog alapjában véve megmaradt, minden vizsgára jellemző, hogy 90 tesztkérdés, 140-150 perc, 60-77% megfelelés. Lesz könyv is &lt;a href="http://www.amazon.com/Programmer-Study-Guide-1Z0-803-Certification/dp/0071772006"&gt;OCA/OCP Java SE 7 Programmer I &amp; II Study Guide (Exams 1Z0-803 &amp; 804) (Certification Press)&lt;/a&gt;. A vizsgák ára darabja kb. 65 000 Ft, ez azonban több, mint régen, hiszen most ugyanahhoz a szinthez két vizsgát kell letenni, így ennek kétszeresével kell számolni.&lt;/p&gt;

&lt;p&gt;Master szintű vizsga még nincs, arra várnunk kell, a hírek szerint fejlesztés alatt. Azonban szerencsére még bármelyik régebbi vizsgával (valamint az újból a Professional, azaz kettes szintűvel) is letehetők az alábbi Oracle Certified Expert vizsgák: Java EE 6 Enterprise JavaBeans Developer, Java EE 6 Java Persistence API Developer (e kettőről már írtam &lt;a href="http://jtechlog.blogspot.hu/2011/02/ejb-es-jpa-developer-certified-expert.html"&gt;korábban&lt;/a&gt;), Java EE 6 Web Services Developer, Java Platform, EE 6 Web Component Developer, Java ME 1 Mobile Application Developer. Java EE 7 még sehol, valamint a 6-os sorozatból sem létezik Enterprise Architect, ahogyan az 5-öshöz volt (, feltehetőleg EE-ből ez lenne a Master szint).&lt;/p&gt;

&lt;p&gt;A véleményem a vizsgáról azóta sem változott. Amíg az Oracle nem tesz valamit itthon, addig ez nem lesz elfogadott, esetleg megkövetelt vizsga. Viszont az ember kipróbálhatja önmagát, jó juttatás lehet ez a cégek részéről, és mint felvételiztető is becsülöm azt, aki időt és energiát áldozott a vizsga letételére, hiszen biztos, hogy tanult meg új dolgokat, szélesedett a látóköre, és a fogalmakat és elnevezéseket is ezentúl konzisztensen tudja használni, így könnyebb lesz vele a kommunikáció. Viszont a vizsgától még nem lesz senki jó programozó.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/761129547306460114/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2012/09/oracle-java-vizsgak.html#comment-form' title='8 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/761129547306460114'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/761129547306460114'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/09/oracle-java-vizsgak.html' title='Oracle Java vizsgák'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>8</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3605609953726890781</id><published>2012-09-05T23:56:00.000+02:00</published><updated>2012-09-05T23:56:05.287+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Community'/><title type='text'>JUM XIX. bejelentés</title><content type='html'>&lt;p&gt;Újra megrendezzük a &lt;a href="http://wiki.javaforum.hu/display/JUM/Home"&gt;JUM&lt;/a&gt;-ot, mely egy alkalmi összejövetel, ahol a magyarországi Javaval foglalkozó szakemberek oszthatják meg a tapasztalataikat egymással. Immár 19. alkalommal kerül megrendezésre 2012. szeptember 19-én, a helyszín ezúttal a &lt;a href="http://www.training360.com/"&gt;Training360&lt;/a&gt;. Auth Gábor fog előadni a Java 8 Lambda expressions témakörben, Kovács Richárd beszél a Grailses tapasztalatairól, én pedig két projektet, esettanulmányt és eszközt mutatok be a munkafolyamatok témakörében (Ant, &lt;a href="http://activiti.org"&gt;Activiti&lt;/a&gt;). További információk a &lt;a href="http://wiki.javaforum.hu/pages/viewpage.action?pageId=28442870"&gt;bejelentésben&lt;/a&gt;, regisztráció szükséges. Gyertek minél többen!&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/3605609953726890781/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2012/09/jum-xix-bejelentes.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3605609953726890781'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3605609953726890781'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/09/jum-xix-bejelentes.html' title='JUM XIX. bejelentés'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7550091435364332920</id><published>2012-08-14T23:52:00.000+02:00</published><updated>2012-08-14T23:54:16.389+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='open source'/><category scheme='http://www.blogger.com/atom/ns#' term='SOA'/><category scheme='http://www.blogger.com/atom/ns#' term='JAX-WS'/><category scheme='http://www.blogger.com/atom/ns#' term='Maven'/><title type='text'>Webszolgáltatások integrációs tesztelése soapUI és JUnit használatával</title><content type='html'>&lt;p&gt;Használt technológiák: JAX-WS 2.2.6-2, JUnit 4.10, soapUI 4.5.1, Maven 3.0.3&lt;/p&gt;

&lt;p&gt;Már többször említettem a soapUI-t, mely az egyik legelterjedtebb eszköz webszolgáltatások fejlesztéséhez. Alapvetően egy webszolgáltatás teszteléséhez használatos kliensnek indult, de rengeteg mindennel kiegészítették, így szinte minden feladatot képes megoldani ezen a területen. Nagyon intuitív grafikus felülettel rendelkezik, és van ingyenes és kereskedelmi verziója is (&lt;a href="http://www.soapui.org/About-SoapUI/compare-soapui-and-soapui-pro.html"&gt;összehasonlítás&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;A legegyszerűbb, és leggyakrabban használt funkció, hogy elég megadni a WSDL URL-jét, és ehhez képes példa kéréseket gyártani. A kitöltendő paramétereket kérdőjellel jelöli meg, az opcionálisakat megjegyzéssel, és kitöltés után azonnal be tudjuk küldeni a kérést, melyre kapott választ azonnal megmutatja (a natív HTTP kérést és választ is). Ennél izgalmasabb talán, hogy teszt suite-okat is össze lehet állítani, benne test case-ekkel. Tudunk generáltatni példa kéréseket, és a válaszokra ellenőrzéseket, asserteket tudunk tenni. Ezek lehetnek egyszerű szöveg tartalmazások, XPath, XQuery kifejezések is, de akár Groovy script is. Felvehetünk property-ket, melyek értékét állíthatjuk, illetve a kérésekbe behelyettesíthetjük. Természetesen Groovy script-ből is használhatjuk őket. Ezekkel lehet pl. megoldani, hogy az első webszolgáltatás kérés visszaad egy sessionid-t, és később azt akarjuk küldeni a további webszolgáltatás kérésekben.&lt;/p&gt;

&lt;p&gt;Írtam is erre egy apró projektet, mely &lt;a href="https://github.com/vicziani/jtechlog-soapui-testing"&gt;elérhető a GitHub-on&lt;/a&gt;. Az ötletet a w3schools-ról vettem, ahol ki van ajánlva egy &lt;a href="http://www.w3schools.com/webservices/tempconvert.asmx"&gt;TempConvert&lt;/a&gt; webszolgáltatás Celsius és Fahrenheit közötti váltásra. Ezt implementálja a TempConvert.java osztály JAX-WS használatával, Maven-nel buildelhető, és a letöltést követően a 'mvn jetty:run' paranccsal futtatható. A webszolgáltatás a http://localhost:8080/services/TempConvert címen érhető el, innen van linkelve a WSDL állomány is. Ezt megadtam a soapUInak, és készítettem két tesztesetet is. A soapUI projekt az src/test/resources/TempConvert-soapui-project.xml állományban található.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;a href="http://1.bp.blogspot.com/-G7GW-TvCFB0/UCrHmf3T9LI/AAAAAAAAJGE/usOu3olByI4/s1600/soapui.png" imageanchor="1" style="margin-left:1em; margin-right:1em"&gt;&lt;img border="0" height="227" width="320" src="http://1.bp.blogspot.com/-G7GW-TvCFB0/UCrHmf3T9LI/AAAAAAAAJGE/usOu3olByI4/s320/soapui.png" /&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;Persze úgy gondolom, hogy a funkcionalitást nem ezen a szinten kell tesztelni, hanem alacsonyabb rétegeket kell megszólítani, viszont nem rossz, ha ilyen jellegű teszt esetek is vannak, melyek gyakorlatilag a webszolgáltatás interfész visszafele kompatibilitását tesztelik. Azért, hogy ne kelljen ezeket kézzel indítgatni, a soapUI fejlesztői lehetővé tették, hogy a soapUI teszteket JUnit-ból is meg lehessen hívni, mi több, egy Maven repositoryt is felállítottak.&lt;/p&gt;

&lt;p&gt;Tehát a használathoz először a pom.xml-be kell felvenni a függőségeket. Érdekes, hogy amennyiben a FastInfoset-et nem vettem fel, volt, amikor elszállt.&lt;/p&gt;

&lt;pre class="brush: xml"&gt;
&amp;lt;repositories&amp;gt;
 &amp;lt;repository&amp;gt;
  &amp;lt;id&amp;gt;eviwareRepository&amp;lt;/id&amp;gt;
  &amp;lt;url&amp;gt;http://www.eviware.com/repository/maven2/&amp;lt;/url&amp;gt;
 &amp;lt;/repository&amp;gt;
&amp;lt;/repositories&amp;gt;

&amp;lt;dependencies&amp;gt;
 &amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;eviware&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;maven-soapui-plugin&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;4.5.1&amp;lt;/version&amp;gt;
  &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
 &amp;lt;/dependency&amp;gt;

 &amp;lt;!--&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;com.sun.xml.fastinfoset&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;FastInfoset&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.2.12&amp;lt;/version&amp;gt;
 &amp;lt;/dependency&amp;gt; --&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/pre&gt;

&lt;p&gt;A következő lépés a teszteset előkészítése. Először el kell indítani a webszolgáltatást, majd azon lefuttatni a soapUI teszteseteket. Nagyon jó &lt;a href="http://www.jroller.com/gmazza/entry/junit_web_service_testing"&gt;cikk található Glen Mazza's Weblogján&lt;/a&gt;, melyben azokat részletezi, hogy hogyan lehet JUnit-ból tesztelni a webszolgáltatásokat. Leírja, hogy hogyan kell webszolgáltatást elindítani az Endpoint osztály segítségével, beágyazott Jettyvel vagy Tomcattel, vagy hogyan lehet külön Tomcatben futó webszolgáltatást tesztelni. Én a már &lt;a href="http://jtechlog.blogspot.hu/2012/08/soa-using-java-web-services.html"&gt;előző cikkben&lt;/a&gt; is említett Endpointot választottam, mint pehelysúlyú megoldás, mely a Javaban található HTTP serveren indul el.&lt;/p&gt;

&lt;pre class="brush: java"&gt;
public class TempConvertIntegrationTest {

    private static String address;

    private static Endpoint ep;

    @BeforeClass
    public static void beforeClass() throws MalformedURLException {
        address = "http://localhost:9000/TempConvert";
        ep = Endpoint.publish(address, new TempConvert());
    }

    @AfterClass
    public static void afterClass() {
        ep.stop();
    }
}
&lt;/pre&gt;

&lt;p&gt;Csak elindítjuk a beépített HTTP servert a teszteset indításakor, és telepítjük rá a TempConvert webszolgáltatás, valamint a teszteset végén leállítjuk. Látszik, hogy a tesztelés http protokollon keresztül történik, végig a teljes lokális hálózati stacken, tehát olyan, mintha különálló kliens hívta volna meg.&lt;/p&gt;

&lt;p&gt;A következő lépésben már csak a soapUI tesztesetet kell elindítani.&lt;/p&gt;

&lt;pre class="brush: java"&gt;
@Test
public void testTempConvert() throws Exception {
  SoapUITestCaseRunner runner = new SoapUITestCaseRunner();
  runner.setProjectFile(
    "src/test/resources/TempConvert-soapui-project.xml");
  runner.setEndpoint(address);
  runner.run();
}
&lt;/pre&gt;

&lt;p&gt;Gyakorlatilag csak a soapUI projektfájl helyét kellett megadni, valamint a projektben definiált címet (ami a WSDL-ből jött) felül lehet írni a setEndpoint metódussal. Első indításkor ('mvn test') elég sokat kell várni, mert sok függősége van a soapUI-nak ('mvn dependency:tree'). A konzolra kiírt üzenetekből nagyon szépen látszik, hogy éppen mi történik, melyik suite-ot, test case-t futtatja, sikeres-e az assertion, stb. A főkönyvtárba *.log állományokat is írogat, hiba esetén megtalálhatók bennük a teljes http kérés és válasz is.&lt;/p&gt;

&lt;p&gt;Érdekességképpen ídeírok egy Groovy assertiont is.&lt;/p&gt;

&lt;pre&gt;
def utils = new com.eviware.soapui.support.GroovyUtils( context )
def holder = utils.getXmlHolder(messageExchange.responseContentAsXml)
def celsius = holder["//fahrenheit"]
log.info(celsius)
assert Integer.parseInt(celsius) == 212
&lt;/pre&gt;

&lt;p&gt;A soapUI ezen kívül még nagyon sok mindenre képes, kedvencem, hogy önmaga is tud webszolgáltatásként viselkedni, embedded Jetty-t indít, és még a választ is meg tudjuk adni, hogy mit adjon vissza, amit szintén script-ezhetünk, így a bejövő paraméterektől függően eltérő válaszokat adhatunk vissza. Ez rendkívül jól jön, amikor egy olyan webszolgáltatáshoz akarunk klienst fejleszteni, mely nem mindig elérhető. Ezen kívül használható terheléses tesztelésre is, valamint akár REST webszolgáltatásokat is hívhatunk, vagy újonnan JMS is tesztelhető vele.&lt;/p&gt; </content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/7550091435364332920/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2012/08/soapui-junit-teszteles.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7550091435364332920'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7550091435364332920'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/08/soapui-junit-teszteles.html' title='Webszolgáltatások integrációs tesztelése soapUI és JUnit használatával'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://1.bp.blogspot.com/-G7GW-TvCFB0/UCrHmf3T9LI/AAAAAAAAJGE/usOu3olByI4/s72-c/soapui.png' height='72' width='72'/><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2800563397160344751</id><published>2012-08-12T22:52:00.001+02:00</published><updated>2012-08-12T22:52:36.383+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='JAXB'/><category scheme='http://www.blogger.com/atom/ns#' term='JAX-WS'/><category scheme='http://www.blogger.com/atom/ns#' term='könyv'/><title type='text'>SOA Using Java Web Services</title><content type='html'>&lt;p&gt;Egy előző bejegyzésben, melyben Java tanuláshoz javasoltam forrásokat, említettem a &lt;a href="http://soabook.com/"&gt;Mark D. Hansen: SOA Using Java Web Services&lt;/a&gt; című könyvet, de most jutott arra időm, hogy végigolvassam a majdnem 600 oldalas könyvet. A post egy könyvleírás, de érdemes végigolvasni, egy-két trükköt, tippet olvasható a webszolgáltatások használatával kapcsolatban. Régebben már írtam egy &lt;a href="http://jtechlog.blogspot.hu/2009/11/jax-ws-melyviz.html"&gt;post-ot a JAX-WS-ről&lt;/a&gt;, ott is merítettem ebből a könyvből.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;a href="http://2.bp.blogspot.com/-6MR__NNLNLg/UCgXZRyqiPI/AAAAAAAAJFw/ojTcdYdnKKY/s1600/cover_300wide.jpg" imageanchor="1" style="margin-left:1em; margin-right:1em"&gt;&lt;img border="0" height="320" width="240" src="http://2.bp.blogspot.com/-6MR__NNLNLg/UCgXZRyqiPI/AAAAAAAAJFw/ojTcdYdnKKY/s320/cover_300wide.jpg" /&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;A könyv alapvetően a JAX-WS 2.0, JAXB 2.0, WS-Metadata 2.0 és a WSEE 1.2 szabványt mutatja be. A könyv nem új, 2007-ben jelent meg, de aktualitását még nem vesztette el, hiszen ugyan van már JAX-WS 2.2, JAX-B 2.2, de igazán kevés újdonság van benne, módosítás még kevesebb. A &lt;a href="http://jax-ws.java.net/nonav/2.2.1/docs/UsersGuide.html#2.0_Features"&gt;JAX-WS újdonságai&lt;/a&gt; között talán a &lt;a href="http://docs.oracle.com/javase/7/docs/api/javax/xml/ws/WebServiceFeature.html"&gt;WebServiceFeature&lt;/a&gt; megjelenése az érdekes, valamint a WS-Addressing említésre méltó. A JAXB &lt;a href="http://jcp.org/aboutJava/communityprocess/maintenance/jsr222/222ChangeLog.html"&gt;specifikáció&lt;/a&gt; vagy &lt;a href="http://jaxb.java.net/nonav/2.2.6/docs/ch02.html#jaxb-2-0-changelog"&gt;implementáció&lt;/a&gt; újdonságai között talán az &lt;a href="http://docs.oracle.com/javase/7/docs/api/javax/xml/bind/annotation/XmlSeeAlso.html"&gt;XmlSeeAlso&lt;/a&gt; annotáció lehet érdekes.&lt;/p&gt;

&lt;p&gt;Igaz, a könyv címében benne van a SOA, alapvetően nem foglalkozik a SOA architektúrával, csak azzal, hogy egy SOA architektúrába hogyan tudjuk a saját alkalmazásunkat legjobban beilleszteni. Arról viszont nagyon részletesen szól, hogy azt hogyan kell felépíteni, milyen rétegekből álljon, milyen eszközöket érdemes használni, és hogy ezek az eszközök hogyan működnek. Nagyon jó és részletes áttekintés található a könyvben az említett szabványok tulajdonságairól, de a részletekbe már nem annyira megy bele. Említi ugyan a REST-et, de akkor még csak a JAX-WS-be próbálja Provider-rel és Dispatch-csel beilleszteni, a JAX-RS-t meg sem említi. A SOAP, WSDL szabványra csak hivatkozik, nem magyarázza, nem tárgyalja részletesen.&lt;/p&gt;

&lt;p&gt;A könyv egy elég jó bevezetővel indul, ahol megnyugtatja az olvasót, hogy nem meglepő, ha nem tudja elsőre átlátni a webszolgáltatások világát, ugyanis tényleg nem egyszerű. A webszolgáltatások írását biztosító eszközrendszer tulajdonságait három részre bontja: hívás (invocation), szerializáció (serialization) és telepítés (deployment). Az hívás alatt azt érti, hogy hogyan kerül meghívásra egy adott webszolgáltatás az adott architektúrán, milyen rétegeken megy keresztül, hogyan talál a megfelelő helyre. A szerializáció biztosítja a paraméterek, visszatérési értékek, kivételek átvitelét. A telepítés azt írja le, hogyan lehet az adott technológiával implementált webszolgáltatás komponenst telepíteni, és hogyan inicializálja, indítja be az adott környezet.&lt;/p&gt;

&lt;p&gt;A könyv szerintem legerősebb fejezete a második fejezet, amikor végigmegy a fentebb említett szabványokon, és hívás/szerializáció/telepítés aspektusok alapján sorba veszi őket. Ennek a fejezetnek dőltem be, ugyanis itt több olyan dolgot is említ, melyre utána később nem tér ki. Ha kitérne, egy teljes technológiát lefedő könyv lenne, de nem is állna meg 600 oldalnál.&lt;/p&gt;

&lt;p&gt;A könyv már az 1. fejezettől kezdve emlegeti, hogy a JAX-WS inkább a bottom up, általa "Start from Java"-nak hívott megközelítést támogatja. Ez azt jelenti, hogy adott a Java forrás, és az alapján szeretnénk webszolgáltatást kiajánlani. Gyakran azonban a top down megközelítésre (előbb a WSDL adott, ő "Start from WSDL"-nek nevezi), vagy inkább a meet in the middle (általa "Start from Java and WSDL"-nek nevezett) megközelítésre van szükség, mikor adott a WSDL is, és egy létező rendszer is. Ekkor gyakran tapasztalhatjuk, hogy a kettő nem felel meg egymásnak. Az üzleti objektumaink felépítése, elnevezése általában nem felel meg annak, amit interfésznek is ki szeretnénk, vagy ki kell ajánlani. A könyv un. wrapper osztályok alkalmazását javasolja. Gyakorlatilag egyrészt kigenerálja az osztályokat a WSDL-ből, valamint meghagyja az üzleti objektumokat is. A kettő között másolást végez. Ettől egyrészt tisztább lesz a kód, viszont több manuális munka van vele. A másolást getter/setter hívásokkal oldja meg, és javasolja, hogy ezeket érdemes különszervezni. Nem említi, hogy erre vannak kész megoldások, pl. BeanUtils.copyProperties vagy a &lt;a href="http://dozer.sourceforge.net/"&gt;Dozer&lt;/a&gt;. Javasolja még azt is, hogy XSLT-vel is lehet konvertálni a megfelelő formátumra.&lt;/p&gt;

&lt;p&gt;A könyv 3. fejezete a REST-et tárgyalja. Furcsa a sorrend, az író azzal magyarázza, hogy első körben érdemes megérteni a webszolgáltatásokat a SOAP boríték nélkül. Erre ugyanúgy a JAX-WS-t használja, és XML-t küld át. Erre manapság már ott van a JAX-RS. Amúgy nagyon lehúzza a REST-et, hogy alkalmatlan a SOA-ra az interfész leíró nyelv hiánya miatt. Azóta ott a &lt;a href="http://en.wikipedia.org/wiki/Web_Application_Description_Language"&gt;WADL&lt;/a&gt;, de nem annyira elterjedt még.&lt;/p&gt;

&lt;p&gt;A 4. fejezet szól kicsit a WSDL-ről és a SOAP-ról, egy nagyon jó leírás található az RPC/Literal, Document/Literal és Document/Literal Wrapped közötti különbségekről. A fejezet alapul vette a gyakran idézett &lt;a href="http://www.ibm.com/developerworks/webservices/library/ws-whichwsdl/"&gt;Which style of WSDL should I use?&lt;/a&gt; cikket is. Az előbb már említett integrációs réteget itt írja le, valamint egy workaroundot, hogy hogy lehet megkerülni azt a kötöttséget, hogy egy WSDL-hez csak egy Java osztály tartozhat. (Igen, két osztály esetén tenni kell elé egy Facade osztályt, mely delegálja tovább a hívásokat.)&lt;/p&gt;

&lt;p&gt;A következő fejezet a JAXB alapfogalmakkal ismertet meg. Érdekes a Binding Language-ről szóló leírás, valamint az XmlAdapter használata típus konverzióra. Ennek használatát nehézkesnek ítéli, nem javasolja nagyobb, bonyolultabb struktúrák konverziójára. Nem igazán megy bele a JAXB részleteibe.&lt;/p&gt;

&lt;p&gt;A 6. és 7. fejezet a JAX-WS fejlesztést mutatja meg a gyakorlatban, az előbbiben egy klienst, az utóbbiban egy szervert fejleszt. Szépen leírja a hívási modellt, majd sorra a példák: natív XML küldése, SOAP küldése, Castor XML mapping használata, aszinkron web szolgáltatás hívás, SOAP message handlerek, hibakezelés. Valamint említi a &lt;a href="http://docs.oracle.com/javase/7/docs/api/javax/xml/ws/Endpoint.html"&gt;Endpoint&lt;/a&gt; osztályt is, mellyel Java SE-ben lehet webszolgáltatás futtatni. A Java SE-ben ugyanis van egy pehelysúlyú &lt;a href="https://blogs.oracle.com/michaelmcm/entry/http_server_api_in_java"&gt;HTTP server&lt;/a&gt;. Ez pl. integrációs tesztelésre tökéletes.&lt;/p&gt;

&lt;p&gt;A 8. fejezet azt írja le, hogy lehet alkalmazásszerverbe webszolgáltatásokat telepíteni. Ezt Glassfish-re írja le. Sajnos hiányzik, hogy mi van csak egy web konténer (pl. Tomcat esetén). Tény, hogy ezzel a szabvány sem foglalkozik. A biztonságot is hamar elintézi egy BASIC autentikációval. Viszont említi az OASIS XML Catalog 1.1-et.&lt;/p&gt;

&lt;p&gt;A 9. fejezet egy példa alkalmazás, mely az eBay, Amazon és Yahoo! szolgáltatásai felé húz egy alkalmazást, melyet szintén meg lehet hívni SOAP és REST webszolgáltatásokon keresztül is. Itt nagyon jó a bridge tervezési minta használata, csak ezért is érdemes elolvasni a fejezetet.&lt;/p&gt;

&lt;p&gt;A 10. fejezet az AJAX és a Java webszolgáltatások kapcsolatáról ír, azt hiszem ma már senki nem így használja. Konkrétan natívan használja a XMLHttpRequest-et, böngészőfüggetlenül implementálja, és XML-t küld. Manapság már valamilyen JavaScript keretrendszerrel oldjuk ezt meg, és JSON-nal. A 11. fejezet egy saját SOA-J keretrendszer fejlesztéséről ír, melyet a könyv szerzőjén kívül szerintem még senki nem használt, így nem is érdemes rá szót vesztegetni.&lt;/p&gt;

&lt;p&gt;A könyv mintapéldái elérhetők, érdekes módon félig Maven-nel build-elődnek, de az alkalmazásszerverre deploy, bizonyos generálások Ant task-kal történnek. Furcsa, hogy nem hív Ant-ot Maven-ből, vagy nem valami Maven JAXB és JAX-WS plugin-eket használ. Bár ez utóbbit megértem, mert elég nagy a kavar körülöttük.&lt;/p&gt;

&lt;p&gt;Kinek érdemes elolvasnia a könyvet? Aki a JAX-WS világában frissen el akar merülni, annak nagyon javaslom. A JAXB-re szerintem jobb a Java EE tutorial, de a JAX-WS-re olvasmányosabb ez, és sokkal több háttérinformációt tartalmaz, kicsit kitekint, hogy valós projektekben milyen problémák szoktak előfordulni, és hogyan kell azokat megoldani. Szerintem a legjobb fejezet a 2. fejezet, mely az említett szabványok összes tulajdonságait, lehetőségeit végigpörgeti, példa nélkül. Aki még nem írt ilyent, annak jók a gyakorlati részek is, de aki már egy-kettőt összedobott, nem fog újdonságot találni, kivéve talán a Dispatch/Provider intenzív használatát. Gyakorlottabb webszolgáltatás fejlesztők sok újdonságot nem fognak találni, nekik elég, ha a 2. fejezetet végigpörgetik, hogy minden tulajdonságáról tudnak-e az adott szabványokról.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/2800563397160344751/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2012/08/soa-using-java-web-services.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2800563397160344751'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2800563397160344751'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/08/soa-using-java-web-services.html' title='SOA Using Java Web Services'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://2.bp.blogspot.com/-6MR__NNLNLg/UCgXZRyqiPI/AAAAAAAAJFw/ojTcdYdnKKY/s72-c/cover_300wide.jpg' height='72' width='72'/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1949829407110462171</id><published>2012-04-22T23:14:00.001+02:00</published><updated>2014-02-02T16:23:11.594+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='EclipseLink'/><category scheme='http://www.blogger.com/atom/ns#' term='Hibernate'/><category scheme='http://www.blogger.com/atom/ns#' term='JPA'/><title type='text'>JPA lazy loading</title><content type='html'>&lt;p&gt;Technológiák: JPA 2.0, EclipseLink 2.3.2, Hibernate 4.1.2&lt;/p&gt;

&lt;p&gt;Gyakorta találkozunk JPA használatakor a lazy loading fogalmával (vagy más néven deferred loading, lazy 
fetching, on-demand fetching, just-in-time reading, indirection, stb.), azonban használata koránt sem olyan triviális, mint amilyennek tűnik. A &lt;a href="http://download.oracle.com/otndocs/jcp/persistence-2.0-fr-eval-oth-JSpec/"&gt;JSR 317: Java Persistence API, Version 2.0&lt;/a&gt; specifikáció is viszonylag szűkszavúan nyilatkozik róla. Annyit ír, hogy @Basic, @OneToOne, @OneToMany, @ManyToOne, @ManyToMany és az @ElementCollection annotációknál használatos, és ez egy &lt;emp&gt;hint&lt;/emp&gt; a perzisztencia megvalósításnak, hogy az adott property-t vagy kapcsolatot nem kell azonnal betölteni, csak az első hozzáférés alkalmával. Egy helyen emeli még ki, amikor deszerializált objektumot kell merge-ölni, és lazy loading van megadva, akkor a különböző implementációk máshogy viselkedhetnek, ezért amennyiben a persistence provider-t cserélgetni szeretnénk, nem érdemes lazy loadingolt mezőn merge-öt használni. A JPA megfogalmazásában a fetch type lazy késleltetett betöltés esetén, és eager, ha azonnal be kell tölteni.&lt;/p&gt;

&lt;p&gt;Miért is érdemes lazy loadingot alkalmazni? Alapvetően teljesítménynövelés céljából. Először meg kell különböztetni a két esetet, mikor egy entitás egy mezőjére, vagy egy kapcsolatra tesszük rá. Az előbbi akkor lehet hasznos, amennyiben egy entitás nem minden mezőjét akarjuk mindig betölteni, mert vagy túl sok van neki, vagy túl nagyok. Utóbbi esetre egy példa egy hallgatói nyilvántartásban a hallgatóhoz tartozhat egy fénykép is, de ez nagy, blob-ban tároljuk, és egy listázó képernyőn nem akarjuk megjeleníteni, csak a részletek képernyőn. Ezzel vigyázni kell, mert ha nem megfelelően használjuk, azaz nincs nagy mennyiségű mező vagy nem nagy méretű, akkor többet ártunk, mint használunk. Ugyanis az újbóli adatbázishoz fordulás erőforrás igényesebb lehet, mint pár plusz adat lekérése. Kapcsolódó entitások esetében példa, ha egy listázó képernyőn nem akarjuk a számlához tartozó tételeket megjeleníteni, kivéve a részletek képernyőn, ahol szükséges őket felsorolni. Háttérben ez úgy történik, hogy egy proxy osztály kerül generálásra (EclipseLink és Hibernate esetében eltérően), és nem tölti be a lekérdezés esetén a megfelelő mezőt vagy kapcsolatot, és így kerül példányosításra a proxy objektum. Amikor a proxy objektumtól mégis elkérésre kerül a nem betöltött mező vagy osztály, akkor próbálkozik a persistence provider a betöltéssel.&lt;/p&gt;

&lt;p&gt;Postomban a lazy loading viselkedését vizsgálom a két legelterjedtebb provider, az &lt;a href="http://www.eclipse.org/eclipselink/"&gt;EclipseLink&lt;/a&gt; és a &lt;a href="http://www.hibernate.org/"&gt;Hibernate&lt;/a&gt; esetében. A &lt;a href="http://jtechlog.blogspot.com/2009/05/hibernate-eclipselink-atallas.html"&gt;Hibernate EclipseLink átállás&lt;/a&gt; post részletesen leírja, hogyan lehet átállni Hibernate-ről EclipseLink-re, valamint ebben leírom, mi az a weaving, Java agent és instrumentation, így ezekre itt nem térek ki részletesebben.&lt;/p&gt;

&lt;p&gt;Példaként már egy &lt;a href="http://jtechlog.blogspot.com/2010/09/entitasok-auditalasa-hibernate-envers.html"&gt;előző postomban&lt;/a&gt; bemutatott esetet használok, kicsit módosítva.&lt;/p&gt;

&lt;img src="http://yuml.me/0946499a" alt="Osztálydiagram" width="500" height="77" /&gt;

&lt;!-- [Employee|id;name;cv]++1-*[Phone|type;number]
[EmployeeService|listEmployees;findEmployeeById;mergeEmployee]-[Employee] --&gt;

&lt;p&gt;A példaprogram letölthető a &lt;a href="https://github.com/vicziani/jtechlog-lazy"&gt;GitHub-ról&lt;/a&gt;. A példaprogram a mvn jetty:run parancs kiadásával már futtatható is. A példaprogram jó példa arra is, hogyan lehet az EclipseLink-et vagy a Hibernate-et Spring-gel integrálni. Az alkalmazásba beágyazott HyperSQL adatbázis-kezelő biztosítja a perzisztenciát. A böngészőbe a http://localhost:8080 címet írva bejön egy oldal (/employees.html), melyet a EmployeeController.listEmployees metódusa szolgál ki, mely a DefaultEmployeeService.listEmployees metódusát hívja. Ez az EntityManager.createNamedQuery-t hívja egy select-tel. Ez adja vissza a List&amp;lt;Employee&gt; struktúrát, melyet a JSP oldal megjelenít. Az alkalmazott nevére kattintva annak részletes adatai jelennek meg, az EmployeeController.findEmployeeById metódusa hívja a EmployeeService.findEmployeeById metódusát, mely a EntityManager.find metódusát hívja, ami azonosító alapján tölti be az adott entitást. Két employee rekord szerepel az adatbázisban, mindkettő 2-2 telefonszámmal (, ahogy az init.sql-ben látható). Az Employee esetén egyrészt a cv mezőt vizsgáljuk, másrészt a List&amp;lt;Phone&amp;gt; kapcsolatot. A service-ben szereplő metódusok hívásakor jön létre a persistence context, majd annak lefutásakor az lezárásra kerül. Az entitások a persistence context lezárásakor detached állapotba kerülnek. A kódot bőséges naplózással láttam el, valamint bekapcsoltam, hogy a persistence provider írja ki a lefuttatott sql parancsokat. Így jól lehet látni, hogy milyen sql-eket ad ki, mikor még él a persistence context, és milyeneket mikor már lezárásra került.&lt;/p&gt;

&lt;h3&gt;EclipseLink&lt;/h3&gt;

&lt;p&gt;Az EclipseLink-et úgy konfiguráltam, hogy static weaving legyen, azaz fordítási időben instrumentálja a class fájlokat. Ehhez a pom.xml-ben a eclipselink-staticweave-maven-plugin-t használtam. Valamint a persistence.xml-ben a eclipselink.weaving property értékét static-ra kellett állítani. Build közben a következőket írja ki a weavinggel kapcsolatban:&lt;/p&gt;

&lt;pre&gt;
[EL Finest]: 2012-04-22 01:41:28.453--ServerSession(3980107)--
Thread(Thread[main,5,main])--Begin predeploying Persistence 
Unit lazyPersistenceUnit; session lazyPersistenceUnit; state 
Initial; factoryCount 0

[EL Finest]: 2012-04-22 01:41:29.062--ServerSession(3980107)--
Thread(Thread[main,5,main])--Begin weaver class transformer 
processing class [jtechlog/lazy/service/Phone].
[EL Finest]: 2012-04-22 01:41:29.078--ServerSession(3980107)--
Thread(Thread[main,5,main])--End weaver class transformer 
processing class [jtechlog/lazy/service/Phone].
&lt;/pre&gt;

&lt;p&gt;Alapértelmezetten az EclipseLink cache be van kapcsolva, ezért a persistence.xml-ben kikapcsoltam azért, hogy követni lehessen, hogy milyen SQL utasításokat ad ki.&lt;/p&gt;

&lt;pre&gt;
&amp;lt;property name="eclipselink.cache.shared.default" value="false"/&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Első körben azt az alapértelmezett esetet vizsgáltam, mikor nem tettem semmilyen annotációt a CV mezőre. A listázó képernyőn a következőt kaptuk:&lt;/p&gt;

&lt;pre class="brush: sql"&gt;
SELECT ID, CV, EMP_NAME FROM EMPLOYEE
-- Persistence context lezárása
SELECT ID, PHONE_NUMBER, PHONE_TYPE, EMPLOYEE_ID FROM PHONE 
  WHERE (EMPLOYEE_ID = ?)
SELECT ID, PHONE_NUMBER, PHONE_TYPE, EMPLOYEE_ID FROM PHONE 
  WHERE (EMPLOYEE_ID = ?)
&lt;/pre&gt;

&lt;p&gt;Az adott alkalmazott kilistázásakor hasonlóképp működik.&lt;/p&gt;

&lt;pre class="brush: sql"&gt;
SELECT ID, CV, EMP_NAME FROM EMPLOYEE WHERE (ID = ?)
-- Persistence context lezárása
SELECT ID, PHONE_NUMBER, PHONE_TYPE, EMPLOYEE_ID FROM PHONE 
  WHERE (EMPLOYEE_ID = ?)
&lt;/pre&gt;

&lt;p&gt;Először vizsgáljuk csak a cv mezőt. Azt kaptuk, amit vártunk, minden mezőt lekérdezett mindkét képernyőn. Aztán a CV mezőre rátettem a @Lob annotációt, a helyzet változatlan volt. Amennyiben rátettem a @Basic(fetch = FetchType.LAZY) annotációt a cv mezőre, máris megváltozott a helyzet (, függetlenül attól, hogy a @Lob rajta volt-e vagy sem).&lt;/p&gt;

&lt;pre class="brush: sql"&gt;
SELECT ID, EMP_NAME FROM EMPLOYEE
-- Persistence context lezárása
SELECT ID, CV, EMP_NAME FROM EMPLOYEE WHERE (ID = ?)
SELECT ID, PHONE_NUMBER, PHONE_TYPE, EMPLOYEE_ID FROM PHONE 
  WHERE (EMPLOYEE_ID = ?)
SELECT ID, EMP_NAME FROM EMPLOYEE WHERE (ID = ?)

SELECT ID, CV, EMP_NAME FROM EMPLOYEE WHERE (ID = ?)
SELECT ID, PHONE_NUMBER, PHONE_TYPE, EMPLOYEE_ID FROM PHONE 
  WHERE (EMPLOYEE_ID = ?)
SELECT ID, EMP_NAME FROM EMPLOYEE WHERE (ID = ?)
&lt;/pre&gt;

&lt;p&gt;Valamint az egy entitást bemutató képernyőn:&lt;/p&gt;

&lt;pre class="brush: sql"&gt;
SELECT ID, EMP_NAME FROM EMPLOYEE WHERE (ID = ?)
-- Persistence context lezárása
SELECT ID, CV, EMP_NAME FROM EMPLOYEE WHERE (ID = ?)
SELECT ID, PHONE_NUMBER, PHONE_TYPE, EMPLOYEE_ID FROM PHONE 
  WHERE (EMPLOYEE_ID = ?)
SELECT ID, EMP_NAME FROM EMPLOYEE WHERE (ID = ?)
&lt;/pre&gt;

&lt;p&gt;Az addig rendben van, hogy az első select-ben ezek után nem kérdezte le a cv mezőt. Láthatjuk, hogy a persistence context lezárása után lekérdezi immár az alkalmazotthoz tartozó összes mezőt, köztük a CV-t is. Ez az EclipseLink egy speciális viselkedése, hogy a persistence context lezárása után is képes sql utasításokat kiadni, betöltve ezzel a lazy-vel definiált mezőket. Az azonban számomra rejtély, hogy miért kell még egy select-et kiadni az employee táblán.&lt;/p&gt;

&lt;p&gt;Most pedig nézzük a kapcsolatot. Látható, hogy a @OneToMany-n alapértelmezetten a fetch type lazy, ugyanis a persistence context lezárása után kéri le a persistence provider a telefonszámokat. Ráadásul alkalmazottanként egy külön select-ben. Itt is látható az EclipseLink különleges viselkedése, hogy a persistence context lezárása után is le tudja kérdezni a még be nem töltött entitásokat. A szabvány amúgy nem írja le, hogy ilyenkor mi legyen. A persistence provider megpróbálhatja feloldani a nem betöltött kapcsolatokat, mint ahogy az EclipseLink is teszi, kivételt dobhat, ahogy a Hibernate, mint azt később látni fogjuk, vagy inicializálatlanul hagyja az adott mezőket. A @OneToMany, @ManyToMany és @ElementCollection esetén az alapértelmezett fetch type lazy, a @Basic, @OneToOne és @ManyToOne esetén eager.&lt;/p&gt;

&lt;p&gt;A következő lépésben beállítottam a @OneToMany annotációnál a fetch paramétert FetchType.EAGER értéket. Az eredmény mind a két esetben ugyanaz volt, mint az előbb, azzal a különbséggel, hogy a kapcsolódó telefonszámokat nem a persistence context lezárása után kérte el, hanem még előtte. Azaz ugyanúgy több select-et futtatott, de mindet a persistence context lezárása előtt, azaz mielőtt átadta volna a vezérlést a view-nak.&lt;/p&gt;

&lt;p&gt;Azon, hogy ne több select-et futtasson le, egyféleképpen tudtam segíteni, és kizárólag a lekérdezés esetén. Átírtam a következőre:&lt;/p&gt;

&lt;pre&gt;
select distinct e from Employee e join fetch e.phones
&lt;/pre&gt;

&lt;p&gt;A distinct használata kötelező, mert ha nem tettem ki, akkor egy alkalmazottat annyiszor hozott le, amennyi telefonszáma volt. A háttérben ugyanis itt egy join van, a következő lekérdezésnek megfelelő select-et futtatja le a persistence provider:&lt;/p&gt;

&lt;pre&gt;
select distinct e, p from Employee e join e.phones p
&lt;/pre&gt;

&lt;p&gt;Viszont a p eredmény értékét egyszerűen nem használja fel, hanem eldobja. A distinct használata tehát szükséges ilyenkor, ekkor az alkalmazottak listázásakor a következő select futott le:&lt;/p&gt;

&lt;pre class="brush: sql"&gt;
SELECT DISTINCT t1.ID, t1.CV, t1.EMP_NAME, t0.ID, t0.PHONE_NUMBER, 
  t0.PHONE_TYPE, t0.EMPLOYEE_ID 
  FROM PHONE t0, EMPLOYEE t1 WHERE (t0.EMPLOYEE_ID = t1.ID)
&lt;/pre&gt;

&lt;p&gt;Különösen érdekes lehet még a lazy loaddal bejelölt, és nem betöltött entitások kezelése cascade merge esetén. Ennek tesztelésére készítettem egy oldalt, mely betölti az alkalmazottat, telefonszámokat lazy fetch-re állítottam, és megjelenít egy űrlapot. Az Employee példányt session-be tettem (EditEmployeeController), majd a detach-elt példányt az űrlap postjakor módosítottam, majd merge-öltem vissza (EmployeeService.mergeEmployee()). Minden hibátlanul működött, a módosítás megtörtént, a telefonszámok érintetlenül maradtak.&lt;/p&gt;

&lt;p&gt;Aztán kipróbáltam azt is, hogy a post után még hozzáadtam egy telefonszámot is. Az EclipseLink betöltötte a telefonszámokat, elvégezte az update-et az employee táblán, majd történt egy insert a phone táblába.&lt;/p&gt;

&lt;pre class="brush: java"&gt;
employee.addPhone(new Phone("home", "123"));
&lt;/pre&gt;

&lt;p&gt;Van egy metódus arra, hogy megvizsgáljuk, hogy az adott kapcsolatok, melyek lazyvel vannak jelölve, betöltésre kerültek-e. A következőképpen használhatjuk:&lt;/p&gt;

&lt;pre class="brush: java"&gt;
Persistence.getPersistenceUtil().isLoaded( 
            em.find(Employee.class, 42), "phoneNumbers"); 
&lt;/pre&gt;

&lt;h3&gt;Hibernate&lt;/h3&gt;

&lt;p&gt;Ugyanazzal az alapfelállással indulok, mint az EclipseLink esetében, azaz nincs plusz annotáció, és a @OneToMany annotációnál sincs plusz paraméter. Az előző cikkem óta a Hibernate 3.3.0.CR2-ben a bájtkód módosítását a CGLib helyett a javassist végzi (, amiről szintén írtam &lt;a href="http://jtechlog.blogspot.com/2011/12/instrumentation-javassist-tal.html"&gt;korábban&lt;/a&gt;) , &lt;a href="https://hibernate.onjira.com/browse/HHH-2506"&gt;ugyanis&lt;/a&gt; az előbbi nagyon inaktív projekt lett, így leváltották. Mindkét oldalt betöltve a következő hibaüzenetet kapom:&lt;/p&gt;

&lt;pre&gt;
org.hibernate.LazyInitializationException: failed to lazily initialize a 
collection of role: jtechlog.lazy.service.Employee.phones, no session or 
session was closed
 at org.hibernate.collection.internal.AbstractPersistentCollection.
throwLazyInitializationException(AbstractPersistentCollection.java:393)
    ...
&lt;/pre&gt;

&lt;p&gt;Ahogy említettem, csak az EclipseLink sajátossága az, hogy lazy loadinggal megjelölt kapcsolatban részt vevő entitásokat a persistence context lezárása után (azaz detach állapotban lévő entitásokat is) be tud tölteni. A Hibernate ezt nem tolerálja, amennyiben nem betöltött mezőre történik hivatkozás, és a persistence context nincs nyitva, ezt a hibaüzenetet kapom. A Hibernate-tel való ismerkedéskor ez a leggyakoribb hiba.&lt;/p&gt;

&lt;p&gt;A probléma megoldására többfajta megoldás létezik:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Eager fetch-t állítunk be a @OneToMany annotáció paraméterében.&lt;/li&gt;
 &lt;li&gt;Ha entitást akarunk a view rétegnek levinni, akkor megtehetjük azt is, hogy amíg a persistence context aktív, meghívjuk a megfelelő getter metódust.&lt;/li&gt;
 &lt;li&gt;A fentivel ekvivalens, ha a view rétegnek nem entitást adunk, hanem egy un. data transfer object-et. Ezt még addig feltöltöm (gyakorlatilag az előző esethez hasonlóan a gettereket hívom), míg a persistence context aktív, így nincs probléma. Ez több programozási feladattal jár, a DTO-k plusz réteget jelentenek.&lt;/li&gt;
 &lt;li&gt;Külön lekérdezést alkalmazunk fetch join-nal, vagy un. projection query-t, vagy akár JDBC-vel is operálhatunk. Ez utóbbi még tervezési minta is Fast Lane Reader, mikor az ORM réteget kikerüljük, tipikusan teljesítménynövelés miatt, és alacsonyabb technológiával dolgozunk.&lt;/li&gt; 
 &lt;li&gt;Az eddigi megoldások azt célozták meg, hogy legyenek betöltve a megfelelő objektumok. A következők azt célozzák meg, hogy ne kelljen detach-elni. Amíg lehet, nyitva hagyjuk a persistence context-et, ha kell, a view réteg lefutása után zárjuk csak le.&lt;/li&gt;
 &lt;li&gt;Vagy alkalmazás által vezérelt tranzakciókezelést vagy persistence context-et, vagy extended persistence context-et használunk. Ugyanis alapértelmezetten egy persistence context a tranzakció lezárásáig tart. Programból mi is vezérelhetjük a tranzakciókat. Vagy az EntityManager létrehozását EntityManagerFactory-n keresztül (createEntityManager metódus), és lezárását (a close metódusával). Vagy stateful session bean (EJB) esetén használhatunk extended persistence context-et, ez nem csak egy tranzakciónyi, hanem a bean élettartamáig élhet, programozottan lehet lezárni.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Amennyiben a @OneToMany annotáció paraméterében eager fetch-t állítunk be, az alkalmazottak listázása ugyanúgy történik, mint az EclipseLink esetén, azaz három query, először az alkalmazottak, majd alkalmazottanként a telefonszámok lekérdezése.&lt;/p&gt;

&lt;p&gt;Azonban a Hibernate az EntityManager.find metódus használatakor már okosabb, mint az EclipseLink, egy left outer joint is tartalmazó lekérdezést futtat:&lt;/p&gt;

&lt;pre class="brush: sql"&gt;
select employee0_.id as id0_1_, employee0_.cv as cv0_1_, 
  employee0_.EMP_NAME as EMP3_0_1_, phones1_.employee_id 
  as employee4_0_3_, phones1_.id as id3_, phones1_.id as id1_0_, 
  phones1_.employee_id as employee4_1_0_, 
  phones1_.PHONE_NUMBER as PHONE2_1_0_, 
  phones1_.PHONE_TYPE as PHONE3_1_0_ 
  from Employee employee0_ 
  left outer join Phone phones1_ 
  on employee0_.id=phones1_.employee_id where employee0_.id=?
&lt;/pre&gt;

&lt;p&gt;Amennyiben a getter metódusokkal akarjuk az entitást inicializálni, vigyázzunk, nem mindegy, hogy mit hívunk meg, mert pl. a getPhones(), getPhones().get(1).getId() nem megfelelő, sőt a getPhones().size() sem, hanem pl. érdemes az első elem nem id mezőjét lekérni. Ez ezért van így, mert a Hibernate úgy módosítja a bájtkódot, hogy a lista létrejön, abban az Employee objektumok is, de csupán az id mezőjük van feltöltve, a többi getter hívás indukálja a további betöltéseket. Ez számomra egy kicsit visszás, mert a kódot olyan technikai részekkel gyarapítjuk, mely üzleti szempontból teljesen lényegtelen, ráadásul az alsóbb rétegnek kell ilyenkor a felsőbb réteg igényeiről tudnia, hogy a visszaadott adat hogy kerül megjelenítésre.&lt;/p&gt;

&lt;p&gt;A join fetch-es lekérdezés ugyanúgy működik itt is, mint az EclipseLink esetén, itt a legenerált SQL kicsit másképp néz ki, a Hibernate az inner join kulcsszót használja.&lt;/p&gt;

&lt;pre class="brush: sql"&gt;
select distinct employee0_.id as id0_0_, phones1_.id as id1_1_, 
  employee0_.cv as cv0_0_, employee0_.EMP_NAME as EMP3_0_0_, 
  phones1_.employee_id as employee4_1_1_, 
  phones1_.PHONE_NUMBER as PHONE2_1_1_, 
  phones1_.PHONE_TYPE as PHONE3_1_1_, 
  phones1_.employee_id as employee4_0_0__, 
  phones1_.id as id0__ 
  from Employee employee0_ 
  inner join Phone phones1_ 
  on employee0_.id=phones1_.employee_id
&lt;/pre&gt;

&lt;p&gt;Persze a ebben az esetben az findEmployeeById metódust is át kellett írni, hogy ne az EntityManager.find metódusát használja, hanem szintén fetch join-os lekérdezést:&lt;/p&gt;

&lt;pre class="brush: java"&gt;
return em.createNamedQuery("findEmployeeById", Employee.class)
  .setParameter("id", id).getSingleResult();
&lt;/pre&gt;

&lt;p&gt;Valamint a NamedQuery:&lt;/p&gt;

&lt;pre class="brush: java"&gt;
@NamedQuery(name = "findEmployeeById", 
  query = "select distinct e from Employee e join fetch e.phones where e.id = :id")
&lt;/pre&gt;

&lt;p&gt;Megoldás lehet az is, hogy ha a persistence context tranzakciónyi, akkor a view rétegben kell a tranzakciót nyitni és zárni. Ezt nevezik transactional view-nak. Ennek továbbfejlesztése, hogy nem a tranzakciót nyitjuk a view-ban, hanem az entity manager-t, ennek neve az "Open EntityManager in View" minta használata, és kb. ugyanazon előnyökkel és hátrányokkal rendelkezik. Ehhez a következőt kell hozzáadni a web.xml-hez:&lt;/p&gt;

&lt;pre class="brush: xml"&gt;
&amp;lt;filter&amp;gt;
    &amp;lt;filter-name&amp;gt;openEntityManagerInViewFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;filter-class&amp;gt;org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter&amp;lt;/filter-class&amp;gt;
&amp;lt;/filter&amp;gt;
&amp;lt;filter-mapping&amp;gt;
    &amp;lt;filter-name&amp;gt;openEntityManagerInViewFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;*.html&amp;lt;/url-pattern&amp;gt;
&amp;lt;/filter-mapping&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Itt az történik, hogy a http kérés beérkeztekor a filter nyit EntityManager-t, azaz persistence context-et, és az adott szálhoz rendeli. A tranzakció kezdésekor a szolgáltatásrétegben a szálhoz rendelt EntityManager-hez kapcsolódik. Lefut a flush, majd a commit a szolgáltatás végén, ha minden rendben ment. Majd meghívásra kerül a view. Ennek visszaadása után zárja le csak a filter az EntityManager-t. Bár egyszerű és gyors megoldásnak tűnik, én nagy terhelésű rendszer esetén nem javasolnám a használatát. Egyrészt többen írják, hogy lassabb, bár saját mérési eredményeim nincsenek. Valamint ahhoz tartom magam, hogy az ilyen jellegű dolgokat minimális ideig tartsunk nyitva. Egyszerű, párfelhasználós, vagy pilot projekt esetén viszont jól jöhet.&lt;/p&gt;

&lt;p&gt;OpenEntityManagerInViewFilter helyett használhatnánk OpenEntityManagerInViewInterceptor-t is, mely az application contextben jön létre, így hozzáfér az abban lévő bean-ekhez.&lt;/p&gt;

&lt;p&gt;Itt még figyeljük meg a lekérdezéseket:&lt;/p&gt;

&lt;pre class="brush: sql"&gt;
select employee0_.id as id0_, employee0_.cv as cv0_, 
  employee0_.EMP_NAME as EMP3_0_ from Employee employee0_
-- Persistence context lezárása
select phones0_.employee_id as employee4_0_1_, 
  phones0_.id as id1_, phones0_.id as id1_0_, 
  phones0_.employee_id as employee4_1_0_, 
  phones0_.PHONE_NUMBER as PHONE2_1_0_, 
  phones0_.PHONE_TYPE as PHONE3_1_0_ from Phone phones0_ 
  where phones0_.employee_id=?
select phones0_.employee_id as employee4_0_1_, 
  phones0_.id as id1_, phones0_.id as id1_0_, 
  phones0_.employee_id as employee4_1_0_, 
  phones0_.PHONE_NUMBER as PHONE2_1_0_, 
  phones0_.PHONE_TYPE as PHONE3_1_0_ 
  from Phone phones0_ where phones0_.employee_id=?
&lt;/pre&gt;

&lt;p&gt;Gyakorlatilag ugyanaz, mint az EclipseLink esetén, azzal a különbséggel, hogy a Hibernate mindenütt alias-okat használ.&lt;/p&gt;

&lt;p&gt;Az alkalmazás által gyártott EntityManager használatát nem javaslom, hiszen nagyon oda kell figyelni, bonyolítja a kódot, plusz munkával jár, és az újrafelhasználhatóságot is megnehezíti. Az extended persistence context szintén nem befutó nálam, hiszen egyrész Spring-ezek, másrészt EJB esetén is kerülöm a stateful session bean-ek használatát.&lt;/p&gt;

&lt;p&gt;Vizsgáljuk meg most a cv mező működését. Ahogy várható, mindig beolvassa. Azonban az már meglepő, hogy a @Lob, vagy a @Basic(fetch = FetchType.LAZY) vagy mindkét annotáció hatására sem változik semmi, azaz mindig berántja. Erről már &lt;a href="http://jtechlogext.blogspot.com/2010/07/jpa-hibernate-lazy-fetch.html"&gt;írtam&lt;/a&gt;, ennek az az oka, hogy ez csak akkor működik, ha az osztályok instrumentálva vannak. A példa projektben a pom.xml-ben a maven-antrun-plugin futtat egy org.hibernate.tool.instrument.javassist.InstrumentTask-ot. Amennyiben ezt megtesszük, a következő kerül a konzolra.&lt;/p&gt;

&lt;pre&gt;
main:
[instrument] starting instrumentation
[instrument] processing class : jtechlog.lazy.service.Employee;  
  file = D:\projects\jtechlog\jtechlog-lazy\target\classes\
  jtechlog\lazy\service\Employee.class
[instrument] processing class : jtechlog.lazy.service.Phone;  
  file = D:\projects\jtechlog\jtechlog-lazy\target\classes\
  jtechlog\lazy\service\Phone.class
&lt;/pre&gt;

&lt;p&gt;A class állományok is nagyobbak lesznek, és belenézve ilyeneket látunk: org/hibernate/bytecode/internal/javassist/FieldHandler. Azért jó ezt tudni, mert pl. engem a fejlesztőeszköz tévesztett meg azzal, hogy saját maga felülvágta a Maven által generált class állományokat, amik azonban még nem voltak instrumentálva. Innentől lazy mező esetén pont úgy működött, mint ahogyan az elvárható volt, és ugyanúgy figyelni kell arra, hogy ne kapjunk LazyInitializationException-t.&lt;/p&gt;

&lt;p&gt;Merge esetén úgy működött, ahogy várható volt. Amennyiben csak az Employee példányon módosítottunk, és a detached objektumot merge-öltem vissza, sikerült, módosult az alkalmazott, és megmaradtak a telefonszámok. Amennyiben azonban a telefonszámokhoz új telefonszámot akartam felvenni, ugyanúgy kaptam a LazyInitializationException-t. Azaz ugyanúgy nekünk kell gondoskodnunk a betöltésről, ahogy azt Hibernate esetén megszokhattuk.&lt;/p&gt;

&lt;h3&gt;Összegzés&lt;/h3&gt;

&lt;p&gt;Bár nem tűnik túl bonyolult témakörnek, a lazy loading kezelése okozott számomra meglepetéseket. Az EclipseLink kicsit jobban elrejti ezt a dolgot, ezért csak ezt a tulajdonságát figyelembe véve jobb választás lehet. Azt azonban mindenképp javaslom, hogy ne hagyatkozzunk az elképzeléseinkre, hogy hogyan történhet a betöltés, hanem mindig állítsuk be azt, hogy a persistence provider írja ki az általa lefuttatott SQL lekérdezéseket, és minden képernyőnél elemezzük azokat, hogy nincs-e felesleges lekérdezés, vagy nem-e lehet úgy megfogalmazni a JPA lekérdezést, hogy több SQL lekérdezés helyett csak egy fusson.&lt;/p&gt;

&lt;p&gt;Egy másik &lt;a href="http://jtechlog.blogspot.com/2011/02/ejb-es-jpa-developer-certified-expert.html"&gt;postban&lt;/a&gt; már említett &lt;a href="http://apress.com/book/view/9781430219569"&gt;Apress kiadó Pro JPA 2 Mastering the Java Persistence API&lt;/a&gt; könyve elég részletesen ír a lazy loading fogalmáról, de az implementációkat az sem hasonlítja össze.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/1949829407110462171/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2012/04/jpa-lazy-loading.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1949829407110462171'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1949829407110462171'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/04/jpa-lazy-loading.html' title='JPA lazy loading'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-266912075707296739</id><published>2012-03-31T00:16:00.000+02:00</published><updated>2012-03-31T00:16:24.371+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='performance'/><category scheme='http://www.blogger.com/atom/ns#' term='monitorozás'/><category scheme='http://www.blogger.com/atom/ns#' term='Módszertan'/><category scheme='http://www.blogger.com/atom/ns#' term='scalability'/><category scheme='http://www.blogger.com/atom/ns#' term='könyv'/><title type='text'>Java Performance</title><content type='html'>&lt;p&gt;A &lt;a href="http://jtechlog.blogspot.com/2011/12/java-memoriakezeles-szemetgyujto.html"&gt;Java memóriakezelés, szemétgyűjtő algoritmusok&lt;/a&gt; postom egy részét a &lt;a href="amazon.com/Java-Performance-Charlie-Hunt/dp/0137142528/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1327511447&amp;sr=1-1"&gt;Java Performance&lt;/a&gt; könyv ihlette.&lt;/p&gt;

&lt;p&gt;A könyv a maga nemében egyedülálló. Ebben a témában viszonylag kevés szakirodalom létezik, még kevesebb, ami ebből még aktuális is. (2011. októberében került kiadásra.) A könyvet Charlie Hunt és Binu John írta. Az előbbi az Oracle-nél vezető beosztásban van, ő a JVM performanciájával foglalkozik, és a HotSpot JVM és a Java SE osztálykönyvtárának gyorsításán dolgozik, valamint Java EE környezetben is járatos, foglalkozott a Oracle GlassFish-sel és az Oracle WebLogic Server-rel is. Binu John jelenleg a Ning, Inc.-nél dolgozik, de előtte a Sun-nál több, mint egy évtizedett töltött teljesítményoptimalizálással, az Enterprise Java Performance csapat tagja volt. Hozzáértésük, tapasztalatuk nagyban meglátszik a könyvön is. A könyvvel kapcsolatban &lt;a href="http://www.infoq.com/articles/book-java-performance"&gt;egy interjú&lt;/a&gt; is készült velük.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;a href="http://1.bp.blogspot.com/-EG3yzQP733k/T3YwHWzfs_I/AAAAAAAAIOc/TiFN0mSFgSU/s1600/JavaPerformanceCover_375x500.gif" imageanchor="1" style="margin-left:1em; margin-right:1em"&gt;&lt;img border="0" height="320" width="240" src="http://1.bp.blogspot.com/-EG3yzQP733k/T3YwHWzfs_I/AAAAAAAAIOc/TiFN0mSFgSU/s320/JavaPerformanceCover_375x500.gif" /&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;A könyv egészen az alapoktól indul. A teljesítmény optimalizálás fogalmait, és egy lehetséges módszertanát ismerteti. Két megközelítést is tárgyal, a top down, és a bottom up megközelítést. A top down a leggyakoribb módszer, a teljes rendszert megfigyelik, és egyre mélyebbre fúrnak, és próbálják megtalálni a gyenge pontokat, és azokat kiemelni. A bottom up megközelítés inkább specialisták egyik eszköze, mikor egy kész rendszert visznek át egyik platformról a másikra, és a másik platform előnyeit próbálják minél jobban kiaknázni. Olyan fogalmakat tisztáz, mint performance monitoring, profiling és tuning.&lt;/p&gt;

&lt;p&gt;A második fejezet kizárólag az operációs rendszerről szól. Leírja, hogy különböző rendszereken (Windows, Linux, Solaris) miként monitorozhatjuk a CPU-t, memóriahasználatot, lock-okat, hálózati forgalmat és disk használatot. Tippeket ad, hogy milyen jelenség esetén mire kell gyanakodnunk. Sokat foglalkozik a több magot tartalmazó processzorokkal is.&lt;/p&gt;

&lt;p&gt;A következő fejezet a HotSpot VM felépítésével, alapfogalmaival foglalkozik. A könyv kizárólag az Oracle JVM-jével foglalkozik, nem tér ki más gyártók megoldásaira, de azt hiszem ez igazán elfogadható, nagyon ritkán láttam más JVM-en futó alkalmazásokat (, sőt egy ilyent kiváltásában is részt vettem az akkor még Sun-os JVM-re). A JVM-et három részre bontja, Runtime-ra, JIT compilerre és memory managerre, mely a Garbage Collector-t foglalja magában. Nagyon részletesen leírja a JVM indulását (20 pontban) és leállását is. Olyan részletesen, hogy volt egy pont, mely nem volt tiszta, utána akartam nézni a weben, és semmi információt nem talaltam róla, kivéve a JDK forráskódjában. Egészen C++ mélységekbe merül. Nagyon jó írás található itt az osztálybetöltésről is, valamint a Java 5-ben megjelent Class data sharingról. Itt a kedvenc részem a 32 és 64 bites architektúra összehasonlítása, ahol kiderül, hogy a 64 bites architektúrára átállás átlagos esetekben miért okozhat 8-15%-os sebességlassulást. Áttekintést ad a GC-ről és a JIT compiler-ről is. Megemlíti a JDK 6 update 20-tól elérhető G1 szemétgyűjtőt is, leírja a működését, bár bevallja, hogy értékelhető mennyiségű tapasztalat még nem gyűlt össze ezzel kapcsolatban. Itt egy-két paragrafusnál elő kellett venni a fordítóprogramok és automaták tárgyon tanultakat.&lt;/p&gt;

&lt;p&gt;A 4. fejezet a monitoringról szól. Tisztázza a célokat, leírja a parancssori kapcsolókat, valamint részletesen tárgyalja a Java 6-ban alapból elérhető JConsole-t és VisualVM-et, és annak VisualGC plugin-ját is. Itt főleg a GC és a JIT monitorozására koncentrál. Az 5. fejezet témája a profiling. A profiling már olyan megfigyelés, ami módosítja a megfigyeltet ("tolakodó"). Itt is a terminológiával indít, majd az Oracle Solaris Studio bemutatása következik. Eztán jön a NetBeans Profiler.&lt;/p&gt;

&lt;p&gt;A következő fejezet már gyakorlatibb jellegű, forráskódok is jócskán szerepelnek benne (furcsa, hogy ezek a könyv végén találhatóak, én nem találtam ezeket a neten). E fejezet felépítése úgy néz ki, hogy bemutat egy programozói hibát, annak feltárásának módját, azaz a jelenséget magát, valamint a megoldást. A 7. fejezet egy konkrét algoritmust mutat be (folyamatábrával), hogy a JVM hogyan finomhangolható, milyen parancssori kapcsolókat lehet használni, azoknak milyen kihatása lehetséges. Bevallom őszintén, ez számomra kevésbé érdekes téma, azt vallom ugyanis, hogy alkalmazás szinten sokkal kevesebb energiabefektetéssel sokkal többet lehet hangolni. Ez ott jöhet jól, ahol a forráskód nem elérhető, vagy láttam már olyant is, hogy a fejlesztőknek nem volt idejük finomhangolásra, így az üzemeltetők próbáltak plusz százalékokat kihozni. Itt az az érdekes, hogy definiálnunk kell a célokat. Ezek a magas rendelkezésre állás, könnyű konfigurálhatóság, áteresztő képesség, gyors válaszidő, memóriahasználat, indulási idő. Ezek közül azonban nem lehet mindnek megfelelni, ugyanis több alapból ellentmond egymásnak. Pl. amennyiben magas rendelkezésre állást akarunk, cluster-es környezetben, azt nem olyan egyszerű konfigurálni.&lt;/p&gt;

&lt;p&gt;A 8. fejezet a benchmarking-ról szól. Na ez az a terület, ahol a legtöbb tévhit van, valamint a legegyszerűbb módon tudjuk magunkat félrevezetni. Szó esik it a warmupról, a System.gc() hívással kapcsolatos tévhitekről, a System.currenTimeMillis() és nanoTime() metódusokról, compiler optimalizációjáról (pl. ha egy metódus visszatérési értékét nem használjuk fel, és nincs mellékhatása, símán kioptimalizálja), inliningról. Rengeteg tippet és trükköt oszt meg. A biztosítékot nálam a statisztikai módszerek alfejezet ütötte ki, ahol standard eloszlástól kezdve nagyon sok mindenről szó esik.&lt;/p&gt;

&lt;p&gt;Ez után következnek a könnyed részek. Hogyan vizsgáljunk többrétegű alkalmazásokat, hogyan monitorozzunk Glassfish-t. Szó esik a web konténerről, NIO-ról, HTTP szálakról, thread pool-okról, connection queue-król. Igaz, GlassFish környezetben, de elég könnyen lehet ezt a tudást más webkonténerre is kiterjeszteni. Megemlíti a JMeter-t. Ír Servlet, JSP és JSTL legjobb gyakorlatokról, a cache-elés fontosságáról, és megemlíti, hogy sokszor akkor is létrejön session, mikor nem is gondolunk rá. A 11. fejezetben szó esik a webszolgáltatásokról, és az alapját képző XML feldolgozásról (pl. JAXB). Külön piros pont, hogy részletesen ír az EntityResolver-ekről (lásd &lt;a href="http://xml.apache.org/commons/components/resolver/"&gt;Apache xml-commons resolver&lt;/a&gt;), és a CatalogResolver-ekről is, melyek a szívem csücskei. A különböző XML processzorokat is összehasonlítja, SAX, DOM, StAX, JAXB. Érdekes megfigyelés, hogy az xsd:any használata mennyire lassít, és még egy érdekes adat, hogy az EJB-ből kiajánlott webszolgáltatások sokkal lassabbak a webkonténerből kiajánlott társaiknál. Ezek a fejezetek még mindig egyedülállóak.&lt;/p&gt;

&lt;p&gt;Az utolsó, 12. fejezet a JPA és EJB teljesítményhangolásáról szól. No, ez már olyan fejezet, amely más könyvekben is megjelenik, talán ugyanilyen részletességgel. Szó esik therad pool-ról, cache-ekról, tranzakciókról, és természetesen a kihagyhatatlan lazy loadingról is.&lt;/p&gt;

&lt;p&gt;Az A függelék a HotSpot VM parancssori kapcsolóit sorolja fel, és magyarázza meg, olyan részletességgel, amilyennel talán sehol máshol nem lehet találkozni. B függelék a forráskódoké, majd következik a részletes, nagyon jól használható tárgymutató.&lt;/p&gt;

&lt;p&gt;Sajnos gyakran észreveszem, hogy ezzel a témával kapcsolatban nagyon sokan helytelen, téves fogalmakat használnak. A könyv rendkívül részletesen ismerteti, magyarázza és definiálja ezeket.&lt;/p&gt;

&lt;p&gt;Egyetlen hátránya a könyvnek, melyet a különböző fórumokon többen is jeleznek, az az írok Sun, illetve most már Oracle iránti elfogultsága. Már az első fejezetben indokolatlanul fényezik az UltraSPARCT T-series processzorokat, és ez a teljes könyvön végigvonul, gyakran említi a Solaris-t, illetve a különböző eszközök közül is csak az Oracle-ösöket tárgyalja ki, mint pl. a NetBeans Profiler-t. Ez utóbbi számomra nem zavaró, hiszen nem lehet a teljes palettát bemutatni, és igazából ezen eszközök nem nagyon térnek el egymástól, a Solaris-os fejezeteket is át lehet ugrani, de a CPU hangsúlyozása már kicsit kínos.&lt;/p&gt;

&lt;p&gt;A könyv majdnem 700 oldal, és nagyon sűrűen van szedve, nincs teletűzdelve feleslegesen ábrákkal sem, emiatt a témát nagyon alaposan bemutató, hosszú, részletes könyv. Nem is lehet egyhuzamban elolvasni, inkább részleteiben, mindig arra a témakörre koncentrálva, amit éppen teljesítmény-hangolni kell. Remélem sikerült kedvet hozni hozzá, és mindenkinek a könyvespolcára kerül ez a könyv.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/266912075707296739/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2012/03/java-performance.html#comment-form' title='1 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/266912075707296739'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/266912075707296739'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/03/java-performance.html' title='Java Performance'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://1.bp.blogspot.com/-EG3yzQP733k/T3YwHWzfs_I/AAAAAAAAIOc/TiFN0mSFgSU/s72-c/JavaPerformanceCover_375x500.gif' height='72' width='72'/><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2913251681129038831</id><published>2012-01-28T22:43:00.001+01:00</published><updated>2012-01-28T22:45:38.347+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Community'/><title type='text'>Űrlap eredmények, könyvsorsolás</title><content type='html'>A &lt;a href="http://jtechlog.blogspot.com/2012/01/visszatekintes-2011-re.html"&gt;Visszatekintés 2011-re&lt;/a&gt; postomban szerepelt egy kérdőív, melyet összesen 26 válaszadó töltött ki. Ezúttal is köszönöm mindenkinek a segítséget, ötleteket, jókívánságokat! A válaszadók között volt végzős egyetemista, junior, de 10-13 éve Java-ban fejlesztő senior, és vezető fejlesztő is. Kb. kétszer annyi senior fejlesztő töltötte ki, mint junior, pár vezető beosztásban dolgozó. Általában mindennel foglalkoznak (backend és frontend is, ismerik és használják a teljes stack-et), számomra meglepő módon csak kevesen írták csak az egyiket. Emellett kitöltötte olyan is, aki mindennapjaiban üzemeltet (is), oktat, tesztel, vagy a build folyamatokkal foglalkozik.&lt;br /&gt;
&lt;br /&gt;
A témák, melyek érdeklik a válaszadókat, és akár konferenciákra is elmennének azzal kapcsolatban, nagyon változatos. Nem volt egyszerű összesíteni, de nem akartam feleletválasztással megkötni a kezeteket, de így is sokan a zárójelbe tett ötletekből csemegéztek. Amiről a válaszadók legszívesebben olvasnának, az magasan a különböző módszertanok, kb. dupla annyian szavaztak rá, mint a második helyezettre. Ahhoz képest, hogy az az elterjedt hit, hogy a fejlesztők nem szeretnek tesztelni, a második helyen a tesztelés/teszt eszközök bemutatása végzett. Számomra meglepő volt, hogy alap JDK-s dolgokról is szívesen szeretnek olvasni, nem kell mindig más technológia után kutakodni. Ezt megerősíti az is, hogy a &lt;a href="http://jtechlog.blogspot.com/2011/12/java-memoriakezeles-szemetgyujto.html"&gt;Java memóriakezelés, szemétgyűjtő algoritmusok&lt;/a&gt; postom is kiemelkedően látogatott. Számomra furcsa, hogy az OSGi-t egy ember említette meg, úgy látszik csökken a népszerűsége. A konferencia fő érdeklődésre számot tartó témái: Java 7 újdonságok, Java EE, cloud, SOA és mobil fejlesztés. Egyrészt nagyon jól csinálják a mostani konferenciák szervezői, mert minden ezekről szól. Másrészt az nagyon érdekes, hogy a válaszadók ezeket a témákat általában nem jelölték meg, hogy a blogomon olvassanak róla. Harmadrészt a JavaFX szinte senkit nem érdekel. A SOA, bár sokan elcsépelt buzzwordnek tartják, mégis előkelő helyen van. A Java jövőjével kapcsolatban általában nincsenek nagy félelmek. A hype ugyan alábbhagyott, de azért mindenki szereti (különben nem olvasnák a blogot), és kivár. Többeknek nem tetszett az Oracle felvásárlás, de szerintük azért talán a Java jövőjét nem fenyegeti.&lt;br /&gt;
&lt;br /&gt;
És akkor kicsit a statisztikáról is. A legtöbb válaszadó nem kizárólag Java-ról akar olvasni. Az olvasók felének jó így a szint, másik fele azt választotta, hogy legyen általános és technikai is. A válaszadók többségének jó így a postok hossza, sokan nem bánnák, ha a hosszúak között lennének rövidebbek is.&lt;br /&gt;
&lt;br /&gt;
És akkor a jövőről. Az űrlap kitöltése alapján azt látom, hogy gyökeres változtatásra nincs szükség. Témák tekintetében a JDK-val és a teljesítményhangolással foglalkozó postokat is igyekszem írni. A válaszadók gyakran való életbeli példákat szeretnétek. Talán nem hangsúlyozom eléggé, de a postok nagy részének alapja egy probléma, amibe a való életben futok bele. A mögé teszek egy kis hátteret is, és a probléma megoldását is megírom. A későbbiekben igyekszem a konkrét környezetet jobban bemutatni. A elvekkel, módszertanokkal, megmondásokkal kapcsolatban van egy kis félelmem. Ugyanis a technológiák, eszközök általában egzakt valamik, amiről viszonylag objektíven lehet írni (mármint egy probléma egy eszközben való megoldásáról, nem magáról az eszközről). Az elvek nem mindig ilyenek, nagyon kevés általánosan elfogadott alapszabály létezik. Gondoljunk bele, hogy pl. a singleton is mennyire megosztja a fejlesztőket, de beszélhetnénk itt a CI-ről, AOP-ről, agilis fejlesztésről, extrém programozásról, TDD-ről, stb. Általában megpróbálok objektív maradni, de így sem mindig sikerül. Ilyen jellegű postokra inkább az év közepétől számíthattok. Másik téma, amiről mindenképpen többet szeretnék írni, az a tesztelés, teszt vezérelt fejlesztés. Amiről biztos, hogy nem fogok írni a közeljövőben, az a JavaFX, OSGi és a JVM-en futó alternatív nyelvek. Tudom, az utóbbi többeknek kedvence, de jelenlegi munkámban még nem látom az alkalmazhatóságukat, nem tartom őket annyira kiforrottnak sem, és a csapat, amelynek tagja vagyok, sem rendelkezik elegendő kompetenciával, hogy be mernénk vetni. Szabadidőm inkább a Java közli technológiáknak szentelem. Egyedül a Jython, ami néha-néha előkerülhet, a többi addig nem, míg megfelelően el nem terjed. A témákat megpróbálom sokszínűen tartani, a szintet sem módosítom. Alapvetően a hosszabb cikkekre fogok továbbra is koncentrálni, de igyekszem rövidebb cikkeket is beszúrni. Köszönöm a javaslatokat, hogy több forráskódot és képet szerepeltessek, ezeket is igyekszem betartani.&lt;br /&gt;
&lt;br /&gt;
A Java 2 útikalauz programozóknak című könyvet i***a@gmail.com e-mail címmel rendelkező válaszadó nyerte, már tud róla, gratulálok!</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/2913251681129038831/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2012/01/urlap-eredmenyek-konyvsorsolas.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2913251681129038831'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2913251681129038831'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/01/urlap-eredmenyek-konyvsorsolas.html' title='Űrlap eredmények, könyvsorsolás'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-340189829288615845</id><published>2012-01-16T00:47:00.002+01:00</published><updated>2012-01-17T16:06:19.190+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Módszertan'/><title type='text'>Ki is az a Java architect?</title><content type='html'>Manapság Magyarországon is egyre gyakrabban keresnek Java architect-et, de kérdés, hogy ez a pozíció vajon milyen feladatokkal járhat? Egzakt definíciója nincs, az itt leírtak a saját tapasztalataim és véleményem tükrözik. Be kell vallanom, a &lt;a href="http://java.dzone.com/articles/technical-job-interview"&gt;Technical Job Interview Questions for Java EE architects&lt;/a&gt; cikk is nagyon elgondolkodtatott.&lt;br /&gt;
&lt;br /&gt;
Az architect szó a görög arkhitecton szóból származik, ami az arkhi (vezető) és tekton (építész) szóból áll, így nagyjából vezető építészt jelent. A főnököm főkonstruktőrt szokott emlegetni, ami nekem szimpatikus és ráadásul magyar kifejezés. Az informatika ezt a kifejezést is az építészetből vette át, mint pl. blueprint vagy a tervezési minta szavakat.&lt;br /&gt;
&lt;br /&gt;
A szoftverfejlesztés az architect fogalmát kb. az 1990-es évek végén vette át, amikor is a szoftver rendszerek egyre bonyolultabbakká váltak, és a szoftverfejlesztési problémák megoldására elkezdett terjedni az objektumorientált programozás. Már nem egyedülálló, monolitikus, szigetként működő alkalmazásokat kellett fejleszteni, hanem más rendszerekhez illeszkedni tudó, azokkal kommunikáló, komoly üzleti logikát megvalósító szoftver rendszereket. A megoldást a rendszerek kisebb alrendszerekre való szétvágása, illetve az alrendszerek több rétegre való bontása jelentette. Elterjedtek a két, három és n-rétegű architektúrák, lassan minden nagyvállalati (enterprise) lett. A rendszerek közötti kapcsolatok megvalósítását az Enterprise Application Integration-től (EAI) várták, amely nem más, mint olyan architektúrális elvek gyűjteménye, melyek az integrációt hivatottak megoldani. És szükség volt valakire, aki az ilyen bonyolult rendszerekkel kapcsolatban képes volt felmérni az igényeket, azonosítani a kockázatokat, becsülni, magas szinten megtervezni és specifikálni a feladatokat, és ellenőrizni a megvalósítást.&lt;br /&gt;
&lt;br /&gt;
Az előzőekből is kiderül, hogy az architect az üzlet és az informatika között helyezkedik el. Ismeri, megismeri, érti az üzleti területet, valamint a megrendelő által megfogalmazott, a rendszerrel kapcsolatos üzleti elvárásokat, az un. funkcionális követelményeket. Az architect feladata ezen követelmények informatikai vetületeinek feltárása, és az informatika felé ezek közvetítése. Az üzleti problémákra technológiai megoldásokat képes adni.&lt;br /&gt;
&lt;br /&gt;
Vegyük sorba, hogy egy szoftverfejlesztés életciklusát alapul véve, melyik fázisban milyen feladatai lehetnek az architect-nek, és ez alapján azt, hogy milyen képességekkel kell rendelkeznie.&lt;br /&gt;
&lt;br /&gt;
Az architect tehát egy szoftverfejlesztési projekt legelején, már az ajánlatírás fázisában aktívan beszáll a projektbe. Egyrészt megérti a funkcionális követelményeket. Ezen kívül képes felmérni a rendszerrel kapcsolatos nem funkcionális gyakran minőségi követelményeket, melyek azok az elvárások, melyek nem konkrétan egy üzleti használati esethez köthetőek. Ilyen pl. a teljesítmény, magas rendelkezésre állás, hibatűrés, skálázhatóság, biztonság, fenntarthatóság, továbbfejleszthetőség, üzemeltethetőség, tesztelhetőség, használhatóság, felhasználói felülettel kapcsolatos követelmények, stb. Nem funkcionális igényként fontos definiálni az ügyfél oldali megszorításokat is, mint pl. a kötelezően használt platformok, eszközök, valamint a más rendszerekhez való illesztési lehetőségeket és elvárásokat. Meg kell említeni a módszertannal kapcsolatos és dokumentációs követelményeket, jogszabályoknak való megfeleléseket és a szakterületi szabályokat. Ezen igények egy része mérhető bizonyos mérőszámok definiálásával, más követelmények azonban korántsem ennyire egyértelműek. A nem funkcionális követelmények érkezhetnek az üzleti oldal, de a megrendelő informatikai gárdája felől is.&lt;br /&gt;
&lt;br /&gt;
Ugyanígy képes felmérni a szállító oldali lehetőségeket is. Ismeri a fejlesztési csapatot, és annak képességeit, a fejlesztők által használt szabványokat, technológiákat és eszközöket.&lt;br /&gt;
&lt;br /&gt;
Ezáltal már az ajánlati fázisban aktívan szerepet kell vállalnia. A követelmények alapján ugyanis azonosítania kell a technológiai kockázatokat, általánosságban a megvalósíthatóságot. A kockázatokat minél előbb fel kell ismernie, és osztályoznia. Becsülnie kell, egy probléma bekövetkezésének valószínűségét, valamint a bekövetkezése által okozott kárt, az elhárításának erőforrás igényét. Valamint meg kell határoznia, hogy milyen erőforrás szükséges a probléma kialakulásának megakadályozására. Ezek alapján egy rangsort kell felállítania.&lt;br /&gt;
&lt;br /&gt;
Ezek alapján víziót kell alkotnia. Bizonyos helyzetekben lehet, hogy prototípus építésére is szükség lehet. És ez alapján erőforrást is kell becsülnie. Látható tehát, hogy már a projekt elején kiemelt szerepe van, hiszen a projekt alapvető sikeressége függ egy jó architektúrán, egy pontos becslésen, mely kihat az árajánlatra, a projekt költségvetésére is. Nem utolsósorban az architect-nek olyan magas szintű döntéseket kell hoznia, mely a projektben részt vevő összes személyre kihat, hiszen az ő által kidolgozott koncepciót kell megvalósítani az általa megbecsült idő alatt, így rajta is múlhat, mennyire motiváltak a projekt tagok, esetleg mennyi túlórát kell a projektbe fektetni.&lt;br /&gt;
&lt;br /&gt;
A követelmény elemzés és tervezés fázisában szintén nagy részt kell vállalnia. Ki kell választania a problémás használati eseteket, és előre priorizálnia. A szoftverrendszer magas szintű tervezését kell elvégeznie és dokumentálnia. Milyen alrendszerekből álljon, ezek hogyan kommunikáljanak egymással és külső rendszerekkel, valamint hogyan épüljenek fel. Milyen eszközök és technológiák használandóak. Itt lehet szükség bonyolultabb prototípusok építésére is. A prototípusoknak több fajtája lehet, eldobandó, továbbfejleszthető és architektúrális. Az eldobandó csak valaminek a kipróbálására jött létre, a továbbfejleszthető akár a későbbi rendszer alapjául is szolgálhat, és az architektúrális az architektúra elemek helyes együttműködésének tesztelésére szolgál, melyet mintaként használva felépíthető a rendszer. Az architektúrális tervezés és a rendszertervezés között több különbség is van, melyet érdemes tisztázni. Az architektúrális tervezés magasabb absztakciós szinten van, nem olyan részletes. Általában csak rendszer/alrendszer szintig megy, illetve azok rétegeit tárgyalja, de részletesen nem foglalkozik a rétegekben szereplő komponensekkel. Általában a nem funkcionális követelményekre, és a kockázatos funkcionális követelményekre koncentrál. Átnézi az elkészült dokumentációkat.&lt;br /&gt;
&lt;br /&gt;
Az implementáció és tervezés során támogatja és ellenőrzi a fejlesztőcsapatot, az egész fejlesztési folyamat előrehaladását nyomon követi. Kidolgoz belső fejlesztési szabványokat, és folyamatosan figyeli azok betartását. Fejlesztők architektúrális kérdéseit igyekszik megválaszolni, segít az esetleges architektúrális módosítások végrehajtásában. A fejlesztés közben workshop-okat rendez az aktuális fejlesztés közben felmerült problémákról, és moderál úgy. Ezek nem akaszthatják meg a fejlesztést, nem lehet kötelező program. Ismernie kell a fejlesztési metodológiát, a használt eszközöket. Ha kell, felgyűri az ingujját, és akár kódolással segíti egy probléma lokalizálását, megoldását. Otthonosan mozog a build, release, deploy folyamatokban. Ugyanígy magas szintű rálátása van a tesztelési folyamatokra, eszközökre (harness) is, hiszen az architektúrákkal kapcsolatban egyre erősebb igény a minél kényelmesebb tesztelhetőség.&lt;br /&gt;
&lt;br /&gt;
A bevezetés és a támogatás során folyamatosan tartja a kapcsolatot az üzemeltetéssel is, a feltárt hibákat 2nd level support részeként elemzi, kategorizálja, és kommunikálja a fejlesztők felé. Próbálja az üzemeltetés és a fejlesztés közötti gyakran jelentkező szakadékot áthidalni, a feleket egymáshoz közelebb hozni.&lt;br /&gt;
&lt;br /&gt;
Milyen képességekkel kell rendelkeznie egy architect-nek, hogy ezeket a feladatokat el tudja látni? A legfontosabb a megfelelő mennyiségű tapasztalat. Ezt egyrészt megszerezheti tanulás révén, folyamatos képzésekkel, önképzéssel, a trendek figyelésével, tájékozottság fenntartásával. Másrészt rengeteg gyakorlati tapasztalattal kell rendelkeznie. Úgy gondolom, egy cégnél több évig (&amp;gt;5) maradó architect elveszik a napi rutinban, hiszen nem találkozik más problémákkal, emberekkel, megoldásokkal, gondolatokkal. Ezért érdemes vagy váltani, vagy részben máshol is ilyen jellegű tevékenységeket vállalni.&lt;br /&gt;
&lt;br /&gt;
Egy architect-nek rendelkeznie kell menedzsment képességekkel és technikai tudással is. Kockázatokat kell kezelnie. Másrészt becsléseket kell végezni. Ez sajnos nem tanulható, csak tapasztalat segíthet abban, hogy egy probléma megoldása az adott környezetben mennyi erőforrást igényel. Állandóan döntéseket kell hoznia. A döntéseket folyamatosan dokumentálni szükséges, ugyanis nem csak egy döntés, de az ahhoz vezető út is nagyon fontos lehet a projekt szempontjából. Nagyon sok projekt esetében hangzott el a kérdés, mikor a projekt előrehaladása folyamán egy döntés logikátlannak tűnt, hogy vajon az elején miért is ez lett meghozva.&lt;br /&gt;
&lt;br /&gt;
Nagyon jó kommunikációs képességekkel kell rendelkeznie. A projekt során szinte az összes projekttaggal kapcsolatban van. Nagyon fontos a követelmények felmérésénél, a víziójának másokkal való elfogadtatásával. Gondoljunk bele, az ő döntései a csapat minden tagjára kihatnak, nem mindegy, hogy mennyire tudja ezeket a többiekkel elfogadtatni. Nem ülhet elefántcsonttoronyban, és ott olvassa a dokumentációkat, és készíti a specifikációit. A fejlesztés során is végig mentoring tevékenységet kell végeznie.&lt;br /&gt;
&lt;br /&gt;
A jó architect megoszt. Megosztja a tapasztalatait, véleményeit, az érdekességeket, melyekkel találkozik. Megosztja a döntéseihez vezető utak lépéseit, a döntésnél figyelembe vett érveket. Megosztja a specifikációkat, dokumentumokat, a pilot eredményeit. Megosztja a vízióját.&lt;br /&gt;
&lt;br /&gt;
Az architect-nek nem feladata mindennek a felderítése, megtervezése. A kollégáira támaszkodik, az általuk adott specifikus tudásokból állít össze egy architektúrát. Figyelembe veszi infrastruktúrális ügyekben az üzemeltetőket, fejlesztési kérdésekben a programozókat, tesztelési kérdésekben a tesztelőket. De érti mindegyik nyelvét, és az átadottakat tudja az üzlet felé kommunikálni, és fordítva. Darabokból épít egészet.&lt;br /&gt;
&lt;br /&gt;
Nem mehet minden probléma mélyére, tudnia kell, mikor kit kell megkérnie. Ha megtenné, elaprózná az idejét, és újra az elefántcsonttoronyban kötne ki, immár technológiai problémákkal körülvéve. A feladatokat meg kell tudnia osztani.&lt;br /&gt;
&lt;br /&gt;
Gyakori kérdés, hogy jól kódol-e az architect? Nem feltétlenül. Persze nem árt, de a többi dolga mellett erre már kevésbé jut ideje, és valljuk be, ha az ember nem 8 órát kódol folyamatosan, ki lehet menni a gyakorlatból. Nem ismeri az eszközöket és API-kat sem olyan mélységben. De egy adott problémát meg tud valósítani, lehet, hogy nem olyan elegánsan, mint egy fejlesztő, feltehetőleg nem is annyi idő alatt, de hasonló megoldásokkal. Kódot olvasni tud, debugol, optimalizál. Ismeri a legjobb gyakorlatokat és tervezési mintákat. Rengeteg tapasztalata van, hogy egy probléma más rendszerekben hogyan került megoldásra. Valamint dereng még senior vagy vezető programozó korából, hogy akkor hogyan is csinálta. A tudásának ereje nem is a tudásának mélységéből, hanem szélességéből adódik. Tudja mit hol kell keresni. Kódolási képességek nélkül nem fogadják el a fejlesztők.&lt;br /&gt;
&lt;br /&gt;
Jó dokumentálási képességekkel kell rendelkeznie, tudnia kell írnia. Rögzíteni a döntéseket, és azok indokait, valamint a vízióját írásban is át kell tudnia adni a feleknek, akár egy ajánlat, akár egy specifikáció esetén.&lt;br /&gt;
&lt;br /&gt;
Maximális mértékben figyelembe kell vennie a körülményeket, alkalmazkodnia kell. Nem szabad abba a hibába esnie, hogy az önéletrajzának bővítse miatt választ technológiát, nem az adott projekten próbál ki új dolgokat, vagy mert csak ahhoz ért. Figyelembe kell vennie a csapatot. Ahhoz, hogy egy feladatot a leghatékonyabban lehessen elvégezni, a maximális újrafelhasználhatóság szükséges, tudásban is. A csapat tudásának megfelelően kell megoldásokat, módszertanokat, eszközöket, technológiákat, szabványokat választania. Nem választ ki egy programozási nyelvet, mert az menő, vagy alkalmasabb a feladatra, ha a fejlesztők közül egyik sem használta még, akár ő sem. Félre kell tenni a személyes preferenciáit.&lt;br /&gt;
&lt;br /&gt;
Amennyiben egy architect nem csak egy konkrét projekten dolgozik, hanem egy cégnél hosszabb távon alkalmazásban áll, érdemes valamilyen stratégián is dolgoznia. Egyrészt be kell gyűjteni a menedzsment felől érkező, még csak a távolban felvillanó üzleti igényeket, és beszélnie kell a fejlesztést végző csapat minden tagjával, hogy mit éreznek nehéznek, problémásnak. A kettőt egybegyúrva, minden oldallal egyeztetve kell kialakítania egy olyan stratégiát, mely egyre gördülékenyebbé és hatékonyabbá teszi a fejlesztéseket, nem korlátoz, és az új tagok munkába állását is kellően megkönnyíti.&lt;br /&gt;
&lt;br /&gt;
No de evezzünk egy kicsit technikai vizekre, nézzük, miben kell otthonosan mozognia egy ilyen szakembernek. Az elosztott rendszerek térhódításával jelent meg az igény az architect-ekre is. Hiszen minél nagyobb az elosztottság, annál több a kihívás, annál több választási lehetőség van. Egy alrendszer is egyre bonyolultabbá és bonyolultabbá válhat. A problémamegoldás egyik hatékony fegyvere a dekompozíció, komponensekre bontás. A komponensek együttműködnek, köztük interfészek helyezkednek el. Fontos az egységbe zárás (encapsulation). Az interfészek használata megkönnyíti a cserélhetőséget, tesztelhetőséget. A komponenseket megfelelően szét kell tudni választani, mindnek csak a saját feladatát kell tudnia elvégeznie (resposibility). Kialakult az Enterprise Application Integration, valamint a Service Oriented Architecture. Látható, hogy mélyebb szinten, alkalmazáson belül ugyanezeket az elveket kell alkalmazni, és látható, hogy az előbbi fogalmak egy az egyben jelennek meg objektumorientált programozás esetén is. High cohesion, low coupling. Ezeket a komponenseket és a komponensek közötti kapcsolatokat magasabb absztrakciós szintre kell emelni, modellezni kell. A rendszereket különböző nézőpontokból kell megfigyelni, pl. statikus esetben a rendszer felépítését, dinamikus esetben a rendszer működését. Ezeket valahogyan ábrázolni kell, kifejező leíró nyelv erre az UML. Fontos, az architect nem a való világ megfelelő darabját szakítja ki (üzleti terület), mint a tervezők, hanem már rendszer szinten, n agyon magas szintű objektumokban gondolkodik, informatikai fogalmakban. Leghasznosabb eszköze a component, deployment és sequence diagram. Gyakori problémákra gyakori, elterjedt megoldásokat alkalmaz, tehát ismeri a tervezési mintákat és személyre tudja szabni azokat. És itt nem kizárólag a Gang of Four tervezési mintákra kell gondolni, hanem az un. architectural pattern-ekre is. Ide kapcsolódik szorosan a refactoring is.&lt;br /&gt;
&lt;br /&gt;
Be kell vetnem pár bűvös szót is, felsorolásképpen, szigorúan össze-vissza, mely területekkel egy architect-nek már találkoznia kellett a szoftverfejlesztéssel kapcsolatban: webszolgáltatások (SOAP/REST), SOA, cloud, event driven architecture, domain driven design, Behaviour-Driven Development, test driven development, continuous integration, continuous delivery, agile development, dependency injection, inversion of control, AOP, caching.&lt;br /&gt;
&lt;br /&gt;
A Sun, később az Oracle ennél talán behatároltabban kezeli az architect-et. Végighallgattam egy több napos "Architecting and Designing J2EE Applications" képzést. Ennek első fele kb. a fentebb leírtakat ecseteli meglepően kevés technológiai utalással, későbbi részek már a technológiára mennek rá. Ennek megfelelő a &lt;a href="http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=326"&gt;Oracle Certified Master, Java EE 5 Enterprise Architect&lt;/a&gt; vizsga is, érdekes, Java EE 6-ra még nem jelent meg. Az említett linken látható, hogy ez nem csak egy teszt kitöltéséből, hanem azon felül egy esszé megírásából és annak megvédéséből áll.&lt;br /&gt;
&lt;br /&gt;
Természetesen az Oracle a saját komponens architektúráját kéri számon, azaz az EJB technológiát, valamint annak környezetét, a Java EE szabványt. Ez utóbbiból megköveteli a JDBC, JPA, JMS, JCA, Servlet, JSP, JSF, JAXB, JAX-WS ismeretét. Kitér a komponensek környezetét biztosító  alkalmazásszerverekre, valamint a Java EE tervezési mintákra is.&lt;br /&gt;
&lt;br /&gt;
Az EJB mellett azonban ne felejtkezzünk el a Spring-ről és az OSGi-ról sem.&lt;br /&gt;
&lt;br /&gt;
Úgy gondolom, az áttekintő tudás hasznos, de nem megkövetelendő a különböző JVM-re épülő nyelvek, mint pl. a Groovy vagy Scala ismerete, valamint a naprakészség olyan modern irányzatokban, mint pl. a NoSQL eszközök.&lt;br /&gt;
&lt;br /&gt;
Ma már az architect-ek is szakosodhatnak. Lehetnek enterprise architect-ek, akik az alkalmazásintegrációt tartják szem előtt. Lehetnek application vagy system architect-ek, akik az alkalmazások belső felépítéséért felelnek. Lehetnek infrastructure architect-ek, akik az infrastruktúráért felelősek, mint hardver, szerver szoftverek, hálózat, adatbázis, és kedvencük a skálázhatóság, fürtözés, terheléselosztás és újabban a virtualizáció.&lt;br /&gt;
&lt;br /&gt;
Megnéztem több állásportált is, száz Java fejlesztői állásra maximum három-öt Java architect jut. Egyrészt nem annyira elterjedt itthon, másrészt szeretik a cégek a saját szakemberüket kinevelni. Meglepő azonban, hogy ez a pár állás viszont elég pontosan írta le a feladatköröket, azaz tudják, kit keresnek.</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/340189829288615845/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2012/01/ki-is-az-java-architect.html#comment-form' title='6 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/340189829288615845'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/340189829288615845'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/01/ki-is-az-java-architect.html' title='Ki is az a Java architect?'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>6</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6156167128518622117</id><published>2012-01-14T22:16:00.006+01:00</published><updated>2012-01-15T11:11:44.885+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Community'/><category scheme='http://www.blogger.com/atom/ns#' term='könyv'/><title type='text'>Visszatekintés 2011-re</title><content type='html'>&lt;p&gt;Így az év elején az ember kicsit visszatekint, és rendszerezi a gondolatait a jövővel kapcsolatban is.&lt;/p&gt;

&lt;p&gt;A 2011-es év folyamán 20 postot írtam. Kicsit próbálkoztam a nem annyira technikai témákkal is, hanem a szoftverfejlesztéssel kapcsolatos általános gondolataimat is próbáltam leírni, pl. a &lt;a href="http://jtechlog.blogspot.com/2011/05/miert-ne-fejlesszunk-sajat.html"&gt;Miért ne fejlesszünk saját keretrendszert?&lt;/a&gt; postban, amihez magasan a legtöbb megjegyzés érkezett, láthatóan titeket is érint a téma. Látható volt az útkeresésem is, ugyanis a Java világ jövője kicsit bizonytalan, nem is ad mindig annyi lelkesedésre okot, és egy kiegészítő eszközt is kerestem, amivel gyakori ismétlődő feladatokat egyszerűen tudok elvégezni, így esett a választásom a Python-ra (&lt;a href="http://jtechlog.blogspot.com/2011/06/masodik-nyelv-python.html"&gt;Második nyelv: Python?&lt;/a&gt;). Természetesen  bejegyzéseim javát így is azok a dolgok tették ki, amivel projektjeim során találkoztam, így került sor a &lt;a href="http://jtechlog.blogspot.com/2011/07/vastag-kliens-java-ban-netbeans.html"&gt;NetBeans Platform&lt;/a&gt; bemutatására, volt egy post sorozat a Subversion, Maven, release témákban, valamint az év végén egy kis &lt;a href="http://jtechlog.blogspot.com/2011/12/java-memoriakezeles-szemetgyujto.html"&gt;Java teljesítményhangolásról&lt;/a&gt; is szó esett.&lt;/p&gt;

&lt;p&gt;Így év elején letisztáztam az egyéb online megjelenéseim is, így látható jobb oldalon az "Elérhetőségek" doboz, melynek első eleme a Google+. A Google Reader az elsődleges hírforrásom, amiben a Google megszüntette a megosztási lehetőséget, a Google+-ba tereli be. Így én is áttértem, így minden érdekes cikket ott fogok megosztani, ha gondoljátok, kövessetek a &lt;a href="https://plus.google.com/115891152269405230539"&gt;Google+-on&lt;/a&gt;. A megosztások itt a blogban is megjelennek a "Google+" dobozban. Még egy változás történt, ezek után a példa kódokat a &lt;a href="https://github.com/vicziani"&gt;GitHub&lt;/a&gt;-on érhetitek el.&lt;/p&gt;

&lt;p&gt;Persze nem maradhatnak el a statisztikák sem. Magasan a legnézettebb post 2011-ben a &lt;a href="http://jtechlog.blogspot.com/2009/10/java-forrasok-tanulashoz.html"&gt;Java források tanuláshoz&lt;/a&gt;, mely egy kezdőknek szóló, 2009-es post. Második a már említett "Miért ne fejlesszünk saját keretrendszert?", és a harmadik a 2010-es &lt;a href="http://jtechlog.blogspot.com/2010/04/maven-kezdolepesek.html"&gt;Maven kezdőlépések&lt;/a&gt;, ami szintén kezdőknek szól. Az idei postok közül a már említett "Vastag kliens Java-ban? NetBeans Platform", és a "Második nyelv: Python?" volt a legnézettebb. Érdekes, hogy annak ellenére, hogy a Java nem a legmegfelelőbb választás vastag kliens fejlesztésére, mégis sokakat érdekelt, míg az utóbbi nem is Java téma.&lt;/p&gt;

&lt;p&gt;A legtöbb látogatót természetesen a Google hozta, a keresési szavak felhőjét mutatja az alábbi kép. Minél nagyobb egy szó, annál többször kerestek rá. Kedvenc keresési kifejezésem a "Honnét lehet rendelni a pom pomt?" Látszik a keresőszavakból, hogy sokan úgy térnek vissza, hogy emlékeznek nagyjából a post címére, és arra keresnek rá. Szomorú azonban, hogy túl sokan akadnak úgy a blogra, hogy könyvet akarnak letölteni. Sláger a Java Útikalauz programozóknak és a J2EE útikalauz java programozóknak című könyv, de sokan keresnek Angstler könyveket és angol nyelvű könyveket is. Úgy gondolom, hogy érdemes ezeket a könyveket megvásárolni, sokszor le lehet ezeket venni a polcról. Egy darabig gyűjtöget az ember, aztán rájön, hogy mire elolvasná, rég elavult, amennyire meg mégis jut idő, annyit meg is lehet vásárolni. A keresőszavakból az is kiderül a számomra, hogy attól függetlenül, hogy kevés Java tartalom van magyar nyelven, az emberek mégis bíznak, hogy magyarul is találnak valamit.&lt;/p&gt;

&lt;a href="http://1.bp.blogspot.com/-Rjb5aSyqFvY/TxHwxVA8WFI/AAAAAAAAHvk/ruqudhTSNTs/s1600/keresoszavak.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 166px;" src="http://1.bp.blogspot.com/-Rjb5aSyqFvY/TxHwxVA8WFI/AAAAAAAAHvk/ruqudhTSNTs/s320/keresoszavak.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5697599733845743698" /&gt;&lt;/a&gt;

&lt;p&gt;A postokban szereplő gyakori szavak a következők: Java, EJB, NetBeans, Maven, Subversion, build, release, branch, merge, szemétgyűjtő algoritmus.&lt;/p&gt;

&lt;p&gt;Legtöbb látogatót a Google után a &lt;a href="http://www.hup.hu"&gt;HUP&lt;/a&gt; hozott, bár csak pár megjegyzésben szerepel a JTechLog-ra link.&lt;/p&gt;

&lt;p&gt;Azért, hogy a blogot még jobbá tegyem, összeállítottam egy kérdőívet, melynek segítségével megpróbálom felmérni az olvasótábor képzettségi szintjét, az érdeklődésre számot tartó témákat, valamint azt, hogy érdemes-e a blogot valamilyen irányba változtatni. Legyen-e több rövidebb tartalom, vagy a postok szintje legyen más. &lt;a href="https://docs.google.com/spreadsheet/viewform?hl=hu&amp;formkey=dG9EV2dBazlqdjFMenFIb21TWTl0U0E6MQ#gid=0"&gt;Kérlek töltsd ki te is, csak kilenc kérdés!&lt;/a&gt; Mindenki véleménye számít. És azért, hogy lássátok, tényleg odafigyelek az olvasókra, a kérdőívet kitöltők között kisorsolom a három kötetes "Java 2 útikalauz programozóknak" könyvem, CD melléklettel. Amennyiben érdekel a könyv, kérlek mindenképp írd a kérdőívbe az e-mail címedet is. Az eredmény január 28-án várható. Érdemes játszani, mivel viszonylag kicsi az olvasótábor, így nagy esély van a nyereményre. Amennyiben nem érdekel, kérlek a kérdőívet akkor is töltsd ki, ezzel is segítve a blogot, hogy számodra is érdekesebb tartalom jelenjen meg a továbbiakban.&lt;/p&gt;

&lt;a href="http://1.bp.blogspot.com/-klEoCvGzt54/TxHw5KEt8aI/AAAAAAAAHvw/A6iyBDtHwR8/s1600/Java-utikalauz-programozoknak.jpg"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 224px; height: 320px;" src="http://1.bp.blogspot.com/-klEoCvGzt54/TxHw5KEt8aI/AAAAAAAAHvw/A6iyBDtHwR8/s320/Java-utikalauz-programozoknak.jpg" border="0" alt=""id="BLOGGER_PHOTO_ID_5697599868347740578" /&gt;&lt;/a&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/6156167128518622117/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2012/01/visszatekintes-2011-re.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6156167128518622117'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6156167128518622117'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/01/visszatekintes-2011-re.html' title='Visszatekintés 2011-re'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://1.bp.blogspot.com/-Rjb5aSyqFvY/TxHwxVA8WFI/AAAAAAAAHvk/ruqudhTSNTs/s72-c/keresoszavak.png' height='72' width='72'/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8365011667058151286</id><published>2011-12-30T02:10:00.018+01:00</published><updated>2014-02-02T16:24:41.207+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='hotspot'/><category scheme='http://www.blogger.com/atom/ns#' term='jvm'/><title type='text'>Java memóriakezelés, szemétgyűjtő algoritmusok</title><content type='html'>&lt;p&gt;Technológiák: Java Development Kit 1.6&lt;/p&gt;

&lt;p&gt;A Java tervezésekor egyik legfőbb szempont a biztonság volt. Ez egyrészt megnyilvánul abban, hogy a felhasználó tudja kontrollálni egy nem megbízható forrásból szerzett program hozzáféréseit, másrészt támogatja a programozókat abban, hogy minél kevesebb hibát vétsenek.&lt;/p&gt;

&lt;p&gt;Ez utóbbi egy szelete az, hogy nem explicit kell memóriát lefoglalnunk, és felszabadítanunk, hanem a virtuális gép megteszi ezt helyettünk. Pontosabban a szemétgyűjtő mechanizmus (garbage collector - GC), melynek feladata a nem használt objektumok eltakarítása a memóriaterületről. Így sokkal kisebb a hibalehetőség, cserébe egy automatizmus szabadítja fel a memóriát, aminek külön erőforrásra van szüksége, ami kiélezett helyzetekben (magas terhelés esetén) akár az alkalmazás teljesítményére is hatással lehet. A hibajelenség, amitől megszabadulunk, az a memóriaszivárgás (memory leak). Ez gyakorlatilag akkor történik, mikor már nincs szükségünk egy objektumra, nincs rá referencia, de a memóriaterületet nem szabadítottuk fel. Szerencsére a szemétgyűjtő mechanizmus megteszi ezt helyettünk.&lt;/p&gt;

&lt;p&gt;(Zárójelben jegyzem meg, hogy Java esetén is szoktak memóriaszivárgásról beszélni, azonban ennek kicsit más a jelentése. Ez a leggyakrabban kollekciók használatakor szokott felmerülni. Képzeljük el, hogy egy dinamikus méretű listát egy tömbbel ábrázolunk. Mivel a tömb mérete fix, egy változó jelzi, hogy a tömb épp hány elemét használjuk ki. Amennyiben töröljük az utolsó elemet, a működés szempontjából elegendő csak ennek a változónak az értékét csökkenteni. Ekkor azonban a tömb változón felüli eleme még tart referenciát az adott objektumra, ezért a szemétgyűjtő nem tudja kidobni. Emiatt kell null-ra állítanunk a tömb megfelelő elemét. Tipikus hiba még az eseménykezelők nem használatos objektumon tartása.)&lt;/p&gt;

&lt;p&gt;Fontos megkülönböztetni két memóriaterület, a heap és a stack fogalmát. A példányváltozók és az az összes példányosított objektum a heap-en helyezkedik el. A metódusban definiált, úgynevezett lokális változók vannak a stack-en (, ide tartoznak a metódushívás aktuális paraméterei is). Vigyázzunk, amennyiben a stack-en szereplő lokális változó típusa osztály, az osztály példánya már a heap-en helyezkedik el, a stack-en kizárólag az erre mutató referencia.&lt;/p&gt;

&lt;p&gt;Ezzel kapcsolatban párszor már találkoztam azzal a tévhittel, hogy a Java szemétgyűjtő mechanizmusa referenciaszámláló alapján működik. Azaz nézi, hogy egy objektumra hány hivatkozás van, és amennyiben ez nullára csökken, az objektum eldobható a memóriából. Ez nem így van. Képzeljük el, hogy A objektum hivatkozik B objektumra, és vissza. Amennyiben más hivatkozás nincs rájuk, mindkettő eltávolítható, de a referenciaszámlálója mindegyiknek egy. Ehelyett a JVM a következőképpen működik. Az élő szálak stack-jeiből elérhető objektumokat járja végig. Ez azt jelenti, hogy végigmegy a referenciákon, azaz az objektumokból elérhető objektumokon is. Ezeket megjelöli. (Ezen szabály alkalmazásán kívül még végigmegy a betöltött és még nem kidobott osztályok statikus tagjain, valamint a JNI-ből bejegyzett objektumokon is.) Eztán a nem megjelölt objektumokat kidobja. Azaz kidobja az összes olyan objektumot mely nem érhető el referenciákon keresztül egy élő szálból sem.&lt;/p&gt;

&lt;p&gt;A szemétgyűjtő mechanizmus megvalósítása nem a szabvány része, ezért különböző gyártók különbözőképpen implementálhatják azokat. Én most a legelterjedtebb, Sun (már Oracle) által gyártott, a Java 2 Platform, Standard Edition JDK-ban megtalálható Java HotSpot virtuális gépről fogok írni, továbbiakban JVM. Jó referencia a &lt;a href="http://java.sun.com/j2se/reference/whitepapers/memorymanagement_whitepaper.pdf"&gt;Memory Management in Java HotSpot Virtual Machine&lt;/a&gt; dokumentum. A JVM-nek három fő része van: runtime, JIT, és a memóriakezelést végző szemétgyűjtő mechanizmus.&lt;/p&gt;

&lt;p&gt;A szemétgyűjtő mechanizmus un. weak generational hypothesis-re épül. Megfigyelték az alkalmazások működését, és a következő szabályokat vették észre:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Az objektumok nagy része rövid életű&lt;/li&gt;
&lt;li&gt;Régi objektumból új objektumra viszonylag kevés hivatkozás van&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ezen megfigyelések az alkalmazások nagy részére igazak, persze lehetnek kivételek. Azaz a legtöbb alkalmazás úgy működik, hogy üzemelése közben gyakorta nagyon rövid életű, temporális objektumot gyárt, mely igazából csak az algoritmusok lefutásáig, a felhasználó kiszolgálásáig kellenek, utána el is dobhatóak. Csak viszonylag kevés objektum kell hosszú távon, és ezek utána hosszú életűek, és általában ritkán hivatkoznak újabb objektumokra. Ezen hipotézis alapján építették fel a szemétgyűjtő mechanizmust, és ezen szabályokkal szembe menni akár a szemétgyűjtő működését is megzavarhatják. (Tipikus példa erre az objektum cache, mely tipikusan a legrégebbi objektum, melybe újabb és újabb objektumok kerülhetnek. Ezeket a szemétgyűjtő kevésbé szereti.)&lt;/p&gt;

&lt;p&gt;A Sun mérnökei a JVM-be ráadásul nem csak egy, hanem több szemétgyűjtő mechanizmust is építettek. Ezek közül a JVM automatikusan képes választani, de akár explicit is megmondhatjuk, hogy melyiket használja. Bizonyos szemétgyűjtő algoritmusok más-más alkalmazások esetén, más-más architektúrákon különbözőképpen teljesíthetnek, így nincs mindenre jó megoldás, nekünk kell vagy a JVM-re hagyatkozni, vagy kiválasztani, hogy melyik a legmegfelelőbb. A választásnál a következőket kell figyelembe venni:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Áteresztőképesség (throughput): a futási idő hány százalékát tölti a CPU az alkalmazásunk futtatásakor nem a szemétgyűjtő futtatásával (persze megfelelő nagy időszeletre nézve)&lt;/li&gt;
&lt;li&gt;GC pluszmunka (overhead): az előző inverze, mennyi időt tölt a CPU a GC futtatásával az összes időhöz képest&lt;/li&gt;
&lt;li&gt;Állási idő (pause time): mennyi ideig áll az alkalmazás, míg a GC fut&lt;/li&gt;
&lt;li&gt;Szeméggyűjtő mechanizmus futtatásának gyakorisága (frequency): milyen gyakran fut a GC&lt;/li&gt;
&lt;li&gt;Memóriaigény (footprint): az alkalmazás memóriaigénye, pl. a heap mérete&lt;/li&gt;
&lt;li&gt;Reakcióidő (promptness): az idő aközött, amikor az objektum begyűjthetővé válik, és aközött, hogy a memória újra felhasználhatóvá válik&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ráadásul ezen mérőszámok egyikének javításakor a másik mérőszám rosszabb lesz, hiszen ellentmondanak egymásnak. Pl. amennyiben azt akarjuk, hogy kevesebbet álljon az alkalmazás, pl. a szemétgyűjtő több szálon dolgozzon, akkor a szálak adminisztrációja megnövekedett erőforrásidénnyel (mind CPU, mind memória) jár.&lt;/p&gt;

&lt;p&gt;Ahhoz, hogy megértsük a szemétgyűjtők működését, először meg kell értenünk a JVM memóriamodelljét. Talán legjobb vizuálisan szemléltetni. Az alábbi ábrára klikkelve bejön egy VisualVM-ben futó Visual GC plugin alapján készített GIF animáció, melyen egy JBoss alkalmazásszervert látunk futni. A VisualVM a JDK-ban megtalálható, a jvisualvm paranccsal indítható. A VisualGC plugin a Tools/Plugins menüpontból indítva külön letölthető. Mindkettő ingyenes, nyílt forráskódú eszköz.&lt;/p&gt;

&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://dl.dropbox.com/u/7683931/jtechlog/visualgc_gifanim.gif" rel="lightbox"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 299px;" src="http://4.bp.blogspot.com/-Hgkvfe-YRjA/Tv0QOVMrD1I/AAAAAAAAHrc/M0vJrloT35I/s320/visualgc_gifanim.gif" border="0" alt="Visual GC plugin egy JBoss futtatása közben" id="BLOGGER_PHOTO_ID_5691723342460686162" /&gt;&lt;/a&gt;

&lt;p&gt;A Spaces ablakban a JVM heap-je látható, ami három részre van felosztva: permanent generation (permgen), young és old. A permgen memóriaterületen helyezkednek el a betöltött osztályok definíciói, valamint a String pool (un. Interned Strings). A young területen (un. generation) helyezkednek el a fiatal objektumok, és az old területen helyezkednek el az idősebb objektumok (az előbb említett hipotézis miatt van ez a megbontás). A szemétgyűjtő mechanizmus mindkét területen lefut, de meg kell különböztetni ezeket. Tehát gyakran lefut az un. minor szemétgyűjtő, mely csak az young generation-ön dolgozik, és ritkábban a major/full szemétgyűjtő, ami az old generation-ön is lefut. Ez ritkábban fut, hiszen lassabban nő, és tovább tarthat, hiszen nagyobb területet kell átvizsgálnia a szemétgyűjtőnek.&lt;/p&gt;

&lt;p&gt;A young generation három részből áll: eden, survivor 0, survivor 1. A frissen példányosított objektumok először az eden-re kerülnek, amikor lefut rajtuk a szemétgyűjtő mechanizmus, és túlélnek (nem kerülnek eldobásra, élő objektumok), akkor kerülnek a survivor (túlélő) egyikére. Egyszerre mindig csak az egyik használt a survivor-ök közül. Amikor lefut a szemétgyűjtő, az a használt survivor-ön is lefut, és a túlélő objektumok átkerülnek a másik survivor területre. Az előző survivor tehát teljesen üres marad. Utána a szemétgyűjtő ismételt lefutásakor a fordított irányban vándorolnak a túlélő objektumok a survivor-ök között. Amennyiben az objektum túlélése elért egy megfelelő számot, átkerül az old generation-be.&lt;/p&gt;

&lt;p&gt;A &lt;a href="http://www.devx.com/Java/Article/21977/1954"&gt;Garbage Collection in the Java HotSpot Virtual Machine&lt;/a&gt; cikk ábráit használva a következő lépésekből áll tehát a young generation-ön a szemétgyűjtés. Az eden és az egyik survivor területen is gyűltek az objektumok.&lt;/p&gt;

&lt;img style="display:block; margin:0px auto 10px; text-align:center;width: 400px; height: 203px;" src="http://1.bp.blogspot.com/-pxm2DRTqypQ/Tv0RPi6bNpI/AAAAAAAAHr0/xKb7L8oFg6g/s400/yg_1.png" border="0" alt="Mark-sweep-compact algoritmus első lépése" id="BLOGGER_PHOTO_ID_5691724462833743506" /&gt;

&lt;p&gt;A túlélő objektumok az eden-ből és az egyik survivor-ből is a másik survivor területre kerülnek, valamint az egyik survivor-ből a bizonyos kort megélt objektumok az old generation-be kerülnek.&lt;/p&gt;

&lt;img style="display:block; margin:0px auto 10px; text-align:center;width: 400px; height: 304px;" src="http://4.bp.blogspot.com/-P05oLdHGVQM/Tv0RUwSJQ0I/AAAAAAAAHsA/j653Ofy-d3s/s400/yg_2.png" border="0" alt="Mark-sweep-compact algoritmus második lépése" id="BLOGGER_PHOTO_ID_5691724552322237250" /&gt;

&lt;p&gt;A szemétgyűjtés után mind az eden, mind az egyik survivor teljesen kiürül.&lt;/p&gt;

&lt;img style="display:block; margin:0px auto 10px; text-align:center;width: 400px; height: 304px;" src="http://3.bp.blogspot.com/-QHLWVHlrIvo/Tv0RYcEuD-I/AAAAAAAAHsM/pxCi8Iw0528/s400/yg_3.png" border="0" alt="Mark-sweep-compact algoritmus harmadik lépése" id="BLOGGER_PHOTO_ID_5691724615616696290" /&gt;

&lt;p&gt;Ha megnézünk egy más parancssori paraméterekkel indított JVM-et (a JDK demo\jfc\Java2D\ könyvtárában a Java2D-t demonstráló példaprogramot a &lt;code&gt;java -jar Java2Demo.jar&lt;/code&gt; paranccsal elindítva) kicsit más karakterisztikát láthatunk, de a működés alapvetően hasonlít. Itt megjelent egy Histogram nevezetű ablak, mely százalékosan mutatja a young generation objektumait, hogy hány százaléka hány szemétgyűjtést élt túl. Az ábrán a Tenuring threshold azt jelenti, hogy 15 szemétgyűjtés túlélése után kerül az objektum az old generation-be.&lt;/p&gt;

&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/-YzLzSTOkHKI/Tv0Q_JqbAfI/AAAAAAAAHro/6ZIyvELJiHE/s1600/gc1.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 230px;" src="http://3.bp.blogspot.com/-YzLzSTOkHKI/Tv0Q_JqbAfI/AAAAAAAAHro/6ZIyvELJiHE/s320/gc1.png" border="0" alt="Visual GC a Java2Demo futtatása közben" id="BLOGGER_PHOTO_ID_5691724181177827826" /&gt;&lt;/a&gt;

&lt;p&gt;Vizsgáljuk meg az első ábrát, az talán látványosabb. Egyrészt kevésbé észrevehető, hogy a Spaces ablakban a háttér világosabb és sötétebb szürke négyzetekkel van behálózva. A sötétszürke a ténylegesen lefoglalt memóriát (utilized, commited), míg a világosabb szürke a JVM által lefoglalható, de még nem lefoglalt memóriát jelzi (uncommited). A konkrét értékek látszanak a Graphs ablakban is. Látható, hogy a young generation esetén az eden-ben lévő objektumok összmérete folyamatosan nő, mígnem a GC grafikonon látjuk, hogy lefut egy szemétgyűjtés (zöld tüske), és ekkor az eden kiürül. Ezzel egy időben azt is látjuk, hogy a túlélő objektumok az egyik survivor-ből átkerülnek a másikba, nagyon szépen látható a narancs grafikonon, hogy egyszerre csak az egyik használt, és mérete nem változik, csak a szemétgyűjtés lefutásakor. Egy normál működésű szerver alkalmazásnál ha ilyen szép fűrészfoggal találkozunk, akkor megnyugodhatunk. Amennyiben a fogak túl sűrűek, ott baj lehet, hiszen a GC-nek gyakran kell futnia, ez egyrészt gyakrabban állítja le az alkalmazást, másrészt több erőforrást is igényel. Amennyiben a szemétgyűjtő lefutása után nem esik vissza a memóriahasználat, akkor is baj van, mert akkor valószínű, hogy memóriaszivárgásunk van. A permgen mérete általában állandó, vagy nagyon lassan növekszik. Ha az telik be, akkor találkozhatunk a java.lang.OutOfMemoryError: PermGen space hibával. Ez általában akkor van, amikor újratelepítgetünk egy alkalmazást az alkalmazásszerveren, és valami osztálybetöltő probléma miatt az előző alkalmazásunkat a konténer nem tudja kidobni, így annak class-ai is a permgen-en maradnak. Ami egy idő után, bizonyos számú telepítés után elfogyhat.&lt;/p&gt;

&lt;p&gt;Amennyiben az egyik survivor betelne, az ide kerülendő objektumok automatikusan az old generation-be kerülnek átmásolásra. Ezt a hibajelenséget premature promotion-nek nevezik. Amennyiben emiatt betelik az old generation is, és le kell futtatni a GC-t, promotion failure-nek nevezik.&lt;/p&gt;

&lt;p&gt;Amennyiben elfogy a memória, az OutOfMemoryError-t kapjuk. Jegyezzük meg azonban, hogy a JVM garantálja, hogy csak akkor dobja, ha a GC lefutott, és ezután nincs szabad memória. Azaz a szemétgyűjtőt mindenképpen meghívja. Emiatt sem érdemes kezelni catch ágban az OutOfMemoryError-t. És azért sem, mert ilyenkor már arra sem lesz memória, hogy kezeljük.&lt;/p&gt;

&lt;p&gt;A memóriakezelésben találunk még egyéb finomságokat, amiket érdemes megjegyezni. Egyrészt úgy kéne kiválogatni a young generation-ből azokat az objektumokat (mark), melyek használtak, hogy ne kelljen az egész old generation-t átvizsgálni, hogy nincs-e visszafele hivatkozás. Ehhez a garbage collector egy card table-t tart nyilván. Az old generation-t 512 bájtos darabokra bontja (chunks), és mindegyikhez egy flag-et társít. Amennyiben az old gen-ben egy objektum referálni kezd egy young gen-ben lévő objektumra, a beállító művelet a hozzá tartozó flag-et is (egy un. write barrier-en keresztül) átbillenti. A végén csak a billentett flag-gel rendelkező old gen-ben lévő objektumokkal kell törődni.&lt;/p&gt;

&lt;p&gt;Másik érdekes technika a gyors memóriafoglaláshoz szükséges. A JVM egy bump-the-pointer mechanizmust alkalmaz, ami egy mutatót használ annak a memóriahelynek a megjelölésére, ahova az új objektumot el lehet tenni. Elteszi az objektumot, majd feljebb emeli a pointer-t. Azonban többszálas környezetben ez macerás lehet, hiszen szinkronizálni kéne erre a mutatóra, és ott szűk keresztmetszet lehet. Ezért a JVM un. Thread-Local Allocation Buffer-eket (TLAB-ok) tart fenn szálanként. Ezek gyakorlatilag szálanként különböző memóriaterületek, így nincs szükség lock-ra.&lt;/p&gt;

&lt;p&gt;Ahhoz, hogy megértsük, mikor melyik szemétgyűjtő fut, valamint hogyan lehet bekapcsolni őket, beszélni kell a parancssori kapcsolókról, valamint az ergonomics-ról.&lt;/p&gt;

&lt;p&gt;A parancssori kapcsolóknak három fajtája van. A standard, non-standard (-X kapcsolóval kezdődnek) és a developer (-XX: kapcsolóval kezdődnek). A szabványos kapcsolókat a Java Virtual Machine Specification definiálja. Az utóbbi két kapcsoló nem szabványos, JVM-enként mások lehetnek. Minden további nélkül változhat a működésük különböző JDK verziók között, tehát mindig érdemes figyelni a release notes-okat. A developer kapcsolók felépítése a következő. Minden paraméternek van egy típusa, általában boolean vagy int. Amennyiben boolean, a paraméter neve előtt + vagy - karakterrel lehet be vagy kikapcsolni (pl. -XX:+UseSerialGC a serial collector bekapcsolására). Amennyiben int, a paraméter neve után kell írni, egyenlőségjellel elválasztva, és gyakran egy mértékegységet is írhatunk utána (pl. -XX:NewSize=64m, amivel az új generáció kezdeti és minimális méretét állítjuk 64 megára). A paraméterek rendelkeznek valamilyen default értékkel. A developer paraméterek egy listája a &lt;a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html"&gt;Java HotSpot VM Options&lt;/a&gt; címmel található az Oracle oldalán.&lt;/p&gt;

&lt;p&gt;A JDK az 1.5 verziótól kezdve felismeri az alatta lévő architektúrát, és két osztály egyikébe sorolja, vagy kliens osztályú, vagy szerver osztályú gépek csoportjába. A JDK 6-ban a detektálásról JDK dokumentációjának &lt;a href="http://docs.oracle.com/javase/6/docs/technotes/guides/vm/server-class.html"&gt;Server-Class Machine Detection&lt;/a&gt; fejezete ír. Alapvetően a legalább 2 CPU-val (maggal) és legalább 2 GB memóriával rendelkező nem Windows-os gépeket soroljuk ide. Az osztályt explicit is meg lehet adni a -client vagy -server parancssori kapcsolók megadásával. Az ergonomics másik része, hogy a egyrészt az osztály alapján választ szemétgyűjtő mechanizmust, valamint a megadott paraméterek alapján automatikusan finomhangolja a heap memóriaterületek méretét, nem nekünk kell megadni azokat. Erről a JDK dokumentációjának &lt;a href="http://docs.oracle.com/javase/6/docs/technotes/guides/vm/gc-ergonomics.html"&gt;Garbage Collector Ergonomics&lt;/a&gt; fejezete ír. Ha egyéb kapcsolót nem adunk meg, kliens osztályú gép esetén client JVM fut, serial collector (lsd. később), 4 mega kezdeti heap méret, és 64 mega maximum heap méret. Szerver esetén a kezdeti heap méret a fizikai memória hatvannegyede, minimum 32 mega, maximum 1 giga. Maximum heap méret a fizikai memória egynegyede, maximum 1 giga.&lt;/p&gt;

&lt;p&gt;És akkor következzenek a szemétgyűjtő mechanizmusok, a következő sorrendben:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Serial Collector&lt;/li&gt;
&lt;li&gt;Parallel/Throughput Collector&lt;/li&gt;
&lt;li&gt;Parallel Compacting Collector&lt;/li&gt;
&lt;li&gt;Concurrent Mark-Sweep (CMS) Collector&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Serial Collector&lt;/h3&gt;

&lt;p&gt;A serial collector esetén a young és az old terület szemétgyűjtése is egy szálon történik, un. stop-the-world módon. Ez azt jelenti, hogy a JVM az alkalmazást teljesen leállítja, amíg a szemétgyűjtés folyik. Ez valójában úgy történik, hogy az összes Java szálat leállítja (un. safepoint), hogy ne változzon a heap, sem a szálhoz tartozó stack. Érezhető, hogy ez a megállás gyakorlatilag a szemétgyűjtéses megközelítés legnagyobb hátránya. Ez normális működés esetén észrevehetetlen, de nagy terhelés, intenzív memóriahasználat, sok párhuzamos felhasználó esetén már nagyban ronthatja az alkalmazásunk teljesítményét. A young generation szemétgyűjtése a fentebb leírt módon történik, azaz a túlélő objektumok a survivor-re, majd az old generation területre kerülnek. Az old generation és permanent generation szemétgyűjtése un. mark-sweep-compact algoritmussal történik. Mark fázisban a szemétgyűjtő megjelöli az élő objektumokat, a sweep fázisban kitakarítja a nem élő objektumokat, és a compact fázisban az élő objektumokat a megfelelő memóriaterület elejére tolja. Így a memóriaterületen nem lesznek lyukak, az elején lesznek az élő objektumok, a végén az üres hely. Így használható a fentebb említett bump-the-pointer mechanizmus. Ezt használva nem jelentkezik a memória töredezettsége, melyet később részletezek.&lt;/p&gt;

&lt;p&gt;A serial collector általában remek választás kliens oldali alkalmazások esetén, akár egy 64 megás heap esetén is viszonylag ritka és rövid (&lt; 0,5 mp) leállásokkal jár. Ez felhasználói felületekkel rendelkező, egy felhasználót kiszolgáló alkalmazások esetén megfelelő. Akkor is jól jöhet, ha több JVM osztozik egy processzoron, hiszen ekkor úgysem tud párhuzamosan futni a szemétgyűjtés a processzorok kihasználtsága miatt, ugyanis a többi algoritmus valahogy párhuzamosítani próbál. A serial collector az alapértelmezett a nem szerver-osztályú gépek esetén. Egyéb esetben a &lt;code&gt;-XX:+UseSerialGC&lt;/code&gt; parancssori kapcsolóval lehet bekapcsolni.&lt;/p&gt;

&lt;h3&gt;Parallel/Throughput Collector&lt;/h3&gt;

&lt;p&gt;A parallel/throughput collector annyival másabb, mint a serial collector, hogy a young generation szemétgyűjtése nem egy szálon, hanem több szálon fut. De ugyanúgy megállítja a többi szálat, és másolja az objektumokat a memóriaterületek között. Az old generation szemétgyűjtése megegyezik a serial collector szemétgyűjtésével, ami a mark-sweep-compact algoritmus. Ennek a szemétgyűjtőnek használatát több processzor(mag) kihasználására tervezték, és ott érdemes alkalmazni, ahol nem baj, ha az old generation meg is akasztja az alkalmazás futását. A young generation szemétgyűjtése tehát rövidebb megállást eredményez, de több processzoridőt és memóriát igényel a szálak karbantartása miatt. Hasznos lehet pl. nagytömegű batch feldolgozások, számlázás, tudományos számítások, stb. Automatikusan kiválasztásra kerül szerver osztályú gépeken, egyéb esetben a &lt;code&gt;-XX:+UseParallelGC&lt;/code&gt; parancssori kapcsolóval lehet bekapcsolni.&lt;/p&gt;

&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/-tBvK_ai1xjc/Tv0Ru1kfiUI/AAAAAAAAHsk/Ol1AlFrE52A/s1600/serial_parallel.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 224px;" src="http://2.bp.blogspot.com/-tBvK_ai1xjc/Tv0Ru1kfiUI/AAAAAAAAHsk/Ol1AlFrE52A/s320/serial_parallel.png" border="0" alt="Serial és parallel collector összehasonlítása" id="BLOGGER_PHOTO_ID_5691725000417970498" /&gt;&lt;/a&gt;

&lt;h3&gt;Parallel Compacting Collector&lt;/h3&gt;

&lt;p&gt;Ez a szemétgyűjtő algoritmus a J2SE 5.0 update 6-ban került bevezetésre. A young generation szemétgyűjtése megegyezik az előző, parallel/throughput collector működésével. A különbség csak az old generation szemétgyűjtésénél van, konkrétan ez is több szálon képes futni. Ez a szemétgyűjtés három fázisból áll: marking, summary, compaction. A marking fázisban a memória régiókra kerül felosztásra. Az alkalmazásból közvetlenül elérhető objektumokat a szálak szétosztják egymás között, és elkezdenek végigmenni a referenciákon, és megjelölik a használt objektumokat. A második, summary fázis már nem objektumokon, hanem régiókon dolgozik. A szemétgyűjtő működésének eredményeképpen egy olyan állapot jön létre, hogy a memóriaterület elején sűrűbb rész van, a végén ritkább. A sűrűbb azt jelenti, hogy onnan viszonylag ritkán kell objektumokat kidobálni. A szemétgyűjtő az elejétől a végéig végigmegy a régiókon, és kitalálja, hogy melyik régiótól kezdve éri meg kidobálni az objektumokat. Ezen pont előtt lévő terület a dense prefix, ezt a szemétgyűjtő nem bántja. A compaction fázisban történik a lyukak feltöltése a ritkább területen. Tehát ennek a szemétgyűjtésnek is a végén a memóriaterület eleje összefüggő, teli, míg a vége üres.&lt;/p&gt;

&lt;p&gt;Ez a szemétygyűjtő akkor lehet megfelelő, ha a szemétgyűjtő által okozott állási idő igenis fájdalmas, így ezt kell csökkenteni, párhuzamossággal. A &lt;code&gt;-XX:+UseParallelOldGC&lt;/code&gt; parancssori kapcsolóval lehet bekapcsolni.&lt;/p&gt;

&lt;h3&gt;Concurrent Mark-Sweep (CMS) Collector&lt;/h3&gt;

&lt;p&gt;A CMS collector-t olyan alkalmazások számára fejlesztették ki, ahol igen fontos a válaszidő, pl. webes alkalmazásoknál. Mivel a young generation szemétgyűjtése annak kis méretéből adódóan igen gyors, az ugyanúgy működik, mint a Parallel/Throughput Collector esetében. A változás itt is az old generation szemétgyűjtésében van. A szemétgyűjtés itt négy fázisból áll: initial mark, concurrent marking phase/pre-cleaning, remarking, concurrent sweeping. Az első, initial mark fázisban a szemétgyűjtő megjelöli az alkalmazásból közvetlenül elérhető objektumokat. Ekkor stop the world van, azaz az alkalmazás szálai leállnak. Majd a concurrent marking phase fázisban az alkalmazás futásával egyidőben (és ettől konkurens) bejelöli a tranzitíven elérhető objektumokat. A remark fázisban ismét stop the world, a szemétgyűjtő bejárja az előző fázis közben módosult objektumokat, ezzel véglegesíti az élő objektumok bejelölését. Ez már több szálon történik. A concurrent sweep fázis eltávolítja a szemetet. Látható, hogy egyrészt több munkával jár, másrészt lehetnek olyan nem használt objektumok, amik nem takarodnak ki az első szemétgyűjtéskor (ez az un. floating garbage). Ez az ára a rövidebb válaszidőnek. Látható, hogy a CMS collector un. non-compacting szemétgyűjtő, azaz a memóriaterületen nem egybefüggően lesznek az objektumok, hanem lyukak lesznek közöttük. Ez egyrészt megnehezíti a kezelést, hiszen nem egy pointer-t kell nyilvántartani, hanem egy listában kell nyilvántartani a szabad területeket. Másrészt fregmentálódáshoz is vezet, azaz nem egyszerű betenni sem egy újonnan példányosított objektumot. A többi szemétgyűjtővel ellentétben a CMS collector nem akkor fut le, mikor betelik a memóriaterület, hanem hamarabb, hogy még képes legyen lefutni. Ha ez nem sikerül, akkor mindenképpen a jól ismert mark-sweep-compact algoritmus fut le, mely az előző szemétgyűjtőknél is.&lt;/p&gt;

&lt;p&gt;A CMS collector jól alkalmazható ott, ahol fontos a gyors válaszidő, és több processzor tud a szemétgyűjtő munkájában részt venni, valamint viszonylag sok hosszúéletű objektum van. Ilyenek tipikusan a többprocesszoros gépeken futó webes alkalmazások. A &lt;code&gt;-XX:+UseConcMarkSweepGC&lt;/code&gt; parancssori kapcsolóval lehet bekapcsolni.&lt;/p&gt;

&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/-11k03z2nctk/Tv0RpKPz9-I/AAAAAAAAHsY/cIXDUtKZI-4/s1600/serial_cms.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 202px;" src="http://3.bp.blogspot.com/-11k03z2nctk/Tv0RpKPz9-I/AAAAAAAAHsY/cIXDUtKZI-4/s320/serial_cms.png" border="0" alt="Serial és CMS collector összehasonlítása" id="BLOGGER_PHOTO_ID_5691724902889158626" /&gt;&lt;/a&gt;

&lt;p&gt;Összefoglalva a következőket lehet megállapítani, a szemétgyűjtőket a következő tulajdonságok alapján lehet vizsgálni:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;A serial szemétgyűjtés jó egy processzoros gépen, de a parallel szemétgyűjtés, amennyiben több processzor tud részt venni, rövidebb ideig tarthat, de több erőforrás szükséges hozzá.&lt;/li&gt;
 &lt;li&gt;A stop the world megközelítés biztosítja, hogy nem módosul a stack/heap, de cserébe leállással jár. A concurrent szemétgyűjtés az alkalmazás mellett fut, így több processzor szükséges, és több erőforrás is szükséges hozzá. Nincs teljesen concurrent szemétgyűjtő, kizárólag olyan, melynek valamely fázisa concurrent.&lt;/li&gt;
 &lt;li&gt;A compacting lassabb ugyan, mert objektumokat kell másolgatni, de egy pointer-rel elintézhető a szabad hely nyilvántartása. Non compacting esetben az adminisztráció is bonyolultabb, valamint töredezettség léphet fel.&lt;/li&gt;
&lt;/ul&gt; 

&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/-Qgi9Ta1Z2UU/Tv0TcIRlNKI/AAAAAAAAHsw/VKq_a23Nsj4/s1600/tablazat.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 400px; height: 130px;" src="http://1.bp.blogspot.com/-Qgi9Ta1Z2UU/Tv0TcIRlNKI/AAAAAAAAHsw/VKq_a23Nsj4/s400/tablazat.png" border="0" alt="Szemétgyűjtő algoritmusok összehasonlítása" id="BLOGGER_PHOTO_ID_5691724902889158626" /&gt;&lt;/a&gt;

&lt;p&gt;&lt;a href="http://blogs.oracle.com/jonthecollector/entry/our_collectors"&gt;Our Collectors&lt;/a&gt; címmel egy elég jó cikket és grafikát találunk a young és old generation szemétgyűjtő algoritmusainak, valamint parancssori paramétereinek kapcsolatáról.&lt;/p&gt;

&lt;p&gt;A Java 6 update 20-ban megjelent, és a 7-es sorozatban is megtalálható a Garbage First Collector, vagy röviden G1. Ez teljesen más megközelítést használ, viszont kevesebb tapasztalat van vele, ezért erről sem írni nem tudok, és mindenkit óvatosságra intenék ezzel kapcsolatban.&lt;/p&gt;

&lt;p&gt;Mivel nézzük, hogy hogyan működik a szemétgyűjtő? Az első, legegyszerűbb eszköz a JVM &lt;code&gt;-verbose:gc&lt;/code&gt; vagy &lt;code&gt;-XX:PrintGCDetails&lt;/code&gt; paraméterrel való futtatása. Nézzünk szét a JVM developer paraméterei között, rengeteg statisztikát ki lehet nyerni. A másik megoldás, ha a fentebb említett VisualVM Visual GC plugin-ját használjuk.&lt;/p&gt;

&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/-GjlUS3xFW4s/Tv2aJr_SwWI/AAAAAAAAHs8/8TuO1vZaPcc/s1600/gc_details.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 245px;" src="http://4.bp.blogspot.com/-GjlUS3xFW4s/Tv2aJr_SwWI/AAAAAAAAHs8/8TuO1vZaPcc/s320/gc_details.png" border="0" alt="A JVM -XX:PrintGCDetails paraméterrel indítva" id="BLOGGER_PHOTO_ID_5691874995283870050" /&gt;&lt;/a&gt;

&lt;p&gt;Nem szorosan ide tartozik, de nagyon hasznos lehet a JVM un. Fatal Error Handling tulajdonsága. Amennyiben olyan hiba keletkezik, melyet nem tudunk kódból lekezelni, pl. OutOfMemoryError, megadhatunk a JVM-nek olyan kapcsolókat, melyeket használva mégis előrébb vagyunk. Pl. &lt;code&gt;-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=&amp;lt;path&gt;&lt;/code&gt; paraméterekkel megmondhatjuk, hogy a JVM készítsen egy heap dump-ot. Amit akár VisualVM-be is betölthetünk, és grafikusan elemezhetünk. A &lt;code&gt;-XX:OnOutOfMemoryError=&amp;lt;parancs(ok)&gt;&lt;/code&gt; paraméterekkel operációsrendszerbeli parancsokat adhatunk meg, melyeket lefuttat a JVM hiba esetén (bármilyen script-et hívhatunk itt). A &lt;code&gt;-XX:+ShowMessageBoxOnError&lt;/code&gt; parancssori kapcsoló hatására feldob egy dialógusablakot. Ez azért jó, mert ekkor még nem áll le a JVM, így akár egy profiler-rel is neki tudunk menni.&lt;/p&gt;

&lt;p&gt;Ez alapján el lehet kezdeni a GC tuning-olását, mely egy külön tudomány. Jó kiindulási alap lehet az Oracle &lt;a href="http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html"&gt;Java SE 6 HotSpot[tm] Virtual Machine Garbage Collection Tuning&lt;/a&gt; cikke.</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/8365011667058151286/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html#comment-form' title='14 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/8365011667058151286'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/8365011667058151286'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html' title='Java memóriakezelés, szemétgyűjtő algoritmusok'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://4.bp.blogspot.com/-Hgkvfe-YRjA/Tv0QOVMrD1I/AAAAAAAAHrc/M0vJrloT35I/s72-c/visualgc_gifanim.gif' height='72' width='72'/><thr:total>14</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-43432132572840305</id><published>2011-12-13T00:45:00.005+01:00</published><updated>2011-12-29T13:05:43.840+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='instrumentation'/><category scheme='http://www.blogger.com/atom/ns#' term='Java SE'/><category scheme='http://www.blogger.com/atom/ns#' term='JMX'/><title type='text'>Instrumentation Javassist-tal</title><content type='html'>&lt;p&gt;Technológiák: Javassist 3.15&lt;/p&gt;

&lt;p&gt;Belefutottam egy olyan &lt;a href="http://stackoverflow.com/questions/7096121/profile-entire-java-program-execution-in-visualvm"&gt;problémába&lt;/a&gt;, hogy egy alkalmazást szeretnék monitorozni VisualVM-mel (régebben már írtam &lt;a href="http://jtechlog.blogspot.com/2011/04/visualvm-glassfish-monitorozas.html"&gt;róla&lt;/a&gt;), azonban az alkalmazás számomra szignifikáns része már lefut, mielőtt hozzá tudnák csatlakozni a virtuális géphez. A VisualVM egy monitoring és menedzsment eszköz, nagyon mélyen lehet a virtuális gép működését megfigyelni, és a JDK része. A &lt;code&gt;-Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=y&lt;/code&gt; parancssori kapcsoló használata nem segít, ugyanis ebben az esetben a megállt alkalmazást csak olyan profiler képes továbblökni, mely beszéli a Java Debug Wire Protocol (JDWP) protokollt, a VisualVM viszont nem ilyen. (Míg a Eclipse TPTP vagy a Netbeans Profiler igen. Más kérdés ugyan, hogy a VisualVM is tartalmaz profiler-t, ráadásul ugyanaz, ami a NetBeans-ben is van, ez utóbbi csak annyival több, hogy a forráskódhoz tud pozícionálni.)&lt;/p&gt;

&lt;p&gt;A problémára több megoldási javaslatot is lehet kapni a neten, pl. más profiler (előbb említetteken kívül még sok van, pl. a JDK részeként szállított parancssori HPROF, vagy a kereskedelmi YourKit vagy JProfiler), debug módban indítás IDE-ből, valamint az alkalmazásban várakozás elhelyezése (sleep, Console input).&lt;/p&gt;

&lt;p&gt;Gondoltam, ez egy megfelelő alkalom az instrumentation és a Javassist kipróbálására. Így készítettem egy egyszerű példaprogramot, mely elérhető a &lt;a href="https://github.com/vicziani/jtechlog-wait4signal"&gt;GitHub&lt;/a&gt;-on. A program egy Java agent, melynek segítségével egy Java alkalmazás adott szálának futása a megadott metódusnál felfüggeszthető, és vagy konzolon bevitt, vagy JMX-en feladott jelre vár. Mindezt az alkalmazás forráskódjának módosítása nélkül.&lt;/p&gt;

&lt;p&gt;Maven-nel build-elhető, és a letöltést követően a 'mvn package assembly:single' parancs kiadásával a target könyvtárban létrejön egy jtechlog-wait4signal-1.0-SNAPSHOT-bin.zip és egy
jtechlog-wait4signal-1.0-SNAPSHOT-tar.gz állomány. Valamelyik lib könyvtárában lévő két jar fájlt kell felhasználni.&lt;/p&gt;

&lt;p&gt;A következő parancs kiadásával lehet az agent-et aktiválni:&lt;/p&gt;

&lt;pre&gt;java -javaagent:jtechlog-wait4signal-1.0-SNAPSHOT.jar=entryPoint=java2d.Java2Demo.main -jar Java2Demo.jar&lt;/pre&gt;

&lt;p&gt;Ekkor a konzolon vár egy Enter lenyomásáig, vagy 5 másodperc múlva mindenképp lefuttatja az alkalmazást.&lt;/p&gt;

&lt;p&gt;A következő parancs kiadásával lehet JMX-en értesítést aktiválni:&lt;/p&gt;

&lt;pre&gt;java -javaagent:jtechlog-wait4signal-1.0-SNAPSHOT.jar=entryPoint=java2d.Java2Demo.main,mode=JMX,timeout=30 -jar Java2Demo.jar&lt;/pre&gt;

&lt;p&gt;Ekkor a &lt;code&gt;jtechlog/SignalMBean signal()&lt;/code&gt; operációjával lehet a futtatást továbbengedni, vagy 30
másodperc múltán timeout.&lt;/p&gt;

&lt;p&gt;Régebben &lt;a href="http://jtechlog.blogspot.com/2009/05/hibernate-eclipselink-atallas.html"&gt;már írtam arról&lt;/a&gt;, hogy az instrumentációt, azaz a bytecode módosítását futásidőben, osztálybetöltéskor a &lt;a href="http://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html"&gt;java.lang.instrument&lt;/a&gt; csomag felhasználásával lehet megvalósítani. Az agent fő osztálya a &lt;code&gt;jtechlog.wait4signal.Wait4SignalMain&lt;/code&gt; osztály, melynek &lt;code&gt;premain&lt;/code&gt; metódusa fut le a saját alkalmazásunk main metódusa előtt. Ahhoz, hogy a -javaagent megadásakor ehhez az osztályhoz kerüljön a vezérlés, a anifest.mf fájlban a Agent-Class bejegyzésnek rá kell hivatkoznia.&lt;/p&gt;

&lt;pre class="brush: java"&gt;public static void premain(String agentArgs, Instrumentation inst) {
 System.out.println("Initializing Wait4Signal Java agent.");
 Wait4SignalMain wait4SignalMain = new Wait4SignalMain();
 wait4SignalMain.doInstrumentation(agentArgs, inst);
}
&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;doInstrumentation&lt;/code&gt; metódus feldolgozza a parancssori paramétereket (a JAR neve és egy egyenlőségjel után megadott String), ezek konvenció szerint név és érték párok, köztük egyenlőségjel, vesszővel elválasztva. Lehetséges paraméterek: entryPoint (kötelező megadni, osztály és metódus neve, mely előtt meg kell állítani a program futását), mode (ha nincs megadva CONSOLE mód, azaz konzolon vár Enter billenytű megnyomását, vagy JMX), és timeout (másodpercben, alapértelmezett értéke 5). Majd a következő utasítás megadásával egy új &lt;code&gt;ClassFileTransformer&lt;/code&gt; implementációt regisztrál:&lt;/p&gt;

&lt;pre class="brush: java"&gt;inst.addTransformer(new WaitTransformer(entryPoint, waiting));
&lt;/pre&gt;

&lt;p&gt;Egy ötlet volt az is, hogy a &lt;code&gt;premain&lt;/code&gt; metódusban állítom meg a program futását, azonban ez nem volt megfelelő, hiszen a JVM ilyenkor olyannyira nem inicializálta magát, hogy a VisualVM sem tudott hozzá kapcsolódni életciklusának ezen pontján.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;WaitTransformer&lt;/code&gt; a &lt;code&gt;transform&lt;/code&gt; metódust definiálja felül, és vizsgálja, hogy az osztály neve megegyezik-e a parancssori kapcsolóként megadottal.&lt;/p&gt;

&lt;pre class="brush: java"&gt;public byte[] transform(ClassLoader loader, String className, 
 Class&amp;lt;?&amp;gt; classBeingRedefined, ProtectionDomain protectionDomain, 
 byte[] classfileBuffer) throws IllegalClassFormatException
&lt;/pre&gt;

&lt;p&gt;A transform metódus számunkra érdekes paraméterei az osztály osztálybetöltője (null, ha bootstrap osztálybetöltő), az osztály neve (vigyázat, pontok helyett perjelekkel), valamint az osztály bytecode-jának byte tömbjét. Ezt szabadon módosíthatjuk, és ezt kell visszaadni a metódus visszatérési értékeként. Vigyázat, az ebből a metódusból kilépő kivételeket a JVM elnyeli.&lt;/p&gt;

&lt;p&gt;Persze nem kell a byte tömböt közvetlenül módosítani, itt jöhet segítségünkre a &lt;a href="http://www.javassist.org/"&gt;Javassist&lt;/a&gt; (Java Programming Assistant), mely egy Java bytecode futásidejű manipulálását megkönnyítő programkönyvtár. Két szintű API-t ad a kezünkbe. A forráskód szintű API segítségével Java utasításokat, mint String-eket szúrhatunk be, ezeket a Javassist on-the-fly fogja átfordítani bytecode-dá. Ekkor persze nem szükséges ismernünk a class fájl szerkezetét. Vagy manipulálhatjuk alacsonyabb szinten is, közvetlen a bytecode-ot. Ezen lehetőségek rendkívül alkalmassá teszik a Javassist-ot AOP keretrendszerek fejlesztésére. Remek &lt;a href="http://www.csg.is.titech.ac.jp/%7Echiba/javassist/tutorial/tutorial.html"&gt;tutorial&lt;/a&gt; is van hozzá.&lt;/p&gt;

&lt;p&gt;A következő részben a Javassist érdekesebb kódrészleteit emelem ki, melyek a bytecode-ot módosítják.&lt;/p&gt;

&lt;pre class="brush: java"&gt;
ClassPool pool = ClassPool.getDefault();
CtClass cl = pool.makeClass(new java.io.ByteArrayInputStream(classfileBuffer));

if (cl.isInterface() == false) {
 CtBehavior[] methods = cl.getDeclaredBehaviors();

 for (int i = 0; i &lt; methods.length; i++) {
  if (entryPoint.endsWith(methods[i].getName())) {
   ctBehavior.insertBefore(waiting.insertBeforeMethod());
  }
 }
 classfileBuffer = cl.toBytecode();
}
cl.detach();
&lt;/pre&gt;

&lt;p&gt;A fenti kódrészlet először lekér egy ClassPool-t, ez a Javassist-ban lévő osztályok tárolására szolgáló konténer. Ebbe definiál egy CtClass (compile-time class) példányt, mely az osztály absztrakt reprezentációja. Ennek forrása az instrumentálás során átadott byte tömb. Amennyiben ez egy interfész, lekéri ennek metódusait a &lt;code&gt;getDeclaredBehaviors()&lt;/code&gt; metódushívással. Ezeken végigiterál, és ha a metódus neve megfelelő, akkor beszúr kódrészletet az &lt;code&gt;insertBefore&lt;/code&gt; metódushívással. Ennek érdekessége, hogy egy String-et vár, tehát bármilyen Java forráskódot be lehet illeszteni, mintha csak a .java forrásfájlba tettük volna ezt.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;waiting.insertBeforeMethod()&lt;/code&gt; a mode parancssori kapcsoló függvényében más és más String-et ad vissza. Pl. CONSOLE mode esetén példányosít egy &lt;code&gt;ConsoleWaiting&lt;/code&gt; objektumot, majd beállítja a timeout property-jét, majd meghívja a &lt;code&gt;wait4signal()&lt;/code&gt; metódusát.&lt;/p&gt;

&lt;pre class="brush: java"&gt;public String insertBeforeMethod() {
 StringBuilder sb = new StringBuilder();
 sb.append("jtechlog.wait4signal.Waiting waiting = new jtechlog.wait4signal.ConsoleWaiting();");
 sb.append(String.format("waiting.setTimeout(%s);", timeout));
 sb.append("waiting.wait4signal();");
 return sb.toString();
}

&lt;/pre&gt;

&lt;p&gt;Érdekessége, hogy a wait4signal() metódus a &lt;code&gt;ConsoleInput&lt;/code&gt; és &lt;code&gt;ConsoleInputReadTask&lt;/code&gt; osztályokat használja a konzolról való beolvasásra, és a Java 5-ben megjelent ExecutorService-t használja a külön szálon való bekérésre. Erre azért van szükség, hogy itt is működjön a timeout (&lt;a href="http://www.javaspecialists.eu/archive/Issue153.html"&gt;The Java Specialists' Newsletter&lt;/a&gt; cikke alapján).&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;JmxWaiting&lt;/code&gt; osztály ezzel szemben egy BlockingQueue-t használ, és abba vár egy üzenetet. A &lt;code&gt;BlockingQueue.poll(int, TimeUnit)&lt;/code&gt; metódusával vár egy üzenetre, timeout esetén null a visszatérési értéke. A BlockingQueue a &lt;code&gt;SignalMBean&lt;/code&gt; MBean-nek is átadásra kerül. Amennyiben a felhasználó meghívja a &lt;code&gt;signal()&lt;/code&gt; operációját, egy üzenetet tesz a Queue-ba. A &lt;code&gt;JmxWaiting&lt;/code&gt; ekkor beszünteti a várakozást, és fut tovább. A JMX-ről egy &lt;a href="http://jtechlog.blogspot.com/2009/09/java-monitorozas-es-menedzsment.html"&gt;korábbi postban&lt;/a&gt; tettem említést.&lt;/p&gt;

&lt;p&gt;Az agent-nek szüksége van tehát a Javassist JAR fájlra is, ehhez a manifest.mf fájlba fel kell venni a Boot-Class-Path bejegyzésbe a JAR fájl nevét. Abszolút (perjel) nélkül adtam meg, így a jtechlog-wait4signal-1.0-SNAPSHOT.jar állománnyal egy könyvtárban fogja keresni (függetlenül a JVM indítási könyvtárától).&lt;/p&gt;

&lt;p&gt;Látható, hogy a JVM induláskor, az osztálybetöltés során a Java class fájlok manipulálása korántsem akkora varázslat, mint első látásra hinnénk. Több nyílt forráskódú alternatíva is létezik bytecode manipulálásra, többek között a &lt;a href="http://cglib.sourceforge.net/"&gt;cglib&lt;/a&gt;, &lt;a href="http://commons.apache.org/bcel/index.html"&gt;Apache Commons BCEL&lt;/a&gt;, &lt;a href="http://asm.ow2.org/"&gt;ASM&lt;/a&gt;.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/43432132572840305/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2011/12/instrumentation-javassist-tal.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/43432132572840305'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/43432132572840305'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/12/instrumentation-javassist-tal.html' title='Instrumentation Javassist-tal'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-912143685418710554</id><published>2011-11-28T01:06:00.001+01:00</published><updated>2012-11-16T11:05:58.755+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Maven'/><category scheme='http://www.blogger.com/atom/ns#' term='DocBook'/><title type='text'>Szabad navigáció okozta problémák webes környezetben</title><content type='html'>&lt;p&gt;Technológiák: Servlet 3.0/JSP 2.2, DocBook 4.5, Docbkx Tools, Docbkx Maven Plugin, Maven 3&lt;/p&gt;

&lt;p&gt;Legrégebb óta írt cikkem kerül most publikálásra, melynek címe "Szabad navigáció okozta problémák webes környezetben".&lt;/p&gt;

&lt;p&gt;Ez a cikk azon problémával foglalkozik, mely a legtöbb webes alkalmazás fejlesztésekor felmerül, ugyanis nem biztosítható az, hogy a felhasználó olyan sorrendben nézze meg az oldalakat, ahogy azt az alkalmazás fejlesztője eltervezi. Használhatja a Vissza és Tovább műveleteket is navigációra, valamint újratöltheti az oldalt a Frissítés művelettel. Ezen műveletek elérhetők a böngésző szokásos gombjai között, billentyűkombinációval, de jobb kattintásra felugró menüben is. Sokan megszokásból, esetleg türelmetlenség (, a lassú válaszidő) miatt duplán kattintanak egy adott hivatkozásra. A felhasználó kézzel is beírhat egy url-t, vagy a Kedvencek közül is választhat egyet, ami szintén hibás működéshez vezethet, ha erre nem készülünk fel, és bízunk, hogy csak a felületi elemeket (űrlap elemek – gomb, legördülő menü, stb., hivatkozások) fogja használni. A böngészők és tűzfalak gyorsítótár beállításai is megzavarhatják az előre tervezett munkafolyamatot. A probléma a webes technológia, a http(s) protokoll, valamint a böngészők adta lehetőségek miatt jelentkezik.&lt;/p&gt;

&lt;p&gt;A cikk egy jtechlog-repost példa projektre hivatkozik, mely &lt;a href="https://github.com/vicziani/jtechlog-repost"&gt;letölthető a GitHub-ról&lt;/a&gt;. Egyszerű webes alkalmazás, servlet 
controller és JSP view réteggel. Maven-nel build-elhető, és a letöltést követően a 'mvn jetty:run' paranccsal futtatható.&lt;/p&gt;

&lt;p&gt;Példaprogrammal, szekvencia diagramokkal és forráskódokkal szemlélteti a webes alkalmazásokban gyakran felmerülő problémákat, melyek a szabad navigációból erednek. Ha te is találkoztál, vagy írtál olyan alkalmazást, ahol problémát okozott, ha a felhasználó véletlenszerűen használta a Vissza/Előre gombokat, ha a többszöri kattintás felesleges terhelést okozott a szerveren, ha Frissít gomb megnyomásakor a böngésző hibaüzenetet dobott fel, akkor a cikk neked való. Nem csak a problémákat, de a rá adott szabványos megoldásokat is ismerteti, mint a Redirect After Post, vagy a Synchronizer Token. Olyan ide kapcsolódó témákat is érint, mint a hosszú, aszinkron folyamatok kezelése, vagy a problémák megoldása AJAX környezetben.&lt;/p&gt;

&lt;p style="text-align: center"&gt;&lt;a href="http://vicziani.github.com/artifacts/repost.pdf"&gt;Szabad navigáció okozta problémák webes környezetben cikk letöltése&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A dokumentáció érdekessége, hogy &lt;a href="http://www.docbook.org/"&gt;DocBook-ban&lt;/a&gt; íródott, mely egy XML formátum könyvek, cikkek publikálására. Ugyanis meguntam a Word ezirányú képességeit, hogy hosszabb dokumentációnál elveszti a kontrollt, bizonyos dolgokat sokszor körülményes vele megcsinálni. Mivel az XML egy szöveges állomány, ilyen nem fordulhat elő a megfelelő tag-ek ismeretében. A DocBook XML állományból a Maven &lt;a href="http://docbkx-tools.sourceforge.net/"&gt;Docbkx Tools&lt;/a&gt; fordít PDF állományt. A háttérben először egy XSL-FO állomány generálódik le, majd azt fordítja az &lt;a href="http://xmlgraphics.apache.org/fop/"&gt;Apache FOP&lt;/a&gt; PDF-fé.&lt;/p&gt;

&lt;p&gt;A DocBook forrást tartalmazó, és a PDF-fé build-elést elvégző Maven projekt szintén &lt;a href="https://github.com/vicziani/jtechlog-repost-doc"&gt;elérhető a GitHub-on&lt;/a&gt; jtechlog-repost-doc néven.&lt;/p&gt;

&lt;p&gt;Ezzel kapcsolatban csak egy probléma merült fel, méghozzá az ékezetes karakterek problémája. Egy PDF megjelenítő ugyanis alapban 14 betűtípust ismer (&lt;a href="http://en.wikipedia.org/wiki/Portable_Document_Format"&gt;"base fourteen fonts"&lt;/a&gt;), és ebben nincsenek ékezetes karakterek. Ezért, ha ilyeneket akarunk, akkor azokat be kell építenünk (embedded font) a PDF állományba. Az Apache FOP ezt azonban bizonyos verziónál csak úgy tudja megtenni, ha a beépítendő betűtípus mellett egy metrics állomány is szerepel, mely egy XML és leírja a betűtípus tulajdonságait. Szerencsére a betűtípusból ilyent generálni is lehet a következő paranccsal: &lt;code&gt;java org.apache.fop.fonts.apps.TTFReader -fn sanf-serif micross.ttf micross-fcm.xml&lt;/code&gt;, persze a megfelelő FOP CLASSPATH beállításával. Szerencsére ilyent nem kellett Maven-ből hívni, ugyanis a Docbkx Tools tartalmaz eszközt erre is, csak a következő részeket kellett a pom.xml-be beilleszteni (fontos a false ansi property).&lt;/p&gt;

&lt;pre class="brush: xml"&gt;
&amp;lt;plugin&amp;gt;
 &amp;lt;groupId&amp;gt;com.agilejava.docbkx&amp;lt;/groupId&amp;gt;
 &amp;lt;artifactId&amp;gt;docbkx-fop-support&amp;lt;/artifactId&amp;gt;
 &amp;lt;version&amp;gt;2.0.13&amp;lt;/version&amp;gt;
 &amp;lt;executions&amp;gt;
  &amp;lt;execution&amp;gt;
   &amp;lt;phase&amp;gt;generate-resources&amp;lt;/phase&amp;gt;
   &amp;lt;goals&amp;gt;
    &amp;lt;goal&amp;gt;generate&amp;lt;/goal&amp;gt;
   &amp;lt;/goals&amp;gt;
   &amp;lt;configuration&amp;gt;
    &amp;lt;ansi&amp;gt;false&amp;lt;/ansi&amp;gt;
   &amp;lt;/configuration&amp;gt;
  &amp;lt;/execution&amp;gt;
 &amp;lt;/executions&amp;gt;
&amp;lt;/plugin&amp;gt;

&amp;lt;plugin&amp;gt;
 &amp;lt;groupId&amp;gt;com.agilejava.docbkx&amp;lt;/groupId&amp;gt;
 &amp;lt;artifactId&amp;gt;docbkx-maven-plugin&amp;lt;/artifactId&amp;gt;
 &amp;lt;version&amp;gt;2.0.13&amp;lt;/version&amp;gt;
 
 &amp;lt;!-- ... --&amp;gt;
 
 &amp;lt;configuration&amp;gt;
  &amp;lt;bodyFontFamily&amp;gt;TimesNewRoman&amp;lt;/bodyFontFamily&amp;gt;
  &amp;lt;monospaceFontFamily&amp;gt;Courier&amp;lt;/monospaceFontFamily&amp;gt;
  &amp;lt;titleFontFamily&amp;gt;ArialBold&amp;lt;/titleFontFamily&amp;gt;
  &amp;lt;fonts&amp;gt;
   &amp;lt;font&amp;gt;
    &amp;lt;name&amp;gt;Arial&amp;lt;/name&amp;gt;
    &amp;lt;style&amp;gt;normal&amp;lt;/style&amp;gt;
    &amp;lt;weight&amp;gt;normal&amp;lt;/weight&amp;gt;
    &amp;lt;embedFile&amp;gt;${basedir}/src/fonts/Arial.ttf&amp;lt;/embedFile&amp;gt;
    &amp;lt;metricsFile&amp;gt;${basedir}/target/fonts/Arial-metrics.xml&amp;lt;/metricsFile&amp;gt;
   &amp;lt;/font&amp;gt;
   &amp;lt;!-- ... --&amp;gt;
&lt;/pre&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/912143685418710554/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2011/11/szabad-navigacio-okozta-problemak-webes.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/912143685418710554'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/912143685418710554'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/11/szabad-navigacio-okozta-problemak-webes.html' title='Szabad navigáció okozta problémák webes környezetben'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6776798504599496909</id><published>2011-11-19T00:05:00.005+01:00</published><updated>2011-11-19T00:34:05.908+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='git'/><title type='text'>GitHub</title><content type='html'>&lt;p&gt;Mivel ki kellett próbálnom valamit a Spring Security-val, frissítettem az erről szóló &lt;a href="http://jtechlog.blogspot.com/2010/01/spring-security.html"&gt;postot&lt;/a&gt;. Ennek keretében csatlakoztam a &lt;a href="https://github.com/vicziani"&gt;GitHub-hoz&lt;/a&gt;, így ezentúl ott közlöm a postokhoz tartozó példa alkalmazásokat, forráskódokat, érdemes figyelni. Az említett posthoz is megtalálható az első &lt;a href="https://github.com/vicziani/jtechlog-spring-security"&gt;példaprogram&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A példaprogramokban angol megnevezéseket használok, de a megjegyzések, dokumentáció, valamint a felületen megjelenő szövegek (pl. jsp-ben) magyarok lesznek.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/6776798504599496909/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2011/11/github.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6776798504599496909'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6776798504599496909'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/11/github.html' title='GitHub'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-9075776410959180550</id><published>2011-09-27T01:15:00.007+02:00</published><updated>2014-02-02T16:25:42.522+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Maven'/><title type='text'>Maven legjobb gyakorlatok</title><content type='html'>&lt;p&gt;Technológiák: Maven 3.0.3&lt;/p&gt;

&lt;p&gt;Maven-nel foglalkozó sorozatom részét azzal zárnám, hogy milyen legjobb gyakorlatokat érdemes betartani. Lehet, hogy bizonyos dolgokat ismételni fogok a &lt;a href="http://jtechlog.blogspot.com/2010/04/maven-kezdolepesek.html"&gt;Maven kezdőlépések&lt;/a&gt; post-omból, de álljanak itt összegyűjtve. Lehet, hogy bizonyos szabályok túl szigorúak, azért van lehetőség egy-két helyen lazábbra engedni.&lt;/p&gt;

&lt;h3&gt;Projekt granularitás&lt;/h3&gt;

&lt;p&gt;Talán a legnehezebb témakör, azaz mennyi projektet hozzunk létre egy bonyolultabb rendszer esetén, és ezek milyen függőségekben legyenek egymással. Az egy projekt csak kis alkalmazásoknál, 3rd party library-knél szokott elegendő lenni, kicsit is bonyolultabb alkalmazások esetén szükség van több projektre. Egy projekt esetén a fejlesztés nehézkesebb, hiszen nem tudjuk kisebb részekben kezelni, mindig mindent le kell fordítani, nagy csomagot előállítani, stb. Maven egy kitűnő támpontot ad, ugyanis az alapfilozófiája az, hogy amennyi projekt, annyi artifact, tehát annyi jar, war, ear, zip, stb.&lt;/p&gt;

&lt;p&gt;Másik kérdés, hogy ezek a projektek mennyire mozognak együtt, vagy külön. Együtt történik a release, vagy gyakran előfordul, hogy az alkalmazás csak egy kis részlete kerül mindig javításra, kiadásra? Van-e olyan rész, mely önmagában is megállja a helyét, pl. egy külön grafikai komponens, melyet akár más projektekben is fel lehet használni. Élhetnek-e külön életet, külön verziószámozással?&lt;/p&gt;

&lt;p&gt;Ezt egyedül a gyakorlat tudja megmondani. Láttam olyan rendszert, ami teljesen különálló modulokból állt, és szépen, külön volt fejleszthető. Egy másik projekt esetében bármit kellett módosítani, mindig hozzá kellett nyúlni 3-4 modulhoz is. Sőt, olyan is megeshet, hogy az elején még minden módosul, míg a hibajavításkor, tovább fejesztéskor már elég csak egy-egy modult bolygatni.&lt;/p&gt;

&lt;p&gt;Néhány támpont azonban. Jó gyakorlat az interfész és implementáció különválasztása (, ez pl. interfészek - web szolgáltatások - esetén nagyon gyakori, és a technológia is megköveteli, mert az interfész osztályoknak mindkét oldalon meg kell lennie). Használjunk szervezet és projekt szintű szülő projekteket. Hasznosak lehetnek a prototípus projektek. Gyakran használt utility osztályokat emeljük ki library-ként. Közös erőforrásokat emeljük ki külön projektbe. Integrációs teszt eseteket emeljük ki külön projektbe. Függőségeket is ki lehet emelni külön projektbe. Ezekről még mindről lesz később szó a post-ban.&lt;/p&gt;

&lt;p&gt;Fontos, hogy a projekt granularitása összefügg az issue tracker-ünkben felvett projektekkel is. Hiszen ha a projektek külön életet élnek, külön verziószámokkal rendelkeznek, akkor érdemes ezeket az issue tracker-ben is külön követni. Ha a projektek általában együtt mozognak, és egyszerre kell javítani, kiadni, követni őket, akkor mind a release, mind a verziókezelés, mind az issue tracking folyamán jelentős pluszmunkát veszünk magunkra.&lt;/p&gt;

&lt;h3&gt;pom.xml formázása&lt;/h3&gt;

&lt;p&gt;Mutasd a pom.xml-ed, megmondom, milyen a projekted! A pom.xml-eket is olyan tisztán kell tartani, mint a forráskódot. Ez egy XML állomány, ahol a tag-ek sorrendje nem kötött, azonban mégis javaslom, hogy a projekten belül az összes modulban ugyanazt a sorrendet használjuk. A függőségeknél is ajánlott egy sorrendet meghatározni, pl. előbb a belső függőségek, majd a nem publikus repository-kból nyert függőségek, majd scope-onként a compile, provided, test scope-ú függőségek. Így ahhoz szokik a szemünk, automatikusan tudjuk, hogy mit hol kell keresni, azonnal láthatjuk, hogy valami van-e definiálva, vagy hiányzik. A forráskódhoz hasonlóan ne használjunk felesleges comment-eket, de amit célszerű, azt jegyezzük fel (pl. függőségekkel kapcsolatos tudnivalók). Ne használjunk csupa nagybetűs comment-eket, ahogy sormintákat se.&lt;/p&gt;

&lt;h3&gt;DRY, KISS&lt;/h3&gt;

&lt;p&gt;Forrásokhoz megfelelően próbáljuk a pom.xml-ekben az ismétlődéseket kerülni (Don't Repeat Yourself). Ez megoldható öröklődéssel, azaz a szülőben definiált a gyermek örökli. Használjunk property-ket, akár beépítetteket, akár saját magunk által definiáltakat. Legyenek a pom.xml-ek egyszerűek (Keep it short and simple). Persze ez főleg akkor lehetséges, ha a projektünk alkalmazkodik a konvenciókhoz, és nem használ semmiféle egzotikus megoldást, ami követendő. Használjunk szabványos megoldásokat, a Maven beépített eszközeit és plugin-jeit. (Pl. verziószám megjelenítését &lt;a href="http://jtechlog.blogspot.com/2011/09/verzioszam-megjelenitese-az.html"&gt;resource filtering&lt;/a&gt; segítségével.) Használjuk a default értékeket, ahelyett, hogy konfigurálnánk (convention over configuration). Pl. standard könyvtárstruktúra.&lt;/p&gt;

&lt;h3&gt;Felelős&lt;/h3&gt;

&lt;p&gt;Legyen a pom.xml-eknek egy felelőse. Lehetőleg a vezető programozó, architect. A pom.xml-be felvett változások általában az architektúra, függőségek módosítását jelzik. Sem a modulok között, sem a 3rd party library-ra nem jó, ha bekerül egy új függőség, a felelős tudta nélkül. Igenis figyelni kell, hogy ne kerüljön bevezetésre egy sokadik XML parser. Remélhetőleg a pom.xml a projekt életciklusa során keveset változik.&lt;/p&gt;

&lt;h3&gt;Konvenciók&lt;/h3&gt;

&lt;p&gt;Ha már a Maven alapelve a konvenciók használata, próbáljunk meg mi is alkalmazkodni ehhez több szinten is, vezessünk be projekt konvenciókat. Ilyen pl. a projektek elnevezési konvenciója (javasolt kisbetűkkel, szavakat kötőjellel elválasztva írni), verziószám konvenciók, stb.&lt;/p&gt;

&lt;h3&gt;Build reprodukálhatóság&lt;/h3&gt;

&lt;p&gt;Lehetőleg törekedjünk arra, hogy nem előkészített környezetben, notebook-on, otthon is fusson le a build. Ne legyen szükség külső függőségekre, speciális könyvtárakra, adatbázis szerverre, stb. Lehetőleg csak a céges repository manager elérésével bárhol le tudjuk futtatni a build-et. A Sonatype könyv organizational portability-nek hívja azt, amikor egy cég belső hálóján lévő bármilyen gépen azonnal le tudjuk futtatni a build-et.&lt;/p&gt;

&lt;p&gt;Olvastam olyan ötletről is, hogy a Maven-t se kelljen egyénileg feltelepíteni, és a repository se foglalja mindenki gépén a helyet, egy megosztott meghajtóra lehet ezeket tenni, és mindenki onnan használhatja. A repository helye alapértelmezésben a home könyvtárunk alatt a /.m2/repository könyvtár. Ez sok esetben nem megfelelő, pl. ékezet, space van benne, vagy pl. szerverrel szinkronizált, központilag mentett, vagy egyszerűen nem szeretnénk a rendszer partíciónkon tárolni ezeket. A lokális repository új helyét a settings.xml-ben a localRepository tag-ek között adhatjuk meg.&lt;/p&gt;

&lt;p&gt;Ügyeljünk arra, hogy lehetőleg környezetenként (fejlesztői/teszt/éles) ugyanazokat az artifact-okat használjuk. Minden környezet függő információt az alkalmazáson kívül tároljuk, konfigurációs állományokban, JNDI-ben, adatbázisban. Így ugyanazt az állományt telepíthetjük minden környezetbe.&lt;/p&gt;

&lt;h3&gt;Repository manager és CI&lt;/h3&gt;

&lt;p&gt;Mindig használjunk repository manager-t. Egyrészt proxy a publikus repository-k felé, másrészt a saját artifact-jainkat is tartalmazza, ami nélkülözhetetlen több modulból álló projektek esetén. Ide tölthetjük fel az egyéb forrásból származó 3rd party jar-okat is.&lt;/p&gt;

&lt;p&gt;Bár nem ide tartozik szorosan, használjunk Continuous Integration eszközt is, mely egyrészt segít az integráció idejének csökkentésében azáltal, hogy gyakori időközönként build-el, és lefuttatja a teszt eseteket, így a problémákról mielőbb értesítést kapunk, nem csak akkor mikor mi is elvégeznénk az integrációt. Valamint különösen alkalmas arra, hogy ellenőrizzük, hogy nem csak egy beállított környezetben fut a projekt, egy fejlesztői gépen, hanem egy független build szerveren is.&lt;/p&gt;

&lt;h3&gt;Magas szintű pom.xml-ek&lt;/h3&gt;

&lt;p&gt;Bizonyos konfigurációkat szervezet szinten (corporate), vagy projekt szinten definiáljuk egy szülő pom.xml-ben. A gyermek projektek ebből öröklik a beállítások, melyek leíró információk pl. a szervezettel, projekttel, fejlesztőkkel kapcsolatban. Tartalmazhatja a distributionManagement szekciót, mely a repository manager elérhetőségét írja le (ne a konkrét projekteknél definiáljuk). Valamint tartalmazhatja a plugin konfigurációkat, azok verziószámát (lásd később, a "Függőségek" fejezetben).&lt;/p&gt;

&lt;h3&gt;Függőségek&lt;/h3&gt;

&lt;p&gt;Mindig tartsuk rendben a függőségeinket. Lehetőleg publikus repository-ban található 3rd party library-ből építkezzünk (, ebben segíthet a &lt;a href="http://mojo.codehaus.org/versions-maven-plugin/"&gt;Version Maven Plugin&lt;/a&gt;). Amennyiben van nem ilyen is, tüntessük fel annak a forrását, amennyiben van forráskódjának, dokumentációjának elérhetőségét. Vigyázzunk, ugyanannak a library-nak ne szerepeljenek különböző verziója függőségben. Ez akkor lehet, ha pl. egy artifact-et egyik verzióról a másikra át is neveztek, vagy pl. groupId-t váltottak. Figyeljünk a library-k megfelelő scope-jára. Lehetnek olyan jar-ok, melyek csak teszteléskor kellenek (test), illetve olyanok, melyeket nem kell az artifact-unkba csomagolni, az alkalmazásszerver biztosítja ezeket (provided). A moduljaink között ne legyen körkörös hivatkozás. A függőségek definiálásánál ne használjunk intervallumokat, adjuk meg a pontos verziószámokat. Amennyiben egy függőséghez több artifact is tartozik, pl. Hibernate, Spring sok modulból áll, akkor javasolt a verziószámot egy külön property-be kiemelni, és az összes modulban arra hivatkozni (pl. ${spring.version}).&lt;/p&gt;

&lt;p&gt;A függőségeinket tartsuk karban. Ne engedjük őket elburjánzani (lsd. "Felelős" fejezet). Futtassuk a dependency:analyze goal-t, feltárva ezzel a deklarált, de nem használt függőségeket (töröljük), valamint a használt, de nem deklarált függőségeket. Ez utóbbi akkor jelentkezhet, ha egy függőségre csak tranzitív függőség van, és mégis használjuk az osztályait. Ekkor javítsuk direkt függőségre.&lt;/p&gt;

&lt;p&gt;Plugin-ek esetén is mindig deklaráljuk a verziószámot, szülő projekt létezése esetén annak pluginManagement szekciójában, hiszen az öröklődik, ahogy egy régebbi &lt;a href="http://jtechlog.blogspot.com/2011/08/maven-plugin-ek-verzioszama.html"&gt;post-ban&lt;/a&gt; írtam.&lt;/p&gt;

&lt;p&gt;Amennyiben ugyanazt a függőséget több modul is használja, érdemes a szülő projektben felsorolni a függőségek verziószámát, és exclude tag-eket a dependencyManagement szekcióban, melyet a gyermek projektek örökölnek, így azokban elegendő csak a groupId-t és artifactId-t deklarálni.&lt;/p&gt;

&lt;p&gt;Amikor egy problémát meg akarunk oldani, és van egy bevált receptünk, és erre több 3rd party library-t is mozgósítunk, és mindig ugyanazokat, akkor szervezzük ki a függőségeket egy külön projektbe (dependency group), így elég erre az egyre függőséget definiálni, ami tranzitíven berántja a többi függőséget is. Ez ellentmondhat annak a szabálynak, hogy amit közvetlenül használunk, azt mindig direkt függőségben deklaráljuk. Ez utóbbit tartsuk be inkább.&lt;/p&gt;

&lt;p&gt;Nem csak Java osztályokat, hanem közösen használt erőforrásokat, pl. képeket, stíluslapokat, stb. is kiszervezhetünk külön projektbe. Vagy akár plugin konfigurációkat is, pl. checkstyle, pmd konfigurációkat is, ha különböző projekteken ugyanúgy akarjuk ezeket használni. A Maven dependency pluginnel sok csodát meg lehet csinálni.&lt;/p&gt;

&lt;h3&gt;Prototípus&lt;/h3&gt;

&lt;p&gt;Kicsit furcsa lehet, hogy a projektek közötti szülő-gyermek kapcsolat, és a modul-almodul kapcsolat két külön fogalom. A szülő-gyermek kapcsolat estén a gyermekben definiáljuk a szülőt, a parent tag-ek között. A gyermek ekkor örökölni fogja a szülő beállításait (lsd. még effective pom). A szülő nem tud a gyermek projektjeiről. Míg egy modul a modules tag-ek között felsorolhatja az almoduljait. Ez által megeshet az a furcsa eset is, hogy egy almodult olyan modul tartalmaz, mely az almodulnak nem szülő projektje. Nézzünk erre egy példát. Van több projektünk, mely nagyon hasonló egymáshoz, mind egy Java EE alkalmazás, melynek kimenete egy EAR. Mindegyik projekt több alprojektből áll, külön az EJB réteg, külön a web réteg, stb. Az ejb és web rétegek azonban nagyon hasonlítanak egymáshoz. Ezért, hogy a copy-paste-et elkerüljük, a közös dolgokat kiemeljük egy szülő projektbe, külön az ejb rétegeknek egy, külön a web rétegeknek egy. Ezeket a projekteket hívják prototípus projekteknek.&lt;/p&gt;

&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" rel="lightbox" href="http://4.bp.blogspot.com/-BgONRQSen2k/ToEIxcJT0yI/AAAAAAAAHdc/uwBC1WOIPdc/s1600/maven_prototype.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 140px;" src="http://4.bp.blogspot.com/-BgONRQSen2k/ToEIxcJT0yI/AAAAAAAAHdc/uwBC1WOIPdc/s320/maven_prototype.png" alt="" id="BLOGGER_PHOTO_ID_5656812252415906594" border="0" /&gt;&lt;/a&gt;

&lt;h3&gt;Archetype&lt;/h3&gt;

&lt;p&gt;Ha gyakran kezdünk új projektet, vagy egy létező rendszerbe új modult, akkor lehetőség van archetype deklarálására. Ez tulajdonképpen egy projekt sablon, amiből ki lehet indulni. Így nem úgy kezdünk egy új projektet, hogy veszünk egy létezőt, és lebutítjuk, hanem már egy sablonból. Vannak előregyártott archetype-ok is, pl. egyszerű Java alkalmazás, egyszerű web alkalmazás, Maven plugin, Confluence plugin, NetBeans modul, stb. Vagy pl. nézhetjük &lt;a href="http://raibledesigns.com/"&gt;Matt Raible&lt;/a&gt; tevékenységét is, az &lt;a href="http://appfuse.org/display/APF/Home"&gt;AppFuse-t&lt;/a&gt; is, mely előre gyártott projekt sablonok, melyek különböző technológiák integrálásával (Spring, JSF, Struts 2, Spring MVC, Stripes, Tapestry 5, Wicket, JPA, stb.) jöttek létre. Ezek kis példa alkalmazások, melyek önmagukban is működnek, nem nekünk kell konfigurálgatni, integrálgatni, jó kiinduló alapot biztosítanak. Be kell vallanom, én annyira nem hiszek az archetype-okban, mert mire új projektet kellett indítani, mindig változott valamelyest a technológia, más keretrendszereket használtunk, más megközelítésmódot alkalmaztunk. Ezeknek tényleg inkább alkalmazásgyáraknál van jelentősége.&lt;/p&gt;

&lt;h3&gt;Assembly&lt;/h3&gt;

&lt;p&gt;Az assembly plugin használatának minden könyv külön fejezetet szentel. Arra használható, hogy gyakorlatilag bármilyen artifact-ot elő tudunk vele állítani, attól függően, hogy hogyan szeretnénk terjeszteni az alkalmazásunkat. Vannak &lt;a href="http://maven.apache.org/plugins/maven-assembly-plugin/descriptor-refs.html"&gt;előre beépített&lt;/a&gt; struktúrák (ezek közül van, ami csak a binárist tartalmazza, a binárist tartalmazza a függőségekkel, csak a forrást tartalmazza, teljes projektet tartalmazza), de természetesen sajátot is tudunk gyártani.&lt;/p&gt;

&lt;h3&gt;Verziókezelő struktúra&lt;/h3&gt;

&lt;p&gt;Bár nem így kéne lennie, egy kicsit kényszerpályán vagyunk azzal kapcsolatban, hogy hogyan szervezzük a verziókezelőben a projektjeinket, Subversion esetén trunk-ot, tag-eket, branch-eket, stb. Erről már írtam egy korábbi &lt;a href="http://jtechlog.blogspot.com/2010/10/release-maven-nel-es-hudson-nel.html"&gt;post-ban&lt;/a&gt;. Egyszerű szabály, hogy a projekt neve és a könyvtár neve egyezzen meg. Nagyon tervezzük meg, dokumentáljuk, és teszteljük a választott struktúrát, különösen a release folyamat esetén.&lt;/p&gt;

&lt;h3&gt;Teszt, release és deployment&lt;/h3&gt;

&lt;p&gt;A unit tesztek lefutása legyen gyors. Amennyiben integrációs teszteket is alkalmazunk, nyugodtan nyissunk neki külön projektet. Gyorsabb lesz tőle a build folyamat, és megfelelően szeparálva lesz a unit tesztektől.&lt;/p&gt;

&lt;p&gt;Használjuk a Maven release plugin-t, egy release elkészítésére. Egy release egy végleges, megváltoztathatatlan artifact, mely könnyen azonosítható, bármikor később reprodukálható. (Szemben a snapshot verzióval, mely egy folyamatosan változó, fejlesztés alatt lévő verzió.&lt;/p&gt;

&lt;p&gt;A deployment-re is külön projektet érdemes készíteni, mely függőségként definiálja a telepítendő artifact-ot. Ezt aztán telepítés során letölti a telepítendő állományt, és telepíti a megfelelő alkalmazásszerverre. Így nem zavarja a normál fejlesztési munkafolyamatot.&lt;/p&gt;

&lt;h3&gt;Nem erőltetném&lt;/h3&gt;

&lt;p&gt;Természetes, hogy amiket a fentiekben javaslok, azoknak ne használjuk az ellentétét. Tehát pl. ne használjunk version range-eket, hanem mindig pontosan deklaráljuk a verziószámokat.&lt;/p&gt;

&lt;p&gt;Én nem szeretem a profile-ok használatát sem, amennyiben lehetőség van rá, kerülöm őket. Konkrétan ott szoktam alkalmazni, ahol gyorsítják a fejlesztés - telepítés - tesztelés folyamatot. Pl. fejlesztés közben nem érdemes a war-t összecsomagolni, ha az alkalmazásszerver a kibontottat is (exploded war, in place deployment) fel tudja olvasni (persze release-kor meg a fájl kell), vagy release-kor más artifact-ot is elő kell állítani (pl olyan jar állományt, melyben bele vannak csomagolva a függőségek). Ezeket fejlesztés közben nem akarom előállítani.&lt;/p&gt;

&lt;p&gt;Csakis a legvégső esetben folyamodnék ahhoz, hogy saját Maven plugin-t fejlesszek. Szerencsére erre még nem volt szükség, mindig találtam olyat, mely megfelelő volt az igényeimnek.&lt;/p&gt;

&lt;p&gt;Ti használtok Maven-t? Mennyi energiát fektettek a pom struktúra kidolgozásába, szinten tartásába, tökéletesítésébe? Segít, vagy hátráltat? Kedvelt eszköz, vagy a szükséges rossz? Tapasztalatok alternatív eszközökkel?&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/9075776410959180550/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2011/09/maven-legjobb-gyakorlatok.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/9075776410959180550'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/9075776410959180550'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/09/maven-legjobb-gyakorlatok.html' title='Maven legjobb gyakorlatok'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://4.bp.blogspot.com/-BgONRQSen2k/ToEIxcJT0yI/AAAAAAAAHdc/uwBC1WOIPdc/s72-c/maven_prototype.png' height='72' width='72'/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3642971482325571342</id><published>2011-09-18T14:24:00.010+02:00</published><updated>2014-02-02T16:26:24.534+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Maven'/><title type='text'>Maven bevezetés, modernizáció</title><content type='html'>&lt;p&gt;Technológiák: Maven 3.0.3&lt;/p&gt;

&lt;p&gt;Valahogy az elmúlt időszakban úgy alakult, hogy három projektben is Maven szaktanácsadást nyújthattam. Ebből egy egy teljesen nulláról induló projekt, egy Ant-ról migrálós projekt valamint egy már meglévő Maven projekt továbbfejlesztése. Az ezekben szerzett tapasztalatokról szeretnék itt beszámolni.&lt;/p&gt;

&lt;p&gt;Ebből a legizgalmasabb a már létező Maven projekt modernizálása, egy Gibraltáron működő online szerencsejáték cégnek, ahova a meghívást &lt;a href="http://britpalmak.blogspot.com/"&gt;Magyusz&lt;/a&gt; és Cseki haverom intézte, akik ott vezető programozói státuszban tevékenykednek. Ezúttal is köszönöm nekik! &lt;a href="http://britpalmak.blogspot.com/2011/07/magyarok-majd-megoldjak.html"&gt;Három napot töltöttem a projektben&lt;/a&gt;, ami során sikerült megismerni a jelenlegi Maven struktúrát, a legjobb gyakorlatokat alkalmazni, és felderíteni a gyenge pontokat. Persze sok utómunkával jár, és vannak ötletek, hogy merre lehetne tovább fejlődni. A három nap tartalmazta a verziókezelés folyamatának kialakítását is, az előző post-jaim ezekről szóltak.&lt;/p&gt;

&lt;p&gt;Magáról az országról sokat nem tudok írni, az eltöltött öt nap benyomások szerzésére volt elegendő. Egy apró brit tengerentúli terület (7 négyzetkilométer), ami minden egyes pontján erősen érződik is. Angol a hivatalos nyelv, emeletes busz, klasszikus londoni telefonfülke és még sok minden megtalálható itt. Amiről az úti beszámolók a leggyakrabban írnak, hogy az országba jutáskor át kell kelni a repülőtér felszállópályáján, ami keresztezi a határról érkező utat, lámpával irányítva, ami piros, ha épp egy repülőgép száll fel, vagy le. Valamint a szikla tetején (, ahonnan gyönyörű a kilátás minden irányban) élő Európában egyedülállóan szabadon élő majmok híresek itt. Apropó Gibraltár egy hatalmas mészkőszikla, ami ki tudja honnan került ide, és át és át van lyuggatva, mint a sajt, belsejében érdekesebbnél érdekesebb és titkos dolgokkal, valamint egy kis feltöltött terület. Déli pontjáról tiszta időben szépen látszik Afrika. Északon Spanyolországgal határos, a nem éppen legszebb La Linea de la Conception várossal, de kicsit messzebb menve már gyönyörű helyekre lehet eljutni, mint egy &lt;a href="http://britpalmak.blogspot.com/2011/07/sikloernyos-etterem.html"&gt;siklóernyős starthely&lt;/a&gt;, vagy egy &lt;a href="http://britpalmak.blogspot.com/2011/07/kitesurf-paradicsom.html"&gt;kitesurf paradicsom&lt;/a&gt;, az óceánnál.&lt;/p&gt;

&lt;a rel="lightbox" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/-PZmnGNKjaMw/TnXnWB8KyjI/AAAAAAAAHZs/F6nx45R1OMg/s1600/gib1.jpg"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 240px;" src="http://2.bp.blogspot.com/-PZmnGNKjaMw/TnXnWB8KyjI/AAAAAAAAHZs/F6nx45R1OMg/s320/gib1.jpg" alt="" id="BLOGGER_PHOTO_ID_5653679272897464882" border="0" /&gt;&lt;/a&gt;

&lt;p&gt;A cég nagyon meggyőző volt, látszott, hogy komolyan veszik, amit csinálnak. Olyan hangulat uralkodott, hogy érződött, hogy odafigyelnek a munkájukra. A társaság igen vegyes, mind nemzetiségileg, mind szakmailag. Érdekes jelenség, hogy a szerverekkel nem fukarkodnak, azonban az emberi erőforrásokban sokkal inkább. Egyik szobában a sporteseményeket követték, impresszív volt a minden asztalon három LCD monitor, valamint a mennyezetről lógó plazmatévék sora. Természetesen a fejlesztőknél is volt egy tévé, hogy a fontosabb sporteseményeket követni lehessen. Alapvetően különbségeket azonban nem tapasztaltam, sem szakmailag, sem technológiailag. Az irodából kilépve azonban azonnal elöntötte a mediterrán hangulat, a meleg, a késő este is napsütés, tengerpart, a hatalmas és tekintélyt parancsoló, a kikötőben állomásozó hajókkal, vonzották az embert a part menti bárok és kaszinó.&lt;/p&gt;

&lt;a rel="lightbox" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/-L9G38OUpUHg/TnXnghWhidI/AAAAAAAAHZ0/kEunQcyTHwI/s1600/gib2.jpg"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 240px;" src="http://3.bp.blogspot.com/-L9G38OUpUHg/TnXnghWhidI/AAAAAAAAHZ0/kEunQcyTHwI/s320/gib2.jpg" alt="" id="BLOGGER_PHOTO_ID_5653679453128198610" border="0" /&gt;&lt;/a&gt;

&lt;p&gt;Lássuk, hogy hogyan is telt a szakmai három nap, hogyan lehet egy Maven "rendrakást" kivitelezni. Egy build folyamat modernizációja subproject sem tér el a klasszikus szoftverfejlesztéstől, ugyanúgy van követelményfelmérés, tervezés, implementáció és tesztelés. Ugyanúgy iterációkra kell bontani, és dokumentációval megtámogatni. A következő lépésekből áll a folyamat.&lt;/p&gt;

&lt;h3&gt;Követelmények&lt;/h3&gt;

&lt;p&gt;A projekt célját érdemes tisztázni. Mi a probléma a jelenlegi folyamattal, mi nehezíti a build folyamatban legjobban a szoftverfejlesztést, mi az ami "legjobban fáj"?. Lehet ez a túl durva vagy túl finom granularitású modularizáció, a hosszú build, a nehézkes fejlesztés, a sok szaktudást igénylő release. Meg kell hallgatni az ügyfelet, hogy milyen ötletei vannak, hiszen ő él a projektben, lehet, hogy sejti, esetleg tudja, hogy mit és hogyan szeretne. Hasznosak a mérőszámok, pl. projektek száma, pom.xml állományok száma, benne szereplő sorok száma, build folyamat hossza időben, stb.&lt;/p&gt;

&lt;p&gt;A felmérés során meg kell ismerni a jelenlegi rendszer architektúráját is, én komponens diagramot használok. Milyen alkalmazások futnak, ezek hogyan kapcsolódnak egymáshoz, milyen közös könyvtárakat használnak. Milyen típusú alkalmazások vannak, standalone, web alkalmazások, esetleg Java EE alkalmazások. Milyen környezetben futnak, milyen operációs rendszerek, alkalmazásszerverek használtak, mennyire fontos a platformfüggetlenség. A build folyamat szempontjából ezek cseppet sem elhanyagolhatóak, hiszen ez alapján nagyjából sejteni lehet, hogy mennyi és milyen típusú artifact-okra lehet számítani. Ez esetemben kb. 10 alkalmazás, közte standalone és webes is.&lt;/p&gt;

&lt;p&gt;Fel kell térképezni a jelenlegi Maven struktúrát. Ez a fejlesztői környezet installálása saját gépen (rögzítsük, hogy ez milyen lépésekből áll, mennyire bonyolult, hogyan lehet egyszerűsíteni), valamint annak futtatása. Rögzítsük impresszióinkat, mennyi ideig tart, vannak-e warning-ok, hibaüzenetek. És a legunalmasabb rész, át kell böngészni egyesével a pom.xml-eket, és jegyzeteket készíteni, hol lehet és kell módosítani. Közben rögzítem azokat az eszközöket is, amelyek nem szokványosak, pl. egyedi forráskód generálás, stb. Feljegyzem, hogy hol "bűzlik a kód". Az ügyfelet is kérdezzük meg, hogy hol érzi rossznak, mit miért csináltak, mert ilyenkor lehet rábukkanni arra, hogy valamiért speciális/egyedi-e az adott projekt, valamint vannak-e hiányosságok az ügyfél tudásában, vagy bizonyos megoldások mellett miért döntött.&lt;/p&gt;

&lt;p&gt;Én közben egy függőségi gráfot is rajzolok. Osztálydiagramot szoktam alkalmazni, ahol színekkel jelzem az alkalmazások típusait, valamint dependency-vel a függőségeket, kompozícióval a modul tartalmazást és generalizációval a szülő kapcsolatot.&lt;/p&gt;

&lt;a ref="lightbox" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/-Sp5_3iaRpM0/TnXyWTzjFfI/AAAAAAAAHaE/EUlOKwnisUM/s1600/modulok.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 177px;" src="http://4.bp.blogspot.com/-Sp5_3iaRpM0/TnXyWTzjFfI/AAAAAAAAHaE/EUlOKwnisUM/s320/modulok.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5653691372321052146" /&gt;&lt;/a&gt;

&lt;p&gt;Nem javaslom a függőségi gráfok generálását. Egyrészt, ha magunk rajzoljuk, sokkal jobban megértjük, valamint vannak olyan függőségek, amik evidensek, és csak az ábrát bonyolítanák (pl. egy common könyvtárra biztos mindenki hivatkozik). Valamint ezek az eszközök értelmesen sem tudják elhelyezni az artifact-okat.&lt;/p&gt;

&lt;p&gt;Sajnos gyakran futok bele olyan projektekbe is, ahol körkörös függőségre bukkanok. Pl. a common library-ra hivatkozik a service és a ui réteg is, de a common visszahivatkozik az ui rétegre. Kiemelten kezeljük ezeket a problémákat.&lt;/p&gt;

&lt;p&gt;Vizsgáljuk meg a külső függőségeket. Ezeket feltűnően lazán szokták kezelni, bekerül a projektbe, de utána kikerül, de a függőségek közül nem távolítják el. Nem megfelelő scope-ba veszik fel, pl. csak teszteléskor van rá szükség, mégis normál függőségként szerepel. Egymással ütköző library-k vannak, melyek csak a véletlennek köszönhetően működnek együtt (pl. előbb van a classpath-ban), ilyenek pl. az naplózó keretrendszerek, az XML library-k. Láttam olyant is, hogy egy library-nak különböző verziói szerepeltek a függőségek között (pl. változott a library group vagy artifact id-ja). Egy feladatra különböző library-k szerepelnek a projektbe, pl. az előbb említetteken túl több webes keretrendszer, REST API, SOAP API, perzisztencia réteg, stb. Sokan megfeledkeznek róla, de ellenőrizzük a licence-eket is.&lt;/p&gt;

&lt;p&gt;Vizsgáljuk meg a teszt eseteket. Granularitásukat, bonyolultságukat. Gyakran keverednek a fogalmak, pl. unit tesztek között találhatunk integrációs tesztet, ami nagyobb egységet tesztel, esetleg külső rendszerekre, adatbázisra is szüksége van.&lt;/p&gt;

&lt;p&gt;Egyeztessünk, milyen riportokra állnak rendelkezésre, és ezek közül melyekre van szükség?&lt;/p&gt;

&lt;h3&gt;Tervezés&lt;/h3&gt;

&lt;p&gt;Amint felmértük a követelményeket, az ügyfél elvárásait, tervezzük meg a migráció, bevezetés folyamatát. Bontsuk lépésekre, definiáljuk a lépések scope-ját.&lt;/p&gt;

&lt;p&gt;Első esetben mindenképpen az elvárt struktúrát tervezzük meg, a már fentebb említett osztálydiagrammal. Lehet, hogy nem kell rajta változtatni, lehet, hogy gyökeres változtatásokat kell bevezetni. Amit mindenképpen meg kell szüntetni, az a körkörös függősségek. Ki kell találni a megfelelő granularitást, új modulokat bevezetni, modulokat összevonni vagy szétválasztani.&lt;/p&gt;

&lt;p&gt;Válasszuk ki a megfelelő eszközöket. Amennyiben úgy gondoljuk, ne erőltessük a Maven-t. Nem minden projekt, és nem minden fejlesztőgárda tud megfelelően illeszkedni hozzá. Minél szabványosabb a projekt, annál egyszerűbb adoptálni. Amennyiben túl sok egyediség van az architektúrában, a fejlesztési folyamatban, vagy a fejlesztők nem eléggé nyitottak a Maven irányába, alaposan gondoljuk meg, hogy van-e értelme, ilyen környezetben kétes a projekt sikere. Amennyiben azonban a Maven-t válasszuk, jelöljük meg, hogy milyen plugin-eket kívánunk használni. Dokumentáljuk döntéseinket.&lt;/p&gt;

&lt;p&gt;Elemezzük a függőségeket. Tervezzük meg, hogy mely függőségek maradhatnak, azok milyen scope-ban. Nézzük meg, hogy a legfrissebb verziók kerültek-e felhasználásra, és ha nem, ennek van-e valamilyen oka. Tervezzük meg, hogyan szüntethetjük meg az ütközéseket. Nézzük meg, hogy mely függőségek nem publikus repository-ból kerülnek letöltésre, létezik-e publikus megfelelőjük. Ha nem, honnan származnak, megvan-e a forráskódjuk.&lt;/p&gt;

&lt;p&gt;Tervezzük meg, hogy az alkalmazások verziószáma hogyan jelenik meg a felületen, és a build folyamat során hogyan kerül beírásra. Erről szól az előző &lt;a href="http://jtechlog.blogspot.com/2011/09/verzioszam-megjelenitese-az.html"&gt;post-om&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Tervezzük meg a test harness-t. Elegendő-e a JUnit, vagy érdemesebb-e a TestNG-t használni. Mivel mérjük a kódlefedettséget? Milyen integrációs teszt keretrendszert használjunk.&lt;/p&gt;

&lt;p&gt;Tervezzük meg a használni kívánt riportokat, azok paraméterezését.&lt;/p&gt;

&lt;p&gt;Én a tervezési fázisban egy olyan dokumentációt is készítek, mely leírja, hogy a fejlesztő csapatnak milyen feladatokat kell elvégeznie. Ez egyrész tartalmazza azokat a feladatokat, melyek előfeltételei a migrációnak. A forráskód, a rendszer megismerésével is találkozni lehet olyan problémákkal, amiket érdemes jelezni, de nem tartoznak szorosan a modernizációhoz - ezeken a fejlesztőcsapat akár párhuzamosan is dolgozhat. Valamint egy olyan dokumentációt is írok, mely a build folyamat továbbfejlesztési lépéseit is tartalmazza, hiszen nem hiszek abban, hogy egyszerre túl nagyot kéne lépni, érdemes kis lépésekben elvégezni a bevezetést. Hiszen az első használatbavételkor pontosodnak majd az igények.&lt;/p&gt;

&lt;h3&gt;Implementáció&lt;/h3&gt;

&lt;p&gt;Amennyiben van olyan teendő, mely blokkolja a Maven build bevezetését, továbbfejlesztését, meg kell várnunk azok befejezését. Találkoztam olyan projekttel, ahol ez több hetet is igénybe vett, hiszen az élet nem állhat meg, a fejlesztő csapat nem minden esetben képes csak a modernizációra figyelni, közben új verziókat kell kiadni, hibákat javítani, stb.&lt;/p&gt;

&lt;p&gt;Első körben, amennyiben a projekt még nem végleges, egy olyan build folyamatot valósítsunk meg, mely bitre pontosan ugyanazokat az artifact-okat gyártja le, mint az előző build folyamat (pl. script-ek, Ant build.xml-ek). Bár lehet, hogy nagyobb refactoring-ot kell elvégeznünk, ez mégis segít a megértésben, a trükkös megoldások felderítésében, a projekt sajátosságainak megértésében. És azonnali eredményt biztosít, hiszen azonnal bevethetjük.&lt;/p&gt;

&lt;p&gt;Alakítsuk ki a könyvtárstruktúrát, lehetőleg a Maven által definiált kvázi szabványoknak megfelelően, és írjuk, módosítsuk a pom.xml állományokat, és alakítsuk ki a verziókezelő struktúrát. A pom.xml-ek megírására most nem térnék ki, a követendő legjobb gyakorlatok a következő post-om tárgya. Konvencióknak megfelelően nevezzük meg a projekteket, adjunk verziószámot, definiáljuk a függőségeket, a plugin-eket (legyenek akár report plugin-ek). Amennyiben szükséges, használjuk profile-okat.&lt;/p&gt;

&lt;p&gt;Az egyik projekt során feladat volt Maven 2-ről Maven 3-ra migrálni. Ezzel csak jó tapasztalataim voltak. Első körben azonnal warning-okat ír ki, ami a nem megfelelő pom.xml bejegyzéseket tartalmazza (pl. nincs definiálva a plugin-ek verziószáma). Ezeket mindenképpen eliminálni szükséges. A build is gyorsabb 3-as Maven-nel, bár nem számottevően. És volt olyan is, hogy egy multimodule projektet a 2-es nem tudott release-elni, mert a modulok közötti függőség esetén nem találta a "testvér" modult a reactor-ban, míg a 3-as gond nélkül megcsinálta.&lt;/p&gt;

&lt;p&gt;Az implementáció során előállt termékek:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Verziókezelő struktúra&lt;/li&gt;
&lt;li&gt;A pom.xml állományok&lt;/li&gt;
&lt;li&gt;Különböző segéd script-ek&lt;/li&gt;
&lt;li&gt;Különböző napló állományok&lt;/li&gt;
&lt;li&gt;Build folyamat dokumentációja&lt;/li&gt;
&lt;li&gt;Továbbfejlesztési javaslatok dokumentációja&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Tesztelés&lt;/h3&gt;

&lt;p&gt;A build folyamatot ugyanúgy kell tesztelni. Első körben elegendő összehasonlítani, hogy az előállított artifact-ek bitre megegyeznek-e. Ha már ezen a szinten is módosításokat tettünk, akkor tesztelni kell, hogy az előállított artifact-el ugyanúgy működnek-e (nem hiányzik-e jar, amit egy ClassNotFoundException jelez, stb.). Adjuk oda a fejlesztőknek az eszközt, hogy vegyék használatba. Elemezzük a használati eseteket, hogy mindent lefedtünk-e. Ez az egyszerű fejlesztés, build parancssorban, build és futtatás IDE-ben. Build a CI szerveren. Fejlesztés branch-en, merge-ölés. Release. Artifact-ek deploy-olása különböző környezetekre. Gyűjtsük össze a fejlesztők benyomásait, tapasztalatait. Határozzuk meg újra a mérőszámokat, és hasonlítsuk össze a projekt kezdetén mértekkel. Szükség esetén javítsuk a hibákat, gyűjtsük a továbbfejlesztési ötleteket.&lt;/p&gt;

&lt;p&gt;Befejezésül annyit, hogy egy Maven alapú build folyamat kialakítása nem egyszerű feladat, és nagymértékben meg kell ismerni, meg kell érteni az alkalmazást is, mely build-elésre kerül. A build folyamat megvalósítása egy kis szoftverfejlesztési projekt, ugyanazon lépésekkel, ugyanúgy iteratívan. Szánjunk időt és erőforrást a kialakítására és karbantartására. Ez az ugródeszka, mely a teljes szoftverfejlesztési infrastruktúra alapját képzi, melybe ezen kívül beletartozik a verziókezelő rendszer, issue tracker, tudástár, repository manager, CI, test harness, quality management eszköz, és beletartoznak olyan lépések, mint tesztelés, release, deployment, code review, minőségbiztosítás, stb.&lt;/p&gt;

&lt;a rel="lightbox" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/-mBhh7Ya1CSY/TnXnnPNKlyI/AAAAAAAAHZ8/TeQOJXqSLgk/s1600/gib3.jpg"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 240px;" src="http://2.bp.blogspot.com/-mBhh7Ya1CSY/TnXnnPNKlyI/AAAAAAAAHZ8/TeQOJXqSLgk/s320/gib3.jpg" alt="" id="BLOGGER_PHOTO_ID_5653679568516192034" border="0" /&gt;&lt;/a&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/3642971482325571342/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2011/09/maven-bevezetes-modernizacio.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3642971482325571342'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3642971482325571342'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/09/maven-bevezetes-modernizacio.html' title='Maven bevezetés, modernizáció'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://2.bp.blogspot.com/-PZmnGNKjaMw/TnXnWB8KyjI/AAAAAAAAHZs/F6nx45R1OMg/s72-c/gib1.jpg' height='72' width='72'/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6632348504802797991</id><published>2011-09-14T00:52:00.001+02:00</published><updated>2011-09-14T00:54:43.384+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Maven'/><title type='text'>Verziószám megjelenítése az alkalmazásban</title><content type='html'>&lt;p&gt;Technológiák: Maven 3.0.3, Build Number Maven Plugin 1.0&lt;/p&gt;

&lt;p&gt;Kocka írt nem olyan régen egy &lt;a href="http://iwillworkforfood.blogspot.com/2011/08/verzioszam.html"&gt;blog post&lt;/a&gt;-jában arról, hogy hogyan lehet az alkalmazás verziószámát kiírni a felületre. Mivel én is nemrég csináltam meg több projektünkben is, álljon itt az én megoldásom.&lt;/p&gt;

&lt;p&gt;Új projektjeink már Maven-t használnak build-eléshez, ahol a pom.xml tartalmazza a verziószámot. Én azt javaslom, hogy ez legyen is elég. Ez egyértelműen azonosít egy artifact-ot, azaz egy alkalmazást (vagy annak moduljait). Maven használata esetén a SNAPSHOT verziószámmal rendelkező artifact-ból lehet több is, de a release-elt artifact-ból csak egy lehet, ha egyszer kiadtuk, az már többet nem módosulhat. Javasolt tesztelésre, élesre csakis release-elt artifact-ot kitenni, így egyértelműen azonosítható, így elég lesz az azonosításra a verziószám is. Abban az esetben, ha mi SNAPSHOT verziókat is ki akarunk adni tesztelésre (amit nem javaslok), érdemes még valamilyen plusz azonosítót társítani a verziószám mellé. Ez lehet egy egyedileg kézzel megadott érték (ekkor elég nagy a hibalehetőség), egy automatikusan növelt egész szám (ennek a tárolásával lehetnek gondok), timestamp, vagy a legegyszerűbb esetben az SCM revision number. De ismétlem, erre csak akkor van szükség, ha snapshot-okat is kiadunk tesztelésre, és azokat akarjuk egyedileg azonosítani, ellenkező esetben elég a verziószám. A verziószámhoz tartozó információkat pedig lehetőleg az issue tracker tartalmazza. Ebből is látszik, hogy az SCM-et én egyszerű tárolónak tekintem, ott nem szeretek plusz meta információkat tárolni, vagy pl. a revision number-t venni bármi alapjául.&lt;/p&gt;

&lt;p&gt;Amennyiben csak a release-elt alkalmazás verziószámát akarjuk kiírni, elegendő egy properties állományt létrehozni, és a Maven-t rávenni, hogy ebbe az állományba írja bele a verziószámot. Utána az alkalmazásba ezt a properties állományt kell becsomagolni, majd ezt beolvasni (pl. classpath-ról, getResourceAsStream-mel). Egy példa alkalmazás &lt;a href="http://dl.dropbox.com/u/7683931/jtechlog/versioninfo.zip"&gt;letölthető&lt;/a&gt;, mellyel ezt demonstrálom. Nem javaslom a MANIFEST.MF állomány piszkálását, mert ez csak akkor működik, ha a JAR be van csomagolva, ha pl. az alkalmazásszerver deploy-kor kicsomagolja az alkalmazást, akkor nem fog működni. A verziószám beírását a properties állományba a Maven a resoure-ok filter-elésével képes megoldani. Ekkor definiáljuk a következőt a pom.xml-ben: &lt;/p&gt;

&lt;pre class="brush: xml"&gt;
&amp;lt;build&amp;gt;
 &amp;lt;resources&amp;gt;
  &amp;lt;resource&amp;gt;
   &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;
   &amp;lt;filtering&amp;gt;true&amp;lt;/filtering&amp;gt;
  &amp;lt;/resource&amp;gt;
 &amp;lt;/resources&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Valamint a properties állományban:&lt;/p&gt;

&lt;pre&gt;
version=${project.version}
&lt;/pre&gt;

&lt;p&gt;Ekkor látni fogjuk, hogy amikor a Maven átmásolja a properties állományt, kicseréli benne a ${project.version} szöveget a projekt verziószámára.&lt;/p&gt;

&lt;p&gt;Amennyiben a MANIFEST.MF állományban is látni szeretnénk a verziószámot, a következővel egészítsük ki a pom.xml-t.&lt;/p&gt;

&lt;pre class="brush: xml"&gt;
&amp;lt;plugin&amp;gt;
 &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
 &amp;lt;artifactId&amp;gt;maven-jar-plugin&amp;lt;/artifactId&amp;gt;
 &amp;lt;version&amp;gt;2.1&amp;lt;/version&amp;gt;
 &amp;lt;configuration&amp;gt;
  &amp;lt;archive&amp;gt;
   &amp;lt;manifest&amp;gt;
    &amp;lt;addDefaultImplementationEntries&amp;gt;true&amp;lt;/addDefaultImplementationEntries&amp;gt;
   &amp;lt;/manifest&amp;gt;
  &amp;lt;/archive&amp;gt;
 &amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Ha mégis úgy döntünk, hogy szükségünk van build number-re is, mert SNAPSHOT verziót is azonosítani akarunk, akkor használhatjuk a &lt;a href="http://mojo.codehaus.org/buildnumber-maven-plugin/"&gt;Build Number Maven Plugin&lt;/a&gt;-t. Ennek két üzemmódja van. A build number-nek vagy az SCM revizióját használja, vagy megadhatunk neki egy formátumot. A formátumot a MessageFormat osztályban leírtaknak megfelelően lehet megadni. Itt behelyettesíthető egy vagy több egész szám, melye(ke)t automatikusan növel, a timestamp, valamint konstans értékek (szöveg és szám is).&lt;p&gt;

&lt;p&gt;Érdekes, hogy mindkét esetben definiálni kell az scm tag-et a pom.xml-ben, mert mindenképp lefuttat egy svn status parancsot, ahonnan ki tudja olvasni a branch nevét, amin éppen vagyunk. Ha nem adjuk meg az scm tag-et, a következő hibajelzést kapjuk:&lt;/p&gt;

&lt;p&gt;Failed to execute goal org.codehaus.mojo:buildnumber-maven-plugin:1.0:create (default) on project versioninfo: Execution default of goal org.codehaus.mojo:buildnumber-maven-plugin:1.0:create failed: The scm url cannot be null. -&gt; [Help 1]&lt;/p&gt;

&lt;p&gt;Először nézzük, hogy mi történik, ha a build number-t a revision-ből akarjuk venni. Ehhez a következőt illesszük a pom.xml-be:&lt;/p&gt;

&lt;pre class="brush: xml"&gt;
&amp;lt;plugin&amp;gt;
 &amp;lt;groupId&amp;gt;org.codehaus.mojo&amp;lt;/groupId&amp;gt;
 &amp;lt;artifactId&amp;gt;buildnumber-maven-plugin&amp;lt;/artifactId&amp;gt;
 &amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt;
 &amp;lt;executions&amp;gt;
  &amp;lt;execution&amp;gt;
   &amp;lt;id&amp;gt;buildNumber&amp;lt;/id&amp;gt;
   &amp;lt;phase&amp;gt;validate&amp;lt;/phase&amp;gt;
   &amp;lt;goals&amp;gt;
    &amp;lt;goal&amp;gt;create&amp;lt;/goal&amp;gt;
   &amp;lt;/goals&amp;gt;
   &amp;lt;configuration&amp;gt;
    &amp;lt;doCheck&amp;gt;true&amp;lt;/doCheck&amp;gt;
    &amp;lt;doUpdate&amp;gt;true&amp;lt;/doUpdate&amp;gt;
   &amp;lt;/configuration&amp;gt;
  &amp;lt;/execution&amp;gt;
 &amp;lt;/executions&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Ekkor egyrészt lefuttat egy "svn status" parancsot, és ellenőrzi, hogy van-e módosított állomány. Majd egy "svn update" parancsot, és egy "svn info" parancsot. Ez alapján eltárolja a revision number-t a ${buildNumber} property-be, az aktuális timestamp-et a ${timestamp} property-be és a branch-et, amin vagyunk a ${scmBranch} property-be (ez lehet a trunk is). Ezeket a property-ket aztán a properties fájlba írva a Maven filter-eli.&lt;/p&gt;

&lt;p&gt;Furcsa mód amennyiben a formátumos megadást is használni akarjuk, akkor azt nem tudjuk itt konfigurálni, hanem fel kell venni egy újabb execution tag-et.&lt;/p&gt;

&lt;pre class="brush: xml"&gt;
&amp;lt;execution&amp;gt;
 &amp;lt;id&amp;gt;buildInfo&amp;lt;/id&amp;gt;
 &amp;lt;phase&amp;gt;validate&amp;lt;/phase&amp;gt;
 &amp;lt;goals&amp;gt;
  &amp;lt;goal&amp;gt;create&amp;lt;/goal&amp;gt;
 &amp;lt;/goals&amp;gt;
 &amp;lt;configuration&amp;gt;
  &amp;lt;buildNumberPropertyName&amp;gt;buildInfo&amp;lt;/buildNumberPropertyName&amp;gt;
  &amp;lt;format&amp;gt;Incremental build number {0}.{1} 
at {2,time} on {2,date}, build on build server {3}{4}, env var: {5}.&amp;lt;/format&amp;gt;
  &amp;lt;items&amp;gt;
   &amp;lt;item&amp;gt;buildNumber0&amp;lt;/item&amp;gt;
   &amp;lt;item&amp;gt;buildNumber1&amp;lt;/item&amp;gt;
   &amp;lt;item&amp;gt;timestamp&amp;lt;/item&amp;gt;
   &amp;lt;item&amp;gt;jupiter&amp;lt;/item&amp;gt;
   &amp;lt;item implementation=&amp;quot;java.lang.Integer&amp;quot;&amp;gt;8&amp;lt;/item&amp;gt;
   &amp;lt;item&amp;gt;${envVar}&amp;lt;/item&amp;gt;
  &amp;lt;/items&amp;gt;
 &amp;lt;/configuration&amp;gt;
&amp;lt;/execution&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Látható, hogy hogyan lehet megadni a formátumot a format tag-ben, és ekkor meg kell adni az items tag-et is, felsorolva a behelyettesítendő értékeket. A buildNumber/d* (ami azt jelenti, hogy a buildNumber szó, megtoldva egy egész számmal) azt fogja eredményezni, hogy létrejön egy buildNumber.properties állomány (helye, neve konfigurálható), és ebben fogja tárolni az aktuális verziót, és build esetén megnöveli egyel. Az előző példában két ilyen verziószámot növelget, és jegyez be ebbe az állományba. A timestamp-et is ki lehet írni, méghozzá formázva (még érdekesebb formátum pl. {0,date,yyyy-MM-dd HH:mm:ss}), valamint konstansokat is meg lehet adni. Ebbe az a jó, hogy akár egy Maven property-t is, ahogy az ${envVar} property mutatja. Ekkor a build-et a "mvn -D envVar=CI install" paranccsal indítva a CI szót fogja a formátumba behelyettesíteni. Ez azért jó, mert akár a build szerveren, a CI (pl. Hudson/Jenkins) is be tudja ezt külön-külön állítani.&lt;/p&gt;

&lt;p&gt;A fenti konfigurációval futtatva a build-et a következőt kapjuk:&lt;/p&gt;

&lt;p&gt;Incremental build number 1.1 at 23:50:06 on 2011.09.13., build on build server jupiter8, env var: CI.&lt;/p&gt;

&lt;p&gt;Ezt az értéket, ahogy a buildNumberPropertyName tag-ben láthatjuk, a ${buildInfo} property-be fogja eltenni (hogy ne üsse az előző ${buildNumber} proerty-t). Ezt a properties állományunkban a Maven megintcsak tudja filter-elni.&lt;/p&gt;

&lt;p&gt;Amennyiben ezeket az értékeket a MANIFEST.MF-ben is szerepeltetni akarjuk, a következőt kell a pom-xml-be írni a maven-jar-plugin konfigurációjánál:&lt;/p&gt;

&lt;pre class="brush: xml"&gt;
&amp;lt;archive&amp;gt;
...
 &amp;lt;manifestEntries&amp;gt;
  &amp;lt;Implementation-Build&amp;gt;${buildNumber}&amp;lt;/Implementation-Build&amp;gt;
 &amp;lt;/manifestEntries&amp;gt;
...
&amp;lt;/archive&amp;gt;
&lt;/pre&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/6632348504802797991/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2011/09/verzioszam-megjelenitese-az.html#comment-form' title='5 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6632348504802797991'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6632348504802797991'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/09/verzioszam-megjelenitese-az.html' title='Verziószám megjelenítése az alkalmazásban'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>5</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3165730631942130096</id><published>2011-09-11T03:02:00.002+02:00</published><updated>2011-09-11T03:06:16.824+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Módszertan'/><title type='text'>Branch-elés a fejlesztési munkafolyamatban</title><content type='html'>&lt;p&gt;Miután tisztában vagyunk az verziókezelő eszközünk képességeivel, a munkafolyamatot kell meghatároznunk, hogyan illesszük be a branch-elést a munkafolyamatainkba, miket kell átgondolni, szabályozni. Én nem hiszem azt, hogy az eszköz nagyban befolyásolná azt, hogy miképpen dolgozunk, de ha mégis így van, lehet, hogy el kell gondolkoznunk az eszköz cseréjén. Megpróbálok most már nem Subversion közeli maradni, azonban pár dolog még mindig Subversion specifikus.&lt;/p&gt;

&lt;p&gt;A branch-elés nem költséges. Ezzel a kijelentéssel sokszor lehet találkozni. Valóban így van, de a branch-eléssel sok olyan dolog is a felszínre kerül, ami azonban mégis kényelmetlenebbé teszi a munkafolyamatot. Nézzük ezek közül egy párat:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Adminisztrálni kell, hogy melyik branch-ben éppen mi történik. Valamint ezt meg kell osztani a fejlesztőgárda tagjaival is, hogy tudják, mikor melyik ágba kell fejleszteni, mikor melyik ágból lehet új branch-t nyitni.&lt;/li&gt;
&lt;li&gt;Merge. Azt hiszem ez önmagáért beszél. Amennyiben módosításokat akarunk ágak között átvinni, nem egyszerű feladat. Persze, az újabb eszközök már támogatják, de gondoljunk csak a szemantikus conflict-okra.&lt;/li&gt;
&lt;li&gt;A branch-eket meg kell szüntetni, különben elburjánzanak, elszaporodnak, így nehéz követni, hogy melyikben éppen milyen fejlesztés folyik, melyikkel mi a cél. Sajnos gyakran előfordul, hogy az ágak annyira elcsúsznak egymástól, hogy a fejlesztőcsapatnak már esélye sincs a merge-re, így párhuzamosan fejlesztenek több ágat.&lt;/li&gt;
&lt;li&gt;Egy fejlesztő egyszerre több branch-en dolgozik, időbe és energiába telik a váltogatás (context switching), esetleg előfordulhat, hogy össze is keveri a branch-eket. Különösen problémás lehet egy mixed working copy esetén.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Elöljáróban néhány jó tanács. A munkafolyamataink megtervezésénél se essünk abba a hibába, hogy túltervezzük, minden lehetőségre felkészítjük őket. Tartsuk be a KISS, YAGNI alapelveket itt is. Ne akarjunk minden problémát megoldani, ne akarjuk a munkafolyamatot kőbe vésni. Javasolt kis lépésekben kell bevezetni, iterációkkal haladva előre. Amennyiben úgy tapasztaljuk, hogy a munkafolyamat nem megfelelő, módosítsunk, legyünk bátrak más megoldást választani. Ez így van a branch-ekkel is. Ha kialakítottunk egy konvenciót, és nem megfelelő, szervezzük át. A verziókezelő rendszerek erre nagyszerű eszközöket nyújtanak. Ennél a témakörben ráadásul gyakran azt vettem észre, hogy egymással teljesen ellentmondó igényekre akarnak a fejlesztők egységes munkafolyamatot kitalálni. Ismerjük fel ezeket, és hozzunk döntést. Amennyiben elakadtunk, vagy túl nagy falatnak érezzük, ne szégyelljünk segítséget kérni. Néha úgy fogjuk érezni, hogy hátraléptünk, hogy kényelmetlenebb a fejlesztési folyamat, de ez néha szükséges ahhoz, hogy tovább tudjunk lépni.&lt;/p&gt;

&lt;p&gt;Én nem hiszek a teljes automatizálásban. A fejlesztőknek igenis egymással kommunikálniuk kell. A Subversion csak egy eszköz a kommunikáció megkönnyítésére. Ezeket az eszközöket ne akarjuk a kommunikáció kiváltására használni. Nem javaslom a branch-ek automatikus létrehozását, automatikus merge-ök futtatását, release kiadást, deploy, stb. Én szeretem, ha mindenre van egy élő embernek is rálátása, és ami jól jöhet, felelőse is. Nem jó, ha ezek a nem egyszerű folyamatok a senki földjét képviselik. Különösen, ha nem fix, hanem alakítható munkafolyamatunk van, sosem jutunk el oda, hogy minden automatikusan történjen. Persze egyes részfolyamatok lehetnek automatizáltak.&lt;/p&gt;

&lt;p&gt;Igaz, hogy azt javaslom, hogy humán erőforrás felügyelje ezeket a műveleteket, azonban érdemes nem mindent rábízni. Tapasztalataim szerint nagyon sokat segít az, ha a leggyakoribb dolgokra előregyártott script-eket használunk. (Illetve a Maven is támogatást biztosít.)&lt;/p&gt;

&lt;p&gt;Kezdjük is az első problémával, hogy hogyan lehet megtudni, hogy melyik branch-en mi történik. Valójában a fejlesztés egyik első számú eszközének egy issue tracker-nek kell lennie. Én a JIRA-ban hiszek, bár egyre kevésbé, ahogy a belsejét is kezdjük megismerni. Ettől függetlenül az egyik legjobb eszköz, és bár fizetős, gyakran találkozhatunk vele, ugyanis ingyenes open source projektek számára, és kis cégek is rendkívül kedvező áron juthatnak hozzá. Ebben verziókat lehet felvenni, és a verziókhoz lehet rendelni az issue-kat. Különböző nézetekben lehet látni a verziók állását (nyitott/összes issue), a verziókhoz tartozó issue-kat, valamint kiadás esetén changelog-ot lehet generálni. A verziókhoz megjegyzéseket lehet hozzáfűzni. Tehát az issue tracker szolgálhat elsődleges információval a branch-ekről is.&lt;/p&gt;

&lt;p&gt;Egy kis közbevetés. A fejlesztőcsapattal, mikor arról beszélgetünk, hogy hogyan használjuk a munkafolyamatban a verziókezelőt, mindig valamilyen ábrákat rajzolunk, ahol a branch-eket rajzoljuk fel, a commit-okat, merge-öket, stb. Ahhoz, hogy megértsük egymást érdemes egységes jelölésrendszert kialakítanunk. Sajnálatos, hogy még nincs ilyen szabványosítva, ha a blogokat is olvasunk, mindenki saját jelölésrendszert használ erre.&lt;/p&gt;

&lt;p&gt;Egy &lt;a href="http://jtechlog.blogspot.com/2011/08/branch-eljunk-e-vagy-sem.html"&gt;előző post-ban&lt;/a&gt; már szó esett a continuous integration-ről, a feature vagy release branch-ek fogalmáról. Létezik köztes megközelítés is. Ilyenkor általában a trunk-ba mennek a javítások, csak a nagyobb fejlesztések, melyek több commit-ból állnak, és a commit-ok között inkonzisztensen hagyják a szoftvert, azokat szervezik külön branch-be. Ha feature branch-t indítunk nem feltétlenül érdemes feature-önként külön branch-et indítani, megfelelő lehet az is, ha a feature-öket csoportokba rendezzük, és egy csoporthoz indítunk egy branch-et. Egy ilyen csoport kap egy verziót, amit fel lehet venni az issue tracker-be, és a feauture-öket meg a verzióhoz rendelni.&lt;/p&gt;

&lt;p&gt;Tehát egy jó fejlesztési munkafolyamat leírás megmondja, hogy bizonyos helyzetekben mit kell tenni. Szabályokat kell hozni a következőkre:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hogyan kell szervezni a branch-eket?&lt;/li&gt;
&lt;li&gt;Ki hozhat létre branch-et?&lt;/li&gt;
&lt;li&gt;Mikor kell branch-et létrehozni?&lt;/li&gt;
&lt;li&gt;Honnan nyitható új branch?&lt;/li&gt;
&lt;li&gt;Hogyan kell a branch-eket elnevezni?&lt;/li&gt;
&lt;li&gt;Honnan hova történik a merge?&lt;/li&gt;
&lt;li&gt;Mikor, milyen gyakran történik a merge?&lt;/li&gt;
&lt;li&gt;Ki merge-öl?&lt;/li&gt;
&lt;li&gt;Mikor történik a branch törlése?&lt;/li&gt;
&lt;li&gt;Ki törli a branch-et?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Subversion specifikus, hogy a branch-eket hogyan érdemes szervezni. Az alap struktúra a /trunk, /branches, /tags könyvtárak használata. Lehet ezen variálni, de vigyázzunk, sok eszköz, köztük a Maven is default ezen a struktúrán dolgozik. Csinálhatunk külön alkönyvtárakat a release és feature branch-eknek. Csinálhatunk külön könyvtárakat a kiadás különböző stációi alapján, pl. QA, RC, beta, GA, stb.&lt;/p&gt;

&lt;p&gt;Láttam olyan működést is, ahol a branch-ek fejlesztőnként voltak. Ezt elfogadhatónak tartom egy open source projektnél, ahol bizonyos fejlesztők csak néha-néha néznek rá a projektre, és szabad akaratukból fejlesztenek. Komoly projektnél azonban szerintem nem jöhet szóba.&lt;/p&gt;

&lt;p&gt;A branch létrehozása történhet a projektvezető által szigorúan vezetett projekteknél. De nem mindig érdemes megszorítást adni, bizonyos projekteknél bármelyik fejlesztő nyithat új ágat. Sőt, lehetséges összekötni az issue tracker-rel is, amikor a verzió létrehozásakor implikálja a branch létrehozását. De akár létrehozhatja a CI eszköz is. Amennyiben azt akarjuk, hogy az új branch a CI-be is be legyen kötve, erről azt értesíteni kell. (A Jenkins REST interfészén keresztül pl. nagyon egyszerű más névvel egy projektet másolni, és az SVN URL-jét megváltoztatni.)&lt;/p&gt;

&lt;p&gt;Feature branch két esetben jöhet létre. Vagy a feature branch deklarálásakor, vagy akkor mikor a fejlesztő elkezdi a munkát. Release branch létrehozása természetesen a release során történik.&lt;/p&gt;

&lt;p&gt;Egy feature branch egészen kis módosítástól kezdve nagy változtatásokat is tartalmazhat. Ez a granularitás projektenként, de akár projekten belül is változhat. Történhet issue-nként, és akkor lehetőség van arra is, hogy egy release esetén össze lehessen válogatni a fejlesztéseket. Ennek előnye a maximális flexibilitás, hátránya azonban az overhead, hiszen sok branch-et kell kezelnünk. Ekkor a branch-et egy issue-val kell azonosítanunk. Másik módszer, ha egy branch több fejlesztést is tartalmaz, melyet verziószámmal tudunk azonosítani. Előző &lt;a href="http://jtechlog.blogspot.com/2011/09/subversion-branch-akar-maven-release.html"&gt;post-ban&lt;/a&gt; láthattuk, hogy a Maven, valamint a Maven Release plugin támogat minket ebben. Mindenképpen javasolt valami verziószám konvenciót alkalmazni. Leggyakoribb a hármas tagolású, ahol az elsőt akkor változtatjuk, ha API szintű változás van, a másodikat, ha API-t nem érintő funkcionális változás van, és a harmadik, ha bugfix-et adunk ki.&lt;/p&gt;

&lt;p&gt;Ahhoz, hogy dönteni tudjunk, ismerni kell a projektet. Az issue-nkénti branch jól jöhet akkor, ha időzítve vannak a kiadásaink, és nem tudjuk, hogy egy kiadásra melyik feature készül el. Prioritások változhatnak, az issue fejlesztése indításakor még fontosnak tűnt, de közben beelőzhet pár fontosabb issue. Az issue-ink elkészülési ideje nem jósolható meg, vagy a szoftver bonyolultsága, vagy a megrendelő megbízhatósága, vagy a fejlesztőcsapat tapasztalatlansága miatt. Így egy verzióban azok lesznek kiadva, melyek fontosnak tűnnek és elkészülhetnek. Amennyiben azonban a projektünk olyan, hogy egy iteráció kezdetén eldönthető, hogy mely issue-k lesznek a verzióban, és addig nem megy ki a verzió, míg mind készen nincs, akkor érdemes verziónként branch-elni.&lt;/p&gt;

&lt;p&gt;A branch a release vagy feature branch esetén legtöbbször a trunk-ból nyitható.&lt;/p&gt;

&lt;p&gt;Akár issue, akár verzió alapján branch-elünk, a branch neve mindig utaljon erre.&lt;/p&gt;

&lt;p&gt;Tag-eket is használnunk kell, amennyiben helyes fejlesztési folyamatot akarunk felépíteni. Gyakori tag pl. a nightly build. Vagy készíthetünk egy tag-et, ami mindig a legutolsó nightly build-re mutat. Ez mindig törölhetjük és újra létrehozhatjuk, de jobb megoldás az svn:externals használata. Természetesen tag-eket használni kell release estén is. (Ezt a Maven release plugin automatikusan elvégzi helyettünk.)&lt;/p&gt;

&lt;p&gt;És akkor a merge-ről. A feature branch, release branch esetén az előző post-ban leírásra került, hogy hova történik a merge. A merge-öt érdemes minél gyakrabban elvégezni úgy, hogy még nem zavarja a fejlesztési munkafolyamatot. Ebben az esetben azonban arra is kell figyelni, hogy a branch-ben gyakran, apróbb részletekben commit-oljunk, hiszen csak ekkor garantálható, hogy a merge is kis részletekben történik. Minél ritkábban van merge, annál nagyobb az esélye, hogy a két ág szétcsúszik, és nő a conflict veszélye. Én előnyben részesítem, ha egy branch-nek van egy felelőse, és ő végzi a merge-ölést. Ő tisztában van a branch keletkezési körülményeivel, céljaival, a benne folyó fejlesztésekkel. Ha conflict van, akkor ő végzi el a merge-öt. Azonban kijelölhető egy másik személy is, aki a merge-öt végzi, vagy akár egy automata is lehet. Ha conflict-hoz ér, a következők közül választhat:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Megkeresi a hozzáértő szakembert&lt;/li&gt;
&lt;li&gt;Legjobb tudása szerint feloldja az ellentmondást, és körbeküldi, hogy van-e valakinek kifogása&lt;/li&gt;
&lt;li&gt;Egyből körbeküldi a hibát, és várja a megoldást&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Amikor a branch-ben szereplő fejlesztés kiadásra került, a branch törölhető. Ez akár a release része is lehet. Törölheti a release, vagy a branch felelőse, vagy egy fejlesztési munkafolyamatért felelős más személy. Ehhez is lehet, hogy extra műveleteket is el kell végezni, pl. job megszüntetése a CI-ben.&lt;/p&gt;

&lt;p&gt;Ami még egy dolog, ami a branch-hez tartozik (és ígérem, hogy utoljára írok erről), hogy a verziókezelőben hogyan érdemes több összetartozó projekt esetén a hierarchiát szervezni. Erről is szó került már egy &lt;a href="http://jtechlog.blogspot.com/2010/10/release-maven-nel-es-hudson-nel.html"&gt;előző post-ban&lt;/a&gt;. Első eset, mikor a /branches, /tags és /trunk könyvtárak alá helyezzük a projektjeinket. A második, mikor minden projektnek van ez a három alkönyvtára. Mindegyiknek van előnye és hátránya. Sőt, a kettőt keverni is lehet, hogy bizonyos projekteket így, bizonyos projekteket úgy szervezünk. Az első eset akkor jó, ha együtt mozognak a projektek verziói, azaz pl. egyszerre történik a release. Azonban ha külön akarjuk választani a verziókat, akkor onnantól kezdve bajban vagyunk. Ha később külön akarjuk választani a projekteket, az sem egyszerű. Jogosultságot megadni csak egy projektre sem egyszerű. A második megoldással azonban mindent meg lehet valósítani, de ha egyszerre akarunk pl. tag-geli, sokkal nehezebb. Erre van egy &lt;a href="http://svn.apache.org/repos/asf/subversion/trunk/tools/client-side/svnmucc"&gt;svnmucc&lt;/a&gt; nevezetű eszköz, mely lehetővé teszi, hogy egy műveletet több URL-en is végre tudjunk hajtani, egy commit-on belül.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/3165730631942130096/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2011/09/branch-eles-fejlesztesi.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3165730631942130096'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3165730631942130096'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/09/branch-eles-fejlesztesi.html' title='Branch-elés a fejlesztési munkafolyamatban'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3931037512697146491</id><published>2011-09-07T02:02:00.002+02:00</published><updated>2011-09-07T02:06:37.296+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Subversion'/><category scheme='http://www.blogger.com/atom/ns#' term='Módszertan'/><category scheme='http://www.blogger.com/atom/ns#' term='Maven'/><title type='text'>Subversion branch, akár Maven Release plugin-nal</title><content type='html'>&lt;p&gt;Technológiák: Subversion 1.6, Maven 3.0.3, Maven Release Plugin 2.0&lt;/p&gt;

&lt;p&gt;Amennyiben mégis amellett döntünk, hogy branch-elni (, és ennek következtében merge-ölni is) fogunk, rengeteg szempontot kell figyelembe venni. Hogyan működik a branch-elés, milyen szabályokat kell és milyen best practice-eket érdemes betartani, hogyan illeszkedik a fejlesztési munkafolyamatba, stb. Bár sok helyen használják, kevés helyen láttam ezek használatát kellően (teljes körűen) leszabályozva, dokumentálva, és bevetve. Nincsenek konvenciók, nem egységes a használata, nehéz beszerezni az információt, hogy honnan kell leágazni, kallódó, már senki által nem karbantartott és ismert branch-ek vannak. Ez a post ismerteti az alapfogalmakat, a Subversion lehetőségeit, valamint hogyan illeszthető a branch-elés a Maven-es munkafolyamatainkba, és milyen problémába ütközhetünk, és oldhatjuk meg. Ez a post előkészíti a post-ot, ami abban próbál majd segíteni, hogy felállítsunk egy szabályrendszert, megpróbál rávilágítani a lehetőségekre, előnyeikre/hátrányaikra, hogy miket kell szem előtt tartani, hogy a fejlesztési munkafolyamatunkat tökéletesítsük, gyakorlatilag best practice-eket ad.&lt;/p&gt;

&lt;p&gt;Mivel azt látom, hogy jelenleg a Subversion a legelterjedtebb verziókezelő rendszer, így erről fogok írni. Bizonyos dolgok mások, bizonyos dolgok egyszerűbbek elosztott verziókezelő rendszer (pl. GIT, Mercurial, stb.) esetén. Abban bízom, hogy az itt (, de inkább a következő post-ban) leírt dolgok egy része azért ott is felhasználható.&lt;/p&gt;

&lt;p&gt;Bár Subversion parancsokat parancssorból kiadni menő, azért néha szóba hozom a &lt;a href="http://tortoisesvn.tigris.org/"&gt;TortoiseSVN&lt;/a&gt; klienst is, ami azon szinte megbocsájthatatlan hibáján kívül, hogy a Windows Explorer-be épül, az egyik legjobb kliens. Próbáltam Subversion-t használni mind NetBeans, mind Eclipse IDE-kből is, de valahogy mindig csak bajom volt vele, sokszor a galibát csak TortoiseSVN-nel tudtam rendbetenni.&lt;/p&gt;

&lt;p&gt;A branch nem más, mint egy új fejlesztési ág, mely már független attól, melyből kinőtt, mégis közös a történelmük. A Subversion-ben a branch (és a tag) létrehozása is egy egyszerű másolás (copy), ebben rejlik az egyszerűsége. A mantra, amit mondogathatunk magunkba, hogy a branch-elés (technikailag) nem költséges. Nem lesz tőle nagyobb a repository, nem fog belassulni, stb. Unix hasonlattal élve, valójában egy hard link létrehozásának felel meg. Azért olcsó csak technikailag, mert az erőforrásigény csak a fejlesztési munkafolyamatba illesztésnél, projekt adminisztrációnál, és a rettegett merge-nél fog megjelenni.&lt;/p&gt;

&lt;p&gt;A branch és merge az 1.5-ös Subversion előtt nagyon problémás. Ennek használatát mindenképp el kell kerülni, érdemes a legfrissebb, 1.6-os verzióval dolgozni, mind szerver, mind kliens oldalon. (Annak megakadályozására, hogy 1.5 előtti klienssel használjuk a Subversion szervert, ezzel veszélyeztetve a merge-höz szükséges adatokat, egy commit hook is telepíthető.) Az 1.5-ös verzióban jelent meg ugyanis a mergeinfo, mely nagyon hasznos a merge-ök nyomon követésénél. Az svn:mergeinfo gyakorlatilag egy közönséges property. Bár lehetőség van rá, lehet kézzel is szerkeszteni, de ez meglehetősen ellenjavalt, hagyjuk a kezelését a merge parancsra.&lt;/p&gt;

&lt;p&gt;A témában az egyik legjobb olvasmány a &lt;a href="http://svnbook.red-bean.com/"&gt;Version Control with Subversion&lt;/a&gt; könyv, mely ingyenesen elérhető. Ez a changeset elnevezést használja, és már az elején definiálja is, ugyanis sokféleképpen szokták ezt a fogalmat használni. A könyv terminológiájában a changeset az változások halmaza (ahol a változás lehet egy állományban történt változás, de akár egy állomány törlése, vagy átmozgatása is), mely egy nevet kap. Subversion-ben minden commit egy külön azonosítót kap (revision), ami gyakorlatilag szintén egy changeset, de implicit névvel, hiszen a verziókövető rendszer adja. A merge legkisebb egysége a changeset.&lt;/p&gt;

&lt;p&gt;A klasszikus használati mód a következő. Elindul a fejlesztés a fősodron, és kiderül, hogy szükség van egy branch-re. Ekkor az svn copy-val (másolással) gyakorlatilag létrehozzuk az új ágat. Mivel a főágon is folyik a fejlesztés, ezt bizonyos időközönként át kell hozni a módosításokat. Ezt már a merge paranccsal tudjuk elvégezni. A Subversion automatikusan karbantartja a mergeinfo property-t is, amibe bekerül, hogy mely revision-ök kerültek már át. Tehát egy újabb merge esetén tudja, hogy mik kerültek már át, és amelyek nem, azokat a módosításokat gyakorlatilag lejátssza az új ágon is. Az állományokat lokálisan módosítja, szóval itt lehet fordítani, tesztelni, és ha minden helyes, akkor lehet commit-olni. Amennyiben vissza akarjuk a branch-ben történt módosításokat vezetni a főágra, először mindenképpen ellenőrizzük, hogy a főág módosításai átkerültek-e, majd a merge-öt a --reintegrate kapcsolóval kell kiadni. Itt a működés teljesen más, ezért kell a --reintegrate kapcsolót használni, ugyanis a branch-en találhatók saját fejlesztések, valamint a főágon történt merge-ök is. Ennek a kapcsolónak a használatával valójában összehasonlítja a két ágat, és a különbséget próbálja a főágra rájátszani. (A merge kiadható a --dry-run kapcsolóval is, ekkor nem módosulnak az állományok, csak egy áttekintést kapunk, hogy mely állományok hogyan módosulnának.) Ha ez megvan, akkor ezt is lehet commit-olni, majd az új ágat törölni lehet.&lt;/p&gt;

&lt;p&gt;Ez a klasszikus eset, azonban fejlesztés közben ez nagyon ritkán ilyen egyszerű. Először is sokszor van conflict. Ez az, mikor a két ágon olyan változás történik, ami látszólag ellentmond egymásnak. A Subversion amúgy is híresen rosszul kezeli ezeket az elosztott verziókezelőkhöz képest. És ráadásul még ott van az előző &lt;a href="http://jtechlog.blogspot.com/2011/08/branch-eljunk-e-vagy-sem.html"&gt;post&lt;/a&gt;-ban említett szemantikus ütközés is, amikor fordulni fordul ugyan a módosított projekt, azonban nem fog helyesen működni.&lt;/p&gt;

&lt;p&gt;Különösen átnevezésekkel van gond. Ugyanis a Subversion átnevezése effektív egy copy, majd egy delete, és nem őrzi meg az információt, hogy ez valójában egy átnevezés volt. Képzeljük el, hogy egy külön ágon javítunk egy állományon, míg a főágon egy mozgatást hajtunk végre. Mikor ezt a külön ágra akarjuk merge-ölni, az eredeti állományt letörli, és az újat hozzáadja. Csak közben elveszik a külön ágon történt javítás. A könyv szerint, amíg ezen nem javítanak, óvatosan merge-öljünk átnevezést.&lt;/p&gt;

&lt;p&gt;Amúgy a könyv a merge parancsra azt mondja, hogy jobb lenne diff-and-apply-nak hívni, mert semmi bűvészkedés nincs a háttérben, a merge összehasonít két ágat, és a különbséget a working copy-ra alkalmazza.&lt;/p&gt;

&lt;p&gt;Ezen eszközökkel haladóbb feladatokat is el tudunk végezni. Pl. ha egy revision-ben hibás kódot commit-oltunk, vissza tudjuk ezt vonni, méghozzá a reverse merge használatával (-c kapcsolóval). Persze a history-ban megmarad, de legalább automatikusan megtörténik az "undo" művelet. Ez TortoiseSVN-ben is megtalálható, bár nem utal a reverse merge-re: Revert changes from this revision menüpont. Ebben az esetben nem keletkezik vagy módosul a mergeinfo.&lt;/p&gt;

&lt;p&gt;Törölt elemet is vissza lehet állítani a merge-gel, azonban javasolt inkább a copy parancs használata, hiszen ha egy revision-ben más is történt a törlésen kívül, akkor az is visszajátszásra kerül, míg a copy esetén kedvünkre tudunk válogatni.&lt;/p&gt;

&lt;p&gt;A cherrypicking szintén egy haladó fogalom, magyar fordításban mazsolázásnak, csemegézésnek, szemezgetésnek lehetne fordítani. (A &lt;a href="http://plastik.hu/2011/08/24/heti-meteor-6/"&gt;Heti Meteor #6&lt;/a&gt;-ban is előjött a téma, teljesen más kontextusban.) Verziókezelés terén ez gyakorlatilag azt jelenti, hogy én egyenként kiválogatom, hogy milyen módosításokat szeretnék merge-ölni az egyik ágról a másik ágra. Ez Subversion esetén annyit tesz, hogy egy vagy több revision-re tudom megmondani, hogy annak a módosításaival történjen a merge (elég bonyolult feltételeket, intervallumokat fogalmazhatok meg). Ez különösen fontos akkor, ha a másik ágon folyik egy hosszabb fejlesztés, de közben egy bug-ot is kijavítottak, amit érdemes áthozni az én ágamba is. Persze ez is eltárolásra kerül a mergeinfo-ban, így ha később az ágban lévő többi módosítást is merge-ölni akarjuk, akkor ezt a revision-t automatikusan átugorja. Itt azonban lehet egy probléma, méghozzá egy revision intervallum közepén lévő merge két intervallumra bontja a módosításokat. Ha ez elsőben elhal a merge conflict-tal, és elhalasztjuk a conflict feloldását, a teljes merge elhal. Ez lehet, hogy későbbi Subversion verziókban javítják, de addigis két részletben kell ilyenkor merge-ölnünk.&lt;/p&gt;

&lt;p&gt;Egy kicsit bővebben a mergeinfo-ról. Egy normál merge esetén létrejön vagy módosul ez a property, azonban vannak esetek, mikor mégsem. Ez lehet akkor, ha a forrás és cél URL nincs egymással kapcsolatban, azaz nincs közös history-juk. Ugyanez van akkor is, ha másik repository-ból merge-ölünk. A mergeinfo-t a TortoiseSVN-nel a Properties menüponttal tudjuk megnézni, nincs rá külön menüpont, hiszen standard property. Ezt amúgy az Subversion explicit mergeinfo-nak nevez. Az implicit mergeinfo nem más, mint a közös history. Ez annyit jelent, ha a közös history-ban lévő módosítást akarunk merge-ölni, akkor a Subversion tudja, hogy semmit nem kell tennie, hisz a közös history miatt a módosítás mindkét ágon benne van.&lt;/p&gt;

&lt;p&gt;A merge tehát figyelembe veszi a history-t. Képzeljünk el egy esetet, ahol az egyik ágon törlünk egy állományt, commit, majd újra hozzáadjuk, és commit. Ebben az esetben az első és második módosításban szereplő állományoknak nincs közös history-ja. Ekkor a merge is törölni, majd hozzáadni fog. Abban az esetben, ha a --ignore-ancestry kapcsolót használjuk, a history-t nem veszi figyelembe a merge, úgy működik, mint egy szimpla diff. Ekkor sem keletkezik vagy módosul a mergeinfo.&lt;/p&gt;

&lt;p&gt;Ha megvizsgáljuk a merge parancsot, három paramétert lehet átadni. Initial repository tree, hasonlítás jobb oldalának is hívják. A final repository tree, a hasonlítás bal oldalának is hívják. A working copy, ahova az összehasonlítás eredményeként előállt diff rá lesz módosítva. Ezzel a paraméterezéssel nagyon vigyázzunk, hisz olyan tree-ket is megadhatunk, aminek semmi köze nincs egymáshoz, ennek az eredménye nagy kavarodás lehet. A könyv még azt is javasolja, hogy a merge-öt mindig a branch főkönyvtárán hajtsuk végre, ne alkönyvtárakon.&lt;/p&gt;

&lt;p&gt;A TortoiseSVN ezt úgy oldja meg, hogy mikor merge-ölni akarunk, megkérdezi, hogy mit szeretnénk.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Merge a range of revisions&lt;/li&gt;
&lt;li&gt;Reintegrate a branch&lt;/li&gt;
&lt;li&gt;Merge two different trees&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ez alapján a fenti paraméterezések helyett csak nekünk kell választanunk, hogy melyiket szeretnénk.&lt;/p&gt;

&lt;p&gt;Mint később látni fogjuk, a --record-only kapcsoló nagyon hasznos lehet. Ezzel ugyanis egy változásra azt mondhatjuk, hogy nem akarjuk, hogy a merge figyelembe vegye. Gyakorlatilag ekkor az történik, hogy a mergeinfo módosul, mintha a kiválasztott módosítás már be lenne merge-ölve (konkrétan behazudjuk a merge-t). Ezért a következő merge ezt ki fogja hagyni.&lt;/p&gt;

&lt;p&gt;Ha branch-ekkel dolgozunk, hasznos lehet a switch parancs használata, mellyel a working copy-t tudjuk update-elni egy másik URL-re. Azaz megadunk egy másik branch-et, és a working copy-nk átáll arra. Pl. jól jöhet akkor, ha fejlesztünk, és rájövünk, hogy ez akkora módosítás, hogy érdemes lenne branch-be tenni. Akkor létrehozzuk a branch-et, át-switch-elünk rá, majd oda történhet a commit. Mivel ez alkönyvtárra is működik, tudunk un. mixed working copy-t is csinálni, ahol az egyik könyvtár az egyik branch-et, a másik könyvtár a másik branch-et tartalmazza. Ezzel egyrészt nagyon vagány dolgokat is meg lehet csinálni, viszont rettenetesen be tud kavarni egy merge esetén. Javaslom, hogy kerüljük ilyenkor a mixed working copy használatát, azaz olyan working copy-val dolgozzunk, melynek minden eleme ugyanahhoz az időpontbeli állapothoz tartozik.&lt;/p&gt;

&lt;p&gt;A tag létrehozása nem sokban különbözik a branch-től, hiszen itt is egy másolás történik, valójában egy pillanatnyi állapot (snapshot), mely egy egyedi nevet kap. A revision is egy ilyen snapshot, azonban számmal azonosított. Konvenció szerint a projekt alá érdemes létrehozni a trunk, tags és branches könyvtárat, tartalmuk értelemszerű. A TortoiseSVN szól is, ha a tags-be akarunk commit-olni. Ezt ugyan lehet, hiszen a Subversion nem különbözteti meg a tag és branch fogalmát, azonban mégis jó, ha betartjuk a konvenciókat.&lt;/p&gt;

&lt;p&gt;Ezen ismeretekkel már meg lehet valósítani az előző &lt;a href="http://jtechlog.blogspot.com/2011/08/branch-eljunk-e-vagy-sem.html"&gt;post-ban&lt;/a&gt; említett feature és release branch-eket.&lt;/p&gt;

&lt;p&gt;A könyv megemlíti a vendor branches fogalmát is. Ezt akkor használhatjuk, ha egy 3rd party library-t patch-elünk, de szeretnénk mindig a módosításokat rávezetni, de a mi módosításunkat nem akarjuk kiadni (persze, ha a licence engedi). Ekkor importáljuk saját repository-ba a 3rd party library-t. Módosítjuk. Amint a 3rd party library-ból kijön egy következő verzió, merge-el vezetjük rá a változásokat, annak a repositry-jából. Így egyrészt a saját módosításaink is megmaradnak, valamint a verziókat is tudjuk emelni.&lt;/p&gt;

&lt;p&gt;Ahhoz azonban, hogy a post-nak valami köze legyen a Java-hoz is, belekeverem a Maven-t is, pontosabban annak &lt;a href="http://maven.apache.org/plugins/maven-release-plugin/"&gt;Release Plugin&lt;/a&gt;-ját, ami ugyanis a &lt;a href="http://maven.apache.org/plugins/maven-release-plugin/branch-mojo.html"&gt;release:branch céllal (goal)&lt;/a&gt; remekül tud branch-elni is, nem csak release-elni, mint egy &lt;a href="http://jtechlog.blogspot.com/2010/10/release-maven-nel-es-hudson-nel.html"&gt;előző post-ban írtam&lt;/a&gt;. Ez a cél igen jól paraméterezhető, de az alapbeállításokkal is el lehet boldogulni. A kötelező paramétere a branchName, amivel a branch nevét kell megadni. Amennyiben ezt nem adjuk meg, a következő hibaüzenetet kapjuk:&lt;/p&gt;

&lt;pre&gt;
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-release-plugin:2.0:branch (default-cli) on project acltuto
rial: The parameters 'branchName' for goal org.apache.maven.plugins:maven-release-plugin:2.0:branch are missing or inval
id -&gt; [Help 1]
&lt;/pre&gt;

&lt;p&gt;Adjuk meg tehát a branch nevét! Tartsuk észben, hogy ezzel a paraméterezéssel létrejön egy branch (copy a branch-es könyvtárba), melyben lévő projekt az &lt;emp&gt;aktuális verziószámot&lt;/emp&gt; fogja tartalmazni, és a working copy verziószáma fog emelkedni.&lt;/p&gt;

&lt;pre&gt;
mvn release:branch -DbranchName=my-branch
&lt;/pre&gt;

&lt;p&gt;A következő dolgok fognak megtörténni. A paraméterek alapértelmezettek, azaz updateBranchVersions=false, updateWorkingCopyVersions=true.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Megvizsgálja, hogy nincs-e lokális módosítás, mely nem lett commit-olva. Ha van, hibaüzenettel leáll (Cannot prepare the release because you have local modifications).&lt;/li&gt;
&lt;li&gt;Megkérdezi, hogy mi legyen a working copy új verziószáma. (Persze ezt parancssorban is meg lehet adni, ha nem interaktív módot akarunk.)&lt;/li&gt;
&lt;li&gt;Módosítja a pom.xml-ben a scm helyét, hogy a branch-re mutasson.&lt;/li&gt;
&lt;li&gt;Commit-olja a pom.xml-t. A commit comment szövege: [maven-release-plugin] prepare branch my-branch&lt;/li&gt;
&lt;li&gt;Végrehajtja a branch-et. A commit comment szövege: [maven-release-plugin]  copy for branch my-branch&lt;/li&gt;
&lt;li&gt;Megemeli a pom.xml-ben a verziószámot, és visszaállítja a scm helyét.&lt;/li&gt;
&lt;li&gt;Commit-olja a pom.xml-t. A commit szövege: [maven-release-plugin] prepare release my-branch
&lt;/ol&gt;

&lt;p&gt;Amennyiben azonban azt akarjuk, hogy a branch-ünk verziószáma ugorjon, viszont a working copy verziószáma maradjon, a következő parancsot adjuk ki:&lt;/p&gt;

&lt;pre&gt;
mvn release:branch -DbranchName=my-branch -DupdateBranchVersions=true -DupdateWorkingCopyVersions=false
&lt;/pre&gt;

&lt;p&gt;Ekkor a folyamat hasonló, mint az előbb, csak a working copy új verziószáma helyett a branch verziószámát kéri be a 2. lépéseben, és a pom.xml-ben is átírja a verziószámot. Ebben az esetben a 6. lépésben nem emel verziószámot, csak az scm helyét állítja vissza.&lt;/p&gt;

&lt;p&gt;Meg lehet adni azt is, hogy mindkét verziószám változzon, mindkét property igazra állításával.&lt;/p&gt;

&lt;p&gt;És valójában itt jön a feketeleves. Amennyiben van két fejlesztési águnk, és mindkettőn folyamatosan fejlesztünk, és adjuk ki a verziókat, mindkét ágon a release során változnak a pom.xml-ek, kizárólag az scm url-ek és a verziószámok. Amennyiben merge-ölni akarunk, a pom.xml-ek conflict-olni fognak, hiszen külön vezettük a verziószámokat mindkét ágon. Ez a conflict azonban a fejlesztési munkafolyamatunkba nem illik bele, hiszen nem akarunk pom.xml-ekben verziószámot szerkesztgetni, az kizárólag release során a release plugin feladata. Azaz ennek a merge-nek úgy kell lefutnia, hogy a pom.xml-ekben a verziószám változásokat ne vegye figyelembe.&lt;/p&gt;

&lt;p&gt;Itt vethetjük be a Subversion --record-only kapcsolóját. Nem kell mást csinálnunk, mint azokra a revision-ökre, melyekben a pom.xml-ben csak a verziószám változott, lefuttatni a merge-öt a --record-only kapcsolóval. Így gyakorlatilag becsapom a Subversion-t, a mergeinfo-ba bekerül, hogy ezen revision-ök már merge-ölve lettek. És a következő merge-nél már nem lesz conflict a pom.xml-re. Ettől függetlenül az olyan pom.xml változások, melyek lényegi részt érintenek, és nem a csak a release plugin által szerkesztett verziószámot, pl. dependency, stb., merge-ölésre kerülnek. Erre a problémára könnyű script-et is írni, hiszen a release plugin mindig úgy commit-ol, hogy a commit message-be szerepel a [maven-release-plugin] szó, valamint konfigurálhatunk saját commit message-eket is, így ezekre lehet szűrni, és rájuk futtatni a merge-öt --record-only kapcsolóval.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/3931037512697146491/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2011/09/subversion-branch-akar-maven-release.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3931037512697146491'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3931037512697146491'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/09/subversion-branch-akar-maven-release.html' title='Subversion branch, akár Maven Release plugin-nal'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5347349015396857015</id><published>2011-08-09T01:03:00.003+02:00</published><updated>2011-08-09T01:10:59.175+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Módszertan'/><title type='text'>Branch-eljünk-e vagy sem?</title><content type='html'>&lt;p&gt;Amíg a szoftverfejlesztés az elején tart, nem adtunk még ki verziót, a folyamat legtöbb esetben lineáris, egy kódbázison dolgozunk, minden fejlesztő ugyanazt látja. Bizonyos esetekben ez így is marad, és sorban fejleszthetjük bele az adott funkciókat, adhatunk ki újabb verziókat. Sajnos azonban ez a legtöbb esetben nem elegendő, így előbb-utóbb szükség lehet eltérni a fősodortól, és párhuzamos fejlesztéseket végezni, elágazunk, branch-et képzünk. Remélhetőleg a legtöbb helyen már rendelkeznek valamilyen verziókezelő eszközzel, mely képes állományokat, és ezek összességét véve a teljes projektet (forrás, erőforrás állományok, script-ek, dokumentáció) hisztorikusan tárolni, ezzel segítve a változások nyomon követését, ki, mikor, mit módosított. Sajnos munkám során láttam olyan fejlesztőcsapatot, ahol még mindig megosztott meghajtókon tárolják a projektet. A fejlesztési munkafolyamatot, a branch-ek kezelését és a fejlesztők közötti kollaborációt pedig ezen eszközök emelik egy magasabb szintre.&lt;/p&gt;

&lt;p&gt;A fő fejlesztési sodor a mainline, melyen a fő fejlesztés történik. Branch-re több esetben is szükség lehet. A klasszikus példa, mikor kiadjuk az 1.0 verziót, elkezdjük a 2.0-ás verzió fejlesztését, és közben derül ki, hogy az 1.0-ás verzióban hibák vannak, melyre az ügyfél azonnali javítást vár, és nem várja meg a 2.0-ás verzió kifejlesztését. Ekkor elágazhatunk az 1.0-ás verziónál, és létrehozhatunk egy külön branch-et az 1.1-es verziónak, mely a hibajavítást fogja tartalmazni. A példán máris látszik, hogy később szükséges lesz a hibajavítás visszavezetése a 2.0-ás verzióba is. Ez a merge, mely során az egyik branch módosításait kell átvezetni egy másik branch-be, jelen esetben a mainline-ba. A jelenlegi eszközök a branch-ek elkészítését nagymértékben támogatják, általában egy parancs, azonban a merge már sokkal problematikusabb művelet.&lt;/p&gt;

&lt;p&gt;Az előbbi használati eseten (, amit nevezzünk bug-fix branch-nek) kívül is szükség lehet branch-ek használatára. Mostanában egyre divatosabb a feature branch-ek és release branch-ek használata, a branch-ek nagymértékű elszaporodása. A feature branch esetén a fejlesztők minden egyes szoftver funkciót (feature, de nevezik story-nak is) külön ágon fejlesztenek. Ezen funkciók lehetőleg legyenek egy jól körülhatárolható és azonosítható egységek, pl. bugtracker issue-k, de láttam már olyant is, hogy mivel ezek túl kis egységek voltak (granularitás), ezeket összefogták nagyobb egységekbe. (Direkt nem nevezném külön verziónak, később kiderül, miért.) Egy feature branch-en egy vagy több fejlesztő is dolgozhat. Amíg a funkció el nem készül, a fejlesztés ezen a branch-en folyik, és párhuzamosan mellette más feature branch-eket is lehet fejleszteni. Amikor egy feature branch elkészül, ez visszavezetésre kerülhet a fősodorba, és kiadható.&lt;/p&gt;

&lt;p&gt;Ez az elmélet, de a használat során felmerülnek kérdések. Egyrészt miért is hasznos, miért nem a fősodorban történik a fejlesztés? A feature branch használatával ugyanis egy adott időpillanatban választhatunk, hogy mely funkciók állnak készen, melyikeket lehet kiadni. Ez a klasszikus szoftverfejlesztéssel, ahol is előre kitűzzük a verziószámokat, és hogy abban milyen funkciók lesznek elérhetőek (, maximum kicsit sakkozunk közöttük) teljesen ellentétes, hiszen itt a következő verzió azokat a fejlesztéseket fogja tartalmazni, amik készen vannak. A funkciók ilyen szintű összeválogatását nevezzük cherry-picking-nek. Ezért nem kell a branch létrehozását verzióhoz kötni. Sok helyen történik ilyen típusú fejlesztés, általában ott, ahol bizonyos okok miatt (politikai indokok, megrendelői bizonytalanság, fejlesztőcsapat képzettsége, stb.) a funkciók kifejlesztésének erőforrásigénye nem kalkulálható, vagy a különböző funkciók szintén ugyanilyen okokra visszavezethetően előzgethetik egymást (pl. épp melyik osztály az erősebb a megrendelőnél). A funkciók külön ágon készülnek, egymást nem zavarják, bármikor bármelyiket be lehet hozni. A probléma természetesen itt is az lesz, hogy mi van akkor, ha két branch módosításait kell összevezetni. Ilyenkor ismét merge-ölni kell.&lt;/p&gt;

&lt;p&gt;Abban az esetben, ha több feature branch-et szeretnénk egy release-be összevonni, akkor az integráció, a merge akár hosszabb folyamat is lehet. Ilyenkor az integrációval akár meg is akaszthatjuk a fő fejlesztést, ha azt a mainline-on végezzük. Ilyenkor szokták bevetni a release branch fogalmát. A release branch-en történik a merge, valamint történhet a tesztek, akár QA tesztek elvégzése is. És amikor ez sikeresen befejeződik, csak ekkor kerülnek vissza a módosítások a mainline-ba. Ezzel a fősodorban mindig az aktuálisan működő, kitesztelt verziónk lesz, melyből biztonságosan le lehet ágazni, és nem kell kérdezni, hogy egy új fejlesztés (branch nyitása) most honnan történjen.&lt;/p&gt;

&lt;p&gt;Ez a fejlesztési folyamat elsőre tökéletesnek tűnhet, de az ördög a részletekben lakozik. Jelen esetben a merge-ben. Amennyiben mindkét ágon módosítás történik, akkor ütközés léphet fel (conflict). Ez szöveges állomány esetén, ha külön sorokban történt a módosítás, egész könnyen, automatikusan kezelhető. Ellenkező esetben humán beavatkozás szükséges. A kezdeti verziókezelők viszont már azt sem tudták kezelni, ha az egyik ágon egy állományban módosítás, a másik ágon ugyanazon állománynak az átnevezése történt. Szerencsére a modern verziókezelőknek ez már nem jelent problémát, hiszen a merge során felhasználják azt az információt is, hogy átnevezés történt. A probléma &lt;a href="http://martinfowler.com/"&gt;Martin Fowler&lt;/a&gt; által elnevezett &lt;a href="http://martinfowler.com/bliki/SemanticConflict.html"&gt;szemantikai ütközéssel&lt;/a&gt; van. Mivel ő a refactoring atyja, ilyen példával a legkönnyebb magyarázni. Az egyik ágon egy refactoring, egy metódus átnevezés történik, a másik ágon meg bevezetésre kerül újabb metódushívás még a régi névvel. A merge során azonnal conflict történik, hiszen a második branch-ben még a régi névvel történik metódushívás. Ezt az eszközök képtelenek feloldani, mert ugyan az állomány átnevezést tudják kezelni, de az ilyen mély, nyelvi szintű refactoring-ot nem. (Vajon elgondolkodott már valaki olyan verziókezelőn, mely egy speciális programozási nyelvre lenne kifejlesztve, és érzékelné a struktúrális változásokat?) A legrosszabb az olyan conflict és annak feloldása, ami során ugyan a forráskód lefordul, de a szoftver nem az elvártnak megfelelően működik&lt;/p&gt;

&lt;p&gt;Fowler nagy híve a Test Driven Development-nek, így az utóbbira az azonnali válasza, hogy minél több teszt esetet írjunk, mely során kijönnek a szemantikai ütközések. Valamint még egy, a bug-fix branch-eken kívül ne használjunk branch-eket, azaz az egész eddigi okfejtést negálja.&lt;/p&gt;

&lt;p&gt;Erre találta ki ugyanis a &lt;a href="http://martinfowler.com/articles/continuousIntegration.html"&gt;continuous integration&lt;/a&gt; fogalmát, mely az Extreme Programming egyik alapelve is. Egy dolgot szeretnék ezzel kapcsolatban mindenekelőtt tisztázni. Azért, mert a fejlesztési folyamatunkban van CI eszköz (pl. a legelterjedtebb Hudson/Jenkins), még nem használunk CI-t. Láttam több helyen olyant, hogy minden egyes branch-re rá volt fűzve a CI, ami a branch-eket build-elgette. Ez nem CI, a CI tagadja a branch-ek használatát, így nem barátja a &lt;a href="http://martinfowler.com/bliki/FeatureBranch.html"&gt;feature branching-nek&lt;/a&gt; sem! Fowler ezt continuous building-nek nevezi, ami ugyan jó dolog, de szerinte nem elegendő.&lt;/p&gt;

&lt;p&gt;A continuous integration gyakorlatilag arra épít, hogy a fejlesztési folyamatban az egyik legfájóbb pont a merge. Ezt úgy próbálja kiküszöbölni, hogy kizárólag a mainline-ban történik a fejlesztés, így nincs szükség merge-ölésre. A mainline-nak mindig egy működő, futtatható, tesztelhető állapotnak kell lennie, hogy ne akassza meg a többiek munkáját. A fejlesztés során így a fejlesztők kötelesek azonnal kommunikálni, hiszen nem vonulhatnak el külön kis branch-ükbe, hanem ha olyan funkciókat fejlesztenek, melyek közös területeket érintenek, azonnal össze kell dolgozniuk. A külön branch-ek esetén erre nincs szükség, két teljesen különböző irányokba elmehetnek, és csak a conflict során derül ki, hogy esetleg már az elején közösen kellett volna dolgozniuk (nem tudta az egyik kéz, mit csinál a másik). A CI arra ösztökéli a fejlesztőket, hogy minél gyakrabban tegyék vissza a saját gépükről a változásokat a mainline-ba (minimum naponta egyszer), megelőzve ezzel az ütközéseket, valamint kis, atomi egységekben dolgozzanak. Szemben a branch-ek esetén, ahol igen nagy méretű módosításokat kellhet összevezetni. A branch-ek használata esetén megfigyelték, hogy a fejlesztők féltek a refactoring-tól, hiszen leggyakrabban azok okoznak szemantikai ütközést. CI esetén a refactoring-ot el lehet végezni, folyamatosan javítva ezzel a kódminőséget.&lt;/p&gt;

&lt;p&gt;Amennyiben a feature branch-ing esetén csökkenteni akarjuk a merge veszélyét megtehetjük azt is, hogy merge-ölgetünk a branch-ek között. Ezt Fowler promiscuous integration-nek nevezi, de ezt sem tartja jó megoldásnak. Több branch esetén már problémás lehet, valamint nagy adminisztrációs terhe van, hogy mi hova lett már merge-ölve (ezen az eszközök kicsit enyhíthetnek).&lt;/p&gt;

&lt;p&gt;Mi van akkor, ha az ügyfél mégis azt kéri, hogy kell neki egy olyan verzió, ami nem tartalmaz olyan funkciókat, amiket mi már elkezdtünk fejleszteni. A CI megoldása erre a &lt;a href="http://martinfowler.com/bliki/FeatureToggle.html"&gt;funkciók ki- és bekapcsolása&lt;/a&gt;. Ugyanis a branch-ek hiánya miatt nincs cherry-picking. Úgy fejlesszük le az új funkciókat, hogy azok kikapcsolhatóak legyenek - például menüpont eltüntetésével. (Azért azt ő sem tagadja, hogy ez több hibalehetőséget is magában rejthet - pl. furcsa olyan teszt esetet írni, ami azt ellenőrzi, hogy nincs-e valami plusz.)&lt;/p&gt;

&lt;p&gt;A CI-nek több eleme is van (automatikus build, melynek időtartamát illik 10 perc alatt tartani, staged build/build pipeline, tesztelés, deployment, CI eszköz, stb.), de a branch-elés szempontjából a post-ban említettek a kiemelendők.&lt;/p&gt;

&lt;p&gt;Martin Fowler szerint a CI szinte mindenütt bevethető. Én ennél sokkal óvatosabban fogalmaznék, szerintem mindkét megközelítésnek megvan a megfelelő alkalmazási környezete. Mint sok mindenben, itt is a projekt ismeretében lehet dönteni. Kevésbé képzett, kevésbé agilis fejlesztőteam-ek, kevésbé rugalmas, vagy problémásabb megrendelő, nagyobb projekt büdzsé esetében kellő körültekintéssel nem lehet probléma a branch-ek használatával. Vigyázzunk, ezek ne szaporodjanak el, kontrolláljuk őket, mert nem egy céget/fejlesztést láttam, ahol annyira szétcsúsztak a branch-ek, hogy a fejlesztők nem látnak esélyt arra, hogy valaha is merge-öljenek, pl. ügyfelenként külön branch-ük van. A menedzsment meg nem biztosít erre erőforrást (idő/pénz), hiszen a problémát sem érti. Vigyázzunk, hogy a branch-ek kellően rövid élettartamúak legyenek, és szüntessük meg őket. A CI egy nagyon jó irány, amennyiben kellően pörgős vagy kicsi a team, a projekt, sikerrel alkalmazhatjuk. Mi saját fejlesztéseinkben a CI-t alkalmazzuk, de több esetet láttam, ahol indokolt a branch-ek használata. Az alkalmazás megfelelő modularizálásával szintén léphetünk egyet a CI felé, egy monolitikus maradványrendszer megkövetelheti a branch-ek használatát. A fejlesztők képzettsége nem biztos, hogy számottevő tényező, mert branch esetén a merge-ben kell nagyon jónak lenni, CI esetén viszont úgy kell fejleszteni, hogy véletlenül se tegyünk a mainline-ba olyan dolgot, ami megakasztja a többi fejlesztőt. Mindkét esetben nagy odafigyeléssel dolgozó, motivált és kommunikációra képes kollégákra van szükségünk.&lt;/p&gt;

&lt;p&gt;A következő post-ban arról fogok írni, hogyha a branch-elés mellett döntünk, mire kell figyelni, milyen lehetőségeink vannak, milyen eszközök támogatnak ebben.&lt;/p&gt;

&lt;p&gt;Te milyen aktívan branch-elsz és miért?&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/5347349015396857015/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2011/08/branch-eljunk-e-vagy-sem.html#comment-form' title='7 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/5347349015396857015'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/5347349015396857015'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/08/branch-eljunk-e-vagy-sem.html' title='Branch-eljünk-e vagy sem?'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>7</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1041560709147746097</id><published>2011-08-08T10:53:00.002+02:00</published><updated>2011-08-08T11:00:27.422+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Community'/><title type='text'>Goldenblog 2011</title><content type='html'>&lt;p&gt;Elindult a Goldenblog szavazás, kilenc kategóriában lehet szavazni a kedvenc blogodra. Szavazni Facebook-belépéssel lehet. Mind a kilenc kategóriában egyet-egyet szavazhattok. A szavazás augusztus 8-án reggel (szintén 7 óra 7 perckor) indul és 21-én éjfélig tart. Újdonság idén, hogy minden kategóriában két (egy szakmai és egy közönségzsűri) nyertest hirdetnek.&lt;/p&gt;

&lt;p&gt;Idén a &lt;a href="http://jtechlog.blogspot.com/"&gt;JTechLog&lt;/a&gt; is indult az IT-blogok kategóriában. Amennyiben tetszik a blog, &lt;a href="http://goldenblog.hu/szavazas.aspx?bId=1353"&gt;szavazz rá&lt;/a&gt;!&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/1041560709147746097/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2011/08/goldenblog-2011.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1041560709147746097'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1041560709147746097'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/08/goldenblog-2011.html' title='Goldenblog 2011'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1410480971650480828</id><published>2011-08-05T00:40:00.005+02:00</published><updated>2011-08-05T00:47:35.205+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Maven'/><title type='text'>Maven plugin-ek verziószáma</title><content type='html'>&lt;p&gt;Technológiák: Maven 2.1.1, Maven 3.0.3&lt;/p&gt;

&lt;p&gt;Egy régebbi &lt;a href="http://jtechlog.blogspot.com/2010/04/maven-kezdolepesek.html"&gt;postban&lt;/a&gt; már említettem, hogy a Maven moduláris felépítésű, és minden plugin-ben van megvalósítva. Az életciklus különböző fázisaiban (phase) különböző plugin-ok különböző céljai (goal) futnak le. Minden feladatot tehát valójában egy-egy plugin végez el, ezen plugin-okból &lt;a href="http://maven.apache.org/plugins/index.html"&gt;rengeteg támogatott&lt;/a&gt; és egyedi plugin is létezik. A compiler plugin végzi a fordítást, a jar, war és ear például a csomagolást, stb. A plugin-ek két csoportra oszthatók, build plugin-ek és reporting plugin-ek.&lt;/p&gt;

&lt;p&gt;A következő post azt demonstrálja, hogy miért szükséges a plugin-ek verziószámát is deklarálni a pom.xml-ben. Egy nem általunk készített alkalmazás Maven 3.0.3-ra migrációjánál a következő hibaüzenetet vettem észre egy projektnél:&lt;/p&gt;

&lt;pre&gt;
[WARNING] Warning: selected war files include a WEB-INF/web.xml which 
will be ignored 
(webxml attribute is missing from war task, or ignoreWebxml attribute 
is specified as 'true')
&lt;/pre&gt;

&lt;p&gt;A hibaüzenet a war plugin adja, a hibaüzenet számomra teljesen értelmezhetetlen. Milyen war fájlok (többesszám!) tartalmaznak már web.xml állományt? A dokumentációt megnézve a hibaüzenetben ezen kívül két hiba is van, az első említett paraméter helyes írásmódja webXml, a másik ignoreWebxml paraméter nem is létezik (http://maven.apache.org/plugins/maven-war-plugin/war-mojo.html).&lt;/p&gt;

&lt;p&gt;Mivel emlékeztem, hogy a Maven 2.1.1 hasonló hibát nem dobott, ezt újra leellenőriztem, és tényleg nem írt ki hibát. Ebből már sejthető volt, hogy verzióeltérés lesz.&lt;/p&gt;

&lt;p&gt;Először egy help:describe paranccsal próbálkoztam Maven 3.0.3-assal, mely egy rövid súgót ad az adott plugin-re vonatkozóan. Ez még egy olyan könyvtárban, ahol nincs pom.xml, tehát projekttől függetlenül. Erről a &lt;a href="http://docs.codehaus.org/display/MAVENUSER/FAQs-1#FAQs-1-HowdoIdeterminewhatversionofapluginIamusing%3F"&gt;FAQ&lt;/a&gt; kicsit félrevezetően ír.&lt;/p&gt;

&lt;pre&gt;
$ mvn help:describe -Dplugin=war
...
Name: Maven WAR Plugin
Description: Builds a Web Application Archive (WAR) file from the project
  output and its dependencies.
Group Id: org.apache.maven.plugins
Artifact Id: maven-war-plugin
Version: 2.1.1
Goal Prefix: war
...
&lt;/pre&gt;

&lt;p&gt;A plugin paraméternél megadott prefix (war) helyett megadhatunk groupId, artifactId párt is (-Dplugin=org.apache.maven.plugins:maven-war-plugin). Amennyiben nem a verziószámra vagyunk kíváncsiak, hanem egy adott verzióhoz tartozó célokra, megadhatunk GAV (groupId, artifactId, version) hármast is, a szokásos jelöléssel, kettőspontokkal elválasztva. De megadhatjuk a GAV-ot három paraméterrel is:&lt;/p&gt;

&lt;pre&gt;
$ mvn help:describe -DgroupId=org.apache.maven.plugins 
  -DartifactId=maven-war-plugin -Dversion=2.1.1 -Ddetail=true -Dgoal=war
&lt;/pre&gt;

&lt;p&gt;Ne feledjük, hogy amennyiben elírjuk a paraméter nevét, a Maven erről nem figyelmeztet, egyszerűen figyelmen kívül hagyja. Részletesebb súgót, mely a paramétereket is tartalmazza a -Ddetail paraméterrel kérhetünk (régebben full paraméter volt). A -Dgoal=war paraméterezéssel tudunk csak egy célról információt kérni.&lt;/p&gt;

&lt;p&gt;Az első parancsot kiadva Maven 2.1.1-nél azt tapasztalhatjuk, hogy a verzió 2.2-SNAPSHOT. Egy kis &lt;a href="https://cwiki.apache.org/MAVEN/maven-3x-compatibility-notes.html"&gt;kutakodás után kiderült&lt;/a&gt;, hogy a Maven 2 és 3 között inkompatibilitás van, azzal kapcsolatban, hogy hogyan keresi meg a verziószámát a használni kívánt plugin-nek. Míg a 2-es a legutolsó verziót tölti le (2.2-SNAPSHOT), addig a 3-asban a stabilitás érdekében azt a döntést hozták, hogy a legutolsó release verziót használja, ami jelenleg a 2.1.1.&lt;/p&gt;

&lt;p&gt;Ez a parancs nem adja viszont azt meg, hogy az adott projektben a kérdéses plugin melyik verziója kerül felhasználásra. Az adott projektben nem volt a plugin definiálva. A Maven 3 már futás közben is tájékoztat a verziószámról.&lt;/p&gt;

&lt;pre&gt;
--- maven-war-plugin:2.1.1:war (default-war) @ earconfig-web ---
&lt;/pre&gt;

&lt;p&gt;Ahhoz, hogy a Maven 2 futás közben is kiírja, a -X kapcsolóval kell indítani, és a nagyon részletes logból kibogarászni:&lt;/p&gt;

&lt;pre&gt;
[DEBUG] Configuring mojo 
  'org.apache.maven.plugins:maven-war-plugin:2.1-alpha-2:war' --&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Látható, hogy míg a 2-es Maven a 2.1-alpha-2 verzióval dolgozik, addig a 3-as a 2.1.1-gyel. De mégis hol van ez definiálva? A választ a következő parancs adja meg:&lt;/p&gt;

&lt;pre&gt;
mvn help:effective-pom
&lt;/pre&gt;

&lt;p&gt;A Maven help plugin-jének effective-pom paranccsa összefésüli a super pom-ot és a projekt pom-ját (, és annak szülőit, valamint figyelembe veszi a profilokat). Mivel a projekt pom-jában nincs a plugin definiálva, azt a super pom-ból veszi, ami a 2-esben a M2_HOME/lib/maven-2.2.1-uber.jar:org/apache/maven/project/pom-4.0.0.xml helyen, míg a 3-asban a M2_HOME/lib/maven-model-builder-3.0.3.jar:org/apache/maven/model/pom-4.0.0.xml helyen van. Tehát a Maven verziójától függ, hogy mik az alapértelmezett plugin verziószámok egy projekten belül.&lt;/p&gt;

&lt;p&gt;Tehát míg a Maven 2 által definiált 2.1-alpha-2 nem dobja a hibát, addig a 2.1.1 igen, amiről egy &lt;a href="http://stackoverflow.com/questions/4342245/maven-webxml-is-missing-from-war-task"&gt;stackoverflow kérdés&lt;/a&gt;, és egy &lt;a href="http://jira.codehaus.org/browse/MWAR-248"&gt;JIRA issue&lt;/a&gt; is megemlékezik. Ennek megoldása egyszerű, helyezzük el a pom.xml-ben a következőt:&lt;/p&gt;

&lt;pre class="brush: xml"&gt;
&amp;lt;build&amp;gt;
  &amp;lt;plugins&amp;gt;
    &amp;lt;plugin&amp;gt;
      &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;maven-war-plugin&amp;lt;/artifactId&amp;gt;
      &amp;lt;configuration&amp;gt;
        &amp;lt;packagingExcludes&amp;gt;WEB-INF/web.xml&amp;lt;/packagingExcludes&amp;gt;
      &amp;lt;/configuration&amp;gt;
    &amp;lt;/plugin&amp;gt;
  &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Úgy tűnik nem tanultunk az előző hibánkból, és újra elkövettük, hogy a plugin verziószámát nem definiáltuk. Erre a Maven 3 már alapból figyelmeztet:&lt;/p&gt;

&lt;pre&gt;
[WARNING] 
[WARNING] Some problems were encountered while building the effective model 
  for jtechlog.earconfig:earconfig-web:war:1.0-SNAPSHOT
[WARNING] 'build.plugins.plugin.version' for 
  org.apache.maven.plugins:maven-war-plugin is missing. @ line 60, column 9
[WARNING] 
[WARNING] It is highly recommended to fix these problems because they 
  threaten the stability of your build.
[WARNING] 
[WARNING] For this reason, future Maven versions might no longer 
  support building such malformed projects.
[WARNING] 
&lt;/pre&gt;

&lt;p&gt;A version tag beillesztésével azonnal javíthatjuk a hibát. Ekkor már nem a super pom-ban definiált verzió, hanem a saját pom.xml-ünkben definiált verzió fog
érvényesülni. A verzió automatikus meghatározását a Maven Automatic Plugin Version Resolution-nek nevezi, és warning amiatt jelenik meg, mert a későbbi verziókban a build reprodukálhatóságának megsegítéseként el kívánják távolítani, ezért érdemes mindenképp explicit definiálni a verziókat.&lt;/p&gt;

&lt;p&gt;Amennyiben a 2-es Maven verziót használjuk, ugyanerre megfelelő az &lt;a href="http://maven.apache.org/plugins/maven-enforcer-plugin/"&gt;enforcer&lt;/a&gt; plugin enforce célja. A következőképp konfigurálhatjuk:&lt;/p&gt;

&lt;pre class="brush: xml"&gt;
&amp;lt;plugin&amp;gt;
  &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;maven-enforcer-plugin&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.0.1&amp;lt;/version&amp;gt;
  &amp;lt;executions&amp;gt;
    &amp;lt;execution&amp;gt;
      &amp;lt;goals&amp;gt;
        &amp;lt;goal&amp;gt;enforce&amp;lt;/goal&amp;gt;
      &amp;lt;/goals&amp;gt;
      &amp;lt;configuration&amp;gt;
        &amp;lt;rules&amp;gt;
          &amp;lt;requirePluginVersions&amp;gt;
            &amp;lt;banLatest&amp;gt;true&amp;lt;/banLatest&amp;gt;
            &amp;lt;banRelease&amp;gt;true&amp;lt;/banRelease&amp;gt;
          &amp;lt;/requirePluginVersions&amp;gt;
        &amp;lt;/rules&amp;gt;
      &amp;lt;/configuration&amp;gt;
    &amp;lt;/execution&amp;gt;
  &amp;lt;/executions&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Futtatáskor a következő hibát kaphatjuk:&lt;/p&gt;

&lt;pre&gt;
[WARNING] Rule 0: org.apache.maven.plugins.enforcer.RequirePluginVersions 
  failed with message:
Some plugins are missing valid versions:(LATEST RELEASE SNAPSHOT are 
  not allowed )
org.apache.maven.plugins:maven-war-plugin.  The version currently in 
  use is 2.1-alpha-2
&lt;/pre&gt;

&lt;p&gt;A Maven 3-nál többet tud, ugyanis a nem definiált plugin-okat is jelzi. Az előbbi példánál maradva, ha nem tettük volna bele a maven-war-plugin definícióját a pom.xml-be, a Maven 3 nem panaszkodott volna, hogy nem a legfrissebb plugin-t futtatja. Az enforcer plugin viszont ezt is észreveszi, bővebb a funkcionalitása.&lt;/p&gt;

&lt;p&gt;Az enforcer plugin-t a 3-as Maven-nel futtatva viszont a következő hibaüzenetet kapjuk. Erről is van &lt;a href="http://jira.codehaus.org/browse/MENFORCER-98"&gt;JIRA issue&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;
[INFO] The requirePluginVersions rule is currently not compatible with Maven3.
&lt;/pre&gt;

&lt;p&gt;Projekt öröklődés esetén a plugin beállításai alapesetben nem öröklődnek. Ahhoz, hogy mégis, a beállításokat a szülő projekt pom-jában a pluginManagement részben kell elhelyezni. Így a verziószám és a konfiguráció is öröklődik. Ekkor a gyermek projektben elegendő csak a groupId-t és az artifactId-t elhelyezni. Nagy projekt esetén jelentős copy-paste munkát takaríthatunk meg ezzel.&lt;/p&gt;

&lt;p&gt;Néha szükségünk lehet arra is, hogy megnézzük, hogy van-e frissebb verzió egy adott plugin-ból. Ezt a versions pluginnal kérhetjük le a következő módon:&lt;/p&gt;

&lt;pre&gt;
mvn versions:display-plugin-updates
&lt;/pre&gt;

&lt;p&gt;Régebben a -cpu kapcsoló is jó volt erre, de ez deprecated, így ne használjuk. Másik lehetőség, hogy egyszerűen rákeresünk a Maven repository-ban a http://search.maven.org címen.&lt;/p&gt;

&lt;p&gt;A plugin-ek verziószámát a site generálás is szépen megmutatja a Maven 2-ben, a plugin-management.html oldalon.&lt;/p&gt;

&lt;a rel="lightbox" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/-uxSShb6DUDM/TjsgidXjC7I/AAAAAAAAHR0/tNYk_m5mttE/s1600/plugin-management.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 303px;" src="http://2.bp.blogspot.com/-uxSShb6DUDM/TjsgidXjC7I/AAAAAAAAHR0/tNYk_m5mttE/s320/plugin-management.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5637135134955342770" /&gt;&lt;/a&gt;

&lt;p&gt;A Maven 3-ban ez &lt;a href="https://cwiki.apache.org/MAVEN/maven-3x-and-site-plugin.html"&gt;nem ilyen egyszerű&lt;/a&gt;. A mvn site parancsot kiadva alapértelmezetten semmit nem kapunk. Konfigurálni kell a maven-site-plugin-t, hogy futtassa a maven-project-info-reports-plugin-t, és az generálja le pl. a plugin-management riporot. Ez a következőképp néz ki:&lt;/p&gt;

&lt;pre class="brush: xml"&gt;
&amp;lt;plugin&amp;gt;
  &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;maven-site-plugin&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;3.0&amp;lt;/version&amp;gt;
  &amp;lt;configuration&amp;gt;
    &amp;lt;reportPlugins&amp;gt;
      &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;maven-project-info-reports-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.4&amp;lt;/version&amp;gt;
        &amp;lt;reports&amp;gt;
          &amp;lt;report&amp;gt;plugin-management&amp;lt;/report&amp;gt;
        &amp;lt;/reports&amp;gt;
      &amp;lt;/plugin&amp;gt;
    &amp;lt;/reportPlugins&amp;gt;
  &amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Azaz ha biztosak akarunk lenni a build reprodukálhatóságában, mindig definiáljuk a plugin-ek verziószámát. A Maven 3 tett egy lépést ennek kikényszerítésének az irányában.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/1410480971650480828/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2011/08/maven-plugin-ek-verzioszama.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1410480971650480828'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1410480971650480828'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/08/maven-plugin-ek-verzioszama.html' title='Maven plugin-ek verziószáma'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://2.bp.blogspot.com/-uxSShb6DUDM/TjsgidXjC7I/AAAAAAAAHR0/tNYk_m5mttE/s72-c/plugin-management.png' height='72' width='72'/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-535551803739667071</id><published>2011-07-02T20:22:00.006+02:00</published><updated>2011-07-03T17:38:13.544+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='open source'/><category scheme='http://www.blogger.com/atom/ns#' term='IDE'/><category scheme='http://www.blogger.com/atom/ns#' term='Swing'/><category scheme='http://www.blogger.com/atom/ns#' term='könyv'/><category scheme='http://www.blogger.com/atom/ns#' term='NetBeans'/><title type='text'>Vastag kliens Java-ban? NetBeans Platform</title><content type='html'>&lt;p&gt;Technológiák: NetBeans Platform 7.0 - Rich-Client Platform (RCP)&lt;/p&gt;

&lt;p&gt;Az előző két post kellően megmozgatta a fantáziátokat, egy-két hozzászólásból nagyon sokat tanultam, most megpróbálok ismét egy kellően provokatív témát felvetni, a vastag kliens fejlesztésről általában, és speciálisan Java környezetben. Ne fogjátok vissza magatokat, várom a véleményeiteket.&lt;/p&gt;

&lt;p&gt;Egy projekt úgy hozta, hogy vastag klienses alkalmazást kell fejleszteni. Igazából mi döntöttünk, hogy az alkalmazást vastag kliensként fejlesztjük le, ilyen szempontból nem volt megkötés, a követelmények elemzésekor azonban mégis oda jutottunk, hogy így járunk a legjobban.&lt;/p&gt;

&lt;p&gt;Nagyon sok embernek említettem, és majdnem mindannyian kérdően néztek rám, és láttam, hogy nem értették. A legjobban az zavar, hogy megemlítettem, hogy vastag kliens alkalmazást fejlesztünk, és bármi egyéb információ nélkül azonnal rávágta, hogy miért. Volt, aki azonnal elkezdte kifejteni, hogy a GWT (ide bármilyen kedvenc keretrendszer neve beilleszthető) mennyivel jobb, mint a vastag kliens alkalmazás fejlesztése.&lt;/p&gt;

&lt;p&gt;Vajon miért ez az ellenszenv? Miért vált ilyen divatossá a webes fejlesztés? De ami a legsúlyosabb kérdés, mindenáron ragaszkodni kell a webes megközelítéshez? Hogy nem is érdekel, hogy miről szól a projekt, nem is érdekel, hogy mik a követelmények, azonnal véleményt formálok, és megpróbálom lebeszélni a fejlesztőket a vastag kliensről? Azokat a fejlesztőket, akik hónapokat gondolkodtak ezen, pilotokat dolgoztak ki, körültekintően próbálták és hasonlították össze a technológiákat?&lt;/p&gt;

&lt;p&gt;Véleményem szerint a vastag kliens fejlesztésének még mindig megvan a létjogosultsága. Kinek jutna eszébe fejlesztőeszközt webeset használni? (Na jó, vannak elvetemültek, április témaként is megjelent, hogy az Eclipse-nek elkészítik a webes verzióját, és félek, vannak, akik meg is tennék.) Egy 3D modellező eszköz (pl. Blender), CAD rendszer (AutoCAD), hatalmas képeket/3d objektumokat feldolgozó orvosi rendszerek, GIS alkalmazások (térképészet) mind mind csak egy példa arra, hogy a vastag kliensnek van még alkalmazási területe. (Corel, Photoshop szerű, valamint videóvágó alkalmazások webes verziói mostanában nagyon mennek, de azért ezek távol állnak a professzionális megoldásoktól. Persze, bizonyos felhasználóknak ezek is elegendőek.) Nekünk egy Visio szerű rajzoló alkalmazást kell fejlesztenünk, bonyolult mögöttes üzleti logikával.&lt;/p&gt;

&lt;p&gt;A vastag kliens kiválasztásában a következő érvek döntöttek. Talán a döntő érv az volt, hogy pixel pontos grafikai megjelenítést és tervezést kell megvalósítani, nagyíthatósággal. A telepítési munkálatok nem problémásak, mivel Intraneten központilag képesek az alkalmazásokat telepíteni. (A Java Web Start óta viszont amúgy sem bonyolult a Java alkalmazások telepítése, de tény, hogy a Java Runtime Environment-et ugyanúgy teríteni kell.) Valamint vastag kliens fejlesztése eszméletlenül hatékony tud lenni, irgalmatlanul gyorsan lehet a képernyőket gyártani. (Láttam projektet, melynél az implementáció felében döntöttek arról, hogy legyen inkább vastag kliens, és az idő tört része alatt összerakták ugyanazon képernyőket.) Sajnos a http protokoll, a html formátum, a különböző adatátvitel megoldások, XML, JSON, AJAX, stb. mind-mind egy plusz probléma, plusz réteg, mellyel foglalkozni kell, teljesen egyik keretrendszer sem képes ezeket elfedni. Meggyőződésem, hogy a http formátumot már rég kinőttük, az egészet el kéne felejteni, és egy újat használni, mely alkalmazás fejlesztésére sokkal megfelelőbb lenne. A vastag kliens alkalmazásfejlesztés esetén azonban a képernyőket tényleg WYSIWYG módon össze lehet dobálni (nem is használunk mockup-okat, drótvázakat, a képernyőket egyből a cél keretrendszerben állítjuk elő), a régóta bizonyított observer tervezési minta (, és az ebből továbbfejlődő eseménykezelés, stb.), valamint az MVC modell is nagyon hatékonyan működik. (Nem véletlen az sem, hogy a legtöbb tervezési mintára itt lehet szép példákat hozni.) Látszik ez abból is, hogy az összes webes keretrendszer próbálja ezt alkalmazni, bár nem sikerülhet nekik, hiszen az alatta lévő http szabvány ezt majdhogynem ellehetetleníti. Szintén nagyon hatékony a komponensekből való építkezés is, itt tényleg megvalósítható könnyen az újrafelhasználás, valamint a személyre szabás is. Ezeknek az elvnek webes környezetben talán legjobban a JSF próbál megfelelni, de az abban való fejlesztés sem olyan hatékony, mint a vastag kliens környezetben. És akkor ne is beszéljünk arról, hogy a fejlesztés mennyivel kényelmesebb, mennyivel gyorsabbak az iterációk, hiszen nem kell környezetet felépíteni, nincs szükség alkalmazásszerverre. Egy bonyolultabb alkalmazásnak is pár másodperc alatt indulni kell. Érdemes webes projekt után átülni kicsit egy vastag klienses projektbe, sokkal gördülékenyebb, magától értetődőbb. És nincs szükség annyi technológia, protokoll, szabvány ismeretére sem.&lt;/p&gt;

&lt;p&gt;Persze, vannak hátrányai is. Egyrészt a fentebb említett telepítési problémák, melyek bizonyos környezetekben egyszerűen kizárják a vastag klienses alkalmazás használatát. Azért ne legyenek téveszméink, ilyen problémák webes környezetben is adódhatnak, különböző böngésző inkompatibilitások, bezavaró plugin-ek, elkonfigurált tűzfalak, stb. Másik a platformfüggetlenség. Ha Java alapú technológiákat választunk, akkor ezzel sem lesz annyi problémánk, mint régen, amikor azért tényleg másképp néztek ki az alkalmazások különböző környezetekben. Amit fel szoktak hozni érvként, tipikusan a Swing ellen, hogy mivel pehelysúlyú komponenseket használ (pont az előbb említett platformfüggetlenség miatt), lassú lehet a megjelenítés, hiszen szoftveresen rajzol, és nem az operációs rendszer (ablakozó rendszer) beépített komponenseit használja az egységes megjelenítés érdekében. A JDK utóbbi verzióiban azonban olyan szintű optimalizációkat hajtottak végre, hogy azért ez már kevésbé érezhető.&lt;p&gt;

&lt;p&gt;A legnagyobb ellenérzés a Swing-gel kapcsolatban történeti okok miatt van. Egyrészt igen, tényleg rossz volt, lassú, és kevésbé platform független. A másik, hogy sokan azt gondolták, hogy minden fajta tudás, előképzettség nélkül neki lehet ülni benne fejleszteni, akár egy Borland Delphi alkalmazást. Sok Swing fejlesztőnek fogalma sincs például a Swing szálkezeléséről. Ez a hozzáállás azonban Swing esetén nem megfelelő. Ahhoz, hogy jó alkalmazásokat írjunk, igenis magas fokú előképzettség kell. Meg kell érteni az MVC modellt (annak is speciális válfaját, hiszen a Swing esetén a kontroller és a nézet össze van nőve), az eseménykezelést (azok fajtáit), a szálkezelést (EDT - event dispatcher thread, 6-os Java-ban megjelent SwingWorker), a kirajzolás folyamatát, a double bufferinget, stb. Ezek hiányában olyan alkalmazások kerülnek ki, melyek gyakran lefagynak, nem válaszolnak a felhasználónak. És nem utolsó sorban a leglényegtelenebb, vagy mégis a legfontosabb a megjelenés. Egyrészt a Swinges komponensek egy időben rettentő rondák voltak, valamint álláspontom szerint a programozóknak csak kis részét szabad az interfész tervezéséhez engedni. Swing esetén nincs ez így, általában a fejlesztők készítik teljes egészében a felhasználói interfészt. Webes környezetben szerencsére ez hamarabb elvált. Igen, és ennek eredménye az volt, hogy a Swing-es interfészek egyszerűen rondák voltak.&lt;/p&gt;

&lt;p&gt;A vastag kliens megvalósításakor azonban már nem elegendő a Swing használata, mely a Java része. Egy ideje nem nagyon fejlesztik, rengeteg komponens hiányzik belőle, és ennek használatával felépíteni egy alkalmazást, hatalmas munka. Jelenleg a Java világban két versenyző van, a &lt;a href="http://netbeans.org/features/platform/"&gt;NetBeans Platform&lt;/a&gt;, valamint az &lt;a href="http://wiki.eclipse.org/index.php/Rich_Client_Platform"&gt;Eclipse Rich Client Platform&lt;/a&gt;. Amint valaki szembesül azzal, hogy vastag kliens alkalmazást fejlesztünk, azonnal arról akar meggyőzni, hogy ezt Eclipse platformon tegyük. Attól függetlenül, hogy az Eclipse RCP-t ismeri-e vagy sem, csupán arra alapozva, hogy az ő kedvenc IDE-je az Eclipse.&lt;/p&gt;

&lt;p&gt;Úgy látszik, ezen a területen mindig ellenállásba ütközöm, és mindig meg kell magyaráznom a döntéseimet. És mindenki tud hozzászólni, függetlenül attól, hogy kizárólag vékony klienses alkalmazásokat fejlesztett. Like-olj, ha idáig eljutottál, és látsz jövőt a Java alapú vastag kliens alkalmazás fejlesztésében.&lt;/p&gt;

&lt;p&gt;Természetesen összehasonlítottuk a két platformot, és arra jutottunk, hogy számunkra a NetBeans Platform használata célravezetőbb. Kerestünk NetBeans Platform fejlesztőt is, és kiderült, hogy sokan nem is ismerik a NetBeans IDE és a NetBeans API közötti különbséget, sok olyan életrajzot kaptunk, amiben az volt leírva, hogy fejlesztett NetBeans-szel. A NetBeans Platform egy keretrendszer vastag klienses alkalmazások fejlesztésére, melynek egyik alkalmazási módja a NetBeans IDE, mely egy Java fejlesztőeszköz. De ezen kívül &lt;a href="http://platform.netbeans.org/screenshots.html"&gt;rengeteg más alkalmazás&lt;/a&gt; is létezik felette. Persze a dolog pikantériája, hogy a Platform is Java-ban íródott, és NetBeans alkalmazást (valamint plugin-t is) NetBeans IDE-vel lehet fejleszteni. És most következzenek az érvek, amiért NetBeans mellett döntöttünk.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fejlesztés szempontjából szerintem mindegy, hogy ki mit választ, egy idő után mindkettőben ugyanazt a fejlesztői hatékonyságot el lehet érni. Tapasztalatom szerint a Eclipse-szel nagyobb munkával, de kényelmesebb környezetet lehet összehozni, mindent a saját, egyéni ízlésünkre igazítva. Rengeteg plugin közül válogathatunk. A NetBeans ezzel szemben nem ad akkora mozgásteret, de ha kicsit kisebbek az igényeink, egy alap telepítéssel mindenhez hozzájuthatunk, nem nekünk kell a pluginek között válogatni. Alapban támogatja a Maven-t, Subersion-t, Mercurial-t, Tomcat-et, és van benne properties fájl szerkesztő (megfelelő automatikus native2ascii kódolással), vizuális szerkesztő. Én inkább az előrecsomagolt megoldásokat szeretem, minthogy nekem kelljen összerakosgatni, ezért a NetBeans ebből a szempontból jobban tetszik, de ez egy szubjektív álláspont. A vizuális szerkesztővel nem nagyon lehet vitatkozni, az Eclipse-nél nincs ilyen, mely kellően egyszerű, könnyen használható és ingyenes lenne, mint a NetBeans Matisse felülete. Hallottam projektről, ahol a képernyőket NetBeans-ben szerkesztették, a fejlesztést Eclipse-ben végezték.&lt;/li&gt;
&lt;li&gt;Az Eclipse az SWT könyvtárat használja, mely saját elemeket, saját modellt alkalmaz. Ennek szükségességét azzal magyarázza, hogy a Swing a pehelysúlyú komponensek miatt lassú, az SWT komponensei natív kódrészleteket is tartalmaznak, így különböző operációs rendszerekre különböző natív komponenseket is telepíteni kell. Egyrészt a modern JVM-eken már nem tapasztalható különbség, érdemes összehasonlítani a NetBeans és Eclipse legújabb verzióit (!!!), számottevő eltérés nincs. Másrészt a projektben résztvevők nálunk masszív Swing tudással rendelkeztek, így felesleges lett volna egy újabb technológiát megtanulni, mely nem hoz semmi előnyt.&lt;/li&gt;
&lt;li&gt;Az Eclipse a modularizációra az OSGi de facto szabványt használja, annak az Equinox implementációját. Nemrég &lt;a href="http://www.theserverside.com/news/2240037102/OSGi-Not-Easy-Enough-to-Use-Not-as-Productive-as-it-Should-Be"&gt;jelent meg&lt;/a&gt; egy interjú Rod Johnsonnal (Spring Framework alapítója és vezetője, író), melyben azt állítja, hogy az OSGi egyrészt nem elég egyszerű, és nem elég produktív. Amire ráláttam projektre, pont ez derült ki, hogy ahelyett, hogy ez egy transzparens réteget biztosítana, elég sok problémát hoz be. A NetBeans modularizációja sokkal egyszerűbb, abszolút fájdalommentesen használható, és épít a Java 6-ban bevezetett szabványos JDK 6 ServiceLoader mechanizmusra. Alapjában véve elmondható, hogy a NetBeans szabványos, JDK-ban lévő megoldásokat próbál alkalmazni, pl. naplózásra is a Java Logging API-t. Melyek lehet, hogy nem a legszofisztikáltabb megoldások, de kipróbált, és sokak által ismert eszközök. Amúgy aki nem tud elszakadni az OSGi-tól, NetBeans-ben is használhatja, erről egy &lt;a href="http://platform.netbeans.org/tutorials/nbm-osgi-quickstart.html"&gt;tutorial&lt;/a&gt; is van.&lt;/li&gt;
&lt;li&gt;Ezen kívül a NetBeans eszméletlen sok &lt;a href="http://netbeans.org/features/platform/all-docs.html"&gt;dokumentációval&lt;/a&gt; rendelkezik, valamint egy &lt;a href="http://platform.netbeans.org/tutorials/nbm-10-top-apis.html"&gt;tíz videóból álló sorozat&lt;/a&gt;, egyenként 30-40 percesek, is bevezet a legfontosabb fogalmakba, mely alapján el lehet indulni.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Egy dolog azonban kiderült, ami hátránya a NetBeans Platformnak. Nagyon nehéz NetBeans Platformos embert találni, Eclipse RCP fejlesztőt talán egyszerűbb.&lt;/p&gt;

&lt;p&gt;Nézzük, hogy mik azok, melyet a NetBeans biztosít a Swing-en felül, mely megkönnyíti a vastag kliens fejlesztést. Csak az érdekesebbeket emelem ki, az összeset a &lt;a href="http://bits.netbeans.org/dev/javadoc/"&gt;JavaDoc-ban&lt;/a&gt; lehet megtalálni.&lt;/p&gt;

&lt;a rel="lightbox" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/-CF2G4L88bE0/Tg9jDtJt_PI/AAAAAAAAG-U/f94Uygxh4iQ/s1600/netbeans-platform-architecture.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 178px;" src="http://1.bp.blogspot.com/-CF2G4L88bE0/Tg9jDtJt_PI/AAAAAAAAG-U/f94Uygxh4iQ/s320/netbeans-platform-architecture.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5624823374920154354" /&gt;&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Module System API: Modulok kezelése, függőségek (tranzitív is), verziózás, automatikus frissítés, életciklus kezelés.&lt;/li&gt;
&lt;li&gt;Lookup API: komponensek közötti laza kapcsolat megvalósítására. Valójában ez egy pehelysúlyú konténer, interfész alapján lehet a példányokat előhívni. Lehet a szolgáltatásokat deklaratív módon (XML-ben megadva), és programozottan is bejegyezni. Van globális tér, és lehet komponensenként is, lokálisan is Lookup-ot használni. Dependency injection nincs.&lt;/li&gt;
&lt;li&gt;Actions API: események definiálására és kezelésére, melyek forrása lehet menüpont, billentyűkombináció, toolbar, felugró menü, stb.&lt;/li&gt;
&lt;li&gt;Window System API, Docking Framework és Tab Control: klasszikus ablakozás, ismert mindenkinek, akár NetBeans-t, akár Eclipse-t használ.&lt;/li&gt;
&lt;li&gt;Dialog, Wizard, MultiView: dialógusablakok, varázslók és több nézettel rendelkező ablakok definiálására (pl. vizuális és XML forrás megjelenítés). Érdekes, hogy amikor ezeket definiálunk, sosem ablakokban, hanem panelekben kell gondolkozni. A hozzá tartozó ablakot és gombokat a NetBeans Platform köré teszi, és általában ad egy callback-et, melyen szabályozni tudjuk az ablak viselkedését, pl. az Ok gomb inaktívvá tételét.&lt;/li&gt;
&lt;li&gt;System Filesystem API, MIME Lookup API, Nodes API és Explorer and Property Sheet API, Navigator API: állományok kezelése, valamint állományok betöltése és hozzá tartozó modell generálása. A NetBeans sok komponense un. Node-okkal dolgozik, melyeket a modell elemeihez lehet rendelni. Pl. egy XML állomány esetén a Node-ok az XML tag-ek, vagy egy Java forráskód esetén a forráskód részei, mint osztály, attribútum, metódus, stb. Ezekből akár egy fa struktúrát is fe lehet építeni. Sok komponens ezeket a Node-okat jeleníti meg.&lt;/li&gt;
&lt;li&gt;Search és Quick Search API: keresések implementálásához.&lt;/li&gt;
&lt;li&gt;Editor API: szerkesztők implementálásához használható API, mely támogatja az IDE-kben ismert funkciókat, mint kódkiegészítés, kódszínezés, code folding, kód sablonok, automatikus behúzás, stb.&lt;/li&gt;
&lt;li&gt;Progress API, Task List API, Output Window, Favorites: olyan UI elemekhez való hozzáféréshez, mint progress bar, tennivalók ablak, konzol ablak, kedvencek.&lt;/li&gt;
&lt;li&gt;Options API: beállítások kezelésére.&lt;/li&gt;
&lt;li&gt;JavaHelp Integration API: szabványos JavaHelp formátumot támogatja a NetBeans Platform, ennek integrációjára való ez az API.&lt;/li&gt;
&lt;li&gt;Print API: nyomtatáshoz.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://platform.netbeans.org/graph/"&gt;Visual Library API&lt;/a&gt;: egy NetBeans-en kívül is használható API, mely gráfok grafikus megjelenítésre szolgál. Widget-eket (különböző grafikus elemek), és közöttük lévő Edge-eket (élek) definiál, és jelenít meg egy koordináta rendszerben, pixel pontosan. Támogatja a nagyíthatóságot, eseménykezelést, képként exportálást, stb. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A Platform ezen kívül támogatja a több nyelvű interfészek fejlesztését (I18N), Undo/Redo funkcionalitást, aszinkron/háttérfolyamatok futtatását.&lt;/p&gt;

&lt;p&gt;Ami számomra a legérdekesebb volt, nem támogatja a felhasználó által bevitt adatok egységes ellenőrzését (validáció). Először a klasszikus megközelítést választottam, hogy hibás érték esetén dialógusablakot kap a felhasználó. A NetBeans azonban ezt nem támogatja, nagyon macerás a körbeprogramozása, inkább az a megoldás, hogy a felhasználónak ne engedjünk hibás értéket bevinni, vagy ha bevitte jelöljük meg, és ne engedjük el az ablakról. A Maven projekt létrehozásakor vettem észre, hogyha hibás értéket írtam be egy beviteli mezőbe, a mező más színre váltott, felkiáltójel ikon jelent meg benne, és alul is kiírásra került a hibaüzenet, valamint az Ok gomb letiltásra került. A forrásból jöttem rá, hogy a &lt;a href="http://kenai.com/projects/simplevalidation/pages/Home"&gt;Simple Validation API&lt;/a&gt;-t használja, melyet NetBeans-en kívül is lehet használni bármilyen Swing-es alkalmazásban. Ezzel kapcsolatban arra kell nagyon vigyázni, hogy csak régi verzió letölthető, kizárólag a forrásból (Subversion checkout után) fordított bináris a használható. Amúgy is gyakran használatos módszer, hogy hiába vannak nagyon szép és részletes dokumentációk, sok dolgot úgy lehet a legegyszerűbben kitalálni, hogy keresni kell egy hasonló funkciót a NetBeans IDE-ben, és annak kell megnézni a forrását.&lt;/p&gt;

&lt;a rel="lightbox" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/-Esw6mur-AIM/Tg9jyGeuxkI/AAAAAAAAG-k/1_ISe_mqoUU/s1600/simple_validation.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 294px;" src="http://4.bp.blogspot.com/-Esw6mur-AIM/Tg9jyGeuxkI/AAAAAAAAG-k/1_ISe_mqoUU/s320/simple_validation.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5624824171993155138" /&gt;&lt;/a&gt;

&lt;p&gt;A NetBeans Platform támogatja a Maven eszközt, az artifact-ok benne vannak a saját repository-ban (http://bits.netbeans.org/maven2/), így standard módon build-elhető, ehhez a &lt;a href="http://mojo.codehaus.org/nbm-maven-plugin/"&gt;NetBeans Modules plugin&lt;/a&gt;-t használja. Automatikus teszt eseteket is lehet írni, erre is van támogatás, és ezáltal mi be is kötöttük continuous integration rendszerbe. A fejlesztés nagyon egyszerű, hiszen sok dolgot varázslóval lehet létrehozni, és a NetBeans legenerálja nekünk a szükséges konfigurációs és forrás állományokat (érdemes megnézegetni, pl. Subversion diff-fel, hogy mit csinál, általában megfelelő, de lehet rajta szépíteni).&lt;/p&gt;

&lt;p&gt;A &lt;a href="http://blogs.oracle.com/geertjan/entry/new_cool_in_netbeans_platform"&gt;7.0-ás NetBeans Platform&lt;/a&gt; újdonsága, hogy a Platform is elkezdi kihasználni a Java 5 újdonságait, pl. több dolgot (lokalizáció, action-ök, mime type) is meg lehet adni annotációban, nem kell XML konfigurációs állományban.&lt;/p&gt;

&lt;p&gt;Az egyedüli dolog eddig, ami nem tetszik, az a paraméterek átadása különböző komponensek között. Nem definit, hogy mit, hol és hogyan kell átadni a következő lehetőségek közül: konstruktor, setter metódus, valamiféle környezeti objektum, callback, általános Map-ban, valamilyen Context/Environment objektumban, Lookup-pal, stb. Gyakran előfordul a tyúk és a tojás esete is, amikor két komponensnek egymásra kell hivatkoznia, de a másodikat nem adhatom át az első konstruktorának, hiszen még nem lett példányosítva.&lt;/p&gt;

&lt;p&gt;A fejlesztéshez a legnagyobb segítséget a The Definitive Guide to NetBeans Platform könyv adja. Minden egyes témába csak egy rövidebb bevezetőt ír, amin el lehet indulni, néhány kódrészlettel. Nem megy bele mélyen a témákba, erre nincs is szükség, a többi részt már bőven ki lehet nézni az API-ból, vagy a forráskódból.&lt;/p&gt;

&lt;a rel="lightbox" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/-yNQDGWiQ2OI/Tg9jjzT-FLI/AAAAAAAAG-c/oYL7KmtcuOg/s1600/netbeans_book.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 241px; height: 320px;" src="http://3.bp.blogspot.com/-yNQDGWiQ2OI/Tg9jjzT-FLI/AAAAAAAAG-c/oYL7KmtcuOg/s320/netbeans_book.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5624823926329578674" /&gt;&lt;/a&gt;

&lt;p&gt;Javaslom mindenkinek, hogy akinek lehetősége van, próbáljon részt venni vastag kliens fejlesztésben is, utána a webes alkalmazásokat is másik oldalról lehet nézni, hiszen teljesen más problémák jönnek itt elő, ami ott egyszerű, itt bonyolult, és fordítva. Rengeteg ötletet lehet meríteni. Valamint a webes programozás után ez egy élmény, akár a fejlesztés sebességében, akár az elegáns megoldások terén. Azonban ne várjuk azt, hogy pár óra alatt belerázódunk, itt is van egy elég komoly felkészülési idő.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/535551803739667071/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html#comment-form' title='17 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/535551803739667071'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/535551803739667071'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html' title='Vastag kliens Java-ban? NetBeans Platform'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://1.bp.blogspot.com/-CF2G4L88bE0/Tg9jDtJt_PI/AAAAAAAAG-U/f94Uygxh4iQ/s72-c/netbeans-platform-architecture.png' height='72' width='72'/><thr:total>17</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3752345250697097633</id><published>2011-06-14T00:00:00.005+02:00</published><updated>2011-06-14T11:25:33.302+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><title type='text'>Második nyelv: Python?</title><content type='html'>&lt;p&gt;Remélem ezzel a cikkel is sikerül annyi gondolatot megmozgatni, mint az előbbivel, ha valami eszetekbe jut, ne legyetek rest hozzászólni!&lt;/p&gt;

&lt;p&gt;Mostanában divat második/sokadik nyelvet keresni, egy kicsit kiszakadni a mindennapi munka egyhangúságából, és egy másik világot megismerni, egy másik programozási nyelvben is jártasságot szerezni.&lt;/p&gt;

&lt;p&gt;Bár sokan azt mondják, hogy ha megtanulsz egy programozási nyelvet, utána a többi gyerekjáték, azért ezzel nem teljesen értek egyet. Egyrészt igaz lehet ez imperatív nyelveknél, de egy funkcionális vagy logikai nyelv már távolabb áll ettől a világtól, érdemes rápillantani a Lispre. Másrészt nem a nyelvben való jártasság, ami a programozó értékét adja, hanem a köré épülő platform, "ecosystem" ismerete. Megtanulni a nyelv szintaktikáját egy dolog, de ismerni az elterjedt keretrendszereket, könyvtárakat, best practice-eket, konvenciókat, eszközöket. Egy másik nyelv megismerése a többi nyelv használatában is fejleszt, ugyanis lehet új és hasznos ötletekkel találkozni, melyeket újra lehet használni.&lt;/p&gt;

&lt;p&gt;Én is elindultam keresni, és a Python mellett döntöttem, olvassátok, miért. A bejegyzésben egy nyelv professzionális elsajátítása mellett érvelek, és nem egyszerű felhasználásról, ami elkerülhetetlen bizonyos esetekben (pl. mennyien használnak JavaScript-et, PL/SQL-t annak alapos ismerete nélkül).&lt;/p&gt;

&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/-nV-DYJYLDMs/TfaMUblTMUI/AAAAAAAAG64/ZZUf8o97ALw/s1600/python-logo-master-v3-TM.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 108px;" src="http://1.bp.blogspot.com/-nV-DYJYLDMs/TfaMUblTMUI/AAAAAAAAG64/ZZUf8o97ALw/s320/python-logo-master-v3-TM.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5617831867820749122" /&gt;&lt;/a&gt;

&lt;p&gt;Semmiképp nem akartam nagyon elrugaszkodni, egy imperatív nyelvet akartam választani. Először egy olyan nyelvet akartam választani, melyet sokan használnak, a munkám során is gyakran találkozok vele, és az álláshirdetésekben is gyakran szerepel. Szóba jöttek az előbb említett nyelvek, a JavaScript, PL/SQL, valamint a PHP is. Ezeket valamilyen szinten ismerni kell, miért ne ismerje meg az ember a lehető legmélyebb szinten. A PL/SQL-lel (Procedural Language extensions to the Structured Query Language) kezdtem. Egy adatorientált imperatív nyelvről van szó (Adán alapul), mely Oracle adatbázisban fut (embedded - viccesen platformfüggetlennek nevezik, hiszen amelyik platformra van Oracle telepítve, ott megy), és emiatt erősen gyártófüggő. Mivel alapvetően adatokon dolgozunk, gyakran jöhet jól, egy adatokhoz közelibb nyelv. Én hiszek abba a modellbe, hogy ne vigyünk fel mindent Java szintre, amit meg lehet egyszerűbben oldani adatbázisban, miért ne. Felesleges bizonyos dolgokat megjáratni a rétegek között. Tipikus ilyen példa a nagy adatmennyiséggel dolgozó riportok. A nyelv sajnos nem adta meg azt, amit vártam tőle, hiányzott a szépség, az elegáns megoldások. Az alap szinttől a professzionális szintig nehéz út vezet, mely nem olyan látványos, és sokszor nincs is igazán szükség az emelt szintű dolgokra, és feltételezem, hogy a látókörömet sem tágítja annyira. Az előnye a hátránya, kizárólag adatmanipulációra használatos.&lt;/p&gt;

&lt;p&gt;A JavaScript fénykorát éli, megvan benne minden, amire a programozónak szüksége lehet, és úton útfélen találkozik vele az ember. Bár szerver oldalon is használható, azért mégis kliens oldalon jellemző. Egy erősen JavaScript/AJAX megoldásokat használó projekt után ezt is elvetettem. Igaz, hogy vonzóak a nyelv képességei, és az, hogy egy oldal újratöltéssel azonnal tesztelhető, mégis úgy találtam, hogy a JavaScript legmélyebb szintű megtanulása a User Interface-hez köt, specializálódsz, és innentől kellenek a design, tipográfiai és usability ismeretek is. Én ebbe az irányba nem akartam elmenni, én ezt külön szakmának tartom, és alapvető hibának, ha a programozókkal akarnak felhasználói felületet terveztetni (tisztelet a kivételnek).&lt;/p&gt;

&lt;p&gt;A PHP-n kellett a legtöbbet gondolkozni, hogy mivel is érveljek ellene. Az alapvető unszimpátia megvolt, de nehéz ezt objektív érvekkel alátámasztani. A Java nagy kihívója webes felületek implementálására, de lazasága miatt nem köti meg annyira meg az ember kezét (értsd: könnyebb benne gányolni). Feltehetőleg ezért nem ismerik el annyira pl. bankos környezetben, és ezért tartják még mindig a Java-t alkalmasabbnak üzleti logika megfogalmazására. Megtanulásával ott vagyok, ahol a part szakad, egy újabb technológia, mellyel kb. ugyanúgy és ugyanazt lehet kihozni webes alkalmazások terén, mint Java használatával. Szerintem ugyanolyan kvalitású fejlesztők ugyanúgy használják jól vagy rosszul mind a kettőt. A .NET-tel kapcsolatban is azt érzem, hogy szimmetrikus párja a Java-nak, szemléletbeli váltást nem hoz, sok pluszt nem nyújt.&lt;/p&gt;

&lt;p&gt;A C, C++ mindig is az alacsony szintű programozásra volt alkalmas (értsd jól, pl. kernel, beágyazott rendszerek fejlesztése, amiről tudjuk, hogy az egyik legnagyobb szaktudást igényli), ebbe az irányba szintén nem akartam elmozdulni.&lt;/p&gt;

&lt;p&gt;Így kilőttem az első követelményt, hogy lehetőleg olyan nyelvet válasszak, ami nagyon elterjedt, és divatos, és nem utolsó sorban keresett. A második legfontosabb követelmény az volt, ha nem is annyira érték emelő, legalább a mindennapi munkámban bizonyuljon hasznosnak. Egyrészt gyakran kell ilyen-olyan kisebb feladatokat megoldani, melyekhez felesleges az IDE-t elindítani, és Java alkalmazást írni rá, tipikusan shell script-ekkel megoldható problémák. Amikkel ugye az a baj, hogy nem platformfüggetlenek, persze van pár jó Windows port, Cygwin pl., melyet aktívan használok. Valamint, ami ehhez is kapcsolódik, hogy bizonyos feladatok megoldásában nagyon lassúnak találom a Java fejlesztési ciklusát, kódolás - fordítás - futtatás, gyakran az effektív munkától veszi el a kapacitásokat, legrosszabb tapasztalatom ezen belül is a portál keretrendszerekkel való fejlesztés bizonyult, ahol több perc kellett a keretrendszer elindításához.&lt;/p&gt;

&lt;p&gt;Így adott is, hogy a script nyelvek közül választottam, méghozzá a Python nyelvet. A nyelv fejlesztése 1989-ben kezdték el fejleszteni, neve a Monty Python’s Flying Circus-ből ered. A nyelvet Guido van Rossum alkotta azzal a céllal, hogy eszközt teremtsen olyanoknak, akik érdeklődnek a programozás iránt, és jó eszközt biztosítson olyanoknak, akik szeretnek és tudnak programozni. Engem az ragadott meg, hogy egy Python script ránézésre megérthető, annyira tiszta a szintaxisa, olyan érzésem volt a nyelvvel való ismerkedés közben, hogyha én nyelvet alkotnék, én is mindent így csinálnék. (Szemben mondjuk egy Perl programmal.)&lt;/p&gt;

&lt;p&gt;A Python általános célú nyelv, interpretált, interaktív, platform független és ingyenes. Nem szükséges objektum orientáltan programozni, de megvan rá a lehetőség, támogatja a többszörös öröklődést, és az operátor overloading-ot.&lt;/p&gt;

&lt;p&gt;Mivel oktatok olyan szemmel is néztem, hogy milyen gyorsan tanulható, és mennyire alkalmas oktatásra. Be kell valljam, sokkal alkalmasabb, mint a Java. Mivel a program struktúrája a behúzáson alapul (igen!), az ifjú fejlesztőket rászoktatja a formázásra, és nagyon könnyen össze tudják kötni a formátumot a struktúrával. Java-ban gyakran látom, hogy küzdenek a szintaktikával, közben nincs idejük a kódot formázni (bár ebben az IDE is segít), és szétesik nekik. Valamint aki oktatott már Java-t, és a változó deklaráció oktatásánál megkérdezi a hallgató, hogy mi az a public static void main, és miért kell kiírni, az tudja, mire gondolok.&lt;/p&gt;

&lt;p&gt;A könnyű megértést az is bizonyítja, hogy egy projektben dokumentum generálásra vezettem be, és anélkül, hogy még bárkinek is részleteztem volna, másnapra többen lemásolták és adaptálták a megfelelő script-eket kizárólag a script és a Google alapján, és mindenkinek tetszett alapvetően.&lt;/p&gt;

&lt;p&gt;Gyakran kell fájlokon matató segédprogramokat írnom, pl. napló állományok elemzésére, amire sosem találtam általános eszközt, a grep/sed párosításból kell általában kihoznom a megoldásokat. Ahhoz, hogy Java-val nyúljunk a problémához, ahhoz egyrészt osztályt, main metódust kell deklarálnunk, majd jön a rémálom, a Stream-ek, Reader-ek használata, ami ugyan koncepció szinten nagyon szép, a decorator design pattern egy remek megvalósítása, de gyakorlatban sajnos használhatatlan. Szóval jó, ha egyszerűen lehet állományokat kezelni.&lt;/p&gt;

&lt;p&gt;Ugyanúgy ilyen jellegű tool-oknál nem hátrány, ha nem kell objektum orientáltan fejleszteni, valamint nem baj, hogy dinamikus típusú, azaz nem kell előre definiálni a típusokat. Nem kell memóriát foglalgatnunk, felszabadítanunk, automatikusan kezeli az erőforrásokat. Nyelvi szinten támogatja a listákat, szótárakat, ami szintén tömör és jól olvasható kódot eredményez. Hibakezelése kivételkezelésen alapszik, mely szintén a kód tisztaságán segít, hiszen tisztán elválik a hibaág. Azért mégsem enged mindent, erős típusosság jellemzi.&lt;/p&gt;

&lt;p&gt;Dinamikus, azaz Python kifejezéseket és utasításokat ki lehet értékeltetni. Ortogonális, azaz kevés fogalommal nagy számú konstrukció írható le, melytől szintén a tanulási görbe lesz meredekebb. Reflektív, azaz futásidőben lehet az osztályokon matatni és introspektív, azaz számos eszköz, mint a debugger és a profiler is, Pythonban implementált.&lt;/p&gt;

&lt;p&gt;A Python abban hasonlít a Java-hoz hogy hatalmas osztálykönyvtár adott hozzá, csak néhány a sok közül: regexp, diff, io, objektum szerializáció, tömörítés, CSV feldolgozás, hash függvények és kriptográfiai funkciók, naplózás, többszálúság, hálózatkezelés és internetes protokollok (socket, ssl, e-mail, json, http kliens és szerver, ftp), formátumok (xml, html), I18N, GUI, stb.&lt;/p&gt;

&lt;p&gt;Néhány kódrészlet, futtatható, ha bemásolod egy állományba és "python [fájlnév.py]":&lt;/p&gt;

&lt;pre class="brush: python"&gt;# Hello World
print "Hello World"

# Listán iterálás
for t in ["a", "b"]:
 print t

# Egy állományban a # karakterrel kezdődő sorok eltávolítása
import fileinput, re

for s in fileinput.input(inplace = 1):
   print re.sub("#.*", "", s),

# Két változó értékének megcserélése
a, b = b, a

# Állomány tartalmának kiírása
f = open("file.txt")
print (f.read())

# Függvény dokumentációjának definiálása és kiírása
def add(a, b):
 "Két szám összeadása"
 return a + b

print add.__doc__

# Egy weboldal letöltése, és a linkek kigyűjtése
import httplib, re

conn = httplib.HTTPConnection("jtechlog.blogspot.com")
conn.request("GET", "/")
r = conn.getresponse()
d = r.read()
for l in re.findall("&amp;lt;a href=\"([^\"]+)\"", d):
 print l

# coding=UTF-8

print "árvíztűrő tükörfúrógép".decode("UTF-8")

# XML beolvasása
import xml.dom.minidom

document = """
&amp;lt;books&amp;gt;
&amp;lt;book title="Beginning Python From Novice to Professional" /&amp;gt;
&amp;lt;/books&amp;gt;
"""
dom = xml.dom.minidom.parseString(document)
for book in dom.getElementsByTagName("book"):
 print book.getAttribute("title")
&lt;/pre&gt;

&lt;p&gt;Ha kedvet kaptál, lájkolj!&lt;/p&gt;

&lt;p&gt;Azért nem szabad letagadni, hogy azért álltam egyből pozitívan a nyelvhez, mert létezik a Jython, ami egy JVM-en futó Python implementáció, gyakorlatilag Java bytekódot állít elő. Emiatt azonban könnyen integrálható a Java-hoz, minden Java könyvtárat tudunk Python-ból is használni.&lt;/p&gt;

&lt;p&gt;Nézzünk is egy példát, méghozzá a QDox Java 3rd party library-t, mely a Java forráskódot tudja elemezni, és API-t biztosít annak bejárására. Egy könyvtárban lévő forráskódok beolvasása, majd az osztályok és azok metódusainak bejárása a következőképp történik Java-ban:&lt;/p&gt;

&lt;pre class="brush: java"&gt;import com.thoughtworks.qdox.*;
import com.thoughtworks.qdox.model.*;
import java.io.File;

public class QDoxSample {

public static void main(String args[]) {
 JavaDocBuilder builder = new JavaDocBuilder();
 builder.addSourceTree(new File(args[0]));
 for (JavaClass clazz: builder.getClasses()) {
   System.out.println("Class: " + clazz.getName());
   for (JavaMethod method: clazz.getMethods()) {
     System.out.println("Method: " + method.getName());
   }
 }
}

}
&lt;/pre&gt;

Ugyanez Python-ban (Jython-ban), figyeljük, milyen elegánsan történik a külső függőség használata:

&lt;pre class="brush: python"&gt;import sys

sys.path.append("qdox-1.12.jar")

from com.thoughtworks.qdox import JavaDocBuilder
from java.io import File

builder = JavaDocBuilder()
builder.addSourceTree(File(sys.argv[1]))
for clazz in builder.getClasses():
  print "Class: " + clazz.getName()
  for method in clazz.getMethods():
    print "Method: " + method.getName()
&lt;/pre&gt;
 
&lt;p&gt;Mivel nem kell mindig fordítgatnunk, hanem azonnal futtatható a script-ünk, tényleg gyorsabb lehet a fejlesztés. Pont emiatt, ha valamit gyorsan ki kell próbálni Java-ban, akkor is a Jython-t veszem elő, és nem egy Java-s IDE-t.&lt;/p&gt;

&lt;p&gt;A Python azért is lehet ismerős, mert a Google a &lt;a href="http://code.google.com/intl/hu-HU/appengine/docs/python/gettingstarted/"&gt;Google App Engine-t Python-ban&lt;/a&gt; és Java-ban bocsájtja rendelkezésünkre. Ahhoz, hogy elkezdjünk fejleszteni, le kell tölteni a &lt;a href="http://code.google.com/intl/hu-HU/appengine/downloads.html"&gt;Google App Engine SDK for Python&lt;/a&gt; környezetet. Hozzunk létre egy állományt, mely kiírja standard kimenetre a szokásos üdvözlő szöveget.&lt;/p&gt;

print 'Content-Type: text/plain'
print ''
print 'Hello, world!'

&lt;p&gt;Ezt az SDK majd HTTP kérésre fogja meghívni, és a kimenetet HTTP válaszba írja vissza. Ehhez konfigurálnunk kell, hogy az összes HTTP kérést ez a script szolgálja ki:&lt;/p&gt;

&lt;pre&gt;application: helloworld
version: 1
runtime: python
api_version: 1

handlers:
- url: /.*
script: helloworld.py
&lt;/pre&gt;

&lt;p&gt;Ha elindítjuk az SDK-t, akkor a menüből a File/Add Existing Application-re kattintva válasszuk ki a script-et és a konfigurációs állományt tartalmazó könyvtárat. Az alkalmazást kiválasztva, a script-et a http://localhost:8080 címen ki is próbálhatjuk. Ha fel akarjuk tölteni a felhőbe, akkor az &lt;a href="https://appengine.google.com/"&gt;App Engine Administration Console-on&lt;/a&gt; létre kell hozni egy alkalmazást, adni neki egy nevet, melyet az előbbi konfig állományban is át kell írni. Az SDK-ban a Deploy gombot megnyomva máris próbálhatjuk az alkalmazásunkat a http://[alkalmazás neve].appspot.com címen.&lt;/p&gt;

&lt;a rel="lightbox" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/-HjYq-N6Kibo/TfaMdynwvlI/AAAAAAAAG7A/y8ozwCkWTJM/s1600/google-app-engine-python-sdk.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 228px;" src="http://4.bp.blogspot.com/-HjYq-N6Kibo/TfaMdynwvlI/AAAAAAAAG7A/y8ozwCkWTJM/s320/google-app-engine-python-sdk.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5617832028623912530" /&gt;&lt;/a&gt;

&lt;p&gt;Ugyanilyen egyszerű az ütemezés, valamint a hozzáférés a Datastore-hoz, Memcache-hez, stb.&lt;/p&gt;

&lt;p&gt;Ne értsetek félre, a Java továbbra is az elsődleges nyelv és platform, melyet használok, és javaslok, de a Python remek kiegészítő tud lenni a mindennapi munkában, hiszen általános célú nyelv, és bizonyos feladatokat könnyebben és gyorsabban lehet megvalósítani.&lt;/p&gt;

&lt;p&gt;Ti mit használtok Java-n kívül önszántatokból, és nem kötelező jelleggel, és miért?&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/3752345250697097633/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html#comment-form' title='20 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3752345250697097633'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3752345250697097633'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html' title='Második nyelv: Python?'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://1.bp.blogspot.com/-nV-DYJYLDMs/TfaMUblTMUI/AAAAAAAAG64/ZZUf8o97ALw/s72-c/python-logo-master-v3-TM.png' height='72' width='72'/><thr:total>20</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798</id><published>2011-05-11T23:06:00.002+02:00</published><updated>2011-05-11T23:18:26.028+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Módszertan'/><title type='text'>Miért ne fejlesszünk saját keretrendszert?</title><content type='html'>&lt;p&gt;Ahogy különböző cégeknél végzek tanácsadásokat, sok helyen látom, hogy saját keretrendszert fejlesztettek, fejlesztenek, döntenek a fejlesztése mellett. Én nem vagyok híve az ilyen jellegű saját megoldásoknak, és mivel sokszor kérdezik, és szóba kerül, leírom az ezzel kapcsolatos gondolataimat.&lt;/p&gt;

&lt;p&gt;Saját keretrendszer fejlesztésének több oka is lehet. Találkoztam több, mint tíz éves (igen, Java) rendszerekkel, ahol ilyent használnak még mindig. Ezen szoftverek abból az időből származnak, amikor még JDBC, Servlet API létezett, és nem volt egységes, kialakult irány, szabványok, kvázi szabványok. Nem volt objektum-relációs megfeleltetés, MVC webes keretrendszerek. Ebben az esetben természetesen elfogadható saját keretrendszer kifejlesztése, bár itt is erősen ajánlott haladni a korral, és ahol lehet, újabb, szabványosabb irányokba elmozdulni. Láttam Java 1.4-en beragadt projektet, régi alkalmazásszerver verziókhoz kötött rendszereket. Ilyenkor érdemes olyan keretrendszereket bevezetni, melyek nem tolakodóak (non-intrusive, azaz a kódot nem járják át az architektúrális elemek), és lépésenként bevezethetőek. Egyik projektünkbe pl. a Spring-et sikerült úgy bevezetni, hogy először csak a perzisztens rétegben, majd egyre felsőbb rétegekben, végül a felhasználói felület rétegben. Érdemes a maradvány kódokat szépen elkeríteni. Amennyiben a maradvány kódjaink nem is objektum orientáltak, használhatjuk az object wrapper megoldást, azaz a procedurális kódunkat körbevesszük egy szép, objektumorientált API-val. Ez alatt az implementációt később cserélhetjük. Barátunk ilyenkor a refactoring, amivel kapcsolatban sokan elfelejtik, hogy refactor közben nem módosítjuk a funkcionalitást. A funkcionalitás teljes megtartásával strukturáljuk át a kódunkat, hogy könnyebben átláthatóbb és továbbfejleszthetőbb legyen.&lt;/p&gt;

&lt;p&gt;Nagyon ritkán érdemes ilyenkor a teljes újraírás mellett dönteni. Nem lehet egy tíz éve fejlesztett rendszert pár hónap alatt újraírni. Kisebb lépésekben érdemes haladni. És közben viszont szerfelett mennyiségű tapasztalattal lehet gazdagodni.&lt;/p&gt;

&lt;p&gt;Másik indok az szokott lenni, hogy a megrendelőknek, vagy inkább a fejlesztőknek egyedi igényeik vannak. Ezt csak nagyon ritkán tudom elképzelni. Amennyiben egy architect kellő tapasztalattal és tudással rendelkezik, biztos, hogy a legtöbb problémára már látott valamilyen megoldást. Nem hiszem el, hogy 9 millió Java programozó, és a nem tudom mennyi egyéb programozó nem futott volna bele ugyanabba a problémába. Ez legtöbbször a fejlesztő csapat szűklátókörűségét bizonyítja. Vagy egyszerűen túl lelkesek, és szeretnék megvalósítani saját ötleteiket. Melyek gyanítom nem is annyira világmegváltóak, hogy ne lehessen azokat máshol megtalálni.&lt;/p&gt;

&lt;p&gt;Ennek kicsit finomabb változata, hogy ugyan tud a fejlesztő csapat arról, hogy vannak már létező eszközök, de nem felel meg mind az összes igénynek. Esetleg összehasonlító elemzést is végeztek, hogy melyik miért nem felel meg az igényeknek. Sajnos a legtöbbször már ismert a vágyott cél, hogy mit kell az elemzésnek kihoznia. Itt is el kell gondolkodni azon, hogy ne a tökéletességet keressük, hiszen nem biztos, hogy pont mi fogjuk azt elérni. Lehet, hogy együtt lehet élni egy eszköz hiányosságaival, ahelyett, hogy teljesen sajátot fejlesztenénk. És ha találunk egy igényeinkhez közel állót, miért ne szállhatnánk be a fejlesztésébe, vagy miért is ne tudnánk arról leágazni (, bár utóbbival is vigyázni kell, hiszen a leágazás után már elveszik az automatikus magasabb verzióra váltás lehetősége, és merge-öléssel találjuk szembe hamar magunkat - ez talán az elosztott verziókezelő rendszerek megjelenésével már kevésbé fájdalmas).&lt;/p&gt;

&lt;p&gt;A gyakori ügyfél igény az, hogy az alkalmazás minél testre szabhatóbb, minél jobban konfigurálhatóbb legyen, igen, programozás nélkül. Mikor ilyen igény merül fel, legyünk óvatosak. Hiszen mit akar az ügyfél? Azt, hogy fejlesztés nélkül újabb funkciókat tudjon maga megvalósítani. Itt már gyanút foghatunk, hiszen nem nekünk akar fizetni, hanem a problémáit maga szeretné megoldani. Azaz bizalmatlan, és ez nem biztos, hogy jó jel egy projekt elején. Egy általános eszköz fejlesztése feltehetően nagyobb költség, mintha a kívánt funkciókat, egyesével, saját keretrendszer nélkül kifejlesztetné. És sajnos sokszor láttam, hogy a személyre szabás túl absztrakt, túl technikai lett, így az ügyfél mégsem tudta használatba venni. Így ahelyett, hogy a programozók implementálták volna a funkciókat standard módon, valami saját eszközben kellett ezeket speciálisan megoldaniuk.&lt;/p&gt;

&lt;p&gt;És már el is jutottunk a 4GL, CASE és RAD eszközök világához. (Vigyázat, nem ugyanazt jelentik, csak ugyanarra a problémára szeretnének megoldást adni.) A programozókban mindig is megvolt az igény, a lustaság, hogy olyan eszközöket készítsenek, melyek saját és mások munkáját könnyítik, akár programot generáljanak. Lehessen "egérrel programozni", informatikai szaktudás nélkül. És valahogy mégis, ezek az eszközök mégsem hozták el a világmegváltást. Miért van az, hogy egy egyszerű programozási nyelv, melyhez csak parancssoros fordító volt, szövegszerkesztőben írtuk a kódot, le tudott taszítani a trónról olyan eszközöket, mint a Delphi, Oracle Forms, stb.? És most is születnek ilyen nyelvek, és megvan a létjogosultságuk, terjednek. Miért hisszük azt, hogy amibe a Borlandnak, Oraclenek beletört a bicskája, mi meg tudjuk valósítani? A nagy piros gombot, amit megnyomunk, és kiesik a szoftver?&lt;/p&gt;

&lt;p&gt;Véleményem szerint itt is látszik a ciklikusság, egyre jobban elkezdenek a nyelvek, platformok elmenni az irányba, hogy automatizálják a fejlesztést, és a végén mindig a süllyesztőben kötnek ki, és egy primitív, egyszerű eszköz veszi át a helyüket. Gondoljunk a Java ilyen irányú fejlesztéseire is, pl. VisualAge for Java, NetBeans ilyen irányú fejlesztései, stb.&lt;/p&gt;

&lt;p&gt;Itt érdemes megemlíteni a forward engineering, reverse engineering és ennek egyvelegét, a roundtrip engineeringet is. Vagy beszélhetünk a Model-driven architecture (MDA) megközelítésről is. A háttérben mindig valami kódgenerálás is áll. Ilyen projektet is gyakran láttam, és sosem tudott meggyőzni. Mi is próbálkoztunk ilyenekkel, de nem sikerült egyértelmű eredményeket elérni. A legtöbb esetben nagyon nehéz belőni a modellezés absztrakciós szintjét, amiből az alkalmazás vázát le lehet generálni, és az fejlesztéssel befejezni. Általában elmennek olyan irányba, hogy már mindent a modellbe akarnak leírni. Ezáltal egy programozási nyelvhez közeli, vagy bonyolultabb modellező nyelv sül ki belőle. A fejlesztőknek ez csak egy darabig izgalmas. Miért kell egy Java fejlesztőnek diagramot rajzolnia? Ezzel kapcsolatban tetszik az UMLet álláspontja. Egy modellt sok tíz képernyőn keresztül, sok ezer tulajdonsággal, szabállyal beparaméterezni sokkal bonyolultabb, mint egy leíró nyelvet használni erre. Sosem szerettem a Rational Rose-t. Sajnos ezen rendszerek a megbízhatatlanságukkal, kiforratlanságukkal szintén elveszik az ember kedvét. Próbáltam AndroMDA-t, openMDX-et, de nagyon behatároltak voltak és hibáktól hemzsegtek. Próbáltam Posseidon for UML, ArgoUML, StarUML eszközöket. Kimérve mindig sokkal gyorsabb volt Java forráskódot írni, Java interfészekkel tervezni, JavaDoc-ot írni, és abból visszagenerálni a modellt. Nem, a Spring Roo-ban sem hiszek.&lt;/p&gt;

&lt;p&gt;Nézzük, milyen hatása van a saját keretrendszerek a programozókra. Gyakran láttam, hogy egy-két okos programozó írta a keretrendszert, és a kevésbé okosnak tartott programozók csak használták. Ismerős? Kérdeztétek már meg, mit gondolnak úgy igazán a keretrendszerről? Egyrészt nagyon sok munkával megtanulnak egy olyan dolgot melyet sehol máshol nem tudnak használni, melytől nem lesznek többek, mely nem motiválja őket, nem írható be az önéletrajzukba. Ki vannak zárva egy körből, nem hozhatnak döntéseket, nem tudnak a miértről. Nem kapnak megfelelő szintű támogatást, dokumentációt. Hallottam programozóról, aki úgy kezdi az interjút, hogy kell-e saját keretrendszerben dolgozni. Ha a válasz igen, akkor nem folytatja az interjút.&lt;/p&gt;

&lt;p&gt;A fejlesztők manapság mindig modern, divatos, trendi technológiákkal akarnak dolgozni. Nehéz őket saját keretrendszerrel megfogni.&lt;/p&gt;

&lt;p&gt;Gyakran láttam, hogy a keretrendszer alkotójának elege lett, továbbállt, otthagyta a rendszerét. Olyanoknak kellett átvenniük, akik nem értették, nem látták át teljesen, nem voltak tisztában a döntési folyamatokkal. A keretrendszer alkotókat gyakran nem lehet elég sokáig lekötni, aktív, kreatív emberek, akik nem állapodnak meg, újabb és újabb ötleteket próbálnak ki, és folyamatosan patkolandó dolgokat hagynak maguk után. Mivel pezseg a vérük, nem töltik idejüket olyan haszontalan dolgokkal, hogy a legapróbb részleteket is átgondolják, a legutolsó részt is lefejlesszék és dokumentálják a rendszert.&lt;/p&gt;

&lt;p&gt;Ilyen fejlesztők gyakran abba a hibába esnek, hogy egy problémát túlzottan általánosan próbálnak megvalósítani. Igaz ugyan, hogy most nem kell, de később jól jöhet. Gyakran lehet a YAGNI (You ain't gonna need it) elvet hallani, hogy pontosan azt fejlesszük le, amire szükség van, ne fejlesszünk olyan funkcionalitást, amire azt gondoljuk, hogy majd szükség lehet rá. Vagy nem lesz rá szükség, vagy nem úgy lesz rá szükség. Az ügyfél ilyen szempontból hatalmas kreativitással rendelkezik, hogy olyant kérjen, amire úgysem gondoltunk.&lt;/p&gt;

&lt;p&gt;Milyen lehet egy ilyen rendszer minősége? Gondoljunk bele, hogy olyan keretrendszereknél, mint a Spring, Struts, stb., melyet több ezren használnak, tesztelnek, nézegetik a forrását, milyen gyakran jegyeznek be hibákat, milyen gyakran frissülnek, milyen a fejlesztői aktivitás. Hogy gondolhatjuk, hogy pár fejlesztővel ugyanolyan szintű eszközt képesek vagyunk gyártani? Úgy, hogy nekünk nem ez a fő profilunk, hanem fő munkaidőben az ügyfelek óhajait, problémáit kell megoldanunk. A keretrendszer fejlesztésére, unit tesztelésére, dokumentációjára sosem marad idő. Előbb az égető problémákat kell megoldani, a funkcionalitásra kell összpontosítani, az ügyfél azért fizet.&lt;/p&gt;

&lt;p&gt;Miért jó ez a menedzsmentnek? Örülnek, ha olyanra költik a pénzt, aminek semmi látszatja nincs? Nem lesz tőle több képernyő. Nem tőle lesz több funkció. A keretrendszer implementálásával csak a lehetőségét valósítjuk meg, hogy a felhasználó számára alkalmazást fejlesszünk. De még nem fejlesztettünk egy percet sem. Mennyire felel meg ez a manapság annyira oly divatos agilis módszertanoknak? Mennyire követi a KISS (keep it simple ...) elvet?&lt;/p&gt;

&lt;p&gt;A keretrendszer azért kell, hogy a képernyőket, funkcionalitást gyorsabban ki tudjuk fejleszteni? Hányszor hangzott el, hogy ezt nem tudja a keretrendszer, ezt a keretrendszerben kell kifejleszteni, ez így túl lassú lenne a keretrendszerben, stb.?&lt;/p&gt;

&lt;p&gt;Bizonyos emberekben valamilyen blokk van, hogy más munkáját használják fel. Kritizálják, mindenből sajátot akarnak írni, saját XML parser, saját protokoll, saját formátum, saját keretrendszer. Ismert a jelenség, nem csak informatikában, "Not Invented Here (NIH)", általában pejoratívan használják.&lt;/p&gt;

&lt;p&gt;Ezek a keretrendszerek nem felelnek meg a szabványoknak. Nem széleskörűen elterjedtek. Nem lehet az utcáról felvenni egy olyan programozót, aki értene hozzá. Nagyon drága a betanítás. Hiszen nincsenek képzett oktatók, nincs oktató anyag. Általában elé adják az új fejlesztő elé, és próbálja meg egyedül felfejteni (a vezető programozónak nincs ideje pátyolgatni), próbálja meg az eddigi megoldásokat lemásolni. Csak általában egy keretrendszer használatával is ugyanarra a problémára a fejlesztők három különböző megoldást használtak.&lt;/p&gt;

&lt;p&gt;Nem csak már bevált, működő, széles körben elterjedt keretrendszereket érdemes használni, hanem érdemes (kvázi) szabvány API-k közül választani, ami alatt cserélhetjük az implementációt. Cseréltünk már Hibernate-et EclipseLink-re, mert jobban megfelelt az igényeinknek. Építkezzünk modulárisan, hiszen csak így van lehetőségünk a modulok esetleges későbbi kiváltására, programozzunk interfészekkel, használjunk rétegeket, tartsuk szem előtt a loose coupling, high cohesion elveket.&lt;/p&gt;

&lt;p&gt;Nagyon fontos, hogy az ezzel kapcsolatos viták során mindig eljutunk a szép architektúra, szép kód fogalmához. A szépség szubjektív. Ízlésről nem vitatkozunk. Parttalannak érzem az XML kontra programozott konfiguráció, a NetBeans kontra Eclipse vitákat, az annotációk túlzott használatát elítélő kijelentéseket. Érvek, objektív érvek kellenek. És még sajnos így is beleütközünk abba, hogy minden megoldásnak van jó és rossz oldala is. És ráadásul lehetnek ezek egyensúlyban is. Döntsünk ésszerűen, érveljünk ésszerűen.&lt;/p&gt;

&lt;p&gt;Félreértés ne essék. A postban direkt sarkítok. Próbálok erős érzelmeket kiváltani. Nem azt mondom, hogy ne fejlesszünk saját keretrendszert, mert akkor még mindig assembly kódot írhatnánk. Vannak okos emberek, okos ötletekkel. Sőt, sok esetben nem is kell nagy ötlet, csak egy elegáns megvalósítás. De mindig alaposan gondoljuk át. Ne játszunk a cégünk, vagy a megrendelő pénzével. Saját keretrendszer kifejlesztése nagyon-nagyon drága, a legtöbb projekt ezt nem bírja el. Ne játszunk a kollégáink türelmével. Ne a saját önzésünk vezéreljen, hanem mérlegeljünk. A kreativitásunkat máshol éljük ki, úgy, hogy az ne menjen egy cég, egy csapat, egy projekt rovására. Próbáljunk különböző vérmérsékletű, kvalitású embereket is bevenni a döntési folyamatba. Legyen lelkes, legyen kétkedő, legyen tapasztalt, legyen kezdő.&lt;/p&gt;

&lt;p&gt;Azt hiszem, hogy a legtöbben azért beleestünk abba a hibába, hogy saját keretrendszert fejlesztettünk, vagy kezdtünk fejleszteni. Ne szégyelljük, próbáljunk idejében váltani, tanulni belőle.&lt;/p&gt;

&lt;p&gt;Érezhető, hogy a szoftverfejlesztés során nagyon fontos az emberi tényező. Nagyon kevés mindenki által elfogadott alapelv van, mindenre lehet érvet/példát találni, és annak ellenkezőjére is. Kevés, hogyha jó technológusok vagyunk, néha jobb lenne pszichológusnak lenni. Próbáljuk felismerni és kihasználni az tipikus fejlesztői viselkedésformákat.&lt;/p&gt;

&lt;p&gt;Van a postban olyan, amit ti is gyakran tapasztaltok? Mi a véleményetek?&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/7709122161237145798/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html#comment-form' title='28 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' title='Miért ne fejlesszünk saját keretrendszert?'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>28</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2002559707916709456</id><published>2011-04-18T00:22:00.008+02:00</published><updated>2011-04-18T00:41:13.683+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Servlet'/><category scheme='http://www.blogger.com/atom/ns#' term='JNDI'/><category scheme='http://www.blogger.com/atom/ns#' term='EJB'/><category scheme='http://www.blogger.com/atom/ns#' term='Maven'/><category scheme='http://www.blogger.com/atom/ns#' term='Java EE'/><title type='text'>Konfigurációs paraméterek EJB és web rétegben Glassfish alkalmazásszerveren</title><content type='html'>&lt;p&gt;Technológiák: Glassfish 3.1, Maven 2.2.1, EJB 3.0 - 3.1, JNDI&lt;/p&gt;

&lt;p&gt;A &lt;a href="http://jtechlog.blogspot.com/2011/02/konfiguracios-parameterek-ejb-retegben.html"&gt;Konfigurációs paraméterek EJB és web rétegben JBoss alkalmazásszerveren&lt;/a&gt; postban leírtam, hogyan lehet JBoss-ban konfigurációs paramétereket felvenni, JNDI segítségével. Ebben a postban leírom, hogy történik mindez Glassfish alatt.&lt;/p&gt;

&lt;p&gt;Az aktualizált példaprojekt &lt;a href="http://dl.dropbox.com/u/7683931/jtechlog/earconfig.zip"&gt;letöltehető.&lt;/a&gt; Ahhoz, hogy lefordítsuk, adjuk ki az mvn package parancsot a főkönyvtárban. Ahhoz, hogy a Glassfish-re telepítsük, a earconfig-ear/target könyvtárban előállt earconfig-ear-1.0-SNAPSHOT.ear kell a Glassfish-re telepítenünk. Persze ezt is megoldhatjuk Maven-ből is, ehhez először indítsuk el a Glassfisht. Az earconfig-ear/pom.xml-ben a glassfish3x profile-ban van definiálva a telepítés, ezért ezzel kell indítani, valamint felül kell definiálnunk jópár paramétert (host, port, stb.). Ehhez átírhatjuk a pom.xml-t, de a -D kapcsolót is használhatjuk a paraméterek felülbírálásához. Tehát adjuk ki a &lt;code&gt;mvn -P glassfish3x cargo:deploy&lt;/code&gt; parancsot a earconfig-ear könyvtárban. Érdemes megjegyezni, hogy Glasshfish 3.1-ben az adminisztrátori felhasználónév admin, és nincs jelszó megadva. Régebben ez admin/adminadmint volt. Valamint figyelni kell arra, hogy az asadmin-nak biztonsági okból már nem lehet paraméterként átadni a jelszót, hanem fájlból olvassa fel. A Cargo nem enged Glassfish-re fájl másolásos telepítést, kizárólag az asadmin-t hajlandó hívni. Ezért eltesz egy állományt a temp könyvtárban, nálam a "C:\Documents and Settings\vicziani\Local Settings\Temp\cargo" helyen. Volt olyan, hogy hiába frissítettem a jelszót a pom.xml-ben, ez a fájl nem változott, így nem sikerült a telepítést. Megoldásaként csak le kellett törölni ezt az állományt. Még egy trükk. Ha nem állítottuk át a jelszót, hanem üresen hagytuk a Glassfish telepítés után, akkor is meg kell adni a Cargo-nak az üres String-et (&amp;lt;cargo.remote.password&amp;gt;${glassfish.password}&amp;lt;/cargo.remote.password&amp;gt;), különben nem sikerül a telepítés. A JBoss-sal ellentétben, itt ha az alkalmazást frissíteni akarjuk, nem elegendő a cargo:deploy parancs, hanem a cargo:redeploy parancs kell, mert a Glassfish jelzi, hogy már van alkalmazás telepítve.&lt;/p&gt;

&lt;p&gt;Glassfish-ben a paraméterek, azaz a rendszer paraméterek (system properties) és a JNDI nevek megadása is háromféleképpen történhet: webes adminisztrátori felületen, parancssori adminisztrátori felületen, vagy konfigurációs állományban.&lt;/p&gt;

&lt;p&gt;A system property megadása a webes felületen a server menüpontban a Properties/System properties képernyőn lehetséges. Itt menet közben tetszőlegesen is át lehet írni.&lt;/p&gt;

&lt;a rel="lightbox" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/-6e7EtuGMqJE/TatoRtBeklI/AAAAAAAAGSQ/WFTCrFa_F0A/s1600/jndi_glassfish_0.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 189px;" src="http://2.bp.blogspot.com/-6e7EtuGMqJE/TatoRtBeklI/AAAAAAAAGSQ/WFTCrFa_F0A/s320/jndi_glassfish_0.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5596681615290831442" /&gt;&lt;/a&gt;

&lt;p&gt;&lt;a href="http://download.oracle.com/docs/cd/E18930_01/html/821-2416/ghcjc.html"&gt;Parancssorban is&lt;/a&gt; fel lehet venni, és listázni.&lt;/p&gt;

&lt;pre&gt;
C:\Kaffe\glassfish3\glassfish\bin&gt;asadmin create-system-properties \
 earconfig.system.property="Hello System Property!"
Command create-system-properties executed successfully.

C:\Kaffe\glassfish3\glassfish\bin&gt;asadmin list-system-properties
The target server contains following 1 system properties
earconfig.system.property=Hello System Property!
Command list-system-properties executed successfully.
&lt;/pre&gt;

&lt;p&gt;A konfiguráció a \glassfish3\glassfish\domains\domain1\config\domain.xml XML konfigurációs állományba kerül bele.&lt;/p&gt;

&lt;p&gt;A JNDI megadása a webes felületen a Resources/JNDI/Custom Resources menüpontban lehetséges. Itt vegyünk fel egy új erőforrást a megfelelő JNDI névvel. Több típus közül is választhatunk. Az értékek megadása un. factory-kkal történik, és a Glassfish tartalmaz pár &lt;a href="http://download.oracle.com/docs/cd/E19798-01/821-1752/giyvw/index.html"&gt;előre gyártott factory-t&lt;/a&gt;: JavaBeanFactory, PropertiesFactory, PrimitiviesAndStringFactory, URLFactory. Amennyiben String-et akarunk felvenni, típusnál a "java.lang.String"-et kell kiválasztani, a Factory Class ilyenkor "org.glassfish.resources.custom.factory.PrimitivesAndStringFactory" lesz, és fel kell venni egy property-t value névvel. Legyen az értéke a "Hello JNDI!".&lt;/p&gt;

&lt;a rel="lightbox" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/-XY1WEM1doEM/TatoVkooENI/AAAAAAAAGSY/q21lhPVBunY/s1600/jndi_glassfish_1.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 206px;" src="http://4.bp.blogspot.com/-XY1WEM1doEM/TatoVkooENI/AAAAAAAAGSY/q21lhPVBunY/s320/jndi_glassfish_1.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5596681681758589138" /&gt;&lt;/a&gt;

&lt;p&gt;URL esetén hasonló a helyzet, de a Resource Type java.net.URL és a factory org.glassfish.resources.custom.factory.URLObjectFactory. Itt property-nek a spec-t kell megadni, érték legyen pl. "http://jtechlog.blogspot.com". Properties megadása már érdekesebb. Itt is a Resource Type-nál ki kell választani a java.util.Properties-t (, a factory org.glassfish.resources.custom.factory.PropertiesFactory lesz). Itt a properties-nél megadhatjuk a név és érték párokat is. Amennyiben egy speciálisat adunk meg org.glassfish.resources.custom.factory.PropertiesFactory.fileName néven, az értéknél szereplő properties fájlt fogja betölteni (, szemben a dokumentációval, ami csak fileName-t ír). A fájlnév lehet abszolút, vagy a Glassfish telepítési könyvtárához képest relatív. A properties állományt szerkesztéskor szépen újra is olvassa. Amennyiben a fájlban és a felületen is megadtunk kulcs-érték párokat, a Glassfish összefésüli ezeket. A JBoss-ban definiálható InetAddress típushoz itt nem találtam factory-t.&lt;/p&gt;

&lt;p&gt;A JNDI bejegyzések ugyanúgy &lt;a href="http://download.oracle.com/docs/cd/E18930_01/html/821-2416/gglpq.html"&gt;parancssorból is konfigurálhatóak&lt;/a&gt;. A Glassfish egy régebbi verziójában volt webes JNDI browser felület. Ez most egyelőre csak parancssorból elérhető.&lt;/p&gt;

&lt;pre&gt;
C:\Kaffe\glassfish3\bin&gt;asadmin create-custom-resource \
--restype java.lang.String \
--factoryclass org.glassfish.resources.custom.factory.PrimitivesAndStringFactory \
--property value="Hello JNDI!" earconfig/string
Custom Resource earconfig/string created.
Command create-custom-resource executed successfully.

C:\Kaffe\glassfish3\bin&gt;asadmin list-custom-resources
earconfig/url
earconfig/properties
earconfig/string
Command list-custom-resources executed successfully.
&lt;/pre&gt;

&lt;p&gt;Az értékek ugyanúgy a \glassfish3\glassfish\domains\domain1\config\domain.xml XML konfigurációs állományba kerülnek. Akár saját factory osztályokat is használhatunk.&lt;/p&gt;

&lt;p&gt;Ezeket elvégezve az alkalmazás a http://localhost:8080/earconfig/ címen érhető el, és a következőt kell kiírnia:&lt;/p&gt;

&lt;pre&gt;
A projekt bemutatja, hogy hogyan lehet Java EE alkalmazásból konfigurációs paramétereket beolvasni.

    * System property EJB rétegben (kulcs: earconfig.system.property): Hello \
System Property!
    * Context lookup (JNDI) EJB rétegben (JNDI nevek: earconfig/string, \
 earconfig/url, earconfig/inetaddress, earconfig/properties): [Hello JNDI!, \
http://jtechlog.blogspot.com, null, {key=value, key2=value2, key1=value1}]
    * System property web rétegben (kulcs: earconfig.system.property): Hello System Property!
    * Context lookup (JNDI) web rétegben (JNDI nevek: earconfig/string, \
 earconfig/url, earconfig/inetaddress, earconfig/properties): [Hello JNDI!, \
http://jtechlog.blogspot.com, null, {key=value, key2=value2, key1=value1}]
&lt;/pre&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/2002559707916709456/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2011/04/konfiguracios-parameterek-ejb-es-web.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2002559707916709456'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2002559707916709456'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/04/konfiguracios-parameterek-ejb-es-web.html' title='Konfigurációs paraméterek EJB és web rétegben Glassfish alkalmazásszerveren'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://2.bp.blogspot.com/-6e7EtuGMqJE/TatoRtBeklI/AAAAAAAAGSQ/WFTCrFa_F0A/s72-c/jndi_glassfish_0.png' height='72' width='72'/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2933517858616487299</id><published>2011-04-14T19:45:00.004+02:00</published><updated>2011-04-14T20:36:36.795+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='monitorozás'/><category scheme='http://www.blogger.com/atom/ns#' term='VisualVM'/><category scheme='http://www.blogger.com/atom/ns#' term='glassfish'/><category scheme='http://www.blogger.com/atom/ns#' term='JMX'/><title type='text'>VisualVM Glassfish monitorozás</title><content type='html'>&lt;p&gt;Technológiák: Java SE 6 Update 23, VisualVM 1.3.2, Glassfish 2.1.1.&lt;/p&gt;

&lt;p&gt;A &lt;a href="http://visualvm.java.net/"&gt;VisualVM&lt;/a&gt; egy vizuális felület, mellyel a Java virtuális gépet monitorozhatjuk. Előnye, hogy a JDK-ba is belekerült, pl. a JDK 6 Update 23-ban a VisualVM 1.3.1 verziója szerepel, a jvisualvm parancs kiadásával azonnal ki is próbálhatjuk. Csatlakozhatunk lokális és távoli virtuális gépekhez is, így akár egy teljes hálózat Java alapú rendszereit monitorozhatjuk. Nem csak külön futtatható, de akár a NetBeans vagy Eclipse fejlesztőeszközbe is plugin-ként telepíthető.&lt;/p&gt;

&lt;p&gt;A virtuális gépről olyan alap információkat szolgáltat, mint a PID, indított osztály, parancssori paraméterek, Java Home, JVM pontos verziószáma, valamint a rendszerváltozók. Olyan teljesítmény adatokat tudhatunk meg vele, mint a CPU felhasználás, memória felhasználás, betöltött osztályok száma, szálak száma, stb. A CPU esetén külön mutatja az alkalmazás és a GC által felhasznált processzor időt. Meghívhatjuk a GC-t is. Memóriánál külön megtekinthetjük a Heap és a Permgen kihasználtságát is (, ez utóbbiba kerülnek az osztálydefiníciók). Kérhetünk Heap Dump-ot, mely egy pillanatfelvételt készít a memóriáról. Megmondja, hogy melyik osztályból hány objektum került példányosításra, és ezeket meg is nézhetjük a grafikus felület segítségével, de akár OQL nyelven lekérdezéseket is végezhetünk. Szálak esetén valós időben nézhetjük a szálak állapotát. Kérhetünk Thread Dump-ot is, melyből kiderül, hogy melyik szál éppen mit csinál, melyik kódsorban áll.&lt;/p&gt;

&lt;p&gt;CPU és memória profiler funkciókkal is rendelkezik. CPU profile esetén megtudhatjuk, hogy a CPU idejének hány százalékát melyik metódusban tölti. Snapshot-okat is kérhetünk, ezeket lementhetjük, és később, vagy akár más gépen is elemezhetjük. Memória profile estén az objektumok számát és területfoglalását figyeli. Itt is kérhetünk snapshot-ot, és ezeket össze is hasonlíthatjuk. Ez egy remek eszköz arra, hogy teszt előtt és után is készítünk egy snapshot-ot, és összehasonlítva azt látjuk, hogy a teszt után mennyivel több objektumunk lett, osztályonként lebontva. A profile azért eléggé megakaszthatja az alkalmazásunkat.&lt;/p&gt;

&lt;p&gt;A JConsole bővíthető, &lt;a href="http://visualvm.java.net/plugins.html"&gt;plugin&lt;/a&gt;-okat lehet hozzá telepíteni. Ezt az alkalmazásból, futás közben is megtehetjük, a Tools/Plugins menüpontban. Érdekes a VisualVM-MBeans plugin, mellyel gyakorlatilag JMX műveleteket tudunk elvégezni. A JMX-ről már írtam a &lt;a href="http://jtechlog.blogspot.com/2009/09/java-monitorozas-es-menedzsment.html"&gt;Java monitorozás és menedzsment&lt;/a&gt; postban, míg a Tomcat JMX adminisztrációjáról a &lt;a href="http://jtechlog.blogspot.com/2010/07/tomcat-jmx-tuzfal.html"&gt;Tomcat JMX tűzfalon keresztül&lt;/a&gt; postban.&lt;p&gt;

&lt;p&gt;Másik érdekes plugin a Visual GC, mely a memóriát memória területekre lebontva monitorozza, külön az Old, Survivor és Eden területeket.&lt;p&gt;

&lt;a rel="lightbox" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/-BAiXFoKOr5U/Tac-laUHnMI/AAAAAAAAGRQ/Jb5BhH0Os_o/s1600/visualvm_visualgc.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 233px;" src="http://2.bp.blogspot.com/-BAiXFoKOr5U/Tac-laUHnMI/AAAAAAAAGRQ/Jb5BhH0Os_o/s320/visualvm_visualgc.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5595509874470919362" /&gt;&lt;/a&gt;

&lt;p&gt;Szintén érdekes a Glassfish plugin, mellyel a Glassfishre érkező HTTP kéréseket tudjuk &lt;a href="http://java.dzone.com/articles/monitoring-glassfish"&gt;monitorozni&lt;/a&gt;, valamint a telepített web alkalmazásokat, élő sessionök számát, valamint az egyes servleteket is külön-külön. Ehhez azonban a Glassfishen is &lt;a href="http://qants.wordpress.com/tag/glassfish-plugin-for-visualvm/"&gt;konfigurálnunk kell&lt;/a&gt;. A bal oldali menüben ki kell választani az Application Server menüpontot, ott a Monitor majd Runtime fület választani, majd a Configura Monitoring linkre kell kattintani. Itt a HTTP Service és a Web Container monitorozását kell minimum LOW-ra állítani. Utána nem árt újraindítani a VisualVM-et, a Glassfish-t nem kell. Sajnos csak 2-es Glassfishhel megy, a 3-as sorozattal próbáltam, de nem sikerült.&lt;/p&gt;

&lt;a rel="lightbox" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/-kffMx1gHwbQ/Tac-heTHrZI/AAAAAAAAGRI/JUVbWXJl4Bc/s1600/visualvm_glassfish.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 233px;" src="http://2.bp.blogspot.com/-kffMx1gHwbQ/Tac-heTHrZI/AAAAAAAAGRI/JUVbWXJl4Bc/s320/visualvm_glassfish.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5595509806820994450" /&gt;&lt;/a&gt;

&lt;p&gt;A VisualVM a &lt;a href="http://platform.netbeans.org/"&gt;NetBeans Platformra&lt;/a&gt; épül. Természetesen &lt;a href="http://visualvm.java.net/api-quickstart.html"&gt;mi is írhatunk&lt;/a&gt; saját plugineket.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/2933517858616487299/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2011/04/visualvm-glassfish-monitorozas.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2933517858616487299'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2933517858616487299'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/04/visualvm-glassfish-monitorozas.html' title='VisualVM Glassfish monitorozás'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://2.bp.blogspot.com/-BAiXFoKOr5U/Tac-laUHnMI/AAAAAAAAGRQ/Jb5BhH0Os_o/s72-c/visualvm_visualgc.png' height='72' width='72'/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5695982303749707840</id><published>2011-02-27T23:33:00.010+01:00</published><updated>2011-08-24T11:14:59.394+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='EJB'/><category scheme='http://www.blogger.com/atom/ns#' term='Maven'/><category scheme='http://www.blogger.com/atom/ns#' term='JBoss'/><category scheme='http://www.blogger.com/atom/ns#' term='Java EE'/><title type='text'>Konfigurációs paraméterek EJB és web rétegben JBoss alkalmazásszerveren</title><content type='html'>&lt;p&gt;Technológiák: JBoss AS 5.1 - 6.0.0, Maven 2.2.1, EJB 3.0 - 3.1, JNDI&lt;/p&gt;

&lt;p&gt;&lt;emp&gt;Frissítés:&lt;/emp&gt; 2011. március 6. - az ismertetett megoldás nem felelt meg a szabványnak, JBoss 6-on nem is működött, javítottam. A példa projektet JBossConfig-ról átneveztem EarConfig-ra. Valamint beletettem egy magyarázó leírást az ENC használatáról.&lt;/p&gt;

&lt;p&gt;&lt;emp&gt;Frissítés:&lt;/emp&gt; 2011. április 18. - ugyanezt leírtam Glassfish-sel is egy későbbi &lt;a href="http://jtechlog.blogspot.com/2011/04/konfiguracios-parameterek-ejb-es-web.html"&gt;postban&lt;/a&gt;. Ennek megfelelően kicsit módosítottam a projektet, hogy mindkét alkalmazásszerveren működjön a build.&lt;/p&gt;

&lt;p&gt;Ha az alkalmazás futtatásához szükséges konfigurációkat paramétereket akarunk tárolni, beolvasni, rengeteg lehetőségünk van. Tapasztalatom szerint szinte mindenhol másképp van megoldva. Ha az alkalmazás tartalmazhatja ezeket a beállításokat, akkor belecsomagolhatjuk, de ekkor figyelembe kell venni, hogy a konfiguráció váltásakor újra kell telepítenünk. Ekkor a konfigurációk szerepelhetnek kódban konstansként, properties állományban (melyet classpath-ról töltünk be), Spring esetén az application context xml-ben, EJB-k esetén enviroment variable-ként (ejb-jar.xml-ben definiálva). Ha különböző környezetek vannak, akkor a build folyamat során kell arról gondoskodni, hogy különböző konfigurációs állományok kerüljenek a különböző környezetekre telepítendő alkalmazásokban.&lt;/p&gt;
&lt;p&gt;Ezen megoldások kevésbé flexibilisek, hiszen módosításkor újra kell telepíteni az alkalmazást, valamint sokkal szebb megoldás, ha környezetenként is ugyanaz a telepítendő alkalmazásunk van, és a környezetfüggő dolgok az alkalmazáson kívül szerepelnek.&lt;/p&gt;
&lt;p&gt;EJB vagy web konténer esetén jó megoldás lehet kevés számú paraméter esetén a system property, több paraméter esetén a JNDI használata is. Semmiképp nem szeretem a fájlrendszerben itt-ott elbújó állományokat, hiszen nagyon nehéz a nyomon követésük, verziókezelésük általában el szokott maradni. Ha nagyon muszáj, talán szóba jöhet az, hogy egy system property, vagy egy JNDI bejegyzés tartalmaz egy referenciát a konfigurációs állományra. A JNDI használatánál arra kell különösen figyelni, hogy konténerek között működő, platformfüggetlen megoldást találjunk.&lt;/p&gt;
&lt;p&gt;Állományt esetén kérdés annak formátuma is. Leggyakoribb a standard properties állomány, melyről páran nem tudják, hogy a Java 1.5 óta kezel XML állományokat is, valamint az 1.6-os Java-tól kezdve képes Writer-ből is tölteni, tehát az állomány karakterkódolása lehet bármilyen, nem kell a native2ascii eszközt használni. Java 1.4-ben megjelent a java.util.prefs is, mely már sokkal több mindent tud, még sem terjedt el, és nem is hallottam jókat felőle. Lehet egyedi XML, de ekkor nekünk kell gondoskodni a beolvasásáról, valamilyen XML könyvtár használatával, netalántán XML binding-gal.&lt;/p&gt;
&lt;p&gt;Persze talán a legteljesebb megoldás az adatbázisban történő tárolás, de az itt tárolt értékek szerkesztése koránt sem olyan triviális.&lt;/p&gt;
&lt;p&gt;A konfigurációs paraméterek kezelése esetén a tárolás után a fő gondom az szokott lenni, hogy hogyan lehet azokhoz hozzáférni, azokat szerkeszteni. A fájl esetén a legegyszerűbb a helyzet, hiszen egy egyszerű szövegszerkesztővel el lehet végezni a módosításokat. Lehet saját webes felület, de ezt külön kell fejleszteni, karbantartani, illetve a parancssorhoz szokott adminisztrátoroknak sem szokott tetszeni, plusz egy probléma, cím, amit meg kell jegyezni. Ha a konténer adminisztrációs felületébe épül, akkor talán kicsit jobb a helyzet. Az adatbázisban tárolt konfigurációs paraméterek esetén lehet nekiesni egy SQL klienssel, de szintén ellenérzést válthat ki, valamint kérdés, hogy milyen gyakran olvassa újra az alkalmazás. Java-ban van persze erre is szabvány, a JDK részét képző JMX, de sajnos én nem nagyon hiszek benne, nem láttam még olyan üzemeltetést, amelyet levett volna a lábáról, és minden probléma nélkül használnák. Talán előrelépés lenne, ha a jelenleg létező felügyeleti rendszerekbe egyszerűen lehetne integrálni.&lt;/p&gt;
&lt;p&gt;Kérdés, hogy a változások mikor lépnek életbe. Hiszen nem biztos, hogy a leghatékonyabb minden esetben újra beolvasni. Általában valamilyen cache mechanizmus használható. Persze itt megadhatunk lejáratot, hogy mennyi idő után olvassa újra, vagy megadhatunk eseményeket, melyek hatására biztos újra megtörténik az újra beolvasás. Állomány szerkesztése esetén ez egyáltalán nem triviális, hiszen vagy az állományt mindig ellenőrizni kell, vagy egy szálat kell indítani, ami megnézi, hogy módosult-e. Ez utóbbi EJB környezetben megint problémás. Erre megoldás lehet a Java 7-ben megjelenő, már régóta várt WatchService API, mely operációs rendszer szinten figyeli az állomány hozzáféréseket, és értesíti az eseményre feliratkozókat.&lt;/p&gt;
&lt;p&gt;Minden megoldásnál még bezavar a &lt;emp&gt;cluster-es működés&lt;/emp&gt;, hiszen kérdés esetén minden egyes node-on szerkeszteni kell az állományt (itt az időbeli eltolódás miatt lehet szétcsúszás, illetve érdekes, hogy hogyan lehet a node-okat egyenként címezni), vagy valahogy a node-ok megbeszélik egymás között a módosításokat. Esetleg vannak olyan konfigurációs beállítások, melyek node-onként eltérnek?&lt;/p&gt;
&lt;p&gt;Tehát konfigurációs paraméterek tárolásakor és a hozzáférés szerint a következőket kell mérlegelnünk:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Értékeik ismertek-e a build folyamatnál?&lt;/li&gt;
&lt;li&gt;Okoz-e problémát, ha a konfigurációs paraméterek csak az alkalmazás újratelepítésével módosíthatóak?&lt;/li&gt;
&lt;li&gt;Milyen gyorsan kell a változnak?&lt;/li&gt;
&lt;li&gt;Milyen gyorsan kell a változásoknak életbe lépniük?&lt;/li&gt;
&lt;li&gt;Milyen szintű felhasználók fogják használni, és nekik mi a megszokott, kényelmes eszköz (parancssor, állomány, adatbázis, felügyeleti rendszer, webes kliens)?&lt;/li&gt;
&lt;li&gt;Egy vagy több helyről jön? Pl. lehet, hogy bizonyos dolgokat a komponens fejlesztők, az application assembler (aki összerakja az alkalmazást darabokból), a telepítő, üzemeltető, netalántán a végfelhasználó is állíthat?&lt;p&gt;&lt;/p&gt;
&lt;/li&gt;&lt;li&gt;Van-e cluster-ezett működés. Okoz-e problémát, ha minden cluster tagot egyenként kell beállítgatni?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Persze vannak keretrendszerek, melyek segíthetnek a megvalósításban, melyek a következő funkciókkal rendelkezhetnek:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Típusosság, bonyolultabb adatstruktúrák támogatása&lt;/li&gt;
&lt;li&gt;Paraméter értékek behelyettesítése már paraméter értékekbe&lt;/li&gt;
&lt;li&gt;Default értékek&lt;/li&gt;
&lt;li&gt;Különböző források támogatása&lt;/li&gt;
&lt;li&gt;Különböző forrásból jövő konfigurációk összefésülése, hierarchikus betöltés&lt;/li&gt;
&lt;li&gt;Módosítások mentése&lt;/li&gt;
&lt;li&gt;Újratöltés&lt;/li&gt;
&lt;li&gt;Observer tervezési minta támogatása, értesítés, ha változik egy paraméter érték&lt;/li&gt;
&lt;li&gt;JMX hozzáférés&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Jó ötlet, hogy az alkalmazás rendelkezzen egy default konfigurációval is, amit az alkalmazás tartalmaz, ami a fejlesztői környezetre konfigurált, így egy checkout után azonnal futtatható az alkalmazás, és ezt érdemes teszt és éles környezetben felülbírálni.&lt;/p&gt;
&lt;p&gt;Amennyiben a konfigurációhoz különböző szerepkörrel rendelkező felhasználók is hozzáférhetnek, szükséges lehet bizonyos paraméterek titkosítására is. Ilyen lehet pl. egy adatbázis kapcsolathoz tartozó jelszó. A probléma jellegéből adódóan természetesen nem lehet teljes védelmet elérni, hiszen az alkalmazásnak is hozzá kell férnie valahogy a jelszóhoz, és legdurvább esetben egy kód visszafejtéssel biztos, hogy hozzá lehet férni az érzékeny adatokhoz. Ez inkább csak megnehezíti a visszafejtést. A JASYPT (Java simplified encryption) könyvtárnak van olyan lehetősége, hogy &lt;a href="http://www.jasypt.org/encrypting-configuration.html"&gt;titkosít bizonyos értékeket&lt;/a&gt; a konfigurációs állományban. Ekkor a konfigurációs paraméter értéke valami hasonló lesz: ENC(G6N718UuyPE5bHyWKyuLQSm02auQPUtm). Képes kezelni properties állományokat, Spring-hez és Hibernate-hez illeszthető.&lt;/p&gt;
&lt;p&gt;Konfigurációs paraméterek kezelésére alkalmas keretrendszerek:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://commons.apache.org/configuration/"&gt;Commons configuration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.jconfig.org/"&gt;jConfig&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jfig.sourceforge.net/"&gt;jFig&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://carbon.sourceforge.net/modules/core/docs/config/index.html"&gt;The Carbon Core Config Subsystem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Furcsa, hogy a legfrissebb is 2008-ban frissült utoljára.&lt;/p&gt;
&lt;p&gt;Ti hogyan oldottátok meg a konfigurációs paraméterek tárolását, szerkesztését?&lt;/p&gt;
&lt;p&gt;A következőkben egy olyan megoldást mutatok be, mely JBoss AS specifikus (tesztelve 5.1 és 6 verziókon is). Nem ad választ minden kérdésre, a cikkben kizárólag a JBoss ez irányú egy-két képességét szeretném bemutatni.&lt;/p&gt;
&lt;p&gt;A post-hoz egy példa projekt is &lt;a href="http://dl.dropbox.com/u/7683931/jtechlog/earconfig.zip"&gt;letölthető&lt;/a&gt;. A projekt Maven-nel fordul, és szépen szemlélteti egy Java EE projekt felépítését Maven környezetben, ahol a build terméke egy EAR állomány. Az alkalmazás négy részből áll. Egy parent project, mely a közös beállításokat tartalmazza (pl. Java 6, UTF-8 kódolás, stb.), valamint három modulja:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;earconfig-ejb: EJB réteg&lt;/li&gt;
&lt;li&gt;earconfig-web: web réteg - erre csak azért van szükség, hogy az EJB réteget meg tudjuk hívni&lt;/li&gt;
&lt;li&gt;earconfig-ear: az alkalmazás maga&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Az alkalmazást kicsomagolva, majd a gyökér könyvtárban a &lt;code&gt;mvn package&lt;/code&gt; parancsot kiadva áll elő az earconfig-ear/target/earconfig-ear-1.0-SNAPSHOT.ear állomány. Ahhoz, hogy telepítsük, vagy másoljuk be a JBoss deploy könyvtárába az alkalmazást, vagy az earconfig-ear könyvtárban a pom.xml-ben írjuk át a jboss.server.dir property értékét arra az elérési útvonalra, ahova a JBoss lett telepítve, és adjuk ki a cargo:deploy parancsot. Ezt bekonfigurálhatjuk fejlesztőeszközben is. A &lt;a href="http://cargo.codehaus.org/"&gt;Cargo&lt;/a&gt; egy olyan könyvtár, mely egységes felületet biztosít web konténerek, alkalmazásszerverek kezelésére, elindítására, leállítására, alkalmazások telepítésére. Mi a Maven pluging-jét használjuk.&lt;/p&gt;
&lt;p&gt;Az alkalmazásnak az ejb és war modulja is pontosan ugyanúgy működik. A ejb modulban az EarConfigBean EJB Bean, a war modulban a EarConfigServlet servlet felelős a paraméterek kiolvasásáért.&lt;/p&gt;
&lt;p&gt;Az első metódus system property-t olvas be a következő Java SE-ben is működő módon:&lt;/p&gt;
&lt;pre class="brush: java"&gt;
System.getProperty("earconfig.system.property");
&lt;/pre&gt;
&lt;p&gt;A második metódus Context lookup-pal lekérdezi a globális JNDI-ben lévő értékeket:&lt;/p&gt;
&lt;pre class="brush: java"&gt;
Context context = new InitialContext();
String[] NAMES = new String[]{"earconfig/string", "earconfig/url", "earconfig/inetaddress", "earconfig/properties"};
for (String name: NAMES) {
   Object entry = context.lookup(name);
   System.out.println(entry.getClass().getName() + " " + entry);
}
&lt;/pre&gt;

&lt;p&gt;Nagyon sokat kínlódtam azzal, hogy a paramétereket globálisan definiáljam a JNDI-ben, majd azokat elérhetővé tegyem a bean, vagy a web alkalmazás ENC-jében, ahogyan arról &lt;a href="http://jtechlog.blogspot.com/2009/01/jndi-nevek-ejb-krnyezetben.html"&gt;korábban írtam&lt;/a&gt;, sőt ehhez akár a @Resource annotációval hozzáférjek. Ezt azonban nem sikerült megoldani.&lt;/p&gt;

&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/-lERPAF8FaWo/TXQUdpgWqEI/AAAAAAAAGBw/EAZE2IweFB4/s1600/enc_overview.png" rel="lightbox"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 134px;" src="http://3.bp.blogspot.com/-lERPAF8FaWo/TXQUdpgWqEI/AAAAAAAAGBw/EAZE2IweFB4/s320/enc_overview.png" border="0" alt="ENC áttekintés" id="BLOGGER_PHOTO_ID_5581108337809205314" /&gt;&lt;/a&gt;

&lt;p&gt;Klasszikus esetben tehát van az EJB komponens, melyhez a standard deployment descriptor-ban (telepítés leíró) vagy a @Resource annotációval lehet egy lokális nevet az ENC-ben deklarálni. Ehhez az előbbi esetén context lookup-pal, az utóbbi esetén szintén a @Resource annotációval fér hozzá az EJB. Az alkalmazásszerverek gyártófüggő módon engedik az erőforrások felvételét a konténeren belül, és kapnak egy globális nevet. A lokális és a globális neveket a gyártófüggő deployment descriptor-ban lehet összekötni.&lt;/p&gt;

&lt;p&gt;Felmerülhet tehát az igény, hogy az ENC-ben deklaráljuk a logikai neveket, és egy gyártófüggő deployment descriptor-ban rendeljük hozzá a konkrét értékeket. Az ENC-ben való deklarációhoz két eszközünk lehet, vagy a standard deployment descriptor, vagy a @Resource annotáció, mely egymásnak alternatívái (, pontosabban a annotációt a deployment descriptor felülírhatja).&lt;/p&gt;

&lt;p&gt;A standard deployment descriptor-ban (ejb-jar.xml) a következő XML tag-ek használatosak erre:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;resource-ref: Factory-k definiálására, tipikusan DataSource-ra használható. További osztályok: javax.jms.QueueConnectionFactory/javax.jms.TopicConnectionFactory, javax.mail.Session, java.net.URL.&lt;/li&gt;
&lt;li&gt;resource-env-ref: a neten sok példa ide a Queue-t vagy Topic-ot említi, de helytelenül, lásd a következő pont. Amit találtam róla, hogy Connector CCI esetén használható.&lt;/li&gt;
&lt;li&gt;message-destination-ref: valójában ez használandó Queue-t vagy Topic definiálására&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ebből máris látható, hogy a mi egyszerű, JNDI-be bejegyzett értékeinkre nem tudunk mivel hivatkozni. Van ugyan egy env-entry tag, de ennek értékét kizárólag az ejb-jar.xml-ben lehet megadni, és nem lehet felüldefiniálni a JNDI-ben megadott értékkel.&lt;/p&gt;

&lt;p&gt;A Java EE szabvány, csak a következő típusokat engedi @Resource annotációval megjelölni:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SessionContext&lt;/li&gt;
&lt;li&gt;DataSource&lt;/li&gt;
&lt;li&gt;UserTransaction&lt;/li&gt;
&lt;li&gt;EntityManager&lt;/li&gt;
&lt;li&gt;TimerService&lt;/li&gt;
&lt;li&gt;Más EJB-k&lt;/li&gt;
&lt;li&gt;Web szolgáltatások&lt;/li&gt;
&lt;li&gt;Sorok és témák (queue/topic)&lt;/li&gt;
&lt;li&gt;Connection factory objektumok a resource adapter-ek számára&lt;/li&gt;
&lt;li&gt;Környezeti változók: String, Character, Byte, Short, Integer, Long, Boolean, Double és Float&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ebből látható, hogy nem lehet akármilyen típushoz, POJO-hoz hozzáférni, ami már beszűkíti a lehetőségeinket. Ezt a tulajdonságát a Resource annotációnak a Spring közönség igen erősen kritizálja, érthető okokból.&lt;/p&gt;

&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/-jb-qsI66nbw/TXQTrHRQeDI/AAAAAAAAGBo/ftdkPUkuO4k/s1600/enc_details.png" rel="lightbox"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 218px;" src="http://3.bp.blogspot.com/-jb-qsI66nbw/TXQTrHRQeDI/AAAAAAAAGBo/ftdkPUkuO4k/s320/enc_details.png" border="0" alt="ENC részletek" id="BLOGGER_PHOTO_ID_5581107469625620530" /&gt;&lt;/a&gt;

&lt;p&gt;Így hát marad az, hogy a globális JNDI nevekhez férjünk hozzá Context lookup segítségével. Jobb esetben erre Service Locator-t használunk. Még jobb estben az előbb említett konfigurációs keretrendszerek valamelyikét.&lt;/p&gt;

&lt;p&gt;De előbb nézzük, hogyan lehet értéket adni egy system property-nek? Vagy parancssorból a Java virtuális gépnek a &lt;code&gt;-D&lt;/code&gt; paraméterrel, vagy kódból a System.setProperty metódussal. A JBoss azonban egy SystemPropertiesService szolgáltatást is biztosít, mely a deploy könyvtárban lévő properties-service.xml-ben van definiálva. Ahhoz, hogy a system property-nek értéket adjunk, a következő sorokat illesszük be a SystemPropertiesService mbean tag alá.&lt;/p&gt;

&lt;pre class="brush: xml"&gt;
&amp;lt;attribute name="Properties"&amp;gt;
  earconfig.system.property=Hello System Property!
&amp;lt;/attribute&amp;gt;
&lt;/pre&gt;

&lt;p&gt;A megoldás szépsége, hogy ezt akkor is megtehetjük, ha éppen fut a JBoss, a -service.xml állományokat a JBoss automatikusan újra felolvassa. Nem csak ebben állíthatjuk be a paramétereket, hanem megadhatunk egy properties állományt is, melyet felolvas.&lt;/p&gt;

&lt;p&gt;Hogyan tehetünk értéket a JNDI-be? Megtehetjük parancssori eszközzel, kódbol, de a JBoss erre is biztosít szolgáltatást, méghozzá &lt;code&gt;&lt;a href="http://docs.jboss.org/jbossas/docs/Server_Configuration_Guide/4/html/Additional_Naming_MBeans-JNDI_Binding_Manager.html#"&gt;JNDIBindingServiceMgr&lt;/a&gt;&lt;/code&gt; néven. Ez alapban nincs konfigurálva a JBoss-ban, ígyhát hozzunk létre egy -service.xml végű állományt, pl. jndi-binding-service.xml, és másoljuk bele a következő tartalmat. (Megtalálható a projektben is a jbossconfig-ear\src\main\jboss\jndi-binding-service.xml állományban.)&lt;/p&gt;

&lt;pre class="brush: xml"&gt;
&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;

&amp;lt;server&amp;gt;

   &amp;lt;mbean code="org.jboss.naming.JNDIBindingServiceMgr"
      name="jboss.jndi:name=JNDIBindingServiceMgr"&amp;gt;
       &amp;lt;attribute name="BindingsConfig" serialDataType="jbxb"&amp;gt;
           &amp;lt;jndi:bindings xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"
                      xmlns:jndi="urn:jboss:jndi-binding-service:1.0"
                      xs:schemaLocation="urn:jboss:jndi-binding-service:1.0 resource:jndi-binding-service_1_0.xsd"&amp;gt;

               &amp;lt;jndi:binding name="earconfig/string"&amp;gt;
                   &amp;lt;jndi:value trim="true"&amp;gt;
                   Hello, JNDI!
                   &amp;lt;/jndi:value&amp;gt;
               &amp;lt;/jndi:binding&amp;gt;

               &amp;lt;jndi:binding name="earconfig/url"&amp;gt;
                   &amp;lt;jndi:value type="java.net.URL"&amp;gt;http://www.jboss.org&amp;lt;/jndi:value&amp;gt;
               &amp;lt;/jndi:binding&amp;gt;

               &amp;lt;jndi:binding name="earconfig/inetaddress"&amp;gt;
                   &amp;lt;jndi:value editor="org.jboss.util.propertyeditor.InetAddressEditor"&amp;gt;
                       127.0.0.1
                   &amp;lt;/jndi:value&amp;gt;
               &amp;lt;/jndi:binding&amp;gt;

               &amp;lt;jndi:binding name="earconfig/properties"&amp;gt;
                   &amp;lt;java:properties xmlns:java="urn:jboss:java-properties"
                    xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"
                    xs:schemaLocation="urn:jboss:java-properties
      resource:java-properties_1_0.xsd"&amp;gt;
                       &amp;lt;java:property&amp;gt;
                           &amp;lt;java:key&amp;gt;key1&amp;lt;/java:key&amp;gt;
                           &amp;lt;java:value&amp;gt;value1&amp;lt;/java:value&amp;gt;
                       &amp;lt;/java:property&amp;gt;
                       &amp;lt;java:property&amp;gt;
                           &amp;lt;java:key&amp;gt;key2&amp;lt;/java:key&amp;gt;
                           &amp;lt;java:value&amp;gt;value2&amp;lt;/java:value&amp;gt;
                       &amp;lt;/java:property&amp;gt;
                   &amp;lt;/java:properties&amp;gt;
               &amp;lt;/jndi:binding&amp;gt;

           &amp;lt;/jndi:bindings&amp;gt;
       &amp;lt;/attribute&amp;gt;
   &amp;lt;/mbean&amp;gt;

&amp;lt;/server&amp;gt;
&lt;/pre&gt;

&lt;p&gt;A példa négy értéket illeszt be a JNDI-be:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;earconfig/string: String típusú&lt;/li&gt;
&lt;li&gt;earconfig/url: URL típusú&lt;/li&gt;
&lt;li&gt;earconfig/inetaddress: InetAddress típusú&lt;/li&gt;
&lt;li&gt;earconfig/properties: Properties típusú&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mint látható, nem csak String-et lehet használni, hanem vannak beépített &lt;a href="http://community.jboss.org/wiki/PropertyEditor"&gt;beépített PropertyEditor-ok&lt;/a&gt;, de sajátot is lehet használni.&lt;/p&gt;

&lt;p&gt;Amennyiben ezt az állományt is bemásoljuk a deploy könyvtárba, az értékek a JNDI-ben azonnal megjelennek. Szerkesztés esetén is azonnal látszanak az új értékek, ugyanis a JBoss az állományt automatikusan újraolvassa. Az eredmény megtekinthető a JMX Console-on is (/jmx-console címen), és a service=JNDIView MBean-t kell kiválasztani, és meghívni a list(boolean verbose) metódusát. A következőt kell látnunk:&lt;/p&gt;

&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/-PAO7WAPXFXA/TXQGTPYQylI/AAAAAAAAGBQ/U1Ftl8QG1zo/s1600/jboss-jmx.PNG" rel="lightbox"&gt;&lt;img style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 320px; height: 224px;" src="http://3.bp.blogspot.com/-PAO7WAPXFXA/TXQGTPYQylI/AAAAAAAAGBQ/U1Ftl8QG1zo/s320/jboss-jmx.PNG" alt="JBoss JMX admin" id="BLOGGER_PHOTO_ID_5581092765834463826" border="0" /&gt;&lt;/a&gt;

&lt;p&gt;Sajnos ezeket az adminisztrációs felületen nem lehet szerkeszteni, kizárólag a fájlokban. Azonban a Glassfish pl. lehetőséget biztosít ezek megadására grafikus adminisztrációs felületen is.&lt;/p&gt;

&lt;p&gt;Így az értékek benne vannak a globális névtérben, lookup-pal már hozzá is tudunk férni. Az alkalmazás az /earconfig címen tekinthető meg, és a következőt kell kiírnia:&lt;/p&gt;

&lt;pre&gt;
A projekt bemutatja, hogy hogyan lehet Java EE alkalmazásból konfigurációs paramétereket beolvasni.

    * System property EJB rétegben (kulcs: earconfig.system.property): Hello \
System Property!
    * Context lookup (JNDI) EJB rétegben (JNDI nevek: earconfig/string, \
 earconfig/url, earconfig/inetaddress, earconfig/properties): [Hello JNDI!, \
http://jtechlog.blogspot.com, 127.0.0.1, {key2=value2, key1=value1}]
    * System property web rétegben (kulcs: earconfig.system.property): Hello System Property!
    * Context lookup (JNDI) web rétegben (JNDI nevek: earconfig/string, \
 earconfig/url, earconfig/inetaddress, earconfig/properties): [Hello JNDI!, \
http://jtechlog.blogspot.com, 127.0.0.1, {key2=value2, key1=value1}]
&lt;/pre&gt;

&lt;p&gt;Persze &lt;a href="http://docs.jboss.org/jbossas/docs/Server_Configuration_Guide/4/html/Writing_JBoss_MBean_Services-A_Standard_MBean_Example.html"&gt;mi is írhatunk saját MBean-t&lt;/a&gt;, mely pakol a JNDI-be.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/5695982303749707840/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2011/02/konfiguracios-parameterek-ejb-retegben.html#comment-form' title='3 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/5695982303749707840'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/5695982303749707840'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/02/konfiguracios-parameterek-ejb-retegben.html' title='Konfigurációs paraméterek EJB és web rétegben JBoss alkalmazásszerveren'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://3.bp.blogspot.com/-lERPAF8FaWo/TXQUdpgWqEI/AAAAAAAAGBw/EAZE2IweFB4/s72-c/enc_overview.png' height='72' width='72'/><thr:total>3</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7968961481638103983</id><published>2011-02-22T00:18:00.003+01:00</published><updated>2012-12-22T14:43:10.729+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='vizsga'/><category scheme='http://www.blogger.com/atom/ns#' term='Oracle'/><category scheme='http://www.blogger.com/atom/ns#' term='Java EE'/><category scheme='http://www.blogger.com/atom/ns#' term='JPA'/><title type='text'>EJB és JPA Developer Certified Expert</title><content type='html'>&lt;p&gt;&lt;em&gt;Frissítés 2011. április 28.&lt;/em&gt;: ma jöttek meg a bizonyítványok, egy kártya és egy levél társaságában.&lt;/p&gt;

&lt;p&gt;2010. szeptember 2-án és 3-án tettem le a &lt;a href="http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=41&amp;p_org_id=1001&amp;lang=US&amp;p_exam_id=1Z0_895"&gt;Java Platform, Enterprise Edition 6 Enterprise JavaBeans Developer&lt;/a&gt;, régi nevén Sun Certified EJB Developer for the Java EE6 Platform (CX-311-093), és a &lt;a href="http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=41&amp;p_org_id=1001&amp;lang=US&amp;p_exam_id=1Z0_898"&gt;Java Platform, Enterprise Edition 6 Java Persistence API Developer&lt;/a&gt;, régi nevén Sun Certified JPA Developer for the Java EE6 Platform (CX-311-094) vizsgákat. A Java EE6 esetén vált a kettő külön, előtte egy volt, Sun Certified Business Component Developer (SCBCD) EE5 néven. Mindkettő vizsga béta vizsga, tehát a publikus kiadás előtt lehetett ezekre jelentkezni. Ez azt jelenti, hogy nem véglegesek a kérdések, erős fejlesztés alatt állnak, segíteni lehet az Oracle-nek egyrészt ezek tökéletesítésében, másrészt meg tudják határozni a nehézségi fokozatukat. A kérdések erőssége igen nagy szórású, vannak túl egyszerű, és túl nehéz kérdések is közöttük. Viszonylag alacsony áron lehet hozzájuk jutni (, ez esetemben 50$ volt vizsgánként - a Sun esetében ezek még ingyenesek voltak), viszont rengeteg kérdésere kell válaszolni (175 - 220), és kb. 5 óra van rájuk.&lt;/p&gt;

&lt;p&gt;A &lt;a href="http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=41&amp;p_exam_id=1Z0_860"&gt;SCBCD vizsga oldalán&lt;/a&gt; részletesebb listát lehet találni a tematikáról, és itt találhatóak &lt;a href="http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=303&amp;p_certName=SQ1Z0-860"&gt;példa kérdések&lt;/a&gt; is.&lt;/p&gt;

&lt;p&gt;A felkészülés során a JPA-t az &lt;a href="http://apress.com/book/view/9781430219569"&gt;Apress kiadó Pro JPA 2 Mastering the Java Persistence API&lt;/a&gt; könyvből tanultam, mely messze a legrészletesebb és legprofibb szakmai könyv, melyet valaha olvastam. Érződik, hogy nem csak azt írja le, hogy hogyan néz ki a szabvány, hanem azt is, hogy miért jutottak a tervezők arra a döntésre, valamint az implementációs különbségekről is lehet olvasni. A szakmai precizitás miatt persze nem mindenütt kellően olvasmányos, 10-15 oldalakon keresztül lazán elkalandozik az ember figyelme. Nálam fejezetek voltak, amik totálisan kiestek. Véleményem szerint a felkészüléshez bőven elegendő könyv. Jó EJB 3.1 könyv szerintem még nem jelent meg, így a &lt;a href="http://www.manning.com/panda/"&gt;Manning kiadó EJB 3 in Action&lt;/a&gt; könyvét ajánlom, valamint az EJB 3.1 felkészüléshez a &lt;a href="http://www.theserverside.com/news/1363656/New-Features-in-EJB-31"&gt;TheServerSide&lt;/a&gt; cikket, az &lt;a href="http://www.oracle.com/technetwork/articles/javaee/javaee6overview-141808.html"&gt;Oracle cikket&lt;/a&gt;, a specifikációt (&lt;a href="http://jcp.org/en/jsr/detail?id=318"&gt;JSR 318&lt;/a&gt;), valamint az &lt;a href="http://apress.com/book/view/9781430219545"&gt;Apress kiadó Beginning Java EE 6 Platform with GlassFish 3&lt;/a&gt; könyvét, nem is azért, mert annyira jó, hanem mert ez az elérhető egyetlen EJB 3.1 könyv. Létezik még EJB vonalon a OReilly Enterprise JavaBeans 3.0 (5th Edition), és az ingyen letölthető Mastering EJB 3.0 (4th Edition) könyv is, lapozgattam őket korábban, de a vizsgára készülésnél nem vettem elő őket. A JavaRanch-on is lehet találni nagyon sok &lt;a href="http://www.coderanch.com/how-to/java/ScbcdLinks#scbcd50"&gt;forrást&lt;/a&gt;, de szerintem ennyi időt már nem éri meg rá áldozni. Ami még sokat számított, az Enthuware's mock simulator, valamint ezúton szeretnék köszönetet mondani Karakó Miklósnak (alias palacsint), többek között a &lt;a href="http://palacsint.hu/blog/20100418/scbcd-jegyzetek"&gt;remek oldala&lt;/a&gt; miatt is. Én nem nagyon gyakorolgattam fejlesztőeszközzel, egy-két dolgot próbáltam ki NetBeans IDE és Glassfish környezetben.&lt;/p&gt;

&lt;p&gt;A körítés ugyanaz volt, mint az SCJP esetén, melyről már &lt;a href="http://jtechlog.blogspot.com/2009/10/scjp.html"&gt;korábban írtam&lt;/a&gt;.

&lt;p&gt;Sajnos a kérdések pontos számát nem tudom, mert nem írták ki előre, hanem a gép témakörönként adta ki, és nem tudtam megjegyezni a témakörönkénti kérdések számát. Érdekes, hogy az eredményen sem a valódi kérdések és helyes válaszok számát írták le, hanem a végleges vizsga 60 és 63 kérdése szerepel rajta, mindkét esetben 60%-ot kell teljesíteni a sikerességhez. Szerintem a JPA vizsga sokkal nehezebb, sokkal több tárgyi tudást és gyakorlatot igényel.&lt;/p&gt;

&lt;p&gt;Nagy negatívuma, hogy megterheli az embert, kb. 200 kérdés 5 órán keresztül nagyon fárasztó tud lenni. Míg az SCJP esetén nagyon sok időm maradt a végén, e kettő vizsgánál minden percet kihasználtam, úgy, hogy arra sem volt időm, hogy átnézzem a válaszokat, csak amiket elhalasztottam, azokon tudtam átrohanni. Igazából akkora engedmény sincs rajta, hiszen 300$ helyett 50$-t kell fizetni érte. Valamint nagy csúszás volt rajta, ugyanis az ígért 12 hét helyett, a 2010. szeptember elején letett béta vizsgák eredményeit 2011. február 4-én és február 11-én kezdték el kipostázni. A végleges vizsgák február 21-én éles üzembe álltak. (&lt;a href="http://blogs.oracle.com/certification/2011/02/0520.html"&gt;Bejelentés itt&lt;/a&gt;, belső technikai problémákra hivatkoznak.) Érdekes, hogy az &lt;a href="http://www.certmanager.net/sun"&gt;Oracle Certification Database - régebben Sun&lt;/a&gt; oldalon már a levél megérkezése előtt pár nappal fenn volt az eredmény a History-ban, de a Current Certifications panelen még a mai napig nem szerepelnek.&lt;/p&gt;

&lt;p&gt;További Java vizsgák az &lt;a href="http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=140"&gt;Oracle Certification Program / Oracle Middleware&lt;/a&gt; oldalon, valamint a &lt;a href="http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=42#2"&gt;Oracle Certification Program / Available Certification Exams&lt;/a&gt; oldalon.&lt;/p&gt;

&lt;p&gt;És pár érdekesség, melyekre a vizsgára való készülés közben bukkantam rá, vagy a vizsga közben tapasztaltam:&lt;/p&gt;

&lt;p&gt;EJB&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nagyon sok figyelmet fordít a role responsibility-re. Ez ugye azért meglepő, mert a könyvek szinte alig írnak róla, kizárólag a szabvány említi nagyon nagy pontossággal.&lt;/li&gt;
&lt;li&gt;CreateException, RemoveException, FinderException (ObjectNotFoundException) extends Exception - checked&lt;/li&gt;
&lt;li&gt;EjbException extends (indirect) RuntimeException&lt;/li&gt;
&lt;li&gt;EJBTransactionRolledbackException extends EJBException, megy a lokális klienseknek, ha rollback van, hogy a kliens tudja, hogy ne folytassa, hiszen úgyis rollback lesz - remote klienseknek TransactionRolledbackException megy&lt;/li&gt;
&lt;li&gt;RemoteException checked&lt;/li&gt;
&lt;li&gt;RemoteException-t nem dobhat bean, MDB bármi mást dobhat&lt;/li&gt;
&lt;li&gt;Az env-entry-type nem lehet primitív típus és Date sem&lt;/li&gt;
&lt;li&gt;EJB 3 meghívása 2-ből: PortableRemoteObject.narrow, ezt castolni, majd ezen create&lt;/li&gt;
&lt;li&gt;Never esetén, ha jön tranzakció: EJBException, mely system exception&lt;/li&gt;
&lt;li&gt;Nem feltétlenül lehet EJB-ből JMX-et hívni&lt;/li&gt;
&lt;li&gt;Üzenet kivétele nem része a tranzakciónak bean managed tranzakció esetén, tehát nincs redeliver&lt;/li&gt;
&lt;li&gt;Öröklődésnél a tranzakciós attribútumoknál az örökölt, de nem override-olt metódus tranzakciós attribútuma megmarad&lt;/li&gt;
&lt;li&gt;Interceptor csak olyan kivételt dobhat, mely deklarálva van az üzleti metódusban&lt;/li&gt;
&lt;li&gt;System exception esetén nem hívódnak meg az interceptor-ok&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JPA&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Viszonylag sokat kérdez rá a JPA 3.1 újdonságára, a Criteria API-ra. Nagyon kell ismerni a szintaktikáját, mert általában leír egy EJB QL kifejezést, és meg kell mondani, hogy melyik Criteria API kódnak felel meg. Gyakran egy metódushívás különbség van. Itt gyakorlatilag tippeltem, mert sosem használtam még élesben. Tippjeim kétharmada jött be.&lt;/li&gt;
&lt;li&gt;Sok figyelmet fordít a optimista és pesszimista lockolásra.&lt;/li&gt;
&lt;li&gt;Version attribute nem lehet secondary táblában&lt;/li&gt;
&lt;li&gt;Bármennyi MappedSuperclass lehet a hierarchiában&lt;/li&gt;
&lt;li&gt;Primary key-t a hierarchiában csak egyszer lehet definiálni&lt;/li&gt;
&lt;li&gt;A FETCH a JOIN után van a JPQL-ben&lt;/li&gt;
&lt;/ul&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/7968961481638103983/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2011/02/ejb-es-jpa-developer-certified-expert.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7968961481638103983'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7968961481638103983'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/02/ejb-es-jpa-developer-certified-expert.html' title='EJB és JPA Developer Certified Expert'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-100801776275799553</id><published>2011-02-05T21:11:00.004+01:00</published><updated>2013-12-23T20:38:49.369+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='jce'/><category scheme='http://www.blogger.com/atom/ns#' term='jca'/><category scheme='http://www.blogger.com/atom/ns#' term='security'/><title type='text'>Elektronikus aláírás és alkalmazása Java-ban, kulcskezelés</title><content type='html'>&lt;b&gt;A post-ot 2013. december 23-án frissítettem.&lt;/b&gt;

&lt;p&gt;Technológiák: JDK 1.6, JCA, JCE, keytool&lt;/p&gt;

&lt;p&gt;Az aláírás és a titkosítás már jóval a számítógépek megszületése előtt ismert volt. Az aláírással igazoljuk, hogy az aláírt dokumentumot elolvastuk, esetleg mi írtuk, és tartalmával egyetértünk. A titkosítás esetén azon dokumentumot titkosítjuk, melyről azt akarjuk, hogy egy adott célcsoporton kívül senki se férhessen hozzá a tartalmához.&lt;/p&gt;
&lt;p&gt;Mindez igaz az informatika világában is, és jelentőségük a hálózatok elterjedésével egyre fontosabb. Egyrészt felmerülnek ugyanazon problémák, mint a klasszikus esetben (pl. hamisíthatóság), valamint új problémák is megjelennek.&lt;/p&gt;
&lt;p&gt;Az aláírás céljai mindkét esetben a következők:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hitelesség (authenticity): a dokumentum származásának igazolása&lt;/li&gt;
&lt;li&gt;sérthetetlenség, integritás (integrity): a dokumentum tartalma nem változott annak aláírása óta&lt;/li&gt;
&lt;li&gt;letagadhatatlanság (non-repudiation): az aláíró nem tudja letagadni, hogy ő írta alá a dokumentumot, és az aláíró személy kiléte jogilag is bizonyítható eredjű&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A titkosítás ezen felül biztosítja:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;titkosság (privacy, confidentiality): a kommunikáló feleken kívül más nem szerezhet tudomást a dokumentum tartalmáról&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;Ez utóbbival foglalkozó tudományág a kriptográfia, mely az ógörög eredetű  szavakból származik, szó szerinti fordításban "titkosírás". Elsősorban informatikai jellegű, és nagyon erős matematikai háttérrel rendelkező területről van szó.&lt;/p&gt;
&lt;p&gt;Az elektronikus aláírás és a titkosítás két nagyon közel álló terület, ugyanazok a fogalmak, algoritmusok használtak mindkét esetben.&lt;/p&gt;

&lt;p&gt;A titkosítás esetén a feladó és a címzett fél is rendelkezik egy algoritmussal, a dokumentum kódolására és dekódolására. (A feladót a szakirodalomban gyakran Alice-nek, és a címzettet Bob-nak nevezik.) Mivel ilyen algoritmusok (függvény, és annak inverze) kitalálása bonyolult feladat, a matematikusok ezt feloldották azzal, hogy kiemelnek belőle egy részt, mely lehetővé teszi, hogy az algoritmusokat mindenki ismerhesse, de a titkosítás mégis működjön, és ez a rész szükség esetén (pl. ha kiderül), cserélhető is legyen. Ez a rész a kulcs, melyet ha csak a két fél ismer, a titkosítás biztosítva van. A kulcs cseréje gyors művelet, míg egy algoritmus kidolgozása, és helyességének bizonyítása sokkal nagyobb feladat. A titkosításnak azt a formáját, ahol egy közös kulcs van, szimmetrikus titkosításnak nevezzük. A kriptográfia egyik alterülete a nyilvános kulcsú titkosítás (aszimmetrikus titkosítás), mely arra ad megoldást, hogyha a feladó és a címzett fél nem tud személyesen találkozni, egy közös kulcsot egyeztetni. A megoldás az, hogy a feladónak és a címzettnek is van egy kulcspárja, a titkos és a publikus kulcs. A kettő matematikai kapcsolatban van egymással, de a nyilvános kulcs alapján gyakorlatilag nem lehet a titkos kulcsot meghatározni. A publikus kulcs terjeszthető, míg a titkos kulcsra nagyon kell vigyázni. Alice a saját titkos, és Bob publikus kulcsával, ha elkódol egy dokumentumot, azt csak Bob tudja kibontani a saját titkos kulcsával.&lt;/p&gt;

&lt;p&gt;Elektronikus aláírás esetén a előbb a dokumentumból egy lenyomat (hash) készül. A hash függvény egy olyan függvény, mely egy végtelen hosszúságú adatot véges hosszúságra képez le. A hash-ből a dokumentum nem visszanyerhető, már csak hossza miatt sem. A hash algoritmusokkal szemben elvárás, hogy lehetőleg gyorsak legyenek, és amennyiben a dokumentum változik, annak hash lenyomata is szignifikánsan változzon meg (lavinahatás). Valamint egy dokumentumhoz gyakorlatilag lehetetlen vele megegyező hash-ű értelmes dokumentumot legyártani, két dokumentum hash-e nagy valószínűséggel különbözzön (ütközésmentesség). (Megjegyzendő, hogy pl. hash-elést alkalmazunk autentikációnál is, ugyanis nem szükséges a felhasználó jelszavát elmenteni az informatikai rendszerekben, elegendő annak hash-ét. Bejelentkezéskor a jelszóból a rendszer egyből hash-t képez, melyet összehasonlít a tárolttal. Így az adminisztrátorok sem férhetnek hozzá a felhasználó jelszavához.) Az elektronikus aláírás során Alice a saját titkos és Bob publikus kulcsával titkosítja a hash-t. Bob elektronikus aláírás ellenőrzésekor egyrészt megkapja a dokumentumot, melyről ugyanazon hash algoritmussal ő is hash-t készít, és kititkosítja Alice által átküldött aláírást, és összehasonlítja az előbb kapott hash-sel. Amennyiben a kettő megegyezik, a dokumentumot biztos, hogy Alice látta el saját titkos kulcsával elektronikus aláírással, és a dokumentum közben nem változott.&lt;/p&gt;

&lt;p&gt;Gyakran előforduló fogalom még a Public Key Infrastructure (PKI) - nyilvános kulcsú infrastruktúra. Ez minden, mely szükséges a nyilvános kulcsú titkosításhoz. Ide tartozik pl. a háttérintézmények, eljárások, szabványok, szabályzatok, stb. Itt kerül megemlítésre a hitelesítésszolgáltató (certificate authority or certification authority - CA),  &lt;a href="http://jtechlog.blogspot.com/2008/12/minstett-elektronikus-alrs.html"&gt;róluk írtam már korábban&lt;/a&gt;. Ugyanis abban az esetben, ha Bob-nak nem Alice adja oda a publikus kulcsát, hanem egy rosszindulatú harmadik személy adja át a sajátját Alice nevében, akkor az Alice-nak szánt dokumentumokat képes ő kibontani. Ezért egy megbízható harmadik félre van szükség, aki igazolja, hogy az adott publikus kulcs kihez tartozik. Ez tanúsítvány formájában történik, mely tartalmazza az adott személy, vagy informatikai rendszer publikus kulcsát, annak adatait (pl. személy esetében nevét, de web szerver esetén a domain nevet), és a hitelesításszolgáltató ezt elektronikusan aláírja.&lt;/p&gt;

&lt;p&gt;Nézzük, milyen szabványokat, algoritmusokat érdemes ismerni ezzel kapcsolatban. Hash algoritmusok, többek között:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MD5: 2005 óta elektronikus aláírás területen használata nem javasolt, 32 karakter hosszú hexadecimális hash&lt;/li&gt;
&lt;li&gt;SHA-1: 2010 december 31-ével elektronikus aláírás területen használata nem javasolt&lt;/li&gt;
&lt;li&gt;SHA-256&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Szimmetrikus kulcsú titkosító algoritmusok, többek között:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RC2, RC4: RSA cég által kifejlesztett algoritmusok.&lt;/li&gt;
&lt;li&gt;DES (Data Encription Standard): az amerikai kormány szinte "hivatalos" rejtjelező eljárásként minősítette, így rendkívül elterjedt.&lt;/li&gt;
&lt;li&gt;3DES (triple-DES): a DES lassanként megfáradt, törése elérhető közelségbe került, így jelentős számú továbbfejlesztett változata jelent meg, de gyakorlatban a 3DES terjedt el, mely egymás után háromszor használja az algoritmust (encrypt - decrypt - encrypt). Szokták három különböző kulccsal és két különböző kulccsal (első és az utolsó egyezik meg) is használni. Előnye, hogy a DES infrastruktúra maradhat, csupán többször alkalmazzák az algoritmust.&lt;/li&gt;
&lt;li&gt;AES (Advanced Encryption Standard): National Institute of Standards and Technology (NIST) által specifikált, amerikai kormány által elfogadott algoritmus a DES leváltására, eredetileg Rijndael néven pályáztak vele.&lt;/li&gt;
&lt;li&gt;Blowfish&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Aszimmetrikus kulcsú titkosító algoritmusok, többek között:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RSA: Egyik leggyakrabban használt titkosítási eljárás, de facto szabvány, matematikai alapjait a moduláris- és a prímszámelmélet egyes tételei jelentik, faktorizáción (prím tényezőkre bontáson) alapul. Míg a prím számokkal való szorzás egyszerű, a prím tényezős felbontásra nincs hatékony algoritmus, ha egy szám két igen nagy prímszám szorzata, akkor ennek prímtényezős felbontása rendkívül sokáig tart. 2000-ben lejár a szabadalmi védelme.&lt;/li&gt;
&lt;li&gt;Digital Signature Algorithm (DSA): NIST javasolta, és az USA digitálisaláírás-szabványává vált (Digital Signature Standard (DSS), specifikálva a FIPS 186-ban, azóta FIPS 186-3-ban).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Az aszimmetrikus titkosító algoritmusok hátránya, hogy sokkal lassabbak a szimmetrikus kulcsú titkosító algoritmusokhoz képest. Ezért pl. az SSL azt a trükköt alkalmazza, hogy kapcsolat felvételekor PKI-t használ, de lekommunikálnak egy szimmetrikus kulcsot, és a továbbiakban azzal, szimmetrikus titkosítással történik a kommunikáció.&lt;/p&gt;

&lt;p&gt;Az elektronikus aláírás és titkosítás területének egyik legismertebb szabványosító testülete az RSA Security, mely nemcsak az RSA algoritmust dolgozta ki, de ő hozta létre a széles körben alkalmazott és implementált &lt;a href="http://www.rsa.com/rsalabs/node.asp?id=2124"&gt;PKCS szabványcsaládot&lt;/a&gt;, mely jelenleg 15 tagból áll, bár van közöttük, ami már érvénytelen. Ennek pl. első eleme a PKCS #1, ami az RSA algoritmus, és az RFC 3447 definiál.&lt;/p&gt;

&lt;p&gt;Az X.500 szabvány hálózati szabványok gyűjtője, és része az X.509 szabvány is, mely definiálja többek között a tanúsítvány formátumát is. Ahogy említettem, a tanúsítvány tartalmaz a publikus kulcson kívül leíró adatokat is, pl. itt kell megemlíteni a hagyományos X.500 distinguished name-t (DN), melyet címtár szolgáltatásokban (pl. LDAP esetén elterjedt) használatos egyedi azonosítóként fejlesztettek ki, mellyel hierarchikus struktúrát lehet megadni, ezek közül a leggyakoribbak az ország (C - country), állam vagy tartomány (ST - state or province), város (city or locality - L), szervezet (O - organization), szervezeti egység (OU - organization unit) és általános név (CN - common name). Ezzel lehet megadni a tanúsítvány tulajdonosát, de magát a tanúsítványkiadót is. Ezen kívül olyanokat tartalmaz még a tanúsítvány, mint a szabvány verziószáma, algoritmus, kiadó, érvényesség, stb., és ezt írja alá a tanúsítványt kiadó. A tanúsítvány kiadójának szintén lehet tanúsítványa, melyet egy másik tanúsítány kiadó adott ki. Az így összeállt láncot hívják tanúsítványláncnak. Érdemes még írni a visszavonási listákról (CRL) is. Hogy a rendszer le legyen védve az ellen, hogy egy kulcspárt ellopnak, és visszaélnek vele, bevezették a visszavonási lista fogalmát. Az eltulajdonított tanúsítványokat be lehet jelenteni, ekkor a visszavonási listára kerül. Ami ezen rajta van, az ahhoz tartozó aláírásokat nem lehet elfogadni. Mivel az eltulajdonítás ténye nem derül ki azonnal, bevezették a kivárási idő fogalmát. Aláírás ellenőrzéskor ugyanis nem szabad azonnal elfogadni azt, hanem ki kell várni a kivárási időt. Ha a tanúsítvány utána sem kerül visszavonási listára, az aláírás elfogadható. A visszavonási listánál korszerűbb és rugalmasabb megoldás az OCSP használata. Az OCSP szolgáltatás használatával rákérdezhetünk egy tanúsítvány visszavonási állapotára, és azonnal hiteles és aláírt választ kapunk. Így nem kell eltelnie a kivárási időnek.&lt;/p&gt;

&lt;p&gt;Másik tanúsítvány formátum a PKCS #12.&lt;/p&gt;

&lt;p&gt;Amikor egy https oldalt nézünk, akkor a háttérben ssl vagy tls titkosított protokollon történik a kommunikáció, mely szintén használja a PKI-t, így szintén tanúsítványokkal dolgozik. A böngészőben ezt a tanúsítványt meg tudjuk nézni. Nézzük meg pl. a https://www.netlock.net/ cím tanúsítványát.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://1.bp.blogspot.com/-45dUkqFWFJE/UriQ2LYVngI/AAAAAAAALEw/LG_hNJ2bptY/s1600/netlock_tanusitvany_2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/-45dUkqFWFJE/UriQ2LYVngI/AAAAAAAALEw/LG_hNJ2bptY/s320/netlock_tanusitvany_2.png" /&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;Látható, hogy a lánc három elemből áll, NetLock Arany (Class Gold) Főtanúsítvány, NetLock Üzleti (Class B) tanúsítványkiadó, valamint a www.netlock.hu tanúsítványokból. Mindegyik adatait le lehet kérni. Akkor hiteles egy tanúsítvány, ha a kibocsájtó tanúsítványa is hiteles. Viszont a gyökér elemnél már nincs kiadó (pontosabban a kiadója saját maga), így annak hitelességét más úton kell garantálni. A böngészők esetében alapesetben benne van egy halom hitelesítésszolgáltató, vagy ha nincs benne, manuálisan fogadhatjuk azt el.&lt;/p&gt;

&lt;p&gt;Az X.509 tanúsítványokat különböző tároló formátumokban tárolhatjuk. Exportálható DER bináris formátumban, vagy ennek BASE64-gyel kódolt variánsában (PEM), vagy PKCS#12 formátumban. Base64 esetén az állományban valami hasonlót látunk:&lt;/p&gt;

&lt;pre&gt;
-----BEGIN CERTIFICATE-----
MIIHfzCCBmegAwIBAgIOSd0P5gz1tLCtWdzTs8EwDQYJKoZIhvcNAQELBQAwgakx
...
EWE+wAfK6TOVlqZIykQxcCU+uzYBR+l0WGYKmNUi3bfXKt0YttWHZ2OHB4UXGtjm
ZBtg
-----END CERTIFICATE-----
&lt;/pre&gt;

&lt;p&gt;Ezt kicsomagolva Base64-gyel egy bináris DER állományt kapunk. Ezt is ki lehet bontani, pl. &lt;a href="http://certlogik.com/decoder/"&gt;webes szolgáltatás&lt;/a&gt; is van rá. Ekkor láthatjuk a felépítését szövegesen is.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://2.bp.blogspot.com/-S0cGchJPL4s/UriQ95tEjEI/AAAAAAAALE4/HqPqHC7wIXE/s1600/netlock_tanusitvany_kibontva_2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://2.bp.blogspot.com/-S0cGchJPL4s/UriQ95tEjEI/AAAAAAAALE4/HqPqHC7wIXE/s320/netlock_tanusitvany_kibontva_2.png" /&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;Látható a használt hash és titkosító algoritmus is: sha256WithRSAEncryption, valamint a kiadó és a tárgy DN-je is.&lt;/p&gt;

&lt;p&gt;Egy egyszeri Java programozó mikor is találkozhat ezzel? Többször, mint gondolnánk:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Applet, Java Web Start, JAR aláírása&lt;/li&gt;
&lt;li&gt;Aláírás/titkosítás alkalmazásból&lt;/li&gt;
&lt;li&gt;SSL kommunikáció konfigurálása Web konténerben, szerver oldali tanúsítvánnyal&lt;/li&gt;
&lt;li&gt;Web alkalmazásnál kliens oldali tanúsítványok használata autentikációhoz&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Java-ban az elektronikus aláírás és titkosítás, a Java Cryptography Architecture (JCA), és Java Cryptography Extension (JCE) API-k segítségével történik. Ezek klasszikus értelemben vett API-k, azaz interfészt biztosítanak, provider-based architecture-t valósítanak meg, azaz az alatta lévő implementáció cserélhető, akár csak a JDBC esetén a driver. Egyik eszköze a Factory design pattern, azaz nem kell az objektumot példányosítani, hanem egy Factory végzi el nekünk a különböző konfigurációk alapján (pl. melyik az elérhető és kiválasztott implementáció).&lt;/p&gt;

&lt;p&gt;Ahhoz, hogy megértsük, hogy miért alakult ki a JCA és a JCE is, vissza kell kicsit menni az időben. Régebben a titkosító algoritmusokra Amerikában nagyon szigorú export korlátozások voltak érvényben. A JCA kizárólag aláírásra használható, nem lehetséges vele, és az alapját képző algoritmusokkal titkosítani. Sőt, nem hogy titkosító algoritmusokat nem lehetett exportálni, de olyan keretrendszereket sem, melyekbe ezek beilleszthetőek. Ezért a JCE külön keretrendszer volt (optional package), melyet külön kellett letölteni és telepíteni. A Java 1.4-től kezdve azonban integrálták a JDK-ba, a SunJCE provider-rel együtt. Alapban egy un. restricted policy fájllal együtt települ, mely korlátozza bizonyos algoritmusok és kulcsméretek használatát. Persze a legtöbb országból letölthető az un. unrestricted policy fájl, mely már engedélyezi ezeket. Ez a &lt;a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html"&gt;letöltések között&lt;/a&gt; Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files 6 néven megtalálható. Ezen kívül telepíthető a JCE alá bármilyen aláírt provider, melyhez van unrestricted policy fájl.&lt;/p&gt;

&lt;p&gt;A Sun-os JDK-ban alapértelmezetten megtalálható egy Sun implementáció is, mind a JCA (SUN), mind a JCE alá (SunJCE). Természetesen alternatív megvalósítást is telepíthetünk, pl. választhatjuk a &lt;a href="http://www.bouncycastle.org/java.html"&gt;Bouncy Castle&lt;/a&gt;-t. Mivel ezt ausztrálok fejlesztették, így nem vonatkozik rá az amerikai export korlátozás. Ami még megragadhatja a figyelmünket ezzel kapcsolatban: Generators/Processors for OpenPGP (RFC 2440).&lt;/p&gt;

&lt;p&gt;Nagy vonalakban a SUN JCA implementáció tartalmazza az MD5 és SHA1 hash-függvényeket, valamint a DSA aláíró algoritmus egy implementációját. Valamint képes kezelni az X.509 tanúsítványláncokat és tartalmazza a JKS kulcsadatbázis implementációt. A SunJCE tartalmazza a DES, 3DES, Blowfish szimmetrikus rejtjelező algoritmusokat, az RSA aszimmetrikus titkosító algoritmust, JCEKS biztonságosabb kulcsadatbázis implementációt, stb. A JCA és JCE dokumentációja is összeolvadt már a Java 6-ban, megtalálható a &lt;a href="http://download.oracle.com/javase/6/docs/technotes/guides/security/"&gt;biztonsággal foglalkozó specifikációkban&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ahhoz, hogy a PKI-t használatba vehessük, először egy kulcspárra van szükségünk. Ezek tárolására a kulcstár szolgál, mely tárolja a privát és publikus kulcsokat, tanúsítványokat, stb. Több implementáció közül is lehet választani, az alapértelmezett a JKS (Java keystore). Ez két szintű jelszóval védett tároló, ugyanis van egy mester jelszó, mellyel a kulcstárhoz lehet hozzáférni, és minden kulcspárhoz is lehet külön jelszót rendelni (ezt akkor kell megadni, mikor a titkos kulcshoz történik hozzáférés). A kulcstárak kezelésére a &lt;a href="http://download.oracle.com/javase/6/docs/technotes/tools/windows/keytool.html"&gt;keytool&lt;/a&gt; eszköz való, mellyel lehet kulcspárokat létrehozni, exportálni, importálni, listázni, törölni, stb. A keytool viszonylag bő paraméterezési lehetőséggel rendelkezik, de rengeteg paraméternek alapértelmezett értéke van, így nem kell mindent megadni. Amennyiben bizonyos paramétereket nem adunk meg, interaktív módon rákérdez.&lt;/p&gt;

&lt;p&gt;A következő paranccsal hozzunk létre egy JKS kulcstárat, és benne egy kulcspárat. Ekkor létrejön egy mykeystore állomány, storepass jelszóval. Benne egy tanúsítvány SHA1withDSA hash és titkosító algoritmussal, mely jtechlog néven elérhető, és a jelszava keypass. A tanúsítvány un. önaláírt (self-signed), ami azt jelenti, hogy a tanúsítványhoz tartozó titkos kulccsal lett aláírva.&lt;/p&gt;
&lt;pre&gt;
keytool -genkeypair -dname "cn=Viczian Istvan, ou=JTechLog, o=Blog, c=HU"
  -alias jtechlog -keypass keypass -keystore .\mykeystore
  -storepass storepass -validity 180
&lt;/pre&gt;
&lt;p&gt;Amennyiben ki akarjuk listázni a keystore tartalmát, a következő parancsot adjuk ki, és a következő kimenetet látjuk.&lt;/p&gt;
&lt;pre&gt;
keytool -list -keystore mykeystore -storepass storepass

Keystore type: JKS
Keystore provider: SUN

Your keystore contains 1 entry

jtechlog, 2011.02.05., PrivateKeyEntry,
Certificate fingerprint (MD5): 8B:FF:C4:FA:38:E7:45:59:64:18:AE:99:F4:F4:80:11
&lt;/pre&gt;
&lt;p&gt;Amennyiben a kiválasztott tanúsítvány részleteit akarjuk kiírni, adjuk ki a következő parancsot:&lt;/p&gt;
&lt;pre&gt;
keytool -list -keystore mykeystore -storepass storepass -alias jtechlog -v

Alias name: jtechlog
Creation date: 2011.02.05.
Entry type: PrivateKeyEntry
Certificate chain length: 1
Certificate[1]:
Owner: CN=Viczian Istvan, OU=JTechLog, O=Blog, C=HU
Issuer: CN=Viczian Istvan, OU=JTechLog, O=Blog, C=HU
Serial number: 4d4d689a
Valid from: Sat Feb 05 16:11:22 CET 2011 until: Thu Aug 04 17:11:22 CEST 2011
Certificate fingerprints:
         MD5:  8B:FF:C4:FA:38:E7:45:59:64:18:AE:99:F4:F4:80:11
         SHA1: 4B:C9:1F:8C:5B:A8:27:44:C8:B5:21:F9:F3:75:8F:E8:A6:07:8A:03
         Signature algorithm name: SHA1withDSA
         Version: 3
&lt;/pre&gt;

&lt;p&gt;Látható, hogy a kiadó és a tulajdonos ugyanaz, tehát tényleg egy önaláírt tanúsítványról van szó. Ezt ki is tudjuk exportálni az X.509 szabványnak megfelelően, akár Base64, akár DER bináris formátumban. Alapértelmezett a bináris, a -rfc kapcsolóval tudjuk kiexportálni a Base64 formátumban.&lt;/p&gt;

&lt;pre&gt;
keytool -exportcert -keystore mykeystore -storepass storepass -alias jtechlog
  -rfc -file jtechlog.cer
&lt;/pre&gt;

&lt;p&gt;Ezt természetesen ugyanúgy lehet a böngészőbe importálni.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;a href="http://1.bp.blogspot.com/_czKgycLvmNo/TU2sQ84OEYI/AAAAAAAAF0k/eieBV-o0KUA/s1600/jtechlog_tanusitvany.png" imageanchor="1"&gt;&lt;img src="http://1.bp.blogspot.com/_czKgycLvmNo/TU2sQ84OEYI/AAAAAAAAF0k/eieBV-o0KUA/s320/jtechlog_tanusitvany.png" border="0" alt="Importált tanúsítvány" /&gt;&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Ha hiteles tanúsítványt szeretnénk, akkor a tanúsítványunkat egy hitelesítésszolgáltatónak is alá kell írnia. Ehhez először egy un. kérvényt (csr - &lt;a href="http://en.wikipedia.org/wiki/Certificate_signing_request"&gt;Certificate signing request&lt;/a&gt;) kell készítenünk, és beküldenünk a hitelesítésszolgáltatónak. Ez a PKCS #10 specifikációnak megfelelő formátumban teszi.

&lt;pre&gt;
keytool -certreq -keystore mykeystore -storepass storepass -keypass keypass
  -alias jtechlog -file jtechlog.csr
&lt;/pre&gt; 

&lt;p&gt;Ennek tartalma szintén egy bináris állomány Base64-gyel kódolva, a következő formátumban:&lt;/p&gt;

&lt;pre&gt;
-----BEGIN NEW CERTIFICATE REQUEST-----
MIICTDCCAgoCAQAwSDELMAkGA1UEBhMCSFUxDTALBgNVBAoTBEJsb2cxETAPBgNVBAsTCEpUZWNo
...
AhQJp7pADvkSv8V5rzZFwv0kj/w+aA==
-----END NEW CERTIFICATE REQUEST-----
&lt;/pre&gt;

&lt;p&gt;Erre a hitelesítésszolgáltató egy felülhitelesített tanúsítványt küld vissza a megfelelő azonosítás és díjfizetés után. Szerencsére lehetőség van a hitelesítésszolgáltatóktól teszt tanúsítványt is igényelni. A NetLock esetén pl. egy &lt;a href="https://www.netlock.hu/index.cgi?lang=HU&amp;amp;tem=ANONYMOUS/online/online_indul.tem"&gt;űrlapon&lt;/a&gt; az e-mail címünket megadni, majd oda kapjuk a további instrukciókat. Első körben le kell tölteni a NetLock Teszt Tanúsítványkiadó &lt;a href="http://www.netlock.hu/index.cgi?raw&amp;amp;ca=teszt3&amp;amp;lang=HU"&gt;tanúsítványát&lt;/a&gt;, majd letölthetjük a kapott teszt tanúsítványt. (Zárójelben megjegyzem, hogy ugyanilyen teszt tanúsítvány a &lt;a href="http://srv.e-szigno.hu/menu/index.php?lap=teszt_igenyles"&gt;Microsec honlapjáról&lt;/a&gt; is letölthető.) A NetLock által kiadott teszt tanúsítvány SHA-256 hash algoritmust és 2048 bit hosszú RSA kulcspárt használ.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;a href="http://4.bp.blogspot.com/_czKgycLvmNo/TU2scTiz2vI/AAAAAAAAF0s/0M9h87Jp_SA/s1600/netlock_teszt_tanusitvany.png" imageanchor="1"&gt;&lt;img src="http://4.bp.blogspot.com/_czKgycLvmNo/TU2scTiz2vI/AAAAAAAAF0s/0M9h87Jp_SA/s320/netlock_teszt_tanusitvany.png" border="0" alt="Teszt tanúsítvány" /&gt;&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Ez a böngészőbe települ, ahonnan PKCS #12 formátumban tudunk tanúsítványt exportálni. Ebben azonban a titkos kulcs is benne van, hiszen csak így tudjuk megfelelően felhasználni. Szerencsére a keytool már ismeri a PKCS #12 formátumot is, csak a &lt;code&gt;-storetype PKCS12&lt;/code&gt; paramétert kell használnunk. A böngészőből tehát mentsük ki a tanúsítványt PKCS #12 formátumban, jtechlog-netlock-test.p12 néven, és adjunk meg egy jelszót: storepass. Listázzuk ki a tartalmát a keytool segítségével.&lt;/p&gt;

&lt;pre&gt;
keytool -list -keystore jtechlog-netlock-test.p12  -storetype PKCS12
  -storepass storepass

Keystore type: PKCS12
Keystore provider: SunJSSE

Your keystore contains 1 entry

netlock teszt aláíró tanúsítvány netlock kft. azonosítója, 2011.02.05., PrivateKeyEntry,
Certificate fingerprint (MD5): 92:4F:6A:DA:0F:29:99:F9:73:C5:AF:7E:2E:AF:AC:A8
&lt;/pre&gt;

&lt;p&gt;A tanúsítványt a titkos kulccsal át is importálhatjuk a saját keystore-unkba.&lt;/p&gt;

&lt;pre&gt;
keytool -importkeystore -deststorepass storepass -destkeypass keypass
  -destkeystore mykeystore -srckeystore jtechlog-netlock-test.p12
  -srcstoretype PKCS12 -srcstorepass storepass
  -alias "netlock teszt aláíró tanúsítvány netlock kft. azonosítója"
&lt;/pre&gt;

&lt;p&gt;Ez után ha kilistázzuk a kulcstárunkat, láthatjuk, hogy benne van. Ahhoz, hogy használatba tudjuk venni, a NetLock Teszt Tanúsítványkiadó tanúsítványát is ki kell mentenünk a böngészőből ("NetLockTeszt(ClassT3)CA.crt") néven, majd azt is importáljuk a kulcstárunkba.&lt;/p&gt;

&lt;pre&gt;keytool -importcert -keystore mykeystore -storepass storepass
  -alias netlockteszt -file "NetLockTeszt(ClassT3)CA.crt"

Owner: EMAILADDRESS=info@netlock.hu, CN=NetLock Teszt (Class T3) CA, OU=Tanúsítványkiadó, O=NetLock Kft., L=Budapest, C=HU
Issuer: EMAILADDRESS=info@netlock.hu, CN=NetLock Teszt (Class T3) CA, OU=Tanúsítványkiadó, O=NetLock Kft., L=Budapest, C=HU
Serial number: 49ac23040010
Valid from: Mon Mar 02 19:18:44 CET 2009 until: Sat Mar 01 19:18:44 CET 2014
Certificate fingerprints:
         MD5:  47:A8:6B:D3:09:74:60:CD:F4:FF:C1:D6:08:0D:20:BE
         SHA1: 90:AD:6E:9B:6E:EE:DC:10:32:65:A2:8D:AD:8C:D1:D3:E0:E6:A4:58
         Signature algorithm name: SHA256withRSA
         Version: 3

Extensions:

#1: ObjectId: 2.5.29.15 Criticality=true
KeyUsage [
  Key_CertSign
  Crl_Sign
]

#2: ObjectId: 2.5.29.19 Criticality=true
BasicConstraints:[
  CA:true
  PathLen:4
]

#3: ObjectId: 2.5.29.14 Criticality=false
SubjectKeyIdentifier [
KeyIdentifier [
0000: 08 8B 02 68 AA 5B 9D BF   2E 11 4B 02 39 34 23 85  ...h.[....K.94#.
0010: 9B B4 95 D6                                        ....
]
]

Trust this certificate? [no]:
&lt;/pre&gt;

&lt;p&gt;Látható, hogy importáláskor megkérdezi, hogy megbízunk-e a tanúsítványba, azaz a beszerzési forrásunk megbízható volt. A JDK alapértelmezetten tartalmazza több hitelesítésszolgáltató tanúsítványát. Egyrészt vannak rendszerszintű tanúsítványok, valamint vannak felhasználóhoz tartozó tanúsítványok. Ezeket a &lt;a href="http://download.oracle.com/javase/6/docs/technotes/guides/deployment/deployment-guide/jcp.html#security"&gt;Java Control Panel-en&lt;/a&gt; is fel lehet venni. A rendszer szintűek a JRE lib\security könyvtárban vannak, jelszava changeit. A felhasználói szintű tanúsítványok a Unix-on a ${user.home}/.java/deployment/security könyvtárban, Windows-on a ${deployment.user.home}\security könyvtárban vannak (pl. "C:\Documents and Settings\vicziani\Application Data\Sun\Java\Deployment\security\trusted.certs"), ezeknek nincs jelszavuk.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;a href="http://1.bp.blogspot.com/_czKgycLvmNo/TU2sqJcZwNI/AAAAAAAAF00/aFYq-jdOZmk/s1600/java_control_panel.png" imageanchor="1"&gt;&lt;img border="0" src="http://1.bp.blogspot.com/_czKgycLvmNo/TU2sqJcZwNI/AAAAAAAAF00/aFYq-jdOZmk/s320/java_control_panel.png" alt="Java Control Panel" /&gt;&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Kilistázva a kulcstárunkat láthatjuk, hogy már három tanúsítvány van a kulcstárunkban:&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;netlock teszt aláíró tanúsítvány netlock kft. azonosítója: NetLock hitelesítésszolgáltató teszt tanúsítvány&lt;/li&gt;
 &lt;li&gt;jtechlog: önaláírt tanúsítvány, privát kulccsal&lt;/li&gt;
 &lt;li&gt;netlockteszt: netlock által számomra kiosztott teszt tanúsítvány, privát kulccsal&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;
keytool -list -keystore mykeystore -storepass storepass

Keystore type: JKS
Keystore provider: SUN

Your keystore contains 3 entries

netlock teszt aláíró tanúsítvány netlock kft. azonosítója, 2011.02.05., PrivateKeyEntry,
Certificate fingerprint (MD5): 92:4F:6A:DA:0F:29:99:F9:73:C5:AF:7E:2E:AF:AC:A8
jtechlog, 2011.02.05., PrivateKeyEntry,
Certificate fingerprint (MD5): 8B:FF:C4:FA:38:E7:45:59:64:18:AE:99:F4:F4:80:11
netlockteszt, 2011.02.05., trustedCertEntry,
Certificate fingerprint (MD5): 47:A8:6B:D3:09:74:60:CD:F4:FF:C1:D6:08:0D:20:BE
&lt;/pre&gt;

&lt;p&gt;Aki nem akar parancssorból bajlódni, az használhatja a grafikus &lt;a href="http://portecle.sourceforge.net/"&gt;Portecle&lt;/a&gt; alkalmazást is.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://3.bp.blogspot.com/-CRU7fwEPRG4/UriRBU50jdI/AAAAAAAALFA/eU35p6PYjOA/s1600/portecle.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://3.bp.blogspot.com/-CRU7fwEPRG4/UriRBU50jdI/AAAAAAAALFA/eU35p6PYjOA/s320/portecle.png" /&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;Megjegyzem, hogy az openssl is képes X.509 és PKCS #12 tanúsítványokat, valamint PKCS #10 Certificate signing request-eket használni, melyek kezelhetők a keytool-lal.&lt;/p&gt;

&lt;p&gt;Az, hogy hogyan használjuk fel ezeket a kulcsokat, egy későbbi post témája lesz.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/100801776275799553/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2011/02/elektronikus-alairas-es-alkalmazasa.html#comment-form' title='5 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/100801776275799553'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/100801776275799553'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/02/elektronikus-alairas-es-alkalmazasa.html' title='Elektronikus aláírás és alkalmazása Java-ban, kulcskezelés'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://1.bp.blogspot.com/-45dUkqFWFJE/UriQ2LYVngI/AAAAAAAALEw/LG_hNJ2bptY/s72-c/netlock_tanusitvany_2.png' height='72' width='72'/><thr:total>5</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-70696356624550932</id><published>2010-12-18T09:04:00.010+01:00</published><updated>2011-01-22T11:44:36.906+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Community'/><title type='text'>Legjobb fejlesztő 2010 verseny tapasztalatok</title><content type='html'>2010. szeptemberében került kiírásra a &lt;a href="http://java2010.legjobbfejleszto.com/"&gt;Legjobb fejlesztő 2010&lt;/a&gt; verseny, melyről már korábban is &lt;a href="http://jtechlog.blogspot.com/2010/09/legjobb-fejleszto-2010-java-programozo.html"&gt;hírt adtam&lt;/a&gt;. Az &lt;a href="http://www.ipsystems.hu/"&gt;IP Systems Kft.&lt;/a&gt; szervezte, és egy &lt;a href="http://java2010.legjobbfejleszto.com/feladat"&gt;valós probléma&lt;/a&gt; leegyszerűsített változatát kellett megoldani egy konkrét alkalmazás kifejlesztésével.
&lt;p&gt;Az IP Systems Kft. engem is meghívott a zsűritagok közé, és megoldások értékelésnél egy bonyolult szempontrendszert sikerült kidolgoznunk. Három fő szempont alapján pontoztuk a megoldásokat, melyeket további alszempontokra bontottunk. A három fő szempont az üzleti funkciók kidolgozottsága és az ergonomikus felhasználói felület, a technológiai megoldás, valamint a forráskód minősége. Ezen szempontok közül én a technológiai megoldást pontoztam, mely során a következőket értékeltem:
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;Java SE ismerete (a versenyző mennyire ismeri és használja jól a standard API-t, milyen interfészeket, osztályokat választ, és azokat hogyan használja, nem rekedt-e meg az 1.4-es Java-nál)&lt;/li&gt;
&lt;li&gt;Szabványoknak való megfelelőség&lt;/li&gt;
&lt;li&gt;3rd party komponensek, könyvtárak kiválasztása és használata&lt;/li&gt;
&lt;li&gt;Rétegekre bontás (hiszen főleg webes alkalmazásokkal indultak a versenyzők), milyen az alkalmazás belső szerkezete, mennyire moduláris, a modulok saját, jól körülhatárolt feladattal rendelkeznek-e, és milyen függőségben vannak egymással&lt;/li&gt;
&lt;li&gt;Hiba és kivételkezelés&lt;/li&gt;
&lt;li&gt;Van-e az alkalmazásban szűk keresztmetszet, első ránézésre performancia problémát okozó kódrészletek&lt;/li&gt;
&lt;li&gt;Mennyire lehet információkat megtudni az alkalmazás futásáról, mennyire támogatja a hibakeresést, naplózás technikai megvalósítása és tartalma&lt;/li&gt;
&lt;li&gt;Hogyan épül fel a projekt és a build folyamat, mennyire alkalmazkodik a konvenciókhoz.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A verseny hírlevelére közel 300-an regisztráltak, végül 14-en adtak be megoldást (ebből sajnos egyet nem sikerült elindítani, hisz nem felelt meg a feltételeknek), illetve egyvalaki versenyen kívül.&lt;/p&gt;
&lt;p&gt;Technológiai megkötés nem volt, lényeg, hogy Java-ban legyen implementálva. Nem volt kötelező a webes alkalmazás, csak preferált. Kiemeltük, hogy egy paranccsal build-elni lehessen a projektet, és egyszerűen telepíthető legyen. A teszt környezet Windows, Internet hozzáféréssel, Internet Explorer-rel (bekapcsolat JavaScript-tel). Build-eléshez Ant és Maven előre telepített volt. Web konténer az Apache Tomcat, alkalmazásszerver GlassFish volt. Nem volt kötelező adatbázist használni, amennyiben mégis szükség volt rá, MySQL, PostgreSQL és Oracle Express Edition állt rendelkezésre. Ezekhez csak DataSource-on keresztül lehetett hozzáférni, ez és a szükséges driver előre telepített volt. Adatbázis sémát létrehozni és azt kezdő adatokkal feltölteni az alkalmazásnak kellett. Mindenkit bíztattunk a proaktivitásra, hogy kérdezzen.&lt;/p&gt;
&lt;p&gt;Már a technológiai kérdések között is feltűnő volt, hogy a legtöbben a build-re és a deploy-ra kérdeztek rá, ez utóbbival kapcsolatban is speciálisan a DataSource használatára, úgy látszik, koránt sem olyan evidens. Többen féltek attól, hogy mi van, ha nem sikerül a build vagy a deploy folyamat (mint később kiderült, jogosan). Valaki rákérdezett, hogy az előfordítási folyamatok is a build részét képezzék-e (pl. GWT compile). Kérdés volt, hogy a Maven kap-e internet hozzáférést, és milyen repository-k vannak bekonfigurálva. Volt, aki a build folyamat részeként szerette volna a deploy-t is elvégezni, akár a DataSource konfigurációval, akár az adatbázis séma létrehozással egyetemben. Páran fennakadtak azon, hogy az adatbázist és bele a rekordokat az alkalmazásnak kell létrehoznia. (Igaz, hogy ez éles környezetben nem javasolt, itt csak a saját dolgunkat akartuk megkönnyíteni.) Volt valaki, aki már látott olyant, hogy az alkalmazás és az adatbázis között tűzfal van, ami elvághatta a kapcsolatot, megbolondítva ezzel a connection pool-t, így arra kérdezett rá, hogy fel kell-e erre készülni, JDBC URL-ben ki lesz védve, vagy manuálisan kell vizsgálnia a kapcsolat érvényességét. (Amúgy nem volt tűzfal, de ha van, akkor mi a DBCP pool esetén a validation query-t szoktuk használni.) Többen próbálták a határokat kitolni, pl. Flex-ben fejleszteni a felületet (végül nem jött ilyen megoldás), Scala használata, vagy az üzleti logika letolása PL/SQL rétegbe, triggerekbe (ezt nem támogattuk, hiszen a Java tudásra voltunk kiváncsiak). Csak egy kérdező volt, akinek nagyobb rendszerben szerzett üzemeltetési tapasztalata lehetett, és méretezésre, rendelkezésre állásra kérdezett rá, valamint arra, hogy egyenletes-e a terhelés (sajnos ő később nem adott be megoldást). Egy kérdés érkezett arra, hogy mennyire kell optimalizálni, adatbázis indexeket használni, cache-elni. Szintén egy kérdező volt, akinek portál tervezési tapasztalatai lehettek, így felmerült az xhtml, kikapcsolt cookie-k, captcha, többnyelvűség, akadálymentesítés (egyik sem volt követelmény). Több kérdés volt a böngésző kompatibilitásra is. Volt kérdés az autentikációval (pl. egy felhasználónak több session-je) és jogosultságkezeléssel (JAAS), valamint a konkurrenciával kapcsolatban is (meglepően kevés). Egy kérdés érkezett, hogy https lesz-e, illetve egy ember kérdezte, hogy a SQL injection-re fel kell-e készülni. Az is kiderült, hogy a fejlesztők nem maguknak szeretnek megjegyzéseket használni, hanem rákérdeznek, hogy kötelező-e. Itt is volt olyan hang, aki nem 3rd party framework-öt használt, hanem saját fejlesztésűt kívánt bevetni. &lt;/p&gt;
&lt;p&gt;És akkor jöjjön néhány adat, hogy ki és mit használt, valamint néhány tapasztalat ezzel kapcsolatban.&lt;/p&gt;
&lt;p style="text-align: center;"&gt;&lt;img src="http://chart.apis.google.com/chart?chs=400x200&amp;amp;cht=p&amp;amp;chd=s:CDBC&amp;amp;chl=Eclipse+%284%29%7CNetBeans+%285%29%7CIDEA+%281%29%7CIsmeretlen+%284%29&amp;amp;chtt=IDE&amp;amp;chts=676767,12.5" alt="IDE" /&gt;&lt;/p&gt;
&lt;p&gt;A fejlesztőeszköz területén nem volt nagy meglepetés, a NetBeans és Eclipse fej-fej mellett, valamint egy IDEA felhasználó. A többi projektről nem derült ki, pl. Maven-nel fordult, és csak a Maven-es pom.xml volt a projektben.&lt;/p&gt;
&lt;p style="text-align: center;"&gt;&lt;img src="http://chart.apis.google.com/chart?chs=400x200&amp;amp;cht=p&amp;amp;chd=s:EBCBB&amp;amp;chl=MySQL+%287%29%7CPostgreSQL+%282%29%7COracle+%283%29%7CEmbedded+-+H2+%281%29%7CNincs+%281%29&amp;amp;chtt=Adatb%C3%A1zis&amp;amp;chts=676767,12.5" alt="Adatbázis" /&gt;&lt;/p&gt;
&lt;p&gt;Adatbázisok közül egyértelműen a MySQL volt a legnépszerűbb. Meglepő volt számomra, hogy beágyazott adatbázist csak egy versenyző használt. Az ő munkája ilyen szempontból kiemelkedő volt, Maven-nel Jetty-t indított, és H2 beágyazott adatbáziskezelőt. Ez a megoldást nagyon kényelmes volt, hiszen nem kellett telepíteni, konfigurálni, hanem azonnal indult. Jó lett volna, ha több ilyen megoldást kapunk. Érdekes még, hogy nem vártunk el adatbázis kapcsolatot, és csak egy versenyző merte ezt mégis megrizikózni. Természetesen nem kapott ezért kevesebb pontot, hiszen nem volt követelmény. Egyszerűen Java Collections Framework-kel oldotta meg a tárolást.&lt;/p&gt;
&lt;p style="text-align: center;"&gt;&lt;img src="http://chart.apis.google.com/chart?chs=420x200&amp;amp;cht=p&amp;amp;chd=s:ECBC&amp;amp;chl=Tomcat+%286%29%7CGlassfish+%284%29%7CJetty+%281%29%7CVastag+%283%29&amp;amp;chtt=Alkalmaz%C3%A1sszerver&amp;amp;chts=676767,12.5" alt="Alkalmazásszerver" /&gt;&lt;/p&gt;
&lt;p&gt;Alkalmazásszerverek, pontosabban web konténerek és alkalmazásszerverek között a Tomcat volt a favorit, ami nem meglepő. Igaz, hogy csak ezt a két választási lehetőséget adtuk, de a sok alkalmazásszerver engedélyezése nagyban megnehezítette volna az értékelést. Volt érdeklődő, aki pl. JBoss-t is szívesen használt volna, de mivel az nem volt opció, a Seam-et, EJB3-astúl, JSF-estűl rágyógyította a Tomcat-re. Érdekes, hogy a Glassfish választása nem hozta magával az EJB vagy a JSF használatát, volt aki Hibernate-et használt Glassfish-on, volt, aki Spring-et. Hárman nem is webes, hanem Swing-es alkalmazást készítettek.&lt;/p&gt;
&lt;p style="text-align: center;"&gt;&lt;img src="http://chart.apis.google.com/chart?chs=400x200&amp;amp;cht=p&amp;amp;chd=s:EDB&amp;amp;chp=0.1&amp;amp;chl=Ant+%287%29%7CMaven+%285%29%7CNincs+%282%29&amp;amp;chtt=Build&amp;amp;chts=676767,12.5" alt="Build" /&gt;&lt;/p&gt;
&lt;p&gt;A legnagyobb csalódást a build folyamatok és a telepítés (deploy) okozták. Különösen úgy, hogy kizárással fenyegettünk, ha valakinek nem fordult egy paranccsal, és nem lehetett a kimenetet azonnal telepíteni, vagy futtatni. Ha ezt betartottuk volna, a pályaművek felét ki kellett volna zárnunk. Látható, hogy még mindig az Ant vezeti a mezőnyt, és volt, aki nem is használt build eszközt (na jó, a Maven több,  project management and comprehension tool). A legtöbben nem tudták, hogy hogyan is érdemes a DataSource-t Tomcat-ben definiálni, vagy hogyan szokás, és hogyan kell használni. (Erről írtam &lt;a href="http://jtechlog.blogspot.com/2009/01/jndi-nevek-tomcat-alatt.html"&gt;korábban&lt;/a&gt;.) Több helyen kellett manuálisan szerkesztenem a context.xml állományt, pedig erre nincs szükség. Erről még részletesebben fogok értekezni egy későbbi bejegyzésben. Volt, akinek problémát okozott, hogy hol érdemes az adatbázist inicializálni, hol lehet az alkalmazás indulását észlelni.&lt;/p&gt;
&lt;p&gt;Sajnos többen is függtek a fejlesztőeszköztől vagy a környezettől, azaz meg kellett adni a NetBeans vagy a Glassfish telepítési mappáját. Sajnos a NetBeans alapból olyan projektet készít, amiben vannak abszolút hivatkozások. Valamint szükség van egy JAR-ra is a fordításhoz. Többen ezt nem vették figyelembe. Volt persze helyes megoldás is, a JAR-t csatolni kell, és build-kor egy környezeti változót felüldefiniálni: -Dlibs.CopyLibs.classpath="lib\org-netbeans-modules-java-j2seproject-copylibstask.jar". Ez persze a NetBeans szégyene, az érdekes, hogy erről több versenyző nem tudott. Javasolt volt pedig egy üres (legalábbis virtuális) gépen kipróbálni a build folyamatot. Összességében látható, hogy a fiatalabb fejlesztők nem fektetnek annyi hangsúlyt a build folyamatra, a hordozhatóság sérült, ezzel pl. egy continuous integration rendszerbe való bekötés lehetősége is.&lt;/p&gt;
&lt;p&gt;Volt olyan aki külön projektbe tette a teszt eseteket. Volt, aki olyan technológiát használt (DataNucleus), melyhez nem volt Maven plugin, így Ant-ot kellett hívni java task-kal. Volt, akinél a build folyamat nem talált megfelelő artifact-ot a Maven repository-ban. Feltehetőleg magának a lokális repository-ba feltelepítette, és erről megfeledkezett. Egy versenyző azon bukott meg sajnos, hogy nem lehetett build-elni, és azonnal telepíteni az alkalmazását.&lt;/p&gt;
&lt;p style="text-align: center;"&gt;&lt;img src="http://chart.apis.google.com/chart?chs=400x200&amp;amp;cht=p&amp;amp;chd=s:CCBE&amp;amp;chp=0.1&amp;amp;chl=Log4J+%283%29%7Cjava.util.Logging+%283%29%7CEgy%C3%A9b+%281%29%7CNincs+%287%29&amp;amp;chtt=Napl%C3%B3z%C3%A1s&amp;amp;chts=676767,12.5" alt="Naplózás" /&gt;&lt;/p&gt;
&lt;p&gt;Ismét egy nagy csalódás. A versenyzők java nem naplózott. Aki használta is, az is inkább kötelességből, vagy a fejlesztőeszköz generálta oda. Úgy látszik, hogy nem érezték szükségét az értelmezhető napló állománynak, támogatva ezzel a visszakövethetőséget. Volt AOP-os megoldás is (interceptor-ral), mely azt írta ki, hogy melyik metódus lett meghívva. Ez üzletileg kevés információt tartalmaz, talán érdemes kiegészíteni egyedi napló üzenetekkel is, melyek az üzleti folyamatokról és modellről adnak bővebb információkat.&lt;/p&gt;
&lt;p style="text-align: center;"&gt;&lt;img src="http://chart.apis.google.com/chart?chs=400x200&amp;amp;cht=p&amp;amp;chd=s:DBF&amp;amp;chp=0.1&amp;amp;chl=JUnit+%285%29%7CTestNG+%281%29%7CNincs+%288%29&amp;amp;chtt=Teszt+esetek&amp;amp;chts=676767,12.5" alt="Naplózás" /&gt;&lt;/p&gt;
&lt;p&gt;Ez is érdekes, hogy teszt esetek írásával kevesen töltötték az idejüket, dacára annak, hogy mostanában a csapból is ez folyik. Akik mégis írtak ilyeneket, azoknál is volt, ahol keveredett a unit teszt és az integrációs teszt fogalma. Mock keretrendszer is csak egy munkában volt (EasyMock).&lt;/p&gt;
&lt;p style="text-align: center;"&gt;&lt;img src="http://chart.apis.google.com/chart?chs=400x200&amp;amp;cht=p&amp;amp;chd=s:CCCBBB&amp;amp;chp=0.1&amp;amp;chl=JPA+-+Hibernate+%283%29%7CJPA+-+EclipseLink+%284%29%7CJDBC+%283%29%7CJDO+%281%29%7CHibernate+%282%29%7CNincs+%281%29&amp;amp;chtt=Adatb%C3%A1zis+el%C3%A9r%C3%A9s&amp;amp;chts=676767,12.5" alt="Adatbázis elérés" /&gt;&lt;/p&gt;
&lt;p&gt;Dícsérendő, hogy sokan használtak ORM réteget. Látható, hogy a szabvány nagy úr, a JPA használata messze leelőzte a Hibernate-et, és JDO-ból is csak egy volt. Az, hogy a JPA implementációk közül a EclipseLink vagy a Hibernate-e a nyerő, ebből nem megállapítható, hiszen a kiírásban Glassfish alkalmazásszerver szerepelt, melynek a beépített JPA provider-e az EclipseLink, így egy kicsit torzít. Szép megoldások születtek, de a JPA 2 nyomait még nem nagyon találtam.&lt;/p&gt;
&lt;p style="text-align: center;"&gt;&lt;img src="http://chart.apis.google.com/chart?chs=400x200&amp;amp;cht=p&amp;amp;chd=s:CBBF&amp;amp;chl=EJB3+%283%29%7CSpring+%282%29%7CSeam+%281%29%7CNincs+%288%29&amp;amp;chtt=%C3%9Czleti+logika+r%C3%A9teg&amp;amp;chts=676767,12.5" alt="Üzleti logika réteg" width="400" height="200" /&gt;&lt;/p&gt;
&lt;p&gt;Szintén egy meglepő eredmény. És az is látszik, hogy a szabvány itt is tarol. Érdekes, hogy a Dependency Injection, Inversion of Control még nincs mindenkinek az eszköztárában, és nem hiányzik, ahogy az interfészekkel való programozás sem valósul meg mindenütt.&lt;/p&gt;
&lt;p style="text-align: center;"&gt;&lt;img src="http://chart.apis.google.com/chart?chs=400x200&amp;amp;cht=p&amp;amp;chd=s:EBCBBB&amp;amp;chp=0.1&amp;amp;chl=JSF+%286%29%7CVaadin+%282%29%7CSwing+%283%29%7CSpring+MVC+%281%29%7CGWT+%281%29%7CServlet%2FJSP+%281%29&amp;amp;chtt=UI+r%C3%A9teg&amp;amp;chts=676767,12.5" alt="UI réteg" /&gt;&lt;/p&gt;
&lt;p&gt;Itt már nagyobb a szórás, de itt is az látszik, hogy a szabvány (JSF) szignifikánsan vezet. A számomra oly kedvelt, illetve az oly sokszor emlegetett keretrendszerek (Spring MVC, GWT, Struts, Tapestry, Wicket) sehol sincsenek. Ezen érdemes egy kicsit elgondolkodni, hogy milyen irányba is érdemes menni, ha a piacon lévő fiatalabb fejlesztők ilyen ismeretekkel rendelkeznek. Persze a JSF sem olyan homogén, használt keretrendszerek: RichFaces (hárman is!), Seam, Trinidad, PrimeFaces, Facelets. Mondjuk túl messzemenő következtetéseket ne vonjunk le, hiszen a versenyzők maguk is bevallották, hogy sokan a verseny feladaton próbálták ki a kiválasztott keretrendszert, és nem rendelkeztek sok tapasztalattal.&lt;/p&gt;
&lt;p&gt;Persze a legtöbb webes felület AJAX-os volt, de főleg Java-s keretrendszer biztosította, és nem natívan került felhasználásra, JavaScript-et nagyon kevesen írtak. Egy műben szerepelt alacsony szinten megvalósítva, ebben DWR, JQuery és JAXB is volt. Szerencsére azt is ritkán láttam, hogy Java kód keveredett volna HTML-lel.&lt;/p&gt;
&lt;p&gt;A Swing-es alkalmazásokból hiányoltam a szálkezelést, a konkurencia kezelését.&lt;/p&gt;
&lt;p&gt;Olyan érdekes technológiák, könyvtárak és eszközök is megjelentek, mint az Envers entitások auditálására, JRebel a fejlesztési ciklus gyorsítására, DataNucleus az adatok perzisztálására, Hazelcast elosztott cache.&lt;/p&gt;
&lt;p&gt;Amit még meg kell említeni, az a jogosultságkezelés. Egy Spring Security volt, egy JBoss Rules-zal megvalósított nagyon egyedi megoldás és egy JAAS. A többiek teljesen egyedileg programozták le. Úgy tűnik ezen a területen sincs még joker megoldás.&lt;/p&gt;
&lt;p&gt;A kivételkezelés is ad-hoc módon történt, érződött, hogy sok helyen csak azért van, mert nem lehet kikerülni, általában nem jól átgondolt stratégiával történt, tisztelet a kivételnek.&lt;/p&gt;
&lt;p&gt;Ami számomra hatalmas pozitívum, hogy egyrészt a Java nyelvben otthonosan mozogtak a versenyzők, Java SE programozási hibát, melléfogást nem találtam. Copy-paste-et szintén nem. Bár egyértelmű, hogy az újrahasznosítás Java kódban sokkal szebb volt sokaknál, mint a felhasználói felületben. Valamint a keretrendszerek megtanulásával együtt a fiatal fejlesztők megtanulják az alapvető architektúrális felépítéseket, sőt nagyon sokat alkalmaztak akár GoF, akár J2EE tervezési mintákat is. Az alkalmazásokat viszonylag szépen rétegekre bontották. Érdekes, hogy a GoF tervezési mintákat főleg a vastag kliensekre találták ki, a legtöbb példa is a Swing-ben található Java-ban, mégis a vastag klienses megoldásokra se rétegek, se a tervezési minták használata nem volt jellemző.&lt;/p&gt;
&lt;p&gt;A díjkiosztó is nagyon kellemesre sikeredett, jó volt megismerkedni a versenyzőkkel, megismerni a véleményüket a feladattal kapcsolatban, és hallgatni, hogy mivel gyűlt meg a legtöbb bajuk. Jó hír, hogy nem technológiát mondtak, hanem inkább az üzleti problémán kellett többet gondolkodniuk.&lt;/p&gt;
&lt;a href="http://2.bp.blogspot.com/_czKgycLvmNo/TQxrRC6fUsI/AAAAAAAAFm0/L71Gvu0eJ-A/s1600/dijkioszto.jpg" rel="lightbox"&gt;&lt;img style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 320px; height: 214px;" src="http://2.bp.blogspot.com/_czKgycLvmNo/TQxrRC6fUsI/AAAAAAAAFm0/L71Gvu0eJ-A/s320/dijkioszto.jpg" alt="Díjkiosztó" id="BLOGGER_PHOTO_ID_5551930381225120450" border="0" /&gt;&lt;/a&gt;
&lt;p&gt;Összességében elmondható, hogy nagyon tanulságos verseny volt, számunkra, mint zsűri számára, és úgy ítélem, a versenyzők számára is. Én személy szerint egy kicsit több pályaművet vártam, nem tudom, hogy mivel lehetett volna még több versenyzőt elcsábítani, hogy mutassa meg tudását. Szerintetek?&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/70696356624550932/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html#comment-form' title='20 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/70696356624550932'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/70696356624550932'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html' title='Legjobb fejlesztő 2010 verseny tapasztalatok'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://2.bp.blogspot.com/_czKgycLvmNo/TQxrRC6fUsI/AAAAAAAAFm0/L71Gvu0eJ-A/s72-c/dijkioszto.jpg' height='72' width='72'/><thr:total>20</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4133758495264721147</id><published>2010-11-14T20:58:00.004+01:00</published><updated>2010-12-19T00:08:20.002+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Oracle'/><category scheme='http://www.blogger.com/atom/ns#' term='Java EE'/><category scheme='http://www.blogger.com/atom/ns#' term='Community'/><title type='text'>Oracle Java Cafe</title><content type='html'>&lt;p&gt;Az Oracle újraszervezte a Java Cafe napot, melynek első eseménye 2010. november 12-én, pénteken volt. Erre kedden kaptam először meghívót, szokatlanul későn. Sajnos az eseménynek sem weblapja nincs, sem azt nem tudom, hogy hogyan lehet a listára feliratkozni.&lt;/p&gt;
&lt;p&gt;Az esemény 13:00-ig tartott, és négy előadás hangzott el. A megnyitót Gere István, az Oracle Oktatási Igazgatója nyitotta, hallottunk a Java múltjáról, az Oracle elkötelezettségéről, valamint arról, hogy az Oracle még több erőforrással kívánja fenntartani a platform fejlődését. Ennek egyik oka, hogy a Java az Oracle egyik legsikeresebb portfóliójának, a Fusion Middleware-nek az alapja. A Fusion Middleware nem más, mint azon Oracle termékek gyűjtője, ami nem adatbázis, és Oracle Applications. A SOA őrületet próbálja megvalósítani, így tartalmazza egy SOA implementációhoz szükséges összes komponenst, kezdve az alap infrastruktúrától (pl. alkalmazásszerver, identity, cache, grid, stb.) egyre feljebb, mint pl. integrációs eszközök (aszinkron üzenetküldés, ESB, BPEL, registry, stb.), folyamat irányítás, üzleti szabályok, egészen a legmagasabb szintig, mint üzleti intelligencia, content management, portál. De magába foglalja a fejlesztőeszközöket és felügyeleti eszközöket is. Sok név ismerős lehet az időközben felvásárol BEA-tól, pl. JRockit, Weblogic, vagy a még régebbi Tuxedo, de itt szerepelnek a tradicionális Oracle termékek is, mint az Oracle Application Server, ADF, JDeveloper, Forms és Reports services, Discoverer, stb.&lt;/p&gt;
&lt;p&gt;Az első előadást &lt;a href="http://blogs.oracle.com/nagy/"&gt;Nagy Péter&lt;/a&gt; tartotta a Java múltjáról, jelenéről és jövőjéről. Itt már több technológiáról esett szó, bár főleg olyan információk hangoztak el, melyek a neten már megtalálhatóak voltak. Az Oracle a felvásárlással most két Java Virtuális Géppel rendelkezik, a Sun-féle HotSpot, és a BEA-féle JRocket. A kettőt össze szeretnék fésülni, hogy csak egy legyen, és természetesen az nyílt forrású &lt;a href="http://openjdk.java.net/"&gt;OpenJDK&lt;/a&gt; projekt keretein belül. (Mellyel kapcsolatban a hét híre, hogy az Oracle és az Applce &lt;a href="http://hup.hu/cikkek/20101114/az_apple_es_az_oracle_openjdk_projektet_jelentett_be_az_os_x-hez"&gt;bejelentette&lt;/a&gt; az OpenJDK Project-et Mac OS X-re. A JDK-nak lesz fizetős változata is, melyhez az Oracle hozzáadott szolgáltatásokat biztosít, pl. előbbi hibajavításokat, valamint support-ot. Az Oracle a JavaFX-et is &lt;a href="http://www.javafx.com/roadmap/"&gt;kiemelt helyen kezeli&lt;/a&gt;. Látszik, hogy tervezik a JavaFX 2.0-t, a JavaFX UI nyílt forráskódú lesz, valamint különös hangsúlyt fordítanak a NetBeans alapú fejlesztő eszközre is. Ingyenes előadás is lesz ezzel kapcsolatban, &lt;a href="http://eventreg.oracle.com/webapps/events/ns/EventsDetail.jsp?p_eventId=116172&amp;src=7038703&amp;src=7038703&amp;Act=49"&gt;OTN Developer Day – Java FX&lt;/a&gt; címmel, mely sajnos már betelt.&lt;/p&gt;
&lt;p&gt;Fejlesztőeszközből szintén nőtt a kínálat. A NetBeans lenne a támogatott, belépő szintű fejlesztőeszköz. Viszont aki ki akarja használni a Fusion Middleware-t, annak JDeveloper-t ajánlott telepítenie. Persze az Eclipse tábor is kap egy Enterprise Pack for Eclipse-t. Az alkalmazás szervereknél sem lesz összefésülés, a GlassFish marad a belépő szintű termék, a referencia implementáció, és ennek is lesz kereskedelmi verziója support-tal, gyorsabb hibajavításokkal, valamint management eszközzel. A GlassFish 3.1 is &lt;a href="http://dlc.sun.com.edgesuite.net/glassfish/3.1/promoted/"&gt;elérhető már&lt;/a&gt; early access-ként, és már támogatja a cluster-ezést. Persze a nagyágyú a WebLogic marad, mely a Fusion Middleware támogatott alapja. Ha nem is lesz egybeolvadás, lesznek az alkalmazásszervereknek közös kódrészletei. Ugyanúgy stratégia irány a mobil fejlesztés is, valamint megjelent egy &lt;a href="http://www.oracle.com/us/products/middleware/exalogic/index.html"&gt;Exadata&lt;/a&gt; megoldás is, melyről &lt;a href="http://blogs.oracle.com/zfekete/2010/11/video_a_sysman_exadata_demo_ce.html"&gt;magyar videó is van&lt;/a&gt;. Ez gyakorlatilag egy összehangolt hardver és szoftver megoldás, mely irgalmatlan teljesítményre képes. Ez most az Oracle zászlóshajója a Cloud Computing témakörben.&lt;/p&gt;
&lt;p&gt;Kérdések között felmerült, hogy mi a helyzet az Oracle Forms, Reports és Discoverer-rel? Az Oracle gondolkozott a kivezetésén, térítve az embereket a Java technológia irányába, azonban ez sikertelen, hiszen rengeteg létező, futó alkalmazás van már megvalósítva ezen technológiákkal. Tehát ezek élnek, fejlődnek (11g), Fusion Middleware részét képzik, &lt;a href="http://www.oracle.com/technetwork/middleware/upgrade-092995.html"&gt;lehet már WebLogic-ra migrálni&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Majd Gere István beszélt az Oracle University SUN Java oktatási portfóliójáról. Érezhető, hogy az Oracle komolyan veszi ezt a területet, négy partnerrel együttműködve végzik az oktatásokat. A tanulási lehetőségek szerteágazóak. Egyrészt a legismertebb a tantermi képzések. Ezen kívül lehetséges az e-learning is, Live Virtual Class néven fut. Lehet self study CD-ket is rendelni, melyek használatával a hallgató maga készülhet fel. Valamint létezik egy Knowledge Center is, melyről előfizetés ellenében lehet mindenféle anyagot letölteni.&lt;/p&gt;
&lt;p&gt;Az oktatási portfóliót is eléggé megvariálták, alkalmazkodtak az Oracle Associate/Professional/Master szintjeihez (, bár ezek korábban is megvoltak a Sun-nál). Az első szint kb. azt jelenti, hogy képben vagy, a második szinten tesztet kell kitölteni, és azt jelenti, hogy ismered a specifikációkat, és a harmadik szint jelenti, hogy képes vagy komplex feladatokat is megoldani. (Itt kapsz egy önállóan megoldandó feladatot, majd igazolnod kell esszékérdésekre válaszolva, hogy te oldottad az meg.) A képzéseket, és a képzéshez tartozó vizsgákat tartalmazó dokumentumot később fogják szétküldeni.&lt;/p&gt;
&lt;p&gt;Következő előadás a Java Master és Oracle Junior képzésről szólt, és Nagy Kálmán (Medusoft Kft.) tartotta. Ennek keretében 2x12 ifjú titánt képeznek 4 (elmélet) + 3 (gyakorlat) hétig. Az elején gyakorlatilag megkapják a hivatalos Oracle tanfolyamokat, majd utána egy projektmunkában vehetnek részt. Itt nem csak a szabvánnyal ismerkedhetnek meg, hanem build, continuous integration eszközökkel, teszteléssel, stb. Nemsokára indul a marketing kampány.&lt;/p&gt;
&lt;p&gt;Az utolsó előadást &lt;a href="http://www.delicious.com/sngeza"&gt;Simon Géza&lt;/a&gt; tartotta (Medusoft Kft.), "JavaEE 6: kevesebb kódolás - több eredmény" címmel. A címet &lt;a href="http://blogs.sun.com/arungupta"&gt;Arun Gupta&lt;/a&gt;: Java EE6=Less Code+More Power előadása alapján választotta, mely hazánkban is &lt;a href="http://www.oracle.com/global/hu/education/eblast/hu_emea_ou_oracle_arungupta_011010_ol.html"&gt;meghallgatható lesz&lt;/a&gt; november 25-26-ig. Az előadás a &lt;a href="http://en.wikipedia.org/wiki/Java_EE_version_history"&gt;Java EE 6&lt;/a&gt; érdekesebb újdonságait villantotta fel, melyek célja a még több automatikus ellenőrzés.&lt;/p&gt;
&lt;p&gt;Az EJB egyik legnagyobb újdonsága a Singleton Session Bean, mellyel megvalósítható, hogy az adott Bean-ből JVM-enként csak egy példány létezzen. Itt problémát első sorban a párhuzamosság okozhat, hiszen ugyanazon objektumhoz több szál is hozzáférhet. Pesze erre is van több megoldás, egyik a @Lock annotáció, konténer által vezérelt szinkronizáció estén, valamint használhatjuk a klasszikus synchronized kulcsszót a bean vezérelt szinkronizáció esetén (ezt inkább ne is használjuk). Másik érdekesség a @Asynchronous annotáció, ilyenkor nem kell JMS-t, sorokat használni az aszinkron híváshoz.&lt;/p&gt;
&lt;p&gt;A Java EE egyik új szabványa a Contexts and Dependency Injection for Java (Web Beans 1.0) JSR 299. A szabvány vezetője a RedHat/JBoss volt. Egyrészt megpróbálja egységesíteni a DI-t, ezzel versenybe szállni azokkal a keretrendszerekkel, melyek ezt magasabb szinten űzték (pl. Spring, Guice, stb.). Másrészt kiterjeszti az EJB-ben szereplő DI-t, ugyanis az nagyon korlátozott funkcionalitással rendelkezett, hiszen csak pár komponensben elérhető. Követi az EJB alapkoncepcióját, hogy legyenek intelligens default értékek, ne kelljen konfigurálni, viszont, ha szükség van rá, akkor legyen lehetőség a testreszabásra, akár külön XML állományban is (beans.xml). A szabvány referencia implementációja a &lt;a href="http://seamframework.org/Weld"&gt;Weld&lt;/a&gt;, mely a Seam keretében lett kitalálva, és ezért remekül integrálható vele. A &lt;a href="http://seamframework.org"&gt;Seam&lt;/a&gt; nem más, mint a JBoss megoldása, nyílt forráskódú keretrendszere RIA alkalmazások fejlesztésére. Integrálja az összes réteget, pl. EJB 3.0, JPA, JSF, AJAX, sőt Business Process Management (BPM), ezáltal egy komplett megoldást nyújtva. A Weld amúgy integrálható a Java EE 5 alkalmazás szerverekbe is. Ezáltal minden rétegben, minden objektumban elérhetővé válik a DI, nem csak EJB-ben, vagy servlet-ben. A context, másképpen scope arra utal, hogy mennyi a bean-ek élettartama, lehet request, session, stb., sőt, saját context-et is definiálhatunk. Szintén ismert benne az események fogalma. Annotációkkal használhatjuk, type safe, és akár saját eseményt is definiálhatunk, méghozzá úgy, hogy nem csak annotációt használunk, hanem saját annotációt hozunk létre.&lt;/p&gt;
&lt;p&gt;Szó esett a RESTful web szolgáltatásokról, hiszen a Java EE már a JAX-RS szabványt is tartalmazza. Erről korábban már &lt;a href="http://jtechlog.blogspot.com/2009/12/restful-web-szolgaltatasok-jersey-vel.html"&gt;itt a blogon is&lt;/a&gt; volt szó, ezt nem részletezném. Remekül illik a Java EE architektúrába, egyszerű, annotációkkal konfigurálható, stb.&lt;/p&gt;
&lt;p&gt;Volt szó még a Bean Validation-ről, mely feladata az olyan kényes kérdés megválaszolása, hogy hol és hogyan ellenőrizzük a beadott adatokat. Közel a felülethez, hogy a felhasználó mielőbb választ kapjon? Vagy az adatbázisnál, hogy ne kerüljön hibás adat mentésre? A válasz, hogy legyen ez az adatot hordozó bean-be, majd itt már az a réteg hívhatja meg, amelyik csak akarja. Deklaratív, annotációval adható meg pár előre definiált ellenőrzés. Saját ellenőrzéseket is bevezethetünk, szintén saját annotációk implementálásával (én itt vesztettem el az érdeklődésemet). Emiatt szintén type safe. Lehetőség van persze feltételes ellenőrzések megadására is.&lt;/p&gt;
&lt;p&gt;Említésre került a JPA 2 két sokak által várt újdonsága, egyrészt a rendezett kollekciók, másrészt a Criteria API. Valamint elhangzott, hogy a GlassFish 3.1 is kipróbálható.&lt;/p&gt;
&lt;p&gt;Lesz december 9-én egy 1 napos szeminárium Swiss knife for Java EE6 címmel is, melynek célja, hogy bemutassanak olyan, a gyakorlatban rendszeresen felmerülő problémákat (és lehetséges megoldásaikat), amelyekhez egy kicsit többre van szükség, mint a JavaEE szabvány ismerete. Lesz szó minél hatékonyabb adatbázis-elérésről, adatbázis séma verziózásról, keretrendszerek összehasonlításáról, tesztelésről, forráskód-kezelésről, automatikus fordításról-csomagolásról. &lt;span style="font-weight:bold;"&gt;Update:&lt;/span&gt; Az eseményről bővebben az &lt;a href="http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getCourseDesc?dc=D70301_1397068_HU&amp;p_org_id=8&amp;lang=HU"&gt;Oracle-nél&lt;/a&gt;.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/4133758495264721147/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/11/oracle-java-cafe.html#comment-form' title='3 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4133758495264721147'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4133758495264721147'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/11/oracle-java-cafe.html' title='Oracle Java Cafe'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>3</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-214682897237729794</id><published>2010-10-25T00:39:00.006+02:00</published><updated>2011-08-08T22:54:19.233+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><title type='text'>Release Maven-nel és Hudson-nel</title><content type='html'>&lt;p&gt;Technológiák: Maven 2.2.1, Maven Release Plugin 2.1 , Hudson 1.381, Hudson M2 Release Plugin 0.6.1&lt;/p&gt;
&lt;p&gt;A &lt;a href="http://en.wikipedia.org/wiki/Software_release_life_cycle"&gt;Wikipedia szerint &lt;/a&gt; a release, vagy magyarul a &lt;a href="http://hu.wikipedia.org/wiki/A_szoftverkiad%C3%A1s_%C3%A9letciklusa"&gt;szoftverkiadás&lt;/a&gt; valamely szoftvertermék és a hozzá tartozó különböző kötelező anyagoknak (média, dokumentáció) a terjesztése. Ír magáról a szoftverkiadás életciklusáról, mely különböző szakaszokból áll (viszonylag szigorúan definiálja ezeket, azonban a valóságban nem annyira szokták ennyire tartani, így értelmezni, és így nevezni ezeket). Ezen a szakaszok az IBM hardverfejlesztési ciklusából öröklődtek. Első szakasz az alfa változat, mely megfelel a legfontosabb funkcionális követelmények. A következő szakasz a béta, mely mely során már minden funkciót tartalmaz, de lehetnek benne hibák, nem elég stabil éles üzemre. Lehetnek zárt és nyilvános béták is, attól függően, hogy a felhasználók mely csoportja vehet részt a tesztelésben. A web 2.0 világában gyakran belefuthatunk béta alkalmazásokba, mely gyakorlatilag a fejlesztőknek ad némi szabadságot, hogy ne kelljen bizonyos hibákkal, támogatással foglalkozni, hanem az érdekesebb funkciókra helyezhessék a hangsúlyt, és nekünk is jelzi, hogy lehetnek problémák, leállások. A béta után jön a kiadásra jelölt (release candidate), mely már a fejlesztők által késznek nyilvánított, ismert hibát nem tartalmaz, melyet javítani kéne. Ezután mehet aranyra (vagy másképp RTM - release to manufacturing/marketing), majd a terjesztés üzleti előkészítése után kiadásra kerül az általánosan elérhető (GA - General availability/acceptance). Persze itt nem áll meg a fejlesztés, sorban jöhetnek ki a hibajavítások, új verziók, egészen a szoftver kivezetéséig (end of life).&lt;/p&gt;
&lt;p&gt;Esetünkben a release elkészítése nem más, mint azon ismétlődő tevékenységek elvégzése, mely lehetővé teszi a szoftver, és a hozzá tartozó különböző matériák terjesztését. A release során  előállnak elő az alfa, béta, stb. kiadások is. Ezek azután különböző felhasználói csoportnak kerülnek átadásra, pl. tesztelőknek, végfelhasználóknak.&lt;/p&gt;
&lt;p&gt;Ha Maven-t használunk projekt kezelésre (több, mint build), akkor a release gyakorlatilag a megfelelő artifact-ok (bináris, valamint pl. a forráskódot, dokumentációt tartozó csomagok) legyártása, és elhelyezése a (első körben privát) repository-ba. Ez után persze ezeket különböző helyre terjeszthetjük, pl. teszt környezetre deploy-olhatjuk, hogy a tesztelők elkezdhessék a munkájukat, de egy GA esetén mehet ki a publikus repository-ba is.&lt;/p&gt;
&lt;p&gt;A release tehát egy vagy több artifact, mely a szoftver éppen aktuális, rögzített állapotát tartalmazza. Hogy ezeken állapotokat egymástól meg tudjuk különböztetni, verziószámot adunk a kiadásnak. A Maven-nél a projekt koordináta része a group id és a artifact id mellett a verzió is. A verzió formátuma viszonylag szabad, a leggyakoribb a major/minor verziószám használata, pl. 1.1, 2.0, de adhatók hozzá egyéb minősítők is, pl. 3.0-beta-5, és ezzel máris visszautalok a szoftverkiadás életciklusára. A Maven ezen kívül nagyon elhatárolja azt a verziót, melyen a fejlesztők még gőzerővel dolgoznak, ezt snapshot-nak hívja (3.0-SNAPSHOT), illetve a release-t, mely verzióban értelemszerűen nem szerepel a SNAPSHOT szó. Egy snapshot tartalmazhat egy szoftvernek több állapotát is, hiszen a fejlesztők folyamatosan dolgoznak rajta. Ez annyiban igaz, hogy a repository-ba deploy-kor a SNAPSHOT szó kicserélésre kerül az adott időponttal, UTC formátumban, pl. 1.0-20080207-230803-1. Ha a Maven függőségeink között SNAPSHOT-ot talál, akkor a repository-ból mindig a legfrissebbet próbálja letölteni (a távoli repository-ból alapértelmezetten naponta egyszer próbálkozik, de ki lehet kényszeríteni a -U kapcsolóval). A release verzió viszont már egy konkrét állapotot mutat, nem lehet ugyanazon release verzióval két különböző artifact. Valamint egy relase verzió nem hivatkozhat snapshot verziókra.&lt;/p&gt;
&lt;p&gt;A Maven repository-k közül is megkülönbözteti a release és snapshot repository-t. Amikor függőségeket kezelünk, akkor a repositories/repository tag alatt megadhatunk különböző repository-kat. A releases és a snapshots tag-ekben definiálhatjuk, hogy az adott repository-ban SNAPSHOT-ok vagy release-ek találhatóak, és hogyan kell őket kezelni (pl. mindig keresse a legfrissebb verziókat SNAPSHOT esetén, vagy mi legyen, ha eltér a checksum - hibaüzenetet adjon, vagy meg is álljon a build). A distributionManagement tag alatt azt adhatjuk meg, hogy a mi artifact-jaink hova kerüljenek, melyik repository-ba. A repository tag-en belül írhatjuk a release repository-t, és a snapshotRepository tag-en belül a SNAPSHOT repository-t.&lt;/p&gt;
&lt;p&gt;Az agilis módszertanok azt hirdetik, hogy gyakran érdemes release-elni, egyrészt, hogy kevesebb funkció, kevesebb módosítás során kisebb a hibalehetőség, gyorsabbak az iterációk, az ügyfelek, felhasználók azt kapnak, amit szeretnének. Viszont egy release során sok műveletet kell elvégezni, amely ha manuális, könnyebb elvéteni. Ilyenek pl. a verziókezelő műveletek, verzió frissítések, artifact-ek legyártása, deploy, stb.&lt;/p&gt;
&lt;p&gt;Ezen műveletek automatizálását segíti a &lt;a href="http://maven.apache.org/plugins/maven-release-plugin/index.html"&gt;Maven Release Plugin&lt;/a&gt;, melyet akkor is érdemes részletesen megvizsgálni, ha nem Maven-nel fejlesztünk.&lt;/p&gt;
&lt;p&gt;Két leggyakrabban használt cél (goal) a release:prepare, mely előkészíti a release-t, és a release:perform, mely végrehajtja azt. A következőket végzi el a release:prepare:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;check-poms: megvizsgálja, hogy az adott verzió SNAPSHOT-e. Ha nem SNAPSHOT, akkor már megtörtént a release, így nem futtatható mégegyszer. (Hibaüzenet: You don't have a SNAPSHOT project in the reactor projects list.)&lt;/li&gt;
&lt;li&gt;scm-check-modifications: megvizsgálja, hogy minden állomány be van-e commit-olva. Mivel a release plugin aktívan használj a verziókezelőt, ezért a POM-ban az scm tag-nek be kell állítva lennie, különben hibaüzenetet kapunk.&lt;/li&gt;
&lt;li&gt;check-dependency-snapshots: megvizsgálja, hogy nincs-e SNAPSHOT függőség. Ha van, akkor hibaüzenetet dob. A plugin-oknál is vizsgálja, hogy van-e SNAPSHOT.&lt;/li&gt;
&lt;li&gt;create-backup-poms: elmenti az előző POM állományt (pom.xml.releaseBackup) néven. Ha bármi probléma van, ebből vissza lehet állni.&lt;/li&gt;
&lt;li&gt;map-release-versions: ha a release interaktív, akkor megkérdezi a felhasználótól a release verzióját. Fel is ajánl egyet, az aktuális verziót SNAPSHOT nélkül, ha jó, elég egy Enter-t ütni.&lt;/li&gt;
&lt;li&gt;input-variables: ha a release interaktív, akkor megkérdezi a felhasználótól a tag nevét. Fel is ajánl egyet, az modul neve + aktuális verzió SNAPSHOT nélkül, ha jó, elég egy Enter-t ütni (pl. fooapp-1.1).&lt;/li&gt;
&lt;li&gt;map-development-versions: ha a release interaktív, akkor megkérdezi a felhasználótól a következő verzió nevét. Fel is ajánl egyet úgy, hogy növeli a minor verziószámot, és hozzáteszi a SNAPSHOT-ot (pl. 1.2-SNAPSHOT). Ha megfelelő, itt is üthetünk Enter-t.&lt;/li&gt;
&lt;li&gt;rewrite-poms-for-release: a POM át lesz írva a release verzióra, és az scm tag-ben is a tag url-je fog szerepelni.&lt;/li&gt;
&lt;li&gt;generate-release-poms: a release-eléshez használt POM legenerálásra.&lt;/li&gt;
&lt;li&gt;run-preparation-goals: az új POM-mal lebuild-eli a projektet, clean verify célokkal. Közben a teszt esetek is lefutnak.&lt;/li&gt;
&lt;li&gt;scm-commit-release: commit-olja a módosított POM-ot.&lt;/li&gt;
&lt;li&gt;scm-tag: elvégzi a tag-gelést a verziókezelőben.&lt;/li&gt;
&lt;li&gt;rewrite-poms-for-development: a következő verzióhoz, ami már újra SNAPSHOT lesz, elkészíti a POM-ot.&lt;/li&gt;
&lt;li&gt;remove-release-poms: eltakarítja a release-hez használt POM-ot.&lt;/li&gt;
&lt;li&gt;scm-commit-development: commit-olja az új POM-ot a verziókezelőbe.&lt;/li&gt;
&lt;li&gt;end-release: véglegesíti a release-t.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Amikor ez megvan, a könyvtárban létrejön egy release.properties, mely a tartalmazz a release főbb jellemzőit, valamint egy pom.xml.releaseBackup, mely az előző POM állomány. Valamint láthatjuk, hogy a verziókezelőben is megjelenik két commit: [maven-relase-plugin] prepare release fooapp-1.2, valamint [mavern-release-plugin] prepare for next development iteration.&lt;/p&gt;
&lt;p&gt;Ha a klasszikus felépítést használjuk a verziókezelőben, Subversion-ben, hogy projekt név, és alatta a trunk, tags és branches könyvtár, akkor a tag automatikusan a tags könyvtárba kerül. Ha nem ezt a felépítést használjuk, akkor paraméterként megadhatjuk a tag helyét a tagBase POM tag-ben:&lt;/p&gt;
&lt;pre class="brush: xml"&gt;
&amp;lt;project&amp;gt;
...
&amp;lt;build&amp;gt;
...
&amp;lt;plugins&amp;gt;
 &amp;lt;plugin&amp;gt;
   &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;maven-release-plugin&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;2.1&amp;lt;/version&amp;gt;
   &amp;lt;configuration&amp;gt;
     &amp;lt;tagBase&amp;gt;https://svn.apache.org/repos/asf/maven/components/releases&amp;lt;/tagBase&amp;gt;
   &amp;lt;/configuration&amp;gt;
 &amp;lt;/plugin&amp;gt;
&amp;lt;/plugins&amp;gt;
...
&amp;lt;/build&amp;gt;
...
&amp;lt;/project&amp;gt;
&lt;/pre&gt;
&lt;p&gt;Új projektnél, vagy nagyobb verzióváltásnál érdemes a -DdryRun=true paramétert használni, ilyenkor ugyanazokat kérdezi meg, ugyanazon teszt eseteket futtatja le, és legenerálja az új POM-ot is, de valójában nem végzi el a műveleteket, pl. a verziókezelőben. Ha mindent rendben találunk, kiadhatjuk a release:clean-t, ami letörli az ideiglenes állományokat, majd a &lt;code&gt;mvn release:prepare&lt;/code&gt; parancsot, immár az előbbi paraméter nélkül.&lt;/p&gt;
&lt;p&gt;Amennyiben nem kézzel akarjuk megadni a verziószámokat, használhatjuk a batch módot (&lt;a href="http://maven.apache.org/plugins/maven-release-plugin/examples/non-interactive-release.html"&gt;Non-interactive Release&lt;/a&gt;), ehhez a &lt;code&gt;mvn --batch-mode release:prepare&lt;/code&gt; parancsot kell kiadni. Ekkor automatikusan azokat a verzószámokat adja, melyeket amúgy felajánlana. Ekkor felülbírálhatjuk az alapértelmezett értékeket a parancssorban is:&lt;/p&gt;
&lt;pre&gt;
mvn --batch-mode -Dtag=my-proj-1.2 release:prepare \
            -DreleaseVersion=1.2 \
            -DdevelopmentVersion=2.0-SNAPSHOT
&lt;/pre&gt;    
&lt;p&gt;Vagy magunk írjuk meg a release.properties állományt.&lt;/p&gt;
&lt;p&gt;Használhatjuk a release:rollback célt is, ekkor az elmentett POM visszaállításra kerül, amit be is commit-ol. Vigyázzunk, a tag-eket nem törli le. Így ha pl. újra akarunk prepare-t futtatni, előtte kézzel el kell távolítanunk a tag-et, mert jelezni fog, hogy már van tag olyan néven.&lt;/p&gt;
&lt;p&gt;Ha viszont minden megfelelően zajlott, akkor kiadhatjuk az &lt;code&gt;mvn release:perform&lt;/code&gt; parancsot, mely a következő lépésekből áll:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;verify-completed-prepare-phase: megvizsgálja, hogy a prepare cél le lett-e futtatva.&lt;/li&gt;
&lt;li&gt;checkout-project-from-scm: a target könyvtárba a teljes projektet checkout-olja, méghozzá az előbb tag-geltet.&lt;/li&gt;
&lt;li&gt;run-perform-goals: fork-ol egy új Maven példányt, és elindítja a checkout-olt projekten a deploy célt.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A deploy során nem csak a fő artifact-ot készíti el, és deploy-olja, hanem a forrást, valamint a JavaDoc-t is tartalmazó artifact-ot is, és mindhármat feltölti, immár a release repository-ba (ezért be kell állítani a distributionManagement/repository tag-et).&lt;/p&gt;
&lt;p&gt;Ez után nekem mindig kellett manuálisan egy svn update parancsot kiadnom, mert nem volt up-to-date.&lt;/p&gt;
&lt;p&gt;Ha útközben valami hiba történt, és le akarjuk törölni az ideiglenesen generált állományokat, a release:clean célt futtassuk. Vigyázzunk, ha ezt a release:prepare után adjuk ki, akkor már nem lehet a release:rollback parancsot használni, hiszen az a pom.xml.releaseBackup alapján dolgozik, melyet a clean letöröl.&lt;/p&gt;
&lt;p&gt;Ezt a folyamatot a &lt;a href="https://www.packtpub.com/apache-maven-2-effective-implementations/book"&gt;Apache Maven 2: Effective Implementation&lt;/a&gt; könyv is részletesen tárgyalja, míg a Sonatype-os &lt;a href="http://www.sonatype.com/books.html"&gt;könyvek&lt;/a&gt; viszont nem.&lt;/p&gt;
&lt;p&gt;Az érdekességek persze akkor fognak előjönni, ha nem egy egyszerű projektünk, hanem vagy szülő projektet adtunk meg, vagy multi module projektünk van.&lt;/p&gt;
&lt;p&gt;Szülő projekt megadásakor arra kell figyelni, hogy először mindenképp a szülőt kell release-elnünk, majd a gyermekben átállni a release-elt verzióra, mert ha először a gyermeket release-eljük, annak a SNAPSHOT szülőre lesz hivatkozása, ami nem megengedett.&lt;/p&gt;
&lt;p&gt;Multi modul esetén, amikor a POM tartalmazza a modulokat, azaz a build egyben elvégezhető, a release is egyben elvégezhető. Ekkor az összes almodulnál be fogja kérni a release verziószámot, és következő verziószámot. Tag-et csak egyet kért be és csinált. Erőssége, hogyha a modulok egymásra, és a szülőre SNAPSHOT verzióval hivatkoznak, azt az összes helyen, az összes modul POM-jában kicseréli a megfelelőre.&lt;/p&gt;
&lt;p&gt;Itt használhatjuk a -DautoVersionSubmodules=true paramétereket, és ekkor egyszer kéri be ezeket az értékeket, és az összes almodul ugyanazt kapja. Valamint megadhatjuk ezeket parancssorban, vagy a fentebb említett properties állományban, például a következőképpen:&lt;/p&gt;
&lt;pre&gt;
scm.tag=my-proj-1.2
project.rel.org.myCompany\:projectA=1.2
project.dev.org.myCompany\:projectA=1.3-SNAPSHOT
&lt;/pre&gt;
&lt;p&gt;Ekkor a rel mutatja, hogy a release verziószám az 1.2-es lesz az org.myCompany group id-jú, és projectA artifact id-jú projektnek, és dev mutatja, hogy a következő SNAPSHOT verziószám a 1.3-SNAPSHOT.&lt;/p&gt;
&lt;p&gt;Lehet a modulokat tartalmazó modult is relase-elni az almodulok nélkül a &lt;code&gt;mvn -N -Darguments=-N release:perform release:prepare&lt;/code&gt; paranccsal. Valamint a gyerek modult is lehet release-elni a szülő nélkül, a hagyományos módon, ekkor viszont nekünk kell a gyerek modulokban a szülő modulnál a SNAPSHOT-ot manuálisan eltávolítani.&lt;/p&gt;
&lt;p&gt;Multi modul esetén a modulokat tartalmazó POM-ot elhelyezhetjük hierarchikusan az almodulok fölé, azaz egy könyvtárban az almodulokat tartalmazó könyvtárakkal. Ezt hívják nested modellnek. Valamint megoldhatjuk úgy is, hogy a modulokat tartalmazó POM-nak is egy külön könyvtárat csinálunk, egy szinten az almodulokkal, és az almodulokra úgy hivatkozunk, hogy ../foosubmodule1, ezt nevezik flat modellnek. A release plugin régebbi verziói csak az első, a nested módot támogatták. Elvileg ezt javították, gyakorlatilag nekem is csak a nested mód működött elsőre. Ez azért érdekes, mert az Eclipse m2eclipse modulja meg viszont csak a flat modellt támogatta. Azt viszont próbálgatásaim alapján tényleg javították. Így én a nested módot javaslom.&lt;/p&gt;
&lt;p&gt;Multi modul projekt esetén kérdés, hogy az verziókezelőben hogyan érdemes a hierarchiát szervezni. Egyrészt lehet úgy Subversion esetén, hogy felül van a trunk, tags és branches könyvtár, és abban az almodulok, másrészt lehet úgy is, hogy az almodulok alatt mindenhol ott a trunk, tags és branches könyvtár. Amennyiben az elsőt választjuk, egyszerűbb egy teljes projektet build-elni, hiszen az egészet egy művelettel ki lehet checkout-olni. Viszont almodulonként is release-elünk, és a tags alatt nem akarjuk keverve látni az összes almodul tag-jeit, akkor használni kell a tagBase POM tag-et. A második esetben a checkout macerásabb, viszont a release plugin alapból ezt támogatja. Ezt úgy szokták megtrükközni, hogy létrehoznak egy könyvtárat, és a Subversion &lt;a href="http://svnbook.red-bean.com/en/1.5/svn.advanced.externals.html"&gt;&lt;code&gt;svn:externals&lt;/code&gt;&lt;/a&gt; tulajdonságával hivatkoznak a Subversion repository másik könyvtáraira. Így a checkout egy művelettel elvégezhető. Ugyanez alkalmazható a branch-eknél is.&lt;/p&gt;
&lt;p&gt;Egy gyakori jótanács, hogy sosem saját gépen release-eljünk, hanem a build szerveren, lehetőleg valamilyen continuous integration eszköz segítségével. Nézzük pl. hogy hogy is megy ez &lt;a href="https://hudson.dev.java.net/"&gt;Hudson&lt;/a&gt; segítségével. A Maven-hez van külön egy plugin, az &lt;a href="http://wiki.hudson-ci.org/display/HUDSON/M2+Release+Plugin"&gt;M2 Release Plugin&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A Hudson web konténerbe is telepíthető, de önmagában is futtatható. Töltsük le a WAR fájlt, és elindítható a &lt;code&gt;java -jar hudson.war&lt;/code&gt; paranccsal, és elérhető lesz a localhost-on a 8080-as porton. A plugin-t telepíteni úgy lehet, hogy a Manage Hudson menüpontban a Manage Plugins funkciót kell kiválasztani, majd az elérhető plugin-ek között ki kell választani a következőt: M2 Release Plugin This plugin allows you to perform a release build using the maven-release-plugin from within Hudson. Majd az Install gombot megnyomni, és a sikeres visszajelzés után újra kell indítani a Hudson-t. Ha ez megvan, akkor a job-oknál a Configure Job menüben a Build Environment cím alatt meg fog jelenni egy Maven release build checkbox. Ha ezt bepipáljuk, akkor a konfigurálhatjuk azokat a release-sel kapcsolatos dolgokat, melyeket parancssorban is.&lt;/p&gt;
&lt;a href="http://1.bp.blogspot.com/_czKgycLvmNo/TMS2TFj2XmI/AAAAAAAAFiQ/Ku5l7DewWu8/s1600/hudson-maven-release-1.png"&gt;&lt;img style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 320px; height: 86px;" src="http://1.bp.blogspot.com/_czKgycLvmNo/TMS2TFj2XmI/AAAAAAAAFiQ/Ku5l7DewWu8/s320/hudson-maven-release-1.png" alt="" id="BLOGGER_PHOTO_ID_5531746681344122466" border="0" /&gt;&lt;/a&gt;
&lt;p&gt;Ha ezt bekapcsoljuk, akkor meg fog jelenni egy Perform Maven Release menüpont az adott job-nál, melyre klikkelve választhatunk, hogy batch módben fusson, automatikus verziószámozással, vagy mi adhassuk meg az összes almodulnak a verziószámát, vagy egy verziószámot adunk meg az összes modulnak.&lt;/p&gt;
&lt;a href="http://1.bp.blogspot.com/_czKgycLvmNo/TMS2dWPJJoI/AAAAAAAAFiY/lvGh54VFaXI/s1600/hudson-maven-release-2.png"&gt;&lt;img style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 320px; height: 119px;" src="http://1.bp.blogspot.com/_czKgycLvmNo/TMS2dWPJJoI/AAAAAAAAFiY/lvGh54VFaXI/s320/hudson-maven-release-2.png" alt="" id="BLOGGER_PHOTO_ID_5531746857619367554" border="0" /&gt;&lt;/a&gt;
&lt;p&gt;Viszont multi modul projekt esetén mi van, ha a modulok külön életet élnek (release child modules independently)? Azaz egy almodulban szeretnék csak verziószámot emelni. A Maven ezt nem annyira támogatja, inkább azt vallja, hogy egy több modulból álló projektet egyszerre kell build-elni és release-elni is. Sőt ezt meg lehet oldani úgy is, hogy alkalmazásszinten, lásd pl. OSGi, vagy ne menjünk messzire, Hudson. Maven esetén ugyanis ha egy multi modul projektnél kiadunk egy release-t, az összes almodul verziószámát emeli.&lt;/p&gt;
&lt;p&gt;Egyik megoldás lehet, hogy a verziókezelőben minden modult a trunk alá tesztünk, de a tag helyét a tagBase konfigurációval átállítjuk. Nested módot, azaz hierarchiát használunk, de a szülőt sosem release-eljük a gyerekekkel (-N kapcsoló), csak magában.&lt;/p&gt;
&lt;p&gt;A másik megoldás &lt;a href="http://stackoverflow.com/questions/1581877/migrating-to-maven-from-an-unusual-svn-directory-structure"&gt;itt található&lt;/a&gt;, mely során a verziókezelőben almodulonként trunk, tags és branches könyvtár van. Valamint a szülő egy külön projekt, az almodulokkal egy szinten, és ez nem tartalmaz hivatkozásokat az almodulokra (azaz lehet release-elni a gyerekek nélkül is). És lehet egy külön projekt, mely már tartalmaz hivatkozásokat az almodulra, de ez nem kerül release-elésre, és svn:externals-szal tartalmaz hivatkozásokat a megfelelő modulokra.&lt;/p&gt;
&lt;p&gt;A modulokat mindkét esetben külön job-ként kell felvenni a continuous integration eszközbe, hogy külön release-elhetők legyenek.&lt;/p&gt;
&lt;p&gt;Alapvetően a Maven-ben a convention over configuration tetszik, mely lehetővé teszi, hogy egyrészt kis energiabefektetéssel lehessen projekteket felépíteni, valamint ne kelljen gondolkozni a különböző konfigurációkon. Sajnos egy multi modul projektnél, ahol külön akarunk release-elni modulonként, nem érzem ezt az elvet. Nincs konvenció arra, hogy hogyan kéne felépíteni a projekt struktúrát (lásd nested kontra flat), hogyan kell ezt a verziókezelőben megjeleníteni, és hogyan lehet szépen release-elni. A net tele van ilyen típusú kérdésekkel, és mindenki leírja a saját megoldását, mely általában vérzik pár sebből. Nem tudom elfogadni azt az állítást, hogy minden projekt más, azért nincs egyértelmű megoldás, mert mindenki ugyanazokat a kérdéseket teszi fel.&lt;/p&gt;
&lt;p&gt;Aki ebben a témában még tovább akar gondolkodni, olvassa el a &lt;a href="http://jtechnics.anzix.net/2010/07/27/maven-release-hudson/"&gt;jTechnics&lt;/a&gt; oldalon megjelent cikket.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/214682897237729794/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/10/release-maven-nel-es-hudson-nel.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/214682897237729794'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/214682897237729794'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/10/release-maven-nel-es-hudson-nel.html' title='Release Maven-nel és Hudson-nel'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://1.bp.blogspot.com/_czKgycLvmNo/TMS2TFj2XmI/AAAAAAAAFiQ/Ku5l7DewWu8/s72-c/hudson-maven-release-1.png' height='72' width='72'/><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-309890508077704267</id><published>2010-09-29T02:01:00.007+02:00</published><updated>2010-09-29T02:08:24.238+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='UML'/><title type='text'>UMLet saját komponens</title><content type='html'>&lt;p&gt;Már egy előző post-ban (&lt;a href="http://jtechlog.blogspot.com/2009/05/uml-tevekenysegdiagram.html"&gt;UML tevékenységdiagram&lt;/a&gt;) írtam az &lt;a href="http://www.umlet.com/"&gt;UMLet&lt;/a&gt; UML diagram rajzoló eszközről, és több diagramot is ezzel készítettem, mint pl. a &lt;a href="http://jtechlog.blogspot.com/2009/08/fa-abrazolasa-adatbazisban.html"&gt;Fa ábrázolása adatbázisban&lt;/a&gt; post-ban lévőt is. Ez utóbbiban látható, hogy olyan komponenst használtam, mely nincs az UMLet-ben (lekerekített sarkú téglalap, árnyékkal és színátmenettel).&lt;/p&gt;
&lt;p&gt;Ezen eszköz alapvető előnye két dologban rejlik. Egyrészt, ahogy már írtam, kellően egyszerű, nem kell dialógusablakok garmadán keresztülvergődni egy UML diagram elkészítéséhez, hanem ki kell tenni a komponenst, melyhez egy darab Properties beviteli mező tartozik. Ebben lehet minden leírni, gyakorlatilag egy kötött formátumot használva (script-szerűen). Másik előnye, hogy saját komponenseket nagyon egyszerű benne megvalósítani, Java nyelven, így gyakorlatilag tetszőlegesen testre szabható, bármilyen saját komponens létrehozható.&lt;/p&gt;
&lt;p&gt;Az UMLet-ben saját elem létrehozására a Custom Element való, melyről az UMLet honlapján egy &lt;a href="http://www.umlet.com/ce/ce.htm"&gt;tutorial&lt;/a&gt; is található.&lt;/p&gt;
&lt;p&gt;Custom Element szerkesztéséhez először a Custom Elements/New... menüpontot válasszuk ki. Ekkor megjelenik az alsó szerkesztő ablak, három szövegmezővel. Az első szövegmezőben a komponens tulajdonságait adhatjuk meg. A másodikban a forráskódját, a harmadikban pedig látunk egy előnézeti képet.&lt;/p&gt;
&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/_czKgycLvmNo/TKKCjNWCLPI/AAAAAAAAFhk/tNFezsMZ7Ks/s1600/umlet_screenshot.png"&gt;&lt;img style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 320px; height: 233px;" src="http://3.bp.blogspot.com/_czKgycLvmNo/TKKCjNWCLPI/AAAAAAAAFhk/tNFezsMZ7Ks/s320/umlet_screenshot.png" alt="" id="BLOGGER_PHOTO_ID_5522119634498759922" border="0" /&gt;&lt;/a&gt;
&lt;p&gt;A példában a következő forráskód szerepel:&lt;/p&gt;
&lt;pre class="brush: java"&gt;
int y=textHeight();

drawRectangle(0,0,width,height);

for(String textline : textlines) {
 printCenter(textline,y);
 y = y + textHeight();
}
&lt;/pre&gt;
&lt;p&gt;Gyakorlatilag a kód kirajzol egy téglalapot, és beleírja a szöveget. A width, height, textlines változók lokális változók, míg a textHeight(), drawRectangle() metódusok.&lt;/p&gt;
&lt;p&gt;Ha valami szebb megjelenítést akarunk, akkor írjuk ide  következő kódot:&lt;/p&gt;
&lt;pre class="brush: java"&gt;
// Változó inicializációk
int dontHideBorder = 1;
int roundedCorner = 5;
int shadowOffset = (int) (5 * zoom);
Color bg = new Color(Integer.decode("#58ACFA"));

// Árnyék 
g2.setColor(new Color(200, 200, 200));
g2.fillRoundRect(shadowOffset, shadowOffset, getWidth() - shadowOffset - dontHideBorder, getHeight() - shadowOffset - dontHideBorder, 10, 10);  

// Színátmenettel feltöltött téglalap
g2.setPaint(new GradientPaint(1, 0, bg, getWidth() + 1, 0, Color.WHITE, false));
g2.fillRoundRect(dontHideBorder, dontHideBorder, getWidth() - shadowOffset, getHeight() - shadowOffset, roundedCorner, roundedCorner);

// Keret
g2.setColor(Color.BLACK);
g2.drawRoundRect(dontHideBorder, dontHideBorder, getWidth() - shadowOffset, getHeight() - shadowOffset, roundedCorner, roundedCorner);

// Szöveg
int y = textHeight();
for (String textline : textlines) {
 if (!textline.contains("=")) {
  printCenter(textline, y);
  y = y + textHeight();
 }
}
&lt;/pre&gt;
&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/_czKgycLvmNo/TKKCYcnRISI/AAAAAAAAFhM/S2mP1qyZ1R0/s1600/umlet_custom_element.png"&gt;&lt;img style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 228px; height: 89px;" src="http://3.bp.blogspot.com/_czKgycLvmNo/TKKCYcnRISI/AAAAAAAAFhM/S2mP1qyZ1R0/s320/umlet_custom_element.png" alt="" id="BLOGGER_PHOTO_ID_5522119449619013922" border="0" /&gt;&lt;/a&gt;
&lt;p&gt;Itt a legérdekesebb, hogy a g2 egy Graphics2D objektum, melyre lehet rajzolni, ez egy standard JDK-ban található osztály. Ez gyakorlatilag a komponens vászna. A 0,0 a bal felső sarka. Bizonyos számolásoknál figyelembe kell venni azt is, hogy nemrég jelent meg a zoom-olás lehetősége az UMLet-ben, így a helyes koordináták meghatározásakor a zoom-mal való szorzás elengedhetetlen (zoom = 1 a 100%-nál, zoom = 0.5 az 50%-nál).&lt;/p&gt;
&lt;p&gt;Látható, hogy a forráskód írása közben fordítás történik, a hibás sorok pirossal kerülnek kiemelésre, és az egeret felé víve megjelenik a hibaüzenet. A háttérben ugyanis az történik, hogy a custom_elements könyvtárba van egy Default.java, mely a default package-ben van, osztályának nevét (&lt;!--CLASSNAME--&gt;) kicseréli a CustomElementImpl-re, valamint a /****CUSTOM_CODE START****/ és /****CUSTOM_CODE END****/ szöveg közötti szöveget kicseréli a szöveges mezőbe beírt értékre. Ezt elmenti a custom_elements/tmp könyvtárba, és futás közben lefordítja az &lt;a href="http://www.eclipse.org/jdt/"&gt;Eclipse Java development tools (JDT)&lt;/a&gt; Core komponensével.  Ez a com.umlet.custom.CustomElementCompiler csomagban található. A Default.java forráskódja a következő:&lt;/p&gt;
&lt;pre class="brush: java"&gt;import java.awt.*;
import java.util.*;

import com.umlet.constants.Constants;

@SuppressWarnings(&amp;quot;serial&amp;quot;)
public class &amp;lt;!CLASSNAME!&amp;gt; extends com.umlet.custom.CustomElement {

 public CustomElementImpl()
 {
  
 }
 
 @Override
 public void paint() {
  Vector&amp;lt;String&amp;gt; textlines = Constants.decomposeStrings(this.getState());
 
  /****CUSTOM_CODE START****/
//Modify the code below to
//define the element's behavior.
//
//Example:  Change the line
//  y = y + textHeight();
//to
//  y = y + 2 * textHeight();
//and observe the element preview.

int y=textHeight();

drawRectangle(0,0,width,height);

for(String textline : textlines) {
 printCenter(textline,y);
 y = y + textHeight();
}
  /****CUSTOM_CODE END****/
 }
}&lt;/pre&gt;
&lt;p&gt;Ebből a következő dolgok következnek. Az új komponens a com.umlet.custom.CustomElement osztály leszármazottja, mely a com.umlet.element.base.Entity leszármazottja. Ezért ezekből származott (nem private) változóit és metódusait el lehet érni.  A java.awt és java.util csomagban lévő osztályok használhatóak közvetlenül, a többit teljes névvel (csomaggal együtt) kell megadni. A textlines változó is elérhető a kódból, ami a Custom Code előtt lett definiálva.&lt;/p&gt;
&lt;p&gt;Láthattuk azt is, hogy automatikus kódkiegészítés van a szövegszerkesztő mezőben. Ez úgy lett megvalósítva, hogy a megfelelő metódusok a CustomElement osztályban @CustomFunction annotációval vannak ellátva.&lt;/p&gt;
&lt;p&gt;Persze ebben a környezetben kényelmetlen szerkeszteni, megtehetjük azt is, hogy kedvenc IDE-nkbe csináljuk ugyanezt. Ehhez a umlet.jar-t kell a CLASSPATH-ba tenni, és a Default.java-t létrehozni, átmásolni, és a Custom Code közé írni a saját kódot, és ezt másolgatni az UMLet-be.&lt;/p&gt;

&lt;p&gt;Ha bonyolultabb dolgokat akarunk megvalósítani, akkor gyakran kaphatunk kivételt, mely a teljes GUI-t lefagyasztja. Ehhez javasolt a Custom Code-ot try-catch-be rakni.&lt;/p&gt;
&lt;pre class="brush: java"&gt;
try {
...
} catch (Exception e) {
printLeft(e.getMessage(), textHeight());
}
&lt;/pre&gt;
&lt;p&gt;Ennek leggyakrabban akkor vesszük hasznát, mikor olyan metódust szeretnénk meghívni, melyre nincs jogosultságunk. Ugyanis az UMLet egy saját SecurityManager-t implementált (com.umlet.custom.CustomElementSecurityManager), mely a következőket engedi: java.lang, java.util, com.umlet.custom, com.umlet.constants, java.awt.geom, java.awt.font, java.awt), ebből a legfájóbb pont a com.umlet.control.diagram.DiagramHandler hiánya, ugyanis ebben rengeteg hasznos metódus található, de nem lehet e miatt elérni. Ekkor a következő hibaüzenetet kapjuk: No security critical tasks allowed in customized elements. Sajnos ugyanez igaz a debug-olásra is, a Log4J csomagja sem engedélyezett. (A Log4J bekapcsolásához amúgy csak a főkönyvtárban kell elhelyezni egy log4j.properties állományt.)&lt;/p&gt;
&lt;p&gt;Ha szeretnénk meta információkat is elhelyezni a komponens mezői között, akkor nekünk kell azt parse-olnunk. Érdemes kulcs érték párokat használni, és Properties-ként beolvasni. Pl. ha módosítani szeretnénk a háttér színét, akkor a bg=#5F04B4 megadásával lehet. Ezt értelmezni a következő kód tudja:&lt;/p&gt;
&lt;pre class="brush: java"&gt;
// Properties mező feldolgozása
Properties props = new Properties();
props.load(new java.io.StringReader(getPanelAttributes()));
bg = new Color(Integer.decode(props.getProperty("bg")));
&lt;/pre&gt;
&lt;p&gt;Hasznos metódus még a textWidth metódus is, nézzük meg pl, ha a szöveget nem középre, hanem lépcsőzetesen akarjuk elhelyezni:&lt;/p&gt;
&lt;pre class="brush: java"&gt;
int x = 2 * zoom;
int y = textHeight();
for (String textline : textlines) {
 if (!textline.contains("=")) {
  print(textline, x, y);
  y = y + textHeight();
  x = textWidth(textline);
 }
}
&lt;/pre&gt;
&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_czKgycLvmNo/TKKCcQIeSvI/AAAAAAAAFhU/KPtBB9_0cfw/s1600/umlet_custom_element_step.png"&gt;&lt;img style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 200px; height: 104px;" src="http://4.bp.blogspot.com/_czKgycLvmNo/TKKCcQIeSvI/AAAAAAAAFhU/KPtBB9_0cfw/s320/umlet_custom_element_step.png" alt="" id="BLOGGER_PHOTO_ID_5522119514988104434" border="0" /&gt;&lt;/a&gt;
&lt;p&gt;Ha elmentjük a diagramot, akkor a Custom Element kódját is bele menti, tehát hordozható.&lt;/p&gt;
&lt;p&gt;Ha gyakran használunk egy bonyolultabb struktúrát (több komponenst), akkor érdemes egy új komponenst létrehozni, mintegy sablonként, saját szöveges konvenciót kitalálni a komponensek leírására, azt parse-olni, és a megjelenítését megvalósítani. Példaképp vegyünk egy csomagdiagramot. Ennek hierarchikus szerkezetét összerakhatjuk komponensekből egyenként, a csomag komponensekből és a közöttük lévő kapcsolatokból, de használhatunk összetett komponenst is. A következő leíráson látható, hogy a struktúrát a behúzás mértéke adja meg:&lt;/p&gt;
&lt;pre&gt;root
 name
 name
  name
  name
root
 name&lt;/pre&gt;
&lt;p&gt;Ennek grafikus reprezentációja:&lt;/p&gt;
&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_czKgycLvmNo/TKKCgZMiaAI/AAAAAAAAFhc/-76BSdiUBt4/s1600/umlet_package_tree.png"&gt;&lt;img style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 242px; height: 320px;" src="http://4.bp.blogspot.com/_czKgycLvmNo/TKKCgZMiaAI/AAAAAAAAFhc/-76BSdiUBt4/s320/umlet_package_tree.png" alt="" id="BLOGGER_PHOTO_ID_5522119586140547074" border="0" /&gt;&lt;/a&gt;
&lt;p&gt;Jó egy kicsit elszakadni a webes alkalmazásoktól, HTML-től, és kézben tartani minden pixelt. A &lt;a href="http://dl.dropbox.com/u/7683931/jtechlog/umlet_custom_elements.zip"&gt;forráskód letölthető&lt;/a&gt;, mely tartalmazza azt a bonyolultabb komponenst is, mely lehetővé teszi, hogy a téglalap mellé balra és jobbra is egy számot lehessen kiírni.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/309890508077704267/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/09/umlet-sajat-komponens.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/309890508077704267'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/309890508077704267'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/09/umlet-sajat-komponens.html' title='UMLet saját komponens'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://3.bp.blogspot.com/_czKgycLvmNo/TKKCjNWCLPI/AAAAAAAAFhk/tNFezsMZ7Ks/s72-c/umlet_screenshot.png' height='72' width='72'/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8096242855848459154</id><published>2010-09-21T00:42:00.004+02:00</published><updated>2010-09-21T00:54:47.598+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><title type='text'>Legjobb fejlesztő 2010 - Java programozó verseny</title><content type='html'>&lt;p&gt;Amennyiben végzős hallgató, friss diplomás szoftverfejlesztő vagy, Java-ban programozol, és szeretnéd megmérettetni magad, érdemes megnézned a &lt;a href="http://legjobbfejleszto.com/"&gt;Legjobb fejlesztő 2010&lt;/a&gt; versenyt. Ha szeretnéd megmutatni magad, és kíváncsi vagy rá, hogy az iparban dolgozó szakértők hogyan értékelik a munkádat, ha állást keresel, ez a verseny neked szól!&lt;/p&gt;
&lt;p&gt;A feladat 2010. október 1-én lesz közzétéve. Egyszerű üzleti problémára számíthatsz.&lt;/p&gt;
&lt;p&gt;Az első három helyezett jutalma pénzdíj, díjról szóló banner, melyet a honlapodon elhelyezhetsz, írásbeli szakmai ajánlás, valamint hosszú távú együttműködési lehetőség.&lt;/p&gt;
&lt;p&gt;Koncentrálj az üzleti problémára, kérdezz, válassz és használj megfelelő technológiákat, tervezz, és írj egy könnyen buildelhető, jól áttekinthető, karbantartható forráskóddal és intuitív, logikus felhasználói felülettel rendelkező szoftvert! A tesztelésről és dokumentálásról se feledkezz meg!&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/8096242855848459154/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/09/legjobb-fejleszto-2010-java-programozo.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/8096242855848459154'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/8096242855848459154'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/09/legjobb-fejleszto-2010-java-programozo.html' title='Legjobb fejlesztő 2010 - Java programozó verseny'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4573282679322514845</id><published>2010-09-21T00:37:00.002+02:00</published><updated>2012-11-16T12:41:02.576+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='xhtml'/><category scheme='http://www.blogger.com/atom/ns#' term='xml'/><title type='text'>XHTML 1.0 ajánlás fordítás</title><content type='html'>&lt;p&gt;Még egyetemi éveim alatt fordítottam a XHTML 1.0 Extensible HyperText Markup Language (Második Kiadás) ajánlást. Most megtaláltam, és gondoltam megosztom. Vannak benne hibák, és nem a legszebb magyar mondatok szerepelnek benne, de hátha valakinek még jó lesz. Elérhető a következő linken:&lt;/p&gt;

&lt;p style="text-align: center;"&gt;&lt;a href="http://vicziani.github.com/xhtml-1.0.htm"&gt;XHTML 1.0 Extensible HyperText Markup Language (Második Kiadás) - magyar fordítás&lt;/a&gt;&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/4573282679322514845/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/09/xhtml-10-ajanlas-forditas.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4573282679322514845'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4573282679322514845'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/09/xhtml-10-ajanlas-forditas.html' title='XHTML 1.0 ajánlás fordítás'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8676689565958825145</id><published>2010-09-10T01:11:00.006+02:00</published><updated>2014-01-04T21:32:48.308+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><title type='text'>Entitások auditálása Hibernate Envers-szel</title><content type='html'>&lt;p&gt;Frissítve: 2014. január 4.

&lt;p&gt;Felhasznált technológiák: Hibernate 4.3.0, HSQLDB 2.3.1, SLF4J 1.7.5, JUnit 4.11, Apache Commons DbUtils 1.5, Maven 3.0.3&lt;/p&gt;

&lt;p&gt;A &lt;a href="http://www.jboss.org/envers"&gt;Hibernate Envers&lt;/a&gt;
egy nagyon egyszerű Hibernate modul arra, hogy az entitásokat auditáljuk, azaz módosításkor a régi értékek is
megmaradjanak az adatbázisban, és azokat bármikor előkereshessük.&lt;/p&gt;
&lt;p&gt;Gyakori megrendelői igény, hogy látni lehessen, hogy ki, mikor és mit módosított bizonyos entitásokon,
 rekordokon. Az alkalmazásfejlesztő szeretné ezt minél transzparensebb módon kezelni, szóval lehetőleg ne kelljen
 ehhez a kódot módosítani. Egyszerű megoldás, hogy az aktuális és az audit rekordok is ugyanabban a táblában
 maradnak, és egy flag-et állítunk. Ezt meg lehet oldani alacsonyabb szinten is, pl.
 adatbázis triggerek alkalmazásával. Azaz a táblára kell tenni egy pre-insert, pre-delete és pre-update
 trigger-t, mely az adott rekordokat átmásolja egy másik, szerkezetileg hasonló táblába. Persze ehhez a triggert
 nekünk kell megírnunk. Az Oracle az audit rekordokat tartalmazó táblát Journal Table-nek nevezi, és bizonyos
 eszközök, pl. az Oracle Designer/2000, képesek ezeket, és a hozzá tartozó triggereket automatikusan legenerálni.
 Ha nem adatbázis alapú megoldást szeretnénk alkalmazni, használhatjuk pl. JPA esetén annak életciklus
 metódusait. Ennél azonban magasabb szintű, és szabványosabb megoldást biztosít a Hibernate Envers.
&lt;/p&gt;
&lt;p&gt;Az Envers gyakorlatilag beépül a Hibernate-be, és akár natív módon, akár JPA-n keresztül használjuk,
 kihasználhatjuk az előnyeit. Működik különálló alkalmazásban, de alkalmazásszerveren belül is, ahol a Hibernate
 végzi a perzisztenciát. A Subversion-höz hasonlóan az Envers is bevezeti a revision fogalmát. Gyakorlatilag
 minden tranzakció, mely auditálandó entitást szúr be, módosít vagy töröl, kap egy revision számot, mely a
 rendszeren belül egyedi. Minden revision-höz elmenti annak dátumát is. Minden entitáshoz létrehoz egy audit
 táblát is, melybe módosításkor vagy törléskor elmenti az előző állapotot, és természetesen hozzácsapja ezt a
 revision számot is. Utána a standard lekérdezésekkel elérjük a normál entitásainkat, de lehetőségünk van akár
 revision szám, akár dátum alapján visszakeresnünk az entitásaink régebbi állapotait.
&lt;/p&gt;
&lt;p&gt;Használata rendkívül egyszerű, 
 &lt;a href="http://docs.jboss.org/hibernate/orm/4.2/devguide/en-US/html/ch15.html"&gt;jól dokumentált&lt;/a&gt;
 mutatja be a lehetőségeit. Én is készítettem egy egyszerű Maven-es projektet, mely 
 &lt;a href="https://github.com/vicziani/jtechlog-hibernate-envers"&gt;letölthető a GitHub-ról&lt;/a&gt;. Ez 
 a tipikus Employee, Phone entitásokból áll, valamint az ezen CRUD műveleteket végző EmployeeService
 osztályból, mely JPA-t használ. Az EmployeeServiceTest teszt eset mutatja az Envers képességeit. A teszt esetek
 az mvn test parancs kiadásával futtathatóak. Adatbázis telepítése nem szükséges, memóriában futó HSQLDB-t
 használ.
&lt;/p&gt;
&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}"
   href="http://yuml.me/diagram/scruffy/class/%5BEmployee%7Cid;name;modifiedAt]++1-%3E*[Phone%7Ctype;number],%20[EmployeeService%7C%7CpersistEmployee%28%29;mergeEmployee%28%29;removeEmployee%28%29;listEmployees%28%29]-[Employee]"&gt;
 &lt;img style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 500px; height: 110px;"
   src="http://yuml.me/diagram/scruffy/class/%5BEmployee%7Cid;name;modifiedAt]++1-%3E*[Phone%7Ctype;number],%20[EmployeeService%7C%7CpersistEmployee%28%29;mergeEmployee%28%29;removeEmployee%28%29;listEmployees%28%29]-[Employee]"
   alt="" border="0"/&gt;
&lt;/a&gt;
&lt;p&gt;Az Envers használatához szükséges, hogy a classpath-ban legyen, ehhez a Maven-ben a következő függőséget kell
 felvennünk:
&lt;/p&gt;
&lt;pre class="brush: xml"&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;hibernate-envers&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${hibernate.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/pre&gt;
&lt;p&gt;Előző verziókban még konfigurálunk kellett a persistence.xml-ben a listenereket, most már elég, ha a jar a classpath-on van.&lt;/p&gt;
&lt;p&gt;Ahhoz, hogy egy entitást az Envers auditáljon, el kell helyezni rajta az @Audited annotációt. Amennyiben nem
 akarjuk az összes mezőjét auditálni, elhelyezhetjük az annotációt a mezőkön is. A példában az Employee és a
 Phone entitáson is elhelyeztük az annotációt.
&lt;/p&gt;
&lt;pre class="brush: java"&gt;@Entity
@Audited
public class Employee implements Serializable {
...
}&lt;/pre&gt;
&lt;p&gt;Az Envers használatához semmi több nem szükséges, a standard JPA műveleteket használva automatikusan megtörténik
 az auditálás. Ez annyit jelent, hogy sémageneráláskor az Employee és Phone tábla mellé létrehoz egy Employee_AUD
 és egy Phone_AUD táblát is, mely megegyezik az eredeti táblákkal, azzal a különbséggel, hogy kiegészíti egy REV
 és egy REVTYPE mezővel, valamint létrehoz egy REVINFO táblát, REV és REVTSTMP mezővel. Minden egyes beszúráskor,
 módosításkor, vagy törléskor, mely auditálandó entitást érint, létrehoz egy új revision-t, azaz beszúr egy új
 rekordot a REVINFO táblába. Ad neki egy egyedi azonosítót, mely egy automatikusan növekvő szám (REV mező), és a
 REVTSTMP mezőben letárolja az aktuális dátumot, időt. Az entitás előző értékét az _AUD végű táblába szúrja be,
 melynek REV mezője tartalmazza a revision egyedi azonosítóját, valamint azt, hogy milyen művelet történt (0: ADD
 - beszúrás, 1: MOD - módosítás, 2: DEL - törlés).
&lt;/p&gt;
&lt;p&gt;Természetesen lehetőség van az auditált entitások lekérdezésére is. Erre a teszteset testForRevisionsOfEntity és
 testForEntitiesAtRevision metódusai mutatnak példákat. A legegyszerűbb lekérdezni egy revision-höz tartozó
 entitást:
&lt;/p&gt;
&lt;pre class="brush: java"&gt;AuditReader auditReader = AuditReaderFactory.get(em);
Employee revision = (Employee) auditReader.createQuery()
    .forEntitiesAtRevision(Employee.class, 1).getSingleResult();&lt;/pre&gt;
&lt;p&gt;Látható, hogy az audit entitások kezelésére az AuditReader való. Ennek is vannak hasznos metódusai, mint a
 findRevision, getCurrentRevision, getRevisionDate, getRevisionNumberForDate, getRevisions, stb. De ezeknél
 sokkal rugalmasabb a Criteria API-hoz hasonlatos lekérdezési lehetőség a createQuery metódus használatával. Itt
 fluent interfész használatával további feltételeket tudunk megadni. Pl. nézzük meg az összes revision
 lekérdezését az Employee osztályhoz:
&lt;/p&gt;
&lt;pre class="brush: java"&gt;List revisions = auditReader.createQuery()
    .forRevisionsOfEntity(Employee.class, false, true).getResultList();&lt;/pre&gt;
&lt;p&gt;Ez egy List&amp;lt;Object[]&amp;gt; példánnyal fog visszatérni. A lista elemei tartalmazzák a revision-öket. Egy elem
 három objektumot tartalmaz. Az első az audit entitás, a második egy DefaultRevisionEntity példány, mely
 tartalmazza a revision azonosítóját és dátumát, a harmadik a RevisionType enum egy értéke (ADD, MOD, DEL).
 Persze az AuditQueryCreator metódusaival ezt a lekérdezést tovább finomíthatjuk, hogy csak a számunkra fontos
 értékeket adja vissza.
&lt;/p&gt;
&lt;p&gt;Az Envers-t természetesen tovább tudjuk konfigurálni, pl. globális paraméterek használatával, vagy további
 annotációkkal. Pl. megadhatjuk a táblák prefix-ét, suffix-ét, mezők neveit, sémát, katalógust. Az @AuditTable,
 @SecondaryAuditTable(s) annotációkkal entitásonként adhatjuk meg az audit tábla nevét. @AuditOverride(s)
 annotációval a mezők neveit tudjuk felülírni. Amennyiben egy kapcsolatban a cél entitást nem akarjuk auditálni,
 használjuk a @Audited(targetAuditMode = RelationTargetAuditMode.NOT_AUDITED) annotációt. Ekkor a betöltött audit
 entitás mindig az aktuális cél entitásra fog mutatni.
&lt;/p&gt;
&lt;p&gt;Megtehetjük azt is, hogy minden revision-höz saját adatokat mentünk el. Pl. a módosítást végző felhasználó nevét.
 Ekkor vagy a DefaultRevisionEntity osztályt kell kiterjeszteni, vagy a @RevisionNumber és @RevisionTimestamp
 annotációkat használni, és felvenni a megfelelő attribútumokat. Mindkét esetben az osztályt el kell látni a
 @RevisionEntity annotációval, és meg kell adni egy RevisionListener interfészt megvalósító osztályt, mely
 newRevision metódusát hívja meg az Envers. Ebben lehet beállítani az előbb említett példa esetén a
 bejelentkezett felhasználó nevét.
&lt;/p&gt;
&lt;p&gt;Itt érdemes megemlékezni a
 &lt;a href="http://commons.apache.org/dbutils/"&gt;Commons DbUtils&lt;/a&gt;
 projektről is. A teszt esetben ugyanis az audit táblák tartalmát JDBC-n keresztül akartam ellenőrizni. A JDBC
 túl nehézkes, Connection, Statement, ResultSet építésével és a kivételkezelésével. Nem akartam emiatt bevetni a
 Spring-et (ágyúval verébre), hogy a JdbcTemplate-et használhassam, így Commons DbUtils-ra esett a választásom,
 mellyel egyszerűen lehet adatbázis műveleteket futtatni. Nézzünk is néhány példát, melyek magukért beszélnek:
&lt;/p&gt;
&lt;pre class="brush: java"&gt;QueryRunner runner = new QueryRunner();
runner.update(conn, &amp;quot;delete from Employee&amp;quot;);

Map result = runner.query(conn,
&amp;quot;select count(*) as cnt from revinfo&amp;quot;, new MapHandler());
assertEquals(1, result.get(&amp;quot;cnt&amp;quot;));

List&amp;lt;Map&amp;gt;&amp;lt;String, Object[]&amp;gt; results = runner.query(conn,
&amp;quot;select * from Employee_AUD order by rev&amp;quot;, new MapListHandler());
assertEquals(1, results.size());
assertEquals(&amp;quot;name1&amp;quot;, results.get(0).get(&amp;quot;name&amp;quot;));&lt;/pre&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/8676689565958825145/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/09/entitasok-auditalasa-hibernate-envers.html#comment-form' title='3 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/8676689565958825145'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/8676689565958825145'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/09/entitasok-auditalasa-hibernate-envers.html' title='Entitások auditálása Hibernate Envers-szel'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>3</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6334662880090545976</id><published>2010-08-15T21:19:00.006+02:00</published><updated>2010-08-15T21:42:48.618+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Community'/><title type='text'>Konferenciák, események</title><content type='html'>&lt;p&gt;Ezen post-ban egy pár eseményt, konferenciát szeretnék kiemelni, amelyek esetleg érdeklődésetekre tarthat számot.&lt;/p&gt;
&lt;p&gt;Az &lt;a href="http://e-nnovation.pl/"&gt;e-nnovation&lt;/a&gt; konferencia 2010. szeptember 23-24 között lesz Lengyelországban (Poznań), amely az e-commerce szektor új fejlesztési irányait és új tendenciáit fogja bemutatni. Várják a webáruházak tulajdonosait, az e-kereskedelmi cégek vezetőit, valamint az e-commerce alkalmazás stratégiai és fejlesztési igazgatóit. A konferencia hasznos lenne mind az értékesítőknek mind a marketing szakértőknek, a Public Relations-ért és az ügyfelekkel való kapcsolatért felelős munkatársaknak, mind az IT üzletág alkalmazottainak, akik programokat készítenek a webáruházak számára. "Start with
e-nnovation" címen versenyt szerveznek mindazoknak, akik szeretnének saját üzletet indítani az IT üzletágban, különösen e-commerce-ben. A legjobb ötlet megvalósítására és későbbi fejleszéstére 10 000 eurós nyeremény jár.&lt;/p&gt;
&lt;p&gt;A &lt;a href="http://10.jdd.org.pl/"&gt;Java Developers' Day 2010&lt;/a&gt; szintén Lengyelországban (Krakkó) kerül megrendezésre 2010. október 7-8 között, mely kifejezetten a Java platformról szól. Linda Rising, mindenki által ismert, főleg Agile-lal, programozási paradigmákkal, objektum orientált szoftverfejlesztéssel foglalkozó szakértő, fog előadást tartani. Ted Neward az előadásával ismét megtiszteli a konferenciát. Neward független tanácsadó, aki az Enterprise rendszerekre specializálódik, akár a legnagyobb vállalatok számára, akár kis cégeknek; az általánosan elismert "Effective Enterprise Java" c. könyv és más kiadványok szerzője is.&lt;/p&gt;
&lt;p&gt;A &lt;a href="http://www.devoxx.com/display/Devoxx2K10/Home"&gt;Devoxx 2010&lt;/a&gt; konferencia 2010. november 15-19 között megrendezve Belgiumban, Antwerpenben. Igazából itt szinte nincs olyan Java-s témakör, ami nem lesz megemlítve, érdemes megnézni a programot az esemény honlapján.&lt;/p&gt;
&lt;p&gt;Marhefka István &lt;a href="http://infokukac.com/2010/08/webexpo-konferencia-praga-2010-szeptember-23-25/"&gt;szakmai blogján megemlíti&lt;/a&gt; a &lt;a href="http://webexpo.net/"&gt;WebExpo konferenciát&lt;/a&gt;, mely Prágában lesz 2010. szeptember 23-25 között. Közép-Európa legnagyobb webbel foglalkozó konferenciája, fókuszban a webfejlesztés, design, az internetes businessek és az agilis szoftverfejlesztés.&lt;/p&gt;
&lt;p&gt;És ne feledkezzünk meg kis hazánkban tartott &lt;a href="http://jum.javaforum.hu"&gt;JUM&lt;/a&gt; szakmai estekről sem. A legközelebbi alkalom 2010. szeptember 15-én lesz, helyszíne 1119 Budapest, Mérnök u. 39. A program még alakulóban, de amint végleges lesz, minden lehetséges csatornán próbáljuk hirdetni.&lt;/p&gt;
&lt;p&gt;Ezen eseményeket a blog naptárjába is rögzítem, melyet jobb oldalt találhattok, és felvehetitek a saját Google Calendar-otokba.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/6334662880090545976/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/08/konferenciak-esemenyek.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6334662880090545976'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6334662880090545976'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/08/konferenciak-esemenyek.html' title='Konferenciák, események'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3361245663649601147</id><published>2010-07-30T19:02:00.007+02:00</published><updated>2012-11-02T23:18:15.398+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='JMX'/><category scheme='http://www.blogger.com/atom/ns#' term='Tomcat'/><title type='text'>Tomcat JMX tűzfalon keresztül</title><content type='html'>&lt;p&gt;Technológiák: Tomcat 6.0.24, JMX&lt;/p&gt;

&lt;p&gt;Elég nagy problémám volt sokáig, hogyha egy Tomcat-et akartam JMX-en monitorozni, melyet tőlem egy tűzfal választott el. Írtam már erről részletesebben egy &lt;a href="http://jtechlog.blogspot.hu/2009/09/java-monitorozas-es-menedzsment.html"&gt;korábbi postban&lt;/a&gt;, álljon itt csak annyi, hogy le kellett kérdeznem egy menedzsment és monitorozó eszközből a következő értékeket: adatbázis connection pool mérete (várakozó és aktív kapcsolatok száma), session-ök száma az alkalmazáson belül, Connector várakozó és kiszolgáló szálak száma, memóriafelhaszálás, stb.&lt;/p&gt;
&lt;p&gt;Ha nincs tűzfal, a megoldás egyszerű. A Tomcat-et úgy kell indítani, hogy JMX-en keresztül is kapcsolódni lehessen hozzá. Ezt úgy lehet megtenni, hogy bizonyos környezeti paramétereket át kell neki adni. Javasolt a bin könyvtárába egy setenv.sh-t elhelyezni, és a következőt írni:&lt;/p&gt;
&lt;pre&gt;  set CATALINA_OPTS=-Dcom.sun.management.jmxremote \
   -Dcom.sun.management.jmxremote.port=%my.jmx.port% \
   -Dcom.sun.management.jmxremote.ssl=false \
   -Dcom.sun.management.jmxremote.authenticate=false
&lt;/pre&gt;
&lt;p&gt;Meg kell jegyezni, hogy ezek akár egy külön properties állományban is megadhatóak, akkor a -Dcom.sun.management.config.file paramétert kell átadni a Tomcat-et indító JVM-nek.&lt;/p&gt;
&lt;p&gt;Ekkor akár jconsole, akár jvisualvm (persze csak az MBean plugin telepítése után) kapcsolódni lehet a Tomcat-hez, a host és a port megadásával, és lehet kezelni JMX-en keresztül.&lt;/p&gt;
&lt;p&gt;Tűzfal esetén ez nem működött, nosza engedjük át a %my.jmx.port% helyett megadott port-ot a tűzfalon, vagy SSL tunel-lel hozzuk ki. Sajnos ez sem jó megoldás, ugyanis igaz, hogy a JMX kliens az ott megadott port-on próbál kapcsolódni, de utána megbeszélnek egy port-ot, melyen a további kommunikáció történik. Mivel itt a szerver választ egy következő szabad port-ot, ezt is át kéne engedni, vagy kihozni, csakhogy ez nem definit.&lt;/p&gt;
&lt;p&gt;Egy működő megoldás volt, hogy a JMX klienst az adott szerveren indítjuk el. Webes eszköz esetén böngészőből lehetett csatlakozni, vastag kliens esetén azonban az X-et kellett ssh-n keresztül kihozni. Egyik sem szerencsés megoldás, hiszen viszonylag sok konfigurációt igényel.&lt;/p&gt;
&lt;p&gt;A &lt;a href="http://download.oracle.com/javase/6/docs/technotes/guides/management/agent.html#gdfvv"&gt;JDK dokumentációja szerint&lt;/a&gt; megvalósítható az, hogy rákényszerítjük a JDK-t arra, hogy az RMIServer-t, melyben a távolról meghívható RMI objektumok vannak, egy már általunk a megadott porton létrehozott RMI registry-be regisztrálja be. Ezt Mimicking Out-of-the-Box Management-nek hívja. Tehát ehhez el kell indítanunk egy RMI registry-t, majd létre kell hoznunk egy JMXServiceURL példányt, valamint egy JMXConnectorServer-t, melynek átadjuk ezt. A környezeti változókat nem írva, ez kb. így néz ki:&lt;/p&gt;
&lt;pre class="brush: java"&gt;LocateRegistry.createRegistry(3000);
MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
JMXServiceURL url = 
  new JMXServiceURL("service:jmx:rmi://localhost:3001/jndi/rmi://localhost:3000/jmxrmi");
JMXConnectorServer cs = JMXConnectorServerFactory
  .newJMXConnectorServer(url, env, mbs);
cs.start();
&lt;/pre&gt;
&lt;p&gt;Ekkor a 3000-es porton indul el az RMI registry, és a 3001-esen az RMI server.&lt;/p&gt;
&lt;p&gt;De nekünk arra van szükségünk, hogy a Tomcat végezze el ezt. A Tomcat 6.0.24-es verziójától jelent meg az extras csomagban a org.apache.catalina.mbeans.JmxRemoteLifecycleListener osztály. Ehhez a letöltésnél az &lt;a href="http://archive.apache.org/dist/tomcat/tomcat-6/v6.0.24/bin/extras/"&gt;extras&lt;/a&gt; könyvtárból le kell töltenünk a catalina-jmx-remote.jar állományt, és elhelyeznünk a $CATALINA_HOME/lib könyvtárunkban. Ha ez megvan, akkor a következő konfigurációt kell beillesztenünk a server.xml állományba:&lt;/p&gt;
&lt;pre class="brush: xml"&gt;&amp;lt;Listener 
  className="org.apache.catalina.mbeans.JmxRemoteLifecycleListener" 
  rmiRegistryPortPlatform="3000" 
  rmiServerPortPlatform="3001" /&amp;gt;&lt;/pre&gt;
&lt;p&gt;Amennyiben ez megvan, az RMI registry a 3000-es, az RMI server a 3001-es port-on fog elindulni, hasonlóan az előző példához. Innentől kezdve ha a következő URL-t adjuk meg a JMX kliensünkben, és átengedjük a két port-ot a tűzfalon, vagy SSH tunnel-lel kihozzuk, láthatjuk a Tomcat MBean-jeit.&lt;/p&gt;
&lt;pre&gt;service:jmx:rmi://localhost:3001/jndi/rmi://localhost:3000/jmxrmi&lt;/hostname&gt;&lt;/hostname&gt;&lt;/pre&gt;
&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_czKgycLvmNo/TFMRgNbWWbI/AAAAAAAAFV8/nf3za7DfTHw/s1600/tomcat_jmx.png"&gt;&lt;img style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 320px; height: 210px;" src="http://4.bp.blogspot.com/_czKgycLvmNo/TFMRgNbWWbI/AAAAAAAAFV8/nf3za7DfTHw/s320/tomcat_jmx.png" alt="" id="BLOGGER_PHOTO_ID_5499758815007365554" border="0" /&gt;&lt;/a&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/3361245663649601147/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/07/tomcat-jmx-tuzfal.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3361245663649601147'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3361245663649601147'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/07/tomcat-jmx-tuzfal.html' title='Tomcat JMX tűzfalon keresztül'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://4.bp.blogspot.com/_czKgycLvmNo/TFMRgNbWWbI/AAAAAAAAFV8/nf3za7DfTHw/s72-c/tomcat_jmx.png' height='72' width='72'/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6926536731502363770</id><published>2010-07-27T00:38:00.007+02:00</published><updated>2011-11-14T21:46:44.127+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Spring'/><category scheme='http://www.blogger.com/atom/ns#' term='könyv'/><title type='text'>Spring Recipes: A Problem-Solution Approach</title><content type='html'>&lt;p&gt;Egyikőtök hívta fel a figyelmem a Spring Recipes: A Problem-Solution Approach könyvre a &lt;a href="http://jtechlog.blogspot.com/2010/05/spring-in-action.html"&gt;Spring In Action&lt;/a&gt; könyvről szóló post-om után. Mivel a könyv a Spring In Action-höz képest más megközelítést alkalmaz, és a Spring 2.5-t is lefedi szemben az előzővel, kíváncsiságból elolvastam. Jelen post-omban próbálok azoknak is csemegét nyújtani, akiket nem érdekel a könyvismertető, ezért megpróbálom kérdés-felelet formájában ismertetni az érdekesebb részeket, így mindenki ellenőrizheti kicsit a Spring-es tudását.&lt;/p&gt;

&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/-yXnlTRgeHqQ/TsF93RgZxBI/AAAAAAAAHjU/WB4ut9Rr428/s1600/spring_recipes_cover.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 253px; height: 320px; border-style:none;" src="http://2.bp.blogspot.com/-yXnlTRgeHqQ/TsF93RgZxBI/AAAAAAAAHjU/WB4ut9Rr428/s320/spring_recipes_cover.png" border="0" alt="Spring Recipes könyvborító" id="BLOGGER_PHOTO_ID_5674955394009121810" /&gt;&lt;/a&gt;

&lt;p&gt;A Spring Recipes könyv tematikája szinte teljesen megegyezik a Spring In Action könyv tematikájával, a tartalmi különbségek főleg a a 2.5-ös Spring verzió újdonságaiból adódnak, valamint a más megközelításből. Ugyanis a könyv felépítése úgy néz ki, hogy minden részben felvet egy problémát (Problem), aminek leírja a megoldását (Solution), valamint leírja ábrákkal, kóddal illusztrálva, hogy hogyan is működik (How It Works). Ebből adódik, hogy nem egy-két példát visz végig, mint a Spring in Action könyv, hanem mindig újat vesz elő. Ezzel néha feleslegesen telik a hely.&lt;/p&gt;
&lt;p&gt;Szerintem nagyon hasznos, hogy az első fejezet a konténer, interfészekkel való programozás, service locator, Inversion of Control, Dependency Injection és a konténer konfigurációs állománnyal való konfigurációját úgy mutatja be, hogy a Java SE eszközeivel (Spring nélkül) le is programoz egy megoldást. Ez nagyon hasznos lehet azoknak, akik nem az elméleti oldalról szeretnék megközelíteni ezen fogalmakat, hanem látni akarnak egy működő példát, gyakorlatilag ebből kiderül, hogy hogyan is indulhatott a Spring, mi is lehet a motorháztető alatt.&lt;/p&gt;
&lt;p&gt;Következő fejezetben kitér a Spring IDE használatára is. Tapasztalatom alapján a Spring IDE már nem nagyon érhető el, a &lt;a href="http://springide.org/"&gt;website-ja is&lt;/a&gt; áll, a SpringSource is a &lt;a href="http://www.springsource.com/developer/sts"&gt;SpringSource Tool Suite&lt;/a&gt; már ingyenesen használható eszközét preferálja. Ki is próbáltam, de számomra olyan minősíthetetlen lassú volt, hogy visszaálltam NetBeans-re.&lt;/p&gt;
&lt;p&gt;A 2007 novemberében kiadott Spring 2.5 a következő újításokat hozta, melyekre ki is tér a könyv. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bean-ek konfigurációja annotációkkal, mint az @Autowired, vagy a JSR-250 által bevezetett @Resource, @PostConstruct, @PreDestroy annotációk.
&lt;/li&gt;
&lt;li&gt;Component scanning: stereotype annotációkkal jelölt bean-ek automatikus feltérképezése, konfigurációja.
&lt;/li&gt;
&lt;li&gt;AspectJ load-time weaving: AspectJ osztálybetöltés közben képes az osztályainkat buherálni, így elérhető, hogy nem a konténerben definiált bean-ekre is működjön az AOP, valamint a teljes AspectJ arzenált bevethessük.
&lt;/li&gt;
&lt;li&gt;Kontrollerek konfigurációja annotációkkal: talán a legnagyobb újdonság, mely a Spring MVC-t érinti. Már nem kell a kontrollereknek Spring-es Controller osztályokból leszármaznia, nem kell azok metódusait ismerni, hanem sokminden rugalmasan annotációkkal is megadható.
&lt;/li&gt;
&lt;li&gt;Spring TestContext framework: annotációk használata a teszt eseteknél, úgy, hogy akár el is szakadhatunk a konkrét teszt implementációktól.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Nézzük, hogy milyen kérdéseket válaszol meg ez a könyv, melyeket a Spring In Action nem említett, a Spring alapelemeivel kapcsolatban:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;Constructor Ambiguity, azaz hogyan lehet a túlterhelt (overload) konstruktorok közül kiválasztani
a nekünk megfelelőt a konstruktor alapú dependency injection-nél?&lt;/dt&gt;
&lt;dd&gt;Az applicationContext.xml-ben használhatjuk a constructor-arg tag-nek a type és index attribútumát, ahol az elsőnek lehet megadni a konstruktor típusát, másodiknak a pozícióját. Ezzel egyértelműen definiálható a konstruktor szignatúra, így nem esik a Spring abba a hibába, hogy a property editor-ok miatt nem tud választani a konstruktorok közül, hiszen mindre tudna konvertálni.&lt;/dd&gt;
&lt;dt&gt;Hogyan állítható be, hogy ellenőrizze a Spring, hogy bizonyos attribútumainkra megtörtént-e a
dependency injection (dependency-checking)?&lt;/dt&gt;
&lt;dd&gt;Egyrészt bean szinten is beállíthatunk dependency-check attribútumot (none, simple, objects, all - egyszerű típusok - primitívek és Collection-ök - és objektumok tetszőleges kombinációjára). Másrészt használhatjuk a @Required annotációt.&lt;/dd&gt;
&lt;dt&gt;Milyen annnotációkkal lehet a dependency injection-t kérni?&lt;/dt&gt;
&lt;dd&gt;Vagy a Spring-es @Autowired vagy a JSR-250-es @Resource annotációval.&lt;/dd&gt;
&lt;dt&gt;Mi van, ha egy interfész több implementációját is le akarjuk kérni, valamint lehet-e választani, hogy melyikre van szükségünk.&lt;/dt&gt;
&lt;dd&gt;A típusnál megadhatunk interfész tömböt vagy collection-t is, ekkor az összes implementáló bean-t injektálni fogja a Spring. Amennyiben válogatni akarunk, egyrészt megtehetjük a @Qualifier annotációval, vagy a @Resource annotáció name attribútumával.&lt;/dd&gt;
&lt;dt&gt;Szülő-gyerek bean-nél lehet-e egy collection elemeit a szülőnél és a gyermeknél is meghatározni?&lt;/dt&gt;
&lt;dd&gt;Igen, lehetőség van a szülő bean-nél deklarált collection elemeinek merge-ölésére a gyermek bean-nél (merge="true" attribútum).&lt;/dd&gt;
&lt;dt&gt;Lehet-e szabályozni, hogy a collection mely implementációja legyen példányosítva, valamint az elemeknek mi legyen a pontos típusa?&lt;/dt&gt;
&lt;dd&gt;A kollekcióknál a type attribútummal adható meg a konkrét implementáció (pl. ha rendezettet akarunk, akkor egy SortedSet), az elemeknél a value-type-pal adható meg a típus. Amennyiben a bean implementációban generikust használunk, a konverzió automatikusan megtörténik.&lt;/dd&gt;
&lt;dt&gt;Van-e a collection-ök megadására rövidebb mód?&lt;/dt&gt;
&lt;dd&gt;A util sémát kell használni, mellyel rövidebben adhatóak meg az elemek, és a konfigurációs állomány is séma alapján validálható.&lt;/dd&gt;
&lt;dt&gt;Állhat-e bean-ként önmagában egy collection?&lt;/dt&gt;
&lt;dd&gt;A util sémát nem csak bean property-n belül használhatjuk, hanem bean szinten is, ekkor egy id attribútumot kell neki adni, amivel aztán a ref-ben hivatkozhatunk rá (un. stand-alone collection).&lt;/dd&gt;
&lt;dt&gt;Hogyan adhatunk meg bean-eket annotációval?&lt;/dt&gt;
&lt;dd&gt;A @Component annotációt használhatjuk, aminek attribútumként a bean nevét is megadhatjuk. Ahhoz, hogy a Spring fel is olvassa ezeket, a konfig állományban a context:component-scan tag-et kell használnunk. Különböző rétegeknek megfelelően használhatjuk a @Repository és @Service annotációkat is. A felolvasást filter-elhetjük is a minősített osztálynévre (FQN - fully qualified name - csomag és osztálynév), reguláris kifejezéssel.&lt;/dd&gt;
&lt;dt&gt;Mivel lehet egy bean-t egy osztály statikus attibútuma alapján definiálni?&lt;/dt&gt;
&lt;dd&gt;A FieldRetrievingFactoryBean osztályt használhatjuk.&lt;/dd&gt;
&lt;dt&gt;Mivel lehet egy bean-t egy másik bean attibútuma alapján definiálni?&lt;/dt&gt;
&lt;dd&gt;A PropertyPathFactoryBean osztályt használhatjuk.&lt;/dd&gt;
&lt;dt&gt;Hogyan tölthetünk be egy külső erőforrást, állományt?&lt;/dt&gt;
&lt;dd&gt;ResourceLoader-t alkalmazhatunk, melyre referenciát a ResourceLoaderAware interfész implementálásával kaphatunk, mely a Resource címe alapján különböző helyről töltheti be azt (pl. ClassPath, fájl, URL, stb.). Természetesen itt is működik a Dependency Injection is.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;A Spring In Action könyv szerintem sokkal érthetőbben, nagyon jó ábrával magyarázza el a bean-ek életciklusát, ezt hiányoltam ebből a könyvből. Persze a Spring Recipes viszont ír a 2.5-ben megjelent @PostConstruct, @PreDestroy annotációkról, melyekhez a annotation-config tag is kell a konfig állományban. Valamint a script-elés is külön fejezetet kapott, ahol megemlíti a lang sémát is.&lt;/p&gt;
&lt;p&gt;Az AOP rész leírása, elméleti háttere is jobb a Spring In Action könyvben, viszont nem hangsúlyozza eléggé, hogy hol a határ a régi, Classic Spring AOP és az új, 2.x-ben használt AOP között. Persze mindkettő mögött a JDK Dynamic Proxy van, melyet a Spring Recipes szintén bemutat, első körben még Spring nélkül (naplózásra, validálásra). Szépen kifejti, hogy az AspectJ használata a POJO-kon, akár az xml konfiguráció, akár az annotációval végzett konfiguráció (melyet mellesleg preferál az xml-lel szemben) még nem jelenti a teljes AspectJ-s arzenált (pl. csak a konténerben definiált bean-ekre lehet használni). Az AspectJ pointcut-okat deklaráló nyelvét is jobban leírja. Ír az advice precedence-ről (Ordered interface, @Order annotáció). Részletesen ír az introduction-ről is, tudunk futásidőben mellyel interfészeket adni egy bean-hez, és implementálni azokat úgy, hogy implementáló osztályokat adunk meg. Ennek hatása gyakorlatilag megegyezik azzal, mintha többszörös öröklődésünk lenne. Az implementáló osztály akár attribútumokat is tartalmazhat, ezeket state-nek nevezi.&lt;/p&gt;
&lt;p&gt;Amennyiben az AspectJ többi részét is ki akarjuk használni, pl. AspectJ-s aspect-ek, additional pointcut types, konténeren kívüli bean-ek AOP-ozása, Load-Time Weaving-et kell alkalmaznunk. Ehhez a context:load-time-weaver tag használata szükséges az xml konfigurációban, valamint a -javaagent kapcsoló a JDK-nak.&lt;/p&gt;
&lt;p&gt;Egy nagyon gyakorlatias fejezet azt mutatja be, hogy mit kell tennünk, ha Domain Driven Design alapján pl. Domain Object-be akarunk Dependency Injection-t. (Ugye itt az a probléma, hogy nincs a konténerben a példányunk.) Ekkor kell a context:spring-configured tag az xml konfigurációban, valamint a @Configurable annotáció.&lt;/p&gt;
&lt;p&gt;Az adatbázis kezelést bemutató részben nem sok különbség van, a Spring Recipes annyiban több, hogy leírja a PreparedStatementCreator, (Batch)PreparedStatementSetter interfészek használatát, valamint a operation object-ek kezelését, valamint egy gyakorlatias példát hoz arra, hogy hogy hozzunk létre saját kivételt egy adatbázis specifikus hibához. Nagy hibája, hogy nem ír a pool-ozásról, míg a Spring In Action szépen leírja az Ehcache konfigurációját (később ez a könyv is megemlíti a Security részben). A Spring In Action elméleti háttere a tranzakciókezelésnél szintén jobb, de a Spring Recipes az izolációs szintekre kódot mutat, amivel jobban megérthető. Itt is megemlíti a Load-Time Weaving-et (tranzakciókezelés nem publikus metódusokban, nem a konténerben lévő bean-ekben).&lt;/p&gt;
&lt;p&gt;A Spring MVC fejezetben a Spring In Action megint jobb alapozást ad, szépen felsorolja az összes interceptor-t. A Spring Recipes ezzel szemben saját interceptor megvalósítását is leírja (HandlerInterceptor), valamint leírja, hogyan választja ki a Spring MVC a Locale-t (LocaleResolver), és hogyan lehet Locale-t váltani (LocaleChangeInterceptor) nemzetköziesített alkalmazásoknál. Ír a HandlerExceptionResolver-ről a kivéltelek kezelésére, valamint a ParameterizableViewController-ről, ahol nem kell a view neveit a Controller-be égetnünk. Nagy piros pont, hogy leírja, hogy kell a Post/Redirect/Get Design Pattern-t alkalmazni. Írja, hogy hogyan használjuk a MultiActionController-t, ha egy Controller-be több műveletet akarunk lekezelni (pl CRUD alkalmazásnál a különböző képernyők, vagy egy form-on több gomb). Viszont a Spring beépített validációján kívül nem ír sem a 3rd party commons, sem a valang validációról. Viszont részletesen ír a Spring 2.5 újdonságáról az annotációkkal való Controller fejlesztésről, valamint nekem új volt a SessionStatus is.&lt;/p&gt;
&lt;p&gt;A Spring In Action viszont említi a következő témákat, amikről a Spring Recipes nem ír: Tiles, Velocity, Freemarker integráció, RSS tartalom gyártása, Struts2, Tapestry integráció.&lt;/p&gt;
&lt;p&gt;A Spring In Action a tesztelést csak függelékben említi, és az annotációkat még csak egy külön projekttel, a Gienah Testing-gel ismertette. A Spring Recipes részletezi a JUnit 3.x, 4.x és TestNG tesztelést is (@RunWith(SpringJUnit4ClassRunner.class), @ContextConfiguration). Külön megemlítendő a @IfProfileValue annotáció, amivel profilokat tudunk deklarálni JUnit esetén is, hasonlóan a TestNG-hez.&lt;/p&gt;
&lt;p&gt;A Spring Security leírásánál ismerteti a saját névteret, saját AccessDecisionVoter-t implementál az ip-cím ellenőrzésére, sőt az ACL-t is részletesen kifejti. Persze nem a 3-asban bevezetett Expression Language-t használja, hanem after invocation providers-eket.&lt;/p&gt;
&lt;p&gt;A Spring Web Flow-nál részletezi a Spring Security integrációt, a perzisztenciát és a JSF-fel való integrációt is, de nem szól a Struts integrációról.&lt;/p&gt;
&lt;p&gt;A Spring-WS-nél már ír az annotációkról, valamint hogy hogyan lehet Marsheller-t váltani.&lt;/p&gt;
&lt;p&gt;Az EJB integrációnál csupán a JNDI-ből való lekérést írja le. A Spring In Action használja a PitchFork-ot, ami egy pehelysúlyú konténer, mely implementálja az EJB IoC-t és interception-t.&lt;/p&gt;
&lt;p&gt;JMS-nél szintén ismerteti a jms séma használatát. Viszont a Spring In Action-ben nagyon érdekes rész volt a Lingo integráció, mellyel úgy tudtunk metódust hívni, hogy alatta észrevétlenül JMS volt az átviteli protokoll. Ez a Spring Recipes könyvben nem szerepel.&lt;/p&gt;
&lt;p&gt;JMS esetén új tag a context:mbean-export a konfig xml-ben.&lt;/p&gt;
&lt;p&gt;Levélküldésnél érdekes, hogy leírja, hogy kell belőni a JAMES Java-ban írt mail szervert, valamint mime levelet is küld (nem sima szöveg, hanem HTML tartalom - akár CSS-sel, képekkel).&lt;/p&gt;
&lt;p&gt;Ütemezésnél leírja, hogy kell Task-ot, Quartz Job-ot hívni, de nem írja, hogy kell egy egyszerű metódust hívni ütemezetten.&lt;/p&gt;
&lt;p&gt;Összességében elmondható, hogy a Spring Recipes könyv már haladó Spring fejlesztőknek szól inkább. Jobban referencia jellegű, és felépítéséből adódóan gyakrabban leveszi az ember a polcról, ha valami problémába ütközik. A Spring In Action ezzel szemben jobban elméleti jellegű, segítségével megérthetjük, hogy a Spring fejlesztésben honnan indultak, hogyan jutottak el egy-egy megoldásig, milyen döntések születtek közben, stb. Inkább kezdőknek javaslom, vagy akit érdekel a mélyebb elméleti áttekintés. A részletes leírások miatt tapasztalatlanabb programozónak működő kódig eljutnia is egyszerűbb a Spring In Action használatával.&lt;/p&gt;
&lt;p&gt;De itt van már a Spring 3, melyet a Spring Recipes könyv augusztusra ígért második kiadása fog lefedni (ilyen izgalmas témaköröket ígér, mint Spring Batch, jBPM integráció, Terracotta és GridGrain integráció, Spring Roo, Grails Framework (és Groovy) integráció, REST web szolgáltatások, OSGi használata Spring Dynamic Modules-szal és SpringSource dm Server - ami közben beolvadt az &lt;a href="http://www.eclipse.org/virgo"&gt;Eclipse Virgo&lt;/a&gt; projektbe.)&lt;/p&gt;
&lt;p&gt;És még &lt;a href="http://mylearn.vmware.com/mgrReg/courses.cfm?ui=S2&amp;amp;a=det&amp;amp;id_course=68949"&gt;Spring oktatás&lt;/a&gt; is lesz augusztus 3-6 között Budapesten.
&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/6926536731502363770/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/07/spring-recipes.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6926536731502363770'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6926536731502363770'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/07/spring-recipes.html' title='Spring Recipes: A Problem-Solution Approach'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://2.bp.blogspot.com/-yXnlTRgeHqQ/TsF93RgZxBI/AAAAAAAAHjU/WB4ut9Rr428/s72-c/spring_recipes_cover.png' height='72' width='72'/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-917558965350491643</id><published>2010-07-11T20:51:00.007+02:00</published><updated>2014-01-04T19:45:52.593+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='open source'/><category scheme='http://www.blogger.com/atom/ns#' term='biztonság'/><category scheme='http://www.blogger.com/atom/ns#' term='Library'/><category scheme='http://www.blogger.com/atom/ns#' term='Tesztelés'/><category scheme='http://www.blogger.com/atom/ns#' term='Maven'/><category scheme='http://www.blogger.com/atom/ns#' term='Spring'/><title type='text'>Spring Security 3 ACL</title><content type='html'>&lt;p&gt;Frissítve: 2014. január 4.&lt;/p&gt;

&lt;p&gt;Felhasznált technológiák: Spring 3.2, Spring Security 3.2, Ehcache 2.6.6, HSQLDB 2.3.1, SLF4J 1.7.5, JUnit 4.11,
    Maven 3.0.3&lt;/p&gt;
&lt;p&gt;A Spring Security-ről már volt szó egy &lt;a href="http://jtechlog.blogspot.com/2010/01/spring-security.html"&gt;korábbi
    post-ban&lt;/a&gt;, ebben a cikkben az üzleti objektumok biztonságáról (Domain Object Security) írok, melyet a Spring
    Security ACL-ekkel old meg, valamint megemlíteném a Spring Security 3 egyik fő újdonságát (Expression-Based
    Access Control).
&lt;/p&gt;
&lt;p&gt;A Spring Security többek között deklaratív autentikációt (durván bejelentkezés, azonosítás) és autorizációt
    (jogosultságkezelés) biztosít. Ez utóbbit webes alkalmazásoknál úgy használjuk ki, hogy URL pattern-eket, védett
    erőforrásokat határozunk meg, és ezekhez szerepköröket rendelünk, így ezen oldalakat csak azon felhasználók
    tudják megnézni, akik rendelkeznek az elvárt szerepkör(ök)kel. Lehetőség van ezen kívül metódushívás szintű
    jogosultságkezelés megvalósítására is, ilyenkor azt tudjuk megmondani, hogy az adott metódust milyen
    szerepkörrel rendelkező felhasználó tudja meghívni. Amennyiben a felhasználó nem rendelkezik a megadott
    szerepkörrel, kivétel keletkezik.
&lt;/p&gt;
&lt;p&gt;Azonban ez sok esetben nem elegendő, komolyabb üzleti alkalmazásnál szükségünk lehet arra, hogy megmondjuk, hogy
    melyik üzleti objektumon, melyik felhasználó (vagy milyen szerepkörrel rendelkező felhasználó), milyen
    műveleteket tudjon elvégezni. Pl. vegyünk egy szerkesztőségi rendszert, ahol minden cikkre megmondhatjuk, hogy
    melyik felhasználó tudja az adott cikket megtekinteni, ki tudja szerkeszteni, esetleg törölni.
&lt;/p&gt;
&lt;p&gt;Ezt persze a már említett post-ban lévő eszközökkel is meg lehet valósítani. Pl. lehet az üzleti metódusban
    lekérni a SecurityContextHolder.getContext().getAuthentication() metódussal a bejelentkezett felhasználót, és a
    szerint végezni el az üzleti műveletet. Amennyiben szépen akarjuk csinálni, ezt akár AOP-vel is csinálhatjuk, és
    külön kódba szervezhetjük ki. Ennek használatával azonban szoros lesz a kapcsolat az üzleti logika és a
    jogosultág-ellenőrzés között, kevésbé lesz átlátható, újrafelhasználható. Csinálhatjuk azt is, hogy saját
    AccessDecisionVoter és GrantedAuthority implementációkat használunk, és minden üzleti objektumon végezhető
    művelethez egy GrantedAuthority tartozik. Itt az üzleti objektumok elszaporodásával a GrantedAuthority példányok
    száma is megnövekszik. Valamint az AccessDecisionVoter is hozzáférhetne az üzleti objektumokhoz, és ez alapján
    dönthetne a jogosultságról. Ilyenkor kell neki egy dao referencia, és minden műveletnél az AccessDecisionVoter
    is el fog végezni egy plusz műveletet. Azonban minden esetben meg kell oldanunk a jogosultságok perzisztálását,
    valamint az üzleti logikát is módosítanunk kell.
&lt;/p&gt;
&lt;p&gt;Szerencsére a Spring Security beépített megoldást ad a problémára, melynek neve a &lt;a
        href="http://docs.spring.io/spring-security/site/docs/3.2.0.RELEASE/reference/htmlsingle/#domain-acls"&gt;Domain
    Object Security&lt;/a&gt;, melyet ACL-ek (access control list), hozzáférési listákkal valósít meg. Az
    &lt;a href="http://en.wikipedia.org/wiki/Access_Control_List"&gt;ACL-ek&lt;/a&gt;
    használata a számítástechnikában máshol is igen elterjedt. Egy ACL egy erőforráshoz tartozik, egy lista, ami
    tartalmazza, hogy az adott erőforráson mely felhasználók milyen műveleteket végezhetnek. Tipikus példa erre a
    fájlrendszerek, ahol minden fájlhoz/könyvtárhoz tartozik egy ACL, mely leírja, hogy mely felhasználók és
    csoportok olvashatják/írhatják/futtathatják (listázhatják) az adott fájlt/könyvtárat. Az ACL elemei az ACE-k
    (access control entry), mely egy sor az ACL-ben.
&lt;/p&gt;
&lt;p&gt;Nézzük, a Spring Security milyen fogalmakat definiál, és ezekhez milyen interfészek kapcsolódnak. Először is egy
    UML diagram.
&lt;/p&gt;
&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}"
   href="http://2.bp.blogspot.com/_czKgycLvmNo/TDoT7RPcRMI/AAAAAAAAFUI/cB0H8i7L_LU/s1600/SpringSecurityAclModel.png"&gt;
    &lt;img style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 320px; height: 278px;"
         src="http://2.bp.blogspot.com/_czKgycLvmNo/TDoT7RPcRMI/AAAAAAAAFUI/cB0H8i7L_LU/s320/SpringSecurityAclModel.png"
         alt="" id="BLOGGER_PHOTO_ID_5492724604493120706" border="0"/&gt;
&lt;/a&gt;
&lt;p&gt;Forrás: &lt;a href="http://grzegorzborkowski.blogspot.com/2008/10/spring-security-acl-very-basic-tutorial.html"&gt;
    Grzegorz Borkowski: Spring Security ACL - very basic tutorial&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;A Spring Security alapban biztosít egy Spring JDBCTemplate-tel megvalósított perzisztenciát is a Domain Object
    Security-hez, mely a legtöbb adatbáziskezelőn működik, hiszen ANSI SQL utasításokat használnak benne. Így az
    interfészeknél leírom, hogy példányait milyen táblában tárolja a Spring Security.
&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;A fő interfész az Acl, mely a listát tartalmazza egy üzleti objektumhoz. Ahogy említettem, egy üzleti
        objektumhoz egy Acl tartozik, és ez tárolja a listaelemeket, melyek felhasználó/művelet párosok, és egy
        ilyen elem adja meg, hogy az adott üzleti objektumra van-e az adott felhasználónak jogosultsága. Az Acl-ek
        fa hierarchiát alkothatnak, így a szülőre is tartalmaz egy referenciát (parent). Az Acl isGranted metódusát
        hívva lehet eldönteni, hogy az adott felhasználó(k)nak van-e joga az adott üzleti objektumon a kérdéses
        műveletet elvégeznie. Az első paramétere a Permission lista, melyben a műveleteket adhatjuk meg, a második
        paramétere a felhasználók listája, és a harmadik paramétere, hogy kell-e audit naplózni a műveletet, vagy
        adminisztratív okokból történt az esemény, ekkor nem kell naplózni. Erre választ a kapcsolódó példányok
        alapján tud választ adni. Valamint tartalmaz egy referenciát a tulajdonos felhasználóra is (owner).
    &lt;/li&gt;
    &lt;li&gt;A felhasználót Sid-nek nevezi (Security Identity), ugyanis lehet principal név (ami vagy egy személyhez,
        vagy egy rendszerhez kapcsolódó felhasználónév), vagy lehet szerepkör is, azaz a Spring Security
        szóhasználatban GrantedAuthority név. A Sid-en kívül a másik gyűjtőnevük a recipient. Így a Sid interfésznek
        két leszármazottja is van, PrincipalSid, valamint GrantedAuthoritySid.
    &lt;/li&gt;
    &lt;li&gt;Az Acl nem tartalmaz közvetlen referenciát az üzleti objektumra, hanem helyette egy ObjectIdentity
        példányra. Ennek két attribútuma az üzleti objektum osztálya (javaType), valamint egyedi azonosítója
        (identifier). Ennek egy implementációja a ObjectIdentityImpl. A Domain Object Security úgy lett
        megvalósítva, hogy megfelelően kezeli a Long, vagy Long-gá konvertálható egyedi azonosítóval rendelkező
        üzleti objektumokat. Amennyiben nem ilyen üzleti objektumaink vannak bizonyos interfészeket magunknak kell
        implementálnunk. A Spring Security készítői később sem kívánják támogatni a Long-tól eltérő egyedi
        azonosítókat. (Én személy szerint amúgy is mindenkinek javaslom, hogy minden üzleti objektumnak legyen egy
        Long egyedi azonosítója, és kerüljük pl. szöveget, dátumot tartalmazó, valamint az összetett elsődleges
        kulcsokat.
    &lt;/li&gt;
    &lt;li&gt;Az Acl ACE elemeket tartalmaz, melyeket az AccessControlEntry interfész reprezentálja. Ez tartalmaz egy
        referenciát egy műveletre (Permission), valamint egy Sid-re, van egy egyedi azonosítója, valamint egy
        granting attribútuma, ami azt mondja meg, hogy az adott jogosultság aktív-e, vagy visszavonásra került.
    &lt;/li&gt;
    &lt;li&gt;Lehet saját Permisson megvalósítást is alkalmazni, de a Spring Security alapértelmezetten tartalmazza a
        BasePermission osztályt, mely a következő műveleteket definiálja: CREATE, READ, WRITE, DELETE,
        ADMINISTRATION, a legtöbb esetben ez is elég lehet.
    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A Spring Security ezen interfészek példányaihoz, illetve a példányok által ábrázolt információkhoz a AclService
    interfészen keresztül enged hozzáférést, ez egy normál service osztály, melyet a szokásos módon deklarálhatunk
    az applicationContext.xml-ben, és kérhetünk rá referenciát dependency injection-nel. Ennek a readAclById és
    readAclsById metódusaivel férhetünk hozzá az Acl-ekhez. Nem mindig használjuk ezt direktben, később látni
    fogjuk, hogy lehet deklaratív módon használni.
&lt;/p&gt;
&lt;p&gt;Az AclService leszármazottja a MutableAclService, mely már módosítási műveleteket is megenged az Acl-eken.
    Ugyanis ezen alkalmazásokban már nem lehet deklaratív módon felvenni az Acl-eket, hiszen maguk az üzleti
    objektumok is folyamatosan változnak, jönnek létre és szűnnek meg, ezért az üzleti logikának kell arról is
    gondoskodnia, hogy az Acl-eket is az üzleti objektumokkal együtt módosítsa. Az AclService egyik implementációja
    a JdbcAclService, a MutableAclService implementációja a JdbcMutableAclService, mely ANSI SQL műveletekkel kezeli
    az Acl-ek perzisztenciáját relációs adatbázisokban. A JdbcMutableAclService a lekérdezéseket egy LookupStrategy
    implementációnak delegálja, mely az adatbázisra optimalizált lekérdezést tartalmazhatja. Ennek egy
    implementációja megtalálható a Spring Security-ban is BasicLookupStrategy néven. Ha az adott adatbázis speciális
    lehetőségeit (pl. hierarchikus lekérdezések, materializált nézet, reduce normalization) ki akarjuk használni,
    saját osztályt kell írni, mely implementálja a LookupStrategy interfészt. A BasicLookupStrategy nem támogatja a
    leszármaztatást. Mind a JdbcMutableAclService-nek, mind a BasicLookupStrategy-nek szüksége van egy
    DataSource-ra.
&lt;/p&gt;
&lt;p&gt;Ahogy említettem a jogosultság ellenőrzéséhez használhatnánk az AclService megfelelő metódusait, de van egy
    egyszerűbb deklaratív módszer is, mely a Spring Security 3-asban jelent meg, és erősen támaszkodik a Spring 3
    Spring Expression Language-ére. Ezt Expression-Based Access Control-nak nevezi, és akár XML leíróban (security
    namespace), akár annotációban (@Pre és @Post) is alkalmazhatjuk. Ebből az ACL is elérhető, és pl. deklarálni
    lehet, hogy az adott metódus hívása előtt vagy után milyen üzleti objektumon (metódus paraméter vagy
    visszatérési érték), milyen műveletre való jogosultságot kell ellenőrizni. Valamint lehetőség van filterezésre
    is, ami pl. egy metódus visszatérési értékeként szereplő listából eltávolítja azon üzleti objektumokat, melyekre
    a bejelentkezett felhasználónak nincs meg a megfelelő műveletre a megfelelő jogosultsága. Persze a háttérben
    ebből ugyanúgy egy Acl lekérdezés, majd metódushívás lesz.
&lt;/p&gt;
&lt;p&gt;A Domain Object Security ezeken felül a következőket biztosítja:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Caching: Ehcache backend-del&lt;/li&gt;
    &lt;li&gt;Transzparens adatbázis műveletek&lt;/li&gt;
    &lt;li&gt;Perzisztencia úgy megvalósítva, hogy minimális legyen a deadlock valószínűsége&lt;/li&gt;
    &lt;li&gt;ORM-től való függetlenség, hiszen plain JDBC van a háttérben&lt;/li&gt;
    &lt;li&gt;Egységbezárás&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Most, hogy ismerjük a Java interfészeket, nézzük, hogy történik a kapcsolódó objektumok perzisztenciája.&lt;/p&gt;
&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}"
   href="http://2.bp.blogspot.com/_czKgycLvmNo/TDoUE8SCxJI/AAAAAAAAFUQ/FpUbIlmsXdM/s1600/springsecurityacl.png"&gt;
    &lt;img style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 320px; height: 147px;"
         src="http://2.bp.blogspot.com/_czKgycLvmNo/TDoUE8SCxJI/AAAAAAAAFUQ/FpUbIlmsXdM/s320/springsecurityacl.png"
         alt="" id="BLOGGER_PHOTO_ID_5492724770665579666" border="0"/&gt;
&lt;/a&gt;
&lt;p&gt;Egy ACL_OBJECT_IDENTITY sor tartozik minden egyes üzleti objektumhoz. Ez tartalmaz egy külső kulcsot az ACL_CLASS
    táblára, mely tartalmazza az üzelti objektum osztályának teljes nevét (fully qualified name - csomaggal együtt).
    Egy ACL_OBJECT_IDENTITY sorhoz több ACL_ENTRY sor tartozhat, mely összeköti az üzleti objektumot, a Sid-et,
    valamint a MASK mezőben (32 biten) tárolja, hogy mely műveletek megengedettek. Ebből pl. a BasePermission csak 5
    bitet használ fel, hiszen 5 műveletet definiál (read - bit 0, write - bit 1, create - bit 2, delete - bit 3 és
    administer - bit 4). Az ACL_SID tábla tartalmazza a Sid-eket, vagyis a felhasználók vagy szerepkörök neveit.
&lt;/p&gt;
&lt;p&gt;Bár a disztribúció tartalmaz egy
    &lt;a href="https://github.com/spring-projects/spring-security/tree/master/samples/contacts-xml/"&gt;példa alkalmazást&lt;/a&gt;,
    készítettem én is egyet, mely talán egy kicsit egyszerűbb, és &lt;a href="https://github.com/vicziani/jtechlog-spring-security-acl"&gt;megtalálható a GitHub-on&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;Az alkalmazás Maven-nel build-elhető. A különböző funkciókat JUnit teszt
    esetek tesztelik, szóval a mvn test parancs kiadásával fordítható és tesztelhető a projekt.
&lt;/p&gt;
&lt;p&gt;Az példa egy egyszerű szerkesztőségi rendszer service rétege, melyben cikkeket lehet felvenni, és be lehet állítani, hogy
    melyik cikken melyik felhasználó milyen műveletet végezhet. Az entitás az Article osztály, a service interfész a
    ArticleService, melynek egy megvalósítása a ArticleServiceImpl. Az egyszerűség kedvéért egy Map-ben tárolja el a
    cikkeket. Az alkalmazás felépítése az UML diagram alapján egyértelmű.
&lt;/p&gt;
&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}"
   href="http://4.bp.blogspot.com/_czKgycLvmNo/TDoURCoT4hI/AAAAAAAAFUY/9yZ9fVPTGD4/s1600/springsecurityacl_pelda.png"&gt;
    &lt;img style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 320px; height: 98px;"
         src="http://4.bp.blogspot.com/_czKgycLvmNo/TDoURCoT4hI/AAAAAAAAFUY/9yZ9fVPTGD4/s320/springsecurityacl_pelda.png"
         alt="" id="BLOGGER_PHOTO_ID_5492724978528018962" border="0"/&gt;
&lt;/a&gt;
&lt;p&gt;Az alkalmazás egy applicationContext.xml-lel rendelkezik, de bonyolultabb alkalmazás esetén javasolt a
    biztonsággal kapcsolatos konfigurációt egy másik (applicationContext-security.xml) állományba kiszervezni. Az
    adatforrás (DataSource) és a tranzakciókezelő beállításait külön XML-be szerveztem
    (applicationContext-test.xml), hiszen feltehetőleg egy éles alkalmazás komolyabb adatbáziskezelővel futna, csak
    a teszt esetek futnak HSQLDB-vel.
&lt;/p&gt;
&lt;p&gt;Az ACL használatához először létre kell hozni a fentebb bemutatott táblákat. A létrehozó script megtalálható a
    &lt;a href="http://docs.spring.io/spring-security/site/docs/3.2.0.RELEASE/reference/htmlsingle/#dbschema-acl"&gt;dokumentációban&lt;/a&gt;
    HyperSQL-re és PostgreSQL-re, de megtalálhatóak a spring-security-acl-3.2.0.RELEASE.jar-ban is
    createAclSchema.sql néven.
&lt;/p&gt;
&lt;p&gt;A következő lépésként hozzuk létre az applicationContext.xml állományt.&lt;/p&gt;
&lt;pre class="brush: xml"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;

&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:security=&amp;quot;http://www.springframework.org/schema/security&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
       http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.2.xsd&amp;quot;&amp;gt;

    &amp;lt;bean id=&amp;quot;articleService&amp;quot; class=&amp;quot;jtechlog.acltutorial.ArticleServiceImpl&amp;quot; /&amp;gt;

    &amp;lt;security:global-method-security pre-post-annotations=&amp;quot;enabled&amp;quot;&amp;gt;
        &amp;lt;security:expression-handler ref=&amp;quot;expressionHandler&amp;quot;/&amp;gt;
    &amp;lt;/security:global-method-security&amp;gt;

    &amp;lt;bean id=&amp;quot;expressionHandler&amp;quot;
          class=&amp;quot;org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;permissionEvaluator&amp;quot; ref=&amp;quot;aclPermissionEvaluator&amp;quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&amp;quot;aclPermissionEvaluator&amp;quot; class=&amp;quot;org.springframework.security.acls.AclPermissionEvaluator&amp;quot;&amp;gt;
        &amp;lt;constructor-arg ref=&amp;quot;aclService&amp;quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&amp;quot;aclCache&amp;quot;
          class=&amp;quot;org.springframework.security.acls.domain.EhCacheBasedAclCache&amp;quot;&amp;gt;
        &amp;lt;constructor-arg&amp;gt;
            &amp;lt;bean class=&amp;quot;org.springframework.cache.ehcache.EhCacheFactoryBean&amp;quot;&amp;gt;
                &amp;lt;property name=&amp;quot;cacheManager&amp;quot;&amp;gt;
                    &amp;lt;bean class=&amp;quot;org.springframework.cache.ehcache.EhCacheManagerFactoryBean&amp;quot; /&amp;gt;
                &amp;lt;/property&amp;gt;
                &amp;lt;property name=&amp;quot;cacheName&amp;quot; value=&amp;quot;aclCache&amp;quot; /&amp;gt;
            &amp;lt;/bean&amp;gt;
        &amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&amp;quot;lookupStrategy&amp;quot;
          class=&amp;quot;org.springframework.security.acls.jdbc.BasicLookupStrategy&amp;quot;&amp;gt;
        &amp;lt;constructor-arg ref=&amp;quot;dataSource&amp;quot; /&amp;gt;
        &amp;lt;constructor-arg ref=&amp;quot;aclCache&amp;quot; /&amp;gt;
        &amp;lt;constructor-arg&amp;gt;
            &amp;lt;bean
                    class=&amp;quot;org.springframework.security.acls.domain.AclAuthorizationStrategyImpl&amp;quot;&amp;gt;
                &amp;lt;constructor-arg&amp;gt;
                    &amp;lt;list&amp;gt;
                        &amp;lt;!-- authority for taking ownership --&amp;gt;
                        &amp;lt;bean class=&amp;quot;org.springframework.security.core.authority.SimpleGrantedAuthority&amp;quot;&amp;gt;
                            &amp;lt;constructor-arg value=&amp;quot;ROLE_ADMIN&amp;quot; /&amp;gt;
                        &amp;lt;/bean&amp;gt;
                        &amp;lt;!-- authority to modify auditing --&amp;gt;
                        &amp;lt;bean class=&amp;quot;org.springframework.security.core.authority.SimpleGrantedAuthority&amp;quot;&amp;gt;
                            &amp;lt;constructor-arg value=&amp;quot;ROLE_ADMIN&amp;quot; /&amp;gt;
                        &amp;lt;/bean&amp;gt;
                        &amp;lt;!-- authority to make general changes --&amp;gt;
                        &amp;lt;bean class=&amp;quot;org.springframework.security.core.authority.SimpleGrantedAuthority&amp;quot;&amp;gt;
                            &amp;lt;constructor-arg value=&amp;quot;ROLE_ADMIN&amp;quot; /&amp;gt;
                        &amp;lt;/bean&amp;gt;
                    &amp;lt;/list&amp;gt;
                &amp;lt;/constructor-arg&amp;gt;
            &amp;lt;/bean&amp;gt;
        &amp;lt;/constructor-arg&amp;gt;
        &amp;lt;constructor-arg&amp;gt;
            &amp;lt;bean class=&amp;quot;org.springframework.security.acls.domain.ConsoleAuditLogger&amp;quot; /&amp;gt;
        &amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&amp;quot;aclService&amp;quot;
          class=&amp;quot;org.springframework.security.acls.jdbc.JdbcMutableAclService&amp;quot;&amp;gt;
        &amp;lt;constructor-arg ref=&amp;quot;dataSource&amp;quot; /&amp;gt;
        &amp;lt;constructor-arg ref=&amp;quot;lookupStrategy&amp;quot; /&amp;gt;
        &amp;lt;constructor-arg ref=&amp;quot;aclCache&amp;quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;&lt;/pre&gt;
&lt;p&gt;Az articleService a saját service osztályunk. A következő global-method-security tag pre-post-annotations attribútuma mondja meg,
    hogy annotációkban adjuk meg a biztonsági beállításokat. Amennyiben nem használunk ACL-t, ennyi elegendő is, de
    esetünkben meg kell adni azt is, hogy Expression-Based Access Control-t használunk, és használni akarjuk majd a
    hasPermission függvényt, mellyel az ACL alapján lehet majd jogosultságot ellenőrizni. Erre kell a
    expressionHandler és a aclPermissionEvaluator is. Az utóbbi dolga a expression system és a Spring Security's ACL
    system közötti híd megépítése. A aclCache bean állítja be, hogy az ACL az Ehcache-t használja cache-eléshez.
    Majd megadjuk az ACL-ek lekérdezéséhez szükséges lookupStrategy bean-t (használja a cache-t és a DataSource-ot
    is). Valamint konstruktorának első paramétere egy AclAuthorizationStrategyImpl, mely azt adja meg, hogy milyen
    jogosultságok szükségesek ahhoz, hogy módosítani lehessen az ACL tulajdonosát, módosítani az audit naplózás
    beállíásokat, valamint módosítani egyéb ACL és ACE beállításokat. A második paramétere egy AuditLogger, melynek
    egyetlen beépített implementációja a ConsoleAuditLogger. Az utolsó bean a aclService, melyet az alkalmazásunkból
    is használni fogunk.
&lt;/p&gt;
&lt;p&gt;A applicationContext-test.xml állományban állítjuk be az adatforrást (beépített adatbáziskezelőt futtat, és
    végrehajtja a sémát létrehozó szkriptet), a tranzakciókezelőt, valamint azt, hogy a
    tranzakció konfigurációja annotációkban történjen.
&lt;/p&gt;
&lt;pre class="brush: xml"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;

&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:tx=&amp;quot;http://www.springframework.org/schema/tx&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:jdbc=&amp;quot;http://www.springframework.org/schema/jdbc&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd
       http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.2.xsd&amp;quot;&amp;gt;

    &amp;lt;tx:annotation-driven /&amp;gt;

    &amp;lt;jdbc:embedded-database id=&amp;quot;dataSource&amp;quot; &amp;gt;
        &amp;lt;jdbc:script location=&amp;quot;classpath*:/createAclSchema.sql&amp;quot; /&amp;gt;
    &amp;lt;/jdbc:embedded-database&amp;gt;


    &amp;lt;bean id=&amp;quot;transactionManager&amp;quot;
          class=&amp;quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;&lt;/pre&gt;
&lt;p&gt;Elengedhetetlen az ACL használatához a tranzakciós környezet, hiszen az ACL-ek adatbázisba kerülnek mentésre
    (JdbcTemplate-tel).
&lt;/p&gt;
&lt;p&gt;Nézzük először, hogy hogyan történik az üzleti objektumhoz ACL rendelése, ehhez nézzük meg a grantPermission
    metódus implementációját.
&lt;/p&gt;
&lt;pre class="brush: java"&gt;@Override
@Transactional
public void grantPermission(String principal, Article article, Permission[] permissions) {
 LOGGER.info("Grant {} permission to principal {} on article {}", permissions, principal, article);
 ObjectIdentity oi = new ObjectIdentityImpl(Article.class, article.getId());
 Sid sid = new PrincipalSid(principal);

 MutableAcl acl;
 try {
  acl = (MutableAcl) aclService.readAclById(oi);
 } catch (NotFoundException nfe) {
  acl = aclService.createAcl(oi);
 }

 for (Permission permission : permissions) {
  switch (permission) {
   case READ:
    acl.insertAce(acl.getEntries().size(), BasePermission.READ, sid, true);
    break;
   case WRITE:
    acl.insertAce(acl.getEntries().size(), BasePermission.WRITE, sid, true);
    break;
  }
 }
 aclService.updateAcl(acl);
}
&lt;/pre&gt;
&lt;p&gt;Először példányosítunk az üzleti objektum alapján egy ObjectIdentityImpl példányt. Majd lekérdezzük, ha nincs,
    létrehozunk hozzá egy Acl-t. Majd az Acl-be felveszünk egy Ace-t, sorrendben a végére, mely tartalmaz egy
    referenciát a BasePermission.READ műveletre, valamint a paraméterként átadott felhasználóra. Azaz a
    ArticleServiceTest teszt osztályban a következő sor (@Before annotációval ellátott init() metódusban található)
    a user1 felhasználónak megadja a jogosultságot, hogy az 1-es azonosítójú cikket szerkeszteni és módosítani
    tudja.
&lt;/p&gt;
&lt;pre class="brush: java"&gt;articleService.grantPermission("user1", article1, new
    ArticleService.Permission[]{ArticleService.Permission.READ, ArticleService.Permission.WRITE});
&lt;/pre&gt;
&lt;p&gt;A következő lépésben meg kell valósítani a jogosultságkezelést. Ez történhet kódból is, javasolt AOP-vel, pl.
    metódushívás előtt AccessDecisionVoter használata, metódushívás után AfterInvocationProvider használata. Ezekben
    az aclService használatával le kell kérni az üzleti objektumhoz tartozó Acl-t, majd annek kell meghívni a
    isGranted metódusát. De vannak erre az ACL-ben megfelelő osztályok is, mint az AclEntryVoter,
    AclEntryAfterInvocationProvider vagy a AclEntryAfterInvocationCollectionFilteringProvider. De sokkal egyszerűbb
    a Expression-Based Access Control használata, amit használhatunk XML konfigurációban is a security:intercept-url
    access paraméterének, vagy a protect-pointcut expression paraméterének, vagy a @PreAuthorize, @PostAuthorize,
    @PreFilter, @PostFilter annotációk paraméterének. Én az utóbbit, az annotációk használatát javasoltam, ezért
    kellett a global-method-security pre-post-annotations attribútuma az applicationContext.xml-ben.
&lt;/p&gt;
&lt;p&gt;Nézzük is a findArticleById és updateArticle metódusok implementációját.&lt;/p&gt;
&lt;pre class="brush: java"&gt;@Override
@PreAuthorize("hasPermission(#id, 'jtechlog.acltutorial.Article', 'read') or hasRole('ADMIN')")
public Article findArticleById(long id) {
 return articles.get(id);
}

@Override
@PreAuthorize("hasPermission(#article, 'write') or hasRole('ADMIN')")
public void updateArticle(Article article) {
 articles.put(article.getId(), article);
}
&lt;/pre&gt;
&lt;p&gt;Az első PreAuthorize annotációban lévő kifejezés azt jelenti, hogy a metódust csak az futtathatja, akinek az id
    paraméterben átadott id-jú Article típusú üzleti objektum-hoz van read jogosultsága (azaz az 1-es Article
    ACL-jének ACE-i között szerepel), vagy ADMIN szerepkörű. A második PreAuthorize annotációban szereplő kifejezés
    azt jelenti, hogy csak az hívhatja meg a metódust, akinek a paraméterként átadott Article üzleti objektra van
    write jogosultsága vagy ADMIN szerepkörű. Tehát látható, hogy feltételt lehet megadni üzleti objektum
    azonosítójára és magára az objektumra is. Az ehhez tartozó teszt eset pl. a testUserWithRead, akinek van
    olvasási de nincs írási jogosultsága az 1-es Article üzleti objektumhoz. A #-os megadási módhoz szükséges a
    debug információkat is a kódba fordítani.
&lt;/p&gt;
&lt;pre class="brush: java"&gt;@Test
public void testUserWithReadAndWrite() {
 SecurityContextHolder.getContext().setAuthentication(new UsernamePasswordAuthenticationToken("user1", "pass1", Collections.
   singletonList(new SimpleGrantedAuthority("USER"))));
 articleService.findArticleById(1);
 articleService.updateArticle(new Article(1, "test"));
}
&lt;/pre&gt;
&lt;p&gt;Az első sorban beállítjuk a bejelentkezett felhasználót, majd meghívjuk a két üzleti metódust, amiből az elsőhöz
    lesz, a másodikhoz nem lesz jogosultsága. És ne feledjük, az üzleti objektum alapján!
&lt;/p&gt;
&lt;p&gt;Még egy érdekes funkció, hogy az ACL képes filter-elni, szűrni az üzleti objektumokat egy kollekcióból a
    jogosultság alapján.
&lt;/p&gt;
&lt;pre class="brush: java"&gt;@Override
@PostFilter("hasPermission(filterObject, 'read') or hasRole('ADMIN')")
public List&amp;lt;Article&amp;gt; findAllArticles() {
 return new ArrayList&amp;lt;&amp;gt;(articles.values());
}
&lt;/pre&gt;
&lt;p&gt;A PostFilter annotáció hatására a visszaadott listából kiveszi az ACL azon üzleti objektumokat, melyekre nincs
    olvasási jogosultsága a bejelentkezett felhasználónak. Vigyázzunk, hogy nagy listák esetén ne így használjuk,
    mert az adatbázisból lekérdezésre kerül, majd onnan lesznek kiszórva. Hatékonyabb megoldás, ha már eleve csak a
    megfelelő üzleti objektumokat kérdezzük le. A hozzá tartozó teszt eset a testFilterUser2, ugyanis a user2-nek a
    három cikk közül csak kettőre van jogosultsága.
&lt;/p&gt;
&lt;pre class="brush: java"&gt;@Test
public void testFilterUser2() {
 SecurityContextHolder.getContext().setAuthentication(new UsernamePasswordAuthenticationToken("user2", "pass2", Collections.
   singletonList(new SimpleGrantedAuthority("USER"))));
 List&amp;lt;Article&amp;gt; articles = articleService.findAllArticles();
 assertEquals(1, articles.size());
}
&lt;/pre&gt;
&lt;p&gt;Az ACL funkcióit JSP-ből is kihasználhatjuk a security:accesscontrollist tag segítségével.&lt;/p&gt;
&lt;p&gt;Tesztelés közben tudatosult bennem, hogy ne módosítgassuk a táblákat az ACL alatt, hiszen a cache miatt az
    adatbázis módosítás nem fog látszani.
&lt;/p&gt;
&lt;p&gt;További olvasnivalók:&lt;/p&gt;
&lt;p&gt;
    &lt;a href="http://heraclitusonsoftware.wordpress.com/software-development/spring/simple-web-application-with-spring-security-specification/"&gt;
        Heraclitus on software blog: Simple web application with Spring Security
    &lt;/a&gt;&lt;br /&gt;
    &lt;a href="http://www.denksoft.com/wordpress/?page_id=20"&gt;Denksoft Blog: ACL Spring Security tutorial&lt;/a&gt;
&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/917558965350491643/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/07/spring-security-3-acl.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/917558965350491643'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/917558965350491643'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/07/spring-security-3-acl.html' title='Spring Security 3 ACL'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3340228008253492972</id><published>2010-07-01T00:54:00.004+02:00</published><updated>2012-09-28T10:29:05.378+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='open source'/><category scheme='http://www.blogger.com/atom/ns#' term='ha'/><category scheme='http://www.blogger.com/atom/ns#' term='biztonság'/><category scheme='http://www.blogger.com/atom/ns#' term='cluster'/><category scheme='http://www.blogger.com/atom/ns#' term='Java EE'/><category scheme='http://www.blogger.com/atom/ns#' term='könyv'/><title type='text'>JBoss in Action</title><content type='html'>&lt;p&gt;A JBoss AS 5 a jelenlegi egyik legelterjedtebb alkalmazásszerver, köszönhetően annak, hogy időben jelentkeztek egy ingyenes, nyílt forráskódú Java EE implementációval, alternatívát teremtve a kereskedelmi, drága, de nehézkes alkalmazásszervereknek. Jeleleg is sokan használják arra, hogy JBoss-ra fejlesztenek, kihasználva annak relatív gyorsaságát, könnyű telepíthetőségét és egyszerű felépítését.&lt;/p&gt;&lt;p&gt;A Java EE megjelenése óta az alkalmazásszerverek a senki földjét képviselik. A fejlesztők hajlamosak adottságnak tekinteni, és megírják az alkalmazásukat a standardok felhasználásával, és akkor foglalkoznak az alkalmazásszerverrel, ha valami probléma adódik vele, pl. az osztálybetöltők táján. Az üzemeltetés viszont szeretne úgy tekinteni rá, mint az alkalmazás része, annak futtatókörnyezete, és nem foglalkozni vele, hiszen mit is érdekli, hogy mi is az a JMS, EJB, connection pool, HTTP Connector és így tovább. Így tehát az alkalmazásszerver telepítése, üzemeltetése, netalántán üzemeltetése általában vagy egy üzemeltetői hajlamokkal megáldott fejlesztőre marad, vagy egy szorgalmas, ezen technológiákba is belelátni kívánó üzemeltető végzi. Sajnos gyakori probléma, hogy nincsenek a szerepkörök, jogosultságok, de legfőképpen a felelősségi körök a megfelelőképp kiosztva, dokumentálva. Legtöbbször az alkalmazásszerver üzemeltetése szükséges rosszként nyomja valakinek a vállát.&lt;/p&gt;&lt;p&gt;Ezen szakadék áthidalását tűzte ki célul a &lt;a href="http://www.manning.com/jamae/"&gt;JBoss In Action&lt;/a&gt; című könyv, mely a JBoss alkalmazásszerver üzemeltetésének, konfigurálásának leírását tűzte ki célul, és szól egyaránt a fejlesztőkhöz és üzemeltetőkhöz is. Teszi ezt mindazzal, hogy elmagyarázza a szükséges fejlesztői fogalmakat (pl. Java EE, EJB, JMS, WAR, EAR,stb.), de elmagyarázza a gyakori üzemeltetési fogalmakat is, mint load balancing, session affinity, scale up/out, SLA, stb (látható, hogy különösen a cluster-ezési részben). Ebben a post-ban megint keverni fogom a könyvkritikát, valamint a véleményemet a JBoss alkalmazásszerverről magáról.&lt;/p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_czKgycLvmNo/TCvMT0XQOuI/AAAAAAAAFTw/2hB3_LX-X0c/s1600/JamaeJohnson.jpg"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 255px; height: 320px;" src="http://1.bp.blogspot.com/_czKgycLvmNo/TCvMT0XQOuI/AAAAAAAAFTw/2hB3_LX-X0c/s320/JamaeJohnson.jpg" border="0" alt="" id="BLOGGER_PHOTO_ID_5488705211726838498" /&gt;&lt;/a&gt;&lt;p&gt;A könyv írását akkor fejezték be véglegesen, amikor a JBoss AS 5.0 CR2 állapotban volt. A különböző kiadások módosításait (Beta2, 3, 4, CR1) már addig is többször át kellett vezetniük a könyvben. Viszont a B függelék tartalmazza a GA-ban történt változásokat, valamint megtalálhatók a &lt;a href="http://www.manning.com/jamae/excerpt_updates_errata.html"&gt;könyv honlapján is&lt;/a&gt; a hibák és változások, melyeket érdemes elolvasni, komoly változások is történtek pl. a konfigurációs állományok és a naplózás körül is.&lt;/p&gt;&lt;p&gt;A könyv felépítése nagyon logikus és áttekinthető. Négy nagyobb részből épül fel, melyeket kisebb fejezetekből állnak.&lt;/p&gt;&lt;p&gt;Az első rész egy bevezetés, mely azzal indul, hogy miért érdemes a JBoss alkalmazásszervert választani. Remélhetőleg az olvasó ezzel már tisztában van, és ezért veszi kezébe a könyvet. Röviden: nyílt forráskódú, annak minden előnyével. Leírja, hogy mik az előfeltételek (JDK) hogyan kell telepíteni az alkalmazásszerver (rendkívül szimpatikus, hogy ki kell csomagolni a zip-et, és a saját könyvtárán kívül sehova máshova nem dolgozik), és nagyon részletesen kifejti, milyen könyvtárakból áll, és azokban milyen fontosabb állományok találhatóak. Itt részletezi a konfigurációk szerepét is. Egy konfiguráció gyakorlatilag egy könyvtár, mely az összes konfigurációs állományt, telepített szolgáltatást és alkalmazást tartalmazza. Konfigurációt választani egyszerűen úgy lehet, hogy a -c kapcsoló után beírjuk a könyvtár nevét. Saját konfigurációt létre lehet hozni egy már létező konfiguráció (öt előregyártott van a JBoss-ban, ebből kettő az 5.0-ban jelent meg) lemásolásával, és ebből lehet eltávolítani a nem használt szolgáltatásokat (ezt hívja slimming-nek). Nagyon hatékony megoldás. Leírja gyorstalpaló módon, hogy gyorsan sikerélményünk legyen, hogy hogyan kell indítani, leállítani az alkalmazásszerver, és hogyan kell alkalmazást telepíteni és eltávolítani.&lt;/p&gt;&lt;p&gt;A következő rész az alkalmazásszerver részletes bemutatását tűzte ki célul. Itt leírja a microcontainer-t, mely az 5.0-ás JBoss-ban jelent meg, és az előző verziókban lévő JMX microkernel-t. Amíg az utóbbi az MBean-eken alapul, addig a modernebb microcontainer már az aktuális divatnak megfelelően egy Inversion of Control container, mely POJO-kat alkalmaz. Sajnos az 5-ös verzióban még nem sikerült minden komponenst átírni erre, ezért a microcontainer-en fut a JMX kernel is, és azon az át nem írt szolgáltatások, mely szerintem egy felemás felépítést kölcsönöz az egésznek, valamint a konfigurációkon is látszik, hogy melyik az ami az új elv szerint, és melyik az, amit a régi struktúrában kell konfigurálni. Hasonló felemásság figyelhető meg a JBoss build folyamatában is, ugyanis átálltak Maven-re, de bizonyos részeket még nem sikerült beilleszteni, így azok még mindig Ant alapúak. A JBoss üzemeltetése során szoros barátságba kell kerülnünk a JMX-szel, ugyanis sok mindent ezen keresztül lehet futás közben lekérdezni és buherálni, a könyv is nagyszerűen részletezi, elérését a webes JMX konzolból, valamint a parancssoros Twiddle eszközből. Furcsa, de nem írja, hogy a JConsole-ból úgy érhetjük el az MBean-eket, hogy a remote process-t választjuk, és a következő URL-t írjuk be:&lt;/p&gt;&lt;pre&gt;service:jmx:rmi://127.0.0.1/jndi/rmi://127.0.0.1:1090/jmxconnector&lt;/pre&gt;&lt;p&gt;Azért furcsa nekem ez a JMX mánia, mert a mai napig nem láttam használható JMX konzolt (a parancssorosak a legjobbak!), valamint vagy nem jön át a tűzfalon (ha RMI felett megy), vagy rusnya és bonyolult telepíteni, ha webes, és az alkalmazásszerveren fut az alkalmazás mellett.&lt;/p&gt;&lt;p&gt;Részletesen ír még a naplózásról, könyvtárakra hivatkozó system property-kről, és a system property-k beállításáról. A "Deploying applications" fejezetből kiderül hogy nem csak a standard .ear, .war, .jar, .rar típusú alkalmazásokat képes telepíteni a JBoss, hanem maguk a deployer-ek is plug-and-play szolgáltatások, melyekből rengeteg van, így a hozzájuk tartozó telepíthető komponensekből is. Ide tartoznak pl. a .aop (aspect oriented), .sar (service), .zip, .wsr (web szolgáltatás), .bsh (bean shell), stb. Itt írja le a classloader-ek működését, melyekről saját bevallása szerint is keveset ír, de mégis sok hasznos információ megtalálható itt. Olvashatunk a class loader repository-król, melyekkel megoldható, hogy az alkalmazások a saját osztályaikat előnyben részesítség (scoping), a delegációról, valamint különösen hasznos, hogy leírja a legtipikusabb hibákat és azok megoldásait (pl. hiányzik egy osztály, sérült egy archív, vagy egy JAR két példányban van a classpath-ban, és ezért ClassCastException jön). Itt írja le, hogyan kell DataSource-t vagy Hibernate archive-ot installálni. A következő, "Securing applications" fejezet a biztonsági alapfogalmakat írja le. A biztonság a JBoss SX szolgáltatásra épül, amiben security domain-eket lehet definiálni, és azokhoz login module-okat rendelni. Persze ehhez is, mint mindenhez, JNDI-n keresztül fér hozzá az alkalmazás, megoldva a fejlesztő és az üzemeltető közötti izolációt. A fejezet ismerti az alapfogalmakat, mint autentication és authorization, principal, credential. Valamint érthető folyamatábrán el is magyarázza a folyamatot. Valamint itt tér ki arra is, hogy hogyan lehet a kapcsolatot titkosítani, megmagyarázza a PKI-t is, a szerver és kliens oldali tanúsítványok szerepét is. Megmutatja, hogyan lehet a felhasználók és szerepkörök adatait fájlból, adatbázisból, LDAP-ból és tanúsítványokból betölteni. A biztonság a könyv egyik nagy erőssége, ugyanis erre az összes fejezetben visszatér, a webes alkalmazások biztonságára külön fejezetet szán, és részletesen ír az EJB-kkel, JMS-sel, web szolgáltatásokkal és portletekkel kapcsolatos biztonsági szolgáltatásokról is.&lt;/p&gt;&lt;p&gt;A következő nagy fejezet a különböző szolgáltatásokról ír, melyből első a JBoss Web Server, ami nem más, mint egy Apache Tomcat. A konfigurációja nem is tér el attól, a server.xml-ben lehet beállítani a legtöbb dolgot, mint a virtual host-ot, a használt port-okat, a HTTP és AJP connector-t, a HTTPS-t, thread pool-t, timeout-okat és várakozási sorokat, valve-okat (kérések elkapására, használatos naplózásra, ip-címek kitiltására, SSO-ra, stb.). Részletesen ír a context-ről és a ROOT alkalmazásról. A következő fejezet ír a web alkalmazások biztonságáról, a basic, digest, form és certificate alapú autentikációs módokról és standard valamint a gyártófüggő deployment descriptor-okról, és leírja a https konfigurációját, a szerver és kliens oldali tanúsítványokat és a keytool használatát. A következő fejezet az EJB-kről (valamint a JPA-ról) szól, itt talán túl részletesen belemegy forráskód szinten, hogy hogy is néz ki egy ilyen alkalmazás. A mintapéldák nem a könyv erősségei, szerintem feleslegesen hoz több, nem kidolgozott példát, elég lett volna egy alkalmazáson bemutatni a fogalmakat. Itt viszonylag kevés konfigurációs lehetőségről ír, ebből hasznos talán a JNDI nevek konfigurálása, a session bean-eknél a pool és az aktiváció/passziváció finomhangolása. Érdekes lehetőség a JMX service object, mellyel nagyon egyszerűen, a @Management és @Service JBoss-os annotációkkal tudunk JMX MBean-eket létrehozni. Érdekes lehet még, hogy a EJB-k közötti távoli metódushívás protokollját lehet változtatni, pl. HTTP-n, de akár SSL-len is át.&lt;/p&gt;&lt;p&gt;Itt ír még a JMS-ről, és nem point-to-point, hanem publish and subscribe példát hoz. Amúgy nagyon tetszetős az a megoldás a JBoss-ban, hogy DataSource-t, JMX Connection Factory-t és Destination-t, Mail Session-t külön XML fájlokban lehet konfigurálni, és annak létrehozásával futásidőben telepíteni, törlésével undeploy-olni. A konfigurációs lehetőségekről itt sem ír sokat, sajnos sokat áldoz a mintapéldára. Ugyanez igaz a web szolgáltatásokra is. Mindkét esetben a biztonság azért rendesen ki van fejtve.
A következő fejezet a JBoss Portal-ról szól, ami azonban a JBoss Portal 2.6.4-ről szól, mely a JBoss AS 4.2.2-n fut. Bevallom, ezt a fejezetet át is ugrottam. A könyvre amúgy jellemző, hogy referencia jelleggel is forgathatjuk, mindig elővehetjük azt a fejezetet, melyre szükségünk van.&lt;/p&gt;&lt;p&gt;A Going to production első fejezete a cluster-ezésről szól. A cluster-ezés a JGroups-ra és JBoss Cache-re épül. Lehet konfigurálni session replikációt, lehet cluster-ezni az EJB-ket, entitásokat és fel lehet állítani magas rendelkezésre állású JNDI-t is. Alapvetően nem hiszek az állapottal rendelkező alkalmazásokban, így HA-nál elegendőnek szoktam érezni a terheléselosztást, ha állapot van, akkor sticky session-nel. Lehetőleg kerülöm az állapot replikálást. Nagyságrendekkel bonyolítja ugyanis az architektúrát és hibakeresést. A két legérdekesebb fejezet számomra a Tuning the JBoss Application Server és Going to production volt. Itt először olyan aranyszabályokat ír le, melyeket sok mindenkinek meg kéne tartania a performance tuning-ra vonatkozóan. Ilyen pl. hogy induljunk egy olyan állapotból, amit reprodukálni tudunk, azaz a terheléses tesztelést lefuttatva mindig ugyanazt az eredményt kapjuk. Utána minden lépésben egyszerre csak egy dolgot változtassunk. Valamint ne megérzéseinkre, hanem a mérésekre hagyatkozzunk. A teljesítményfokozást az alapoktól, a hardvertől, OS-től kezdi. Még alkalmazásszerver függetlenül leírja a Java memóriahasználatát és a GC működését. Ez volt az egyik legjobb írás, amit valaha erről a témáról olvastam. Se nem túl mély, se nem túl általános, és sok hasznos gyakorlati tanácsot is leír, mind monitorozásra vonatkozóan, mind azzal kapcsolóan, hogy hogyan és mi alapján állítgassuk a titokzatos -Xms, -Xms, --XXNewSize, --XXMaxNewSize, --XX:NewRatio, stb. parancssori paramétereket. Talán az AS hangolásáról sem ír ilyen jól, ahol a DataSource-okat, HTTP thread pool-t és JSP servlet fordítást említi. Ami nekem külön tetszik, mert jó ötlet, hogy abban az esetben, ha egy gépen több példányt akarunk futtatni, akkor nem kell az összes konfig állományban átírni az összes port-ot, hogy ne legyen port ütközés, hanem a PortBinding-nál meg lehet adni egy increment paramétert, mely az összes port-ot megemeli az itt megadott számmal. Esik itt még szó arról, hogy hogy lehet a JBoss-t szolgáltatásként futtatni Windows-on és Linux-on, valamint hogyan cserélhetjük le a beépített Hipersonic SQL-t egy másik adatbázisra.&lt;/p&gt;&lt;p&gt;Az első függelék leírja a JNDI nevek problémáját, hogy a globális JNDI neveket a Java EE 5 szabvány még nem rögzítette, melyről már &lt;a href="http://jtechlog.blogspot.com/2009/01/jndi-nevek-ejb-krnyezetben.html"&gt;én is írtam&lt;/a&gt;. Erre javasol egy megoldást. A második függelék a 5.0 GA-ban történt változásokról ír. Esik itt szó a webes adminisztrációs felületről, ami régóta hiányzik a JBoss-ból (hát a mostani sem egy lenyűgöző megoldás), a common/lib könyvtárról, a profile service repository-ról, konfigurációs állományok helyének módosításáról és a naplózás változásairól.&lt;/p&gt;&lt;p&gt;Összességében a könyv nagyon nehéz feladatra vállalkozott, hiszen a fejlesztőknek sok alapvető fogalmat magyaráz el, melyet átugorhatnak, az üzemeltetőknek viszont nem tudom mennyire van értelme ennyire belemászniuk a forráskódokba. Az biztos, hogy több szép megvillanás van a könyvben melyek miatt mind a két tábornak érdemes, ha nem is az elejétől a végéig átolvasnia, de legalább az érdekes fejezeteket átlapoznia.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/3340228008253492972/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/07/jboss-in-action.html#comment-form' title='4 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3340228008253492972'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3340228008253492972'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/07/jboss-in-action.html' title='JBoss in Action'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://1.bp.blogspot.com/_czKgycLvmNo/TCvMT0XQOuI/AAAAAAAAFTw/2hB3_LX-X0c/s72-c/JamaeJohnson.jpg' height='72' width='72'/><thr:total>4</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3613942055503022824</id><published>2010-06-20T22:50:00.008+02:00</published><updated>2014-03-25T20:35:11.252+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='open source'/><category scheme='http://www.blogger.com/atom/ns#' term='ha'/><category scheme='http://www.blogger.com/atom/ns#' term='cluster'/><category scheme='http://www.blogger.com/atom/ns#' term='scalability'/><category scheme='http://www.blogger.com/atom/ns#' term='Java EE'/><category scheme='http://www.blogger.com/atom/ns#' term='Tomcat'/><category scheme='http://www.blogger.com/atom/ns#' term='könyv'/><category scheme='http://www.blogger.com/atom/ns#' term='lb'/><title type='text'>Clusterezés általában és Tomcaten</title><content type='html'>&lt;p&gt;A skálázatóság (Scalability) és magas rendelkezésre állás (High availability) fogalma ugyan gyakran használatos, mégis alapvető félreértések szoktak ezzel kapcsolatban adódni. A skálázhatóság azt jelenti, hogy újabb erőforrások hozzáadásával (gondoljunk hardver hozzáadására), nő a rendszer áteresztőképessége. Azaz nagyobb terhelés esetén több felhasználót/gyorsabban tud kiszolgálni. A skálázhatóságnak két formája van. A vertikális skálázhatóság (skale up) során ugyanabba a szerverbe több processzort, memóriát téve nő annak áteresztőképessége. Horizontális skálázhatóság esetén több szervert állítunk be, melyek kiszolgálják a felhasználói kéréseket. A magas rendelkezésre állás biztosítása esetén olyan tervezést, implementációt, olyan eszközöket és technológiákat választunk, melyek használatával egy adott időintervallumon belül csökkentjük a leállási idő (downtime) hosszát, amikor is a felhasználó nem fér hozzá a rendszerhez. A magas rendelkezésre állású rendszerek fejlesztése különösen fontos kórházakban, bankokban, repülőtereken és TELCO cégeknél. A leállás lehet előre tervezett (planned), mint pl. tipikusan éjszakai telepítés, vagy véletlenszerű is, amit valamilyen hiba okozhat. A magas rendelkezésreállást százalékban szokták megadni. Gyakran lehet hallani az "öt kilences" rendelkezésreállású rendszert, mely azt jelenti, hogy egy évben az idő 99,999%-ában működik, azaz 0,001%-ban áll. Ez 365*8*60 * 0,001 / 100 = 5,256 perc. Gyakori félreértés, hogy a rendszer (az üzemeltetés szerint) működött, csak épp a felhasználó nem tudta használni (pl. ment a hardver, szoftver, csak éppen hálózati kapcsolat nem volt). Természetesen ez leállásnak minősül. Azzal is szoktak itt trükközni, hogy mi is a teljes leállás. Ha a felhasználó elér bizonyos funkciókat, csak éppen a dolgát nem tudja elvégezni, az leállásnak minősül-e? Persze ezt már nem olyan könnyű definiálni. Szorosan ide tartozik a visszaállás ideje is (recovery time), mely azt adja meg, hogy bizonyos események esetén mennyi idő alatt lehet visszaállni (pl. mentésből). Itt is figyelembe kell venni, hogy pl. egy szoftveres hiba esetén pl. elegendő lehet egy virtuális gép visszamásolása és elindítása, adatvesztés esetén már valamilyen adathordozóról kell visszaállítani az adatokat, de egy árvíz esetén, ahol úsznak a szerverek, már több időre van szükség (ha nincs pl. másodlagos, helyilag szeparált másolat). Az SLA (service level agreement) írja le a magas rendelkezésre állási célokat és követelményeket. Amerikából jövő hírekben lehet hallani, hogy egy fél napos leállás hány millió dolláros károkat tud okozni, de hazai példa is van, mikor a T-Mobile hálózata fél napra szoftverfrissítés következtében felmondta a szolgálatot.&lt;/p&gt;&lt;p&gt;Nézzük még az ide kapcsolódó fogalmakat. A hibatűrés (fault tolerance) annak a foka, hogy a rendszer mennyire képes elviselni egy-egy komponensének hibáját, mennyire lesz ez észrevehető a felhasználó számára. Single point of failure-nek nevezzük azt a komponenst, mely kiesése esetén a rendszer megáll. Ezen pontok kiküszöbölésére a megoldás, hogy a komponensből több példányt állítunk be. Sajnos ennek nem csak előnyei vannak, hanem hátrányai is. Több komponens bevezetésével ugyanis bonyolódik az architektúránk, több komponens hibásodhat meg, és sokkal nehezebb lesz a hibakeresés, magasabb a telepítési és üzemeltetési költség, képzettebb szakemberekre van szükség. Amennyiben több komponenst állítunk be ugyanannak a feladatnak az elvégzésére (redundancia), melyek a kliensei számára transzparensek, fürtözésről (cluster) beszélünk, mely a horizontális skálázhatóság eszköze. A fürtözés esetén lehetőség van magas rendelkezésre állású fürtök kialakításásra (High-availability (HA) clusters), melyek kialakításánál alapvető cél, hogyha valamelyik komponens meghibásodás folytán kiesik, helyét egy másik komponens vegye át (failover). Beszélhetünk aktív/aktív (active/active) fürtről, mikor két komponens esetén mind a kettő kiszolgálja a kéréseket, valamint beszélhetünk aktív/passzív (active/passive) fürtről, mikor csak az egyik komponens működik, a másik nem szolgál ki felhasználókat. A passzív tag lehet működő/bekapcsolt, mely nem szolgál ki kéréseket, viszont gyorsan üzembe állítható (hot), és lehet kikapcsolt állapotban is, mely nem pazarol energiát, de elindítása időbe telik (cold). A fürt tagjai un. heartbeat (szívverés) segítségével jelzik, hogy még működésben vannak. Amikor a szívverést a másik fél nem érzékeli, de ettől független mindkét komponens funkcionál (pl. a köztük lévő hálózati kapcsolat szakad meg), "split-brain" effektus léphet fel, mikor mind a kettő azt hiszi magáról, hogy él, és a másik halott. Ez hamar inkonzisztens működéshez és adatokhoz vezethet.&lt;/p&gt;Beszélhetünk ezen kívül terheléselosztásról is (load-balancing clusters), ekkor amikor kérés jön be a felhasználó felől, valamilyen szabály alapján dönteni kell, hogy melyik komponenshez továbbítódik a kérés. Ezt egy terheléselosztó végzi. Itt felmerül a kérés, hogy mi van akkor, ha a terheléselosztó hibásodik meg? Ekkor azt is clusterezzük? Mindig lesz a rendszerben egy single point of failure. A terhelés elosztás esetén, amennyiben a komponenseink állapot tartóak, azaz egy állapot megmarad két felhasználói kérés között (felhasználói munkamenet, session), mit lehet tenni? Az egyik válasz, hogy az állapotot egy olyan helyen tároljuk, mely közös, és melyhez mind a két komponens hozzáfér. Ez lehet egy adatbázis, elosztott cache, stb. Másik megoldás lehet, hogy a felhasználó kéréseiről gondoskodunk, hogy mindig ugyanahhoz a komponenshez essenek be, ennek neve session affinity, vagy sticky session. Vagy választhatjuk azt is, hogy mindegy melyik komponenshez esik be a kérés, a komponensek között megoldjuk az állapotok replikálását (session replication). Ez esetben is érdemes lehet bekapcsolni a sticky sessiont. Ebből látszik, hogy legegyszerűbb dolgunk akkor van, ha nem állapottartó a rendszerünk.&lt;p&gt;De mi alapján döntsön a terheléselosztó, hogy hova ossza kérést? A legegyszerűbb megoldás, hogy körben forgó (round robin) DNS-t használunk, és így hálózati szintre toltuk le a megoldást, azaz a felhasználó kérésében szereplő domain nevet a dns hol az egyik, hol a másik ip-címre fogja feloldani. Történhet véletlenszerűn, egyszerűbb algoritmusok alapján (pl. minden páros ip-címről érkező kérés az első komponensre megy), vagy egész bonyolult algoritmusok alapján. Bizonyos terhelészelosztók tudják azt, hogy figyelik a komponenseket, és amennyiben az egyik leáll, annak nem osztanak további kéréseket (health checking). Lehetőség lehet un. graceful shutdownra is, amikor tervezett leállás, pl. új verzió kirakása esetén először kiiktatjuk az egyik komponenst. A terheléselosztó új kéréseket erre már nem irányít, de a már folyamatban lévő kéréseket, felhasználói munkameneteket kiszolgálja, gyakorlatilag megvárja, hogy a kérések kifussanak. Ha az összes kérés megszűnt, el lehet végezni rajta a karbantartást, és újra visszakapcsolni, hogy fogadhasson kéréseket. Majd ugyanezt kell eljátszani a másik komponenssel is. Ezáltal megoldható a leállás nélküli telepítés/karbantartás. Bizonyos terheléselosztók tudják azt is, hogy figyelik a háttér komponensek terhelését, és a kérést annak oszthatják, melyek terhelése a legalacsonyabb.

Alkalmazás clusterezése estén úgy is elvégezhetjük a különböző komponensekre való szétosztást, hogy minden komponensre ugyanazt a konfigurációt tesszük, tehát gyakorlatilag szimmetrikusak, ugyanazokat a szolgáltatásokat biztosítják. De funkciónként szét is választhatjuk azokat, pl. külön szerverekre helyezzük el a különböző alkalmazás rétegeket, pl. üzleti logikát és felhasználói felületet szétválasztjuk, vagy pl. az erőforrásigényes műveleteket külön szerverekre, akár céleszközökre bízzuk, mint pl. thumbnail generálás, riport generálás, PDF előállítás, XML feldolgozás, stb.&lt;/p&gt;&lt;p&gt;Látható, hogy a témakör korántsem egyszerű, és nincs egységes megoldás. Mindegyiknek van előnye és hátránya is. Cél, hogy a megrendelői igényeket nem funkcionális követelményekként gyűjtsük össze, és ez alapján válasszunk olyan megoldást, mely költség/érték arányban a legmegfelelőbb.&lt;/p&gt;Végtelen lehetőség közül választhatunk, mind architekúrálisan, mind eszközileg. Vannak hardveres/szoftveres megoldások, kereskedelmi és fizetős termékek.
&lt;p&gt;Ebben a posztban a Tomcat terheléselosztásáról és a Tomcat fürtözéséről fogok írni. A konfigurációt Windowson mutatom be, de könnyen adoptálható Linuxra is. Az aktuális verziók: Apache HTTP Server 2.2.15, Apache Tomcat 6.0.26. A témában magasan a legjobb könyv a &lt;a href="http://www.amazon.com/Professional-Apache-Tomcat-WROX-Guides/dp/0471753610"&gt;Professional Apache Tomcat 6 (WROX Professional Guides)&lt;/a&gt;&lt;/p&gt;
&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://tomcat.apache.org/tomcat-6.0-doc/images/tomcat.gif"&gt;&lt;img style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 130px; height: 92px;" src="http://tomcat.apache.org/tomcat-6.0-doc/images/tomcat.gif" alt="" border="0" /&gt;&lt;/a&gt;&lt;p&gt;A legegyszerűbb konfiguráció, ha a felhasználók kéréseit a Tomcat szolgálja ki egy példányban. Ennél bonyolultabb konfiguráció, ha a Tomcat elé egy web szervert, tipikusan egy Apache HTTP Servert tesztünk. Ez sok helyen maradvány, ugyanis a statikus tartalmat régebben a C-ben implementált HTTP Server sokkal gyorsabban szolgált ki. Ma már ez nem szempont, a Tomcat is képes ugyanolyan sebesség elérésére. HTTP Servert persze most is választhatunk, ha olyan funkciókra van szükségünk, melyek ezekben implementáltak, valamint ehhez értünk. A HTTP Server elterjedtsége miatt nagyon sokan dolgoznak azon, hogy biztonságos web szerver legyen, de pont ezen elterjedtsége miatt a támadások elsődleges célpontja is. Abban az esetben viszont, ha több Tomcat példányunk van, melyek között a terhelést el kell osztani, nem sok választásunk van, valamilyen terheléselosztót alkalmazni kell. Ez lehet a már említett round robin DNS, hardveres céleszköz, a tűzfalaknak is vannak ilyen megoldásaik, Linuxos megoldások (Pound, HAProxy), vagy választhatjuk az Apache HTTP Servert. A következőkben az Apache HTTP Server konfigurálását fogom bemutatni.&lt;/p&gt;&lt;h3&gt;Több Tomcat példány indítása&lt;/h3&gt;&lt;p&gt;Lehetőségünk van egy számítógépen is több Tomcat példányt indítani úgy, hogy csak egy binárist használjon. Ehhez egyrészt telepítsük fel a Tomcatet (pl. C:\Kaffe\apache-tomcat-6.0.26), erre a CATALINA_HOME környezeti változóval lehet majd hivatkozni, majd mindegyik példánynak hozzunk létre egy külön könyvtárat (pl. C:\Kaffe\tomcat1, C:\Kaffe\tomcat2), erre a CATALINA_BASE környezeti változóval lehet hivatkozni. A következő lépéseket mindkét példányon csináljuk meg, a CATALINA_BASE alatt. Hozzunk létre egy bin, conf és webapps könyvtárat. A bin könyvtárban hozzunk létre egy startup.bat állományt, a következő tartalommal:&lt;/p&gt;&lt;pre&gt;SET CATALINA_HOME=C:\Kaffe\apache-tomcat-6.0.26
SET CATALINA_BASE=C:\Kaffe\tomcat1

%CATALINA_HOME%\bin\startup.bat
&lt;/pre&gt;&lt;p&gt;Természetesen a második példánynál a CATALINA_BASE értéke C:\Kaffe\tomcat2 legyen. Ez jelzi az indító scriptnek, hogy a bináris a apache-tomcat-6.0.26 könyvtárban, de a példány konfigurációja a tomcat1 és tomcat2 könyvtárban helyezkedik el. A conf könyvtárba másoljuk át a CATALINA_HOME/conf könyvtár tartalmát, és szerkesszük meg a server.xml állományt. Egyrészt mindkét példánynál kommentezzük ki az AJP connectort (&amp;lt;Connector port="8009" ...), hiszen kizárólag HTTP connectort fogunk konfigurálni. Az első példány server.xml-jében állítsuk a HTTP connector portot 8080-ról 8081-re, majd a második példány server.xml-jében állítsuk át a szerver portot 8005-ről 9005-re, és a HTTP connector portot 8080-ról 9080-ra. Így elkerülhetjük, hogy a különböző példányok port ütközésbe kerüljenek. Javasolt még az AccessLogValve-t bekapcsolni, azaz kivenni megjegyzésből, mert így nyomon követhetjük a kéréseket, hogy melyik példány szolgálta ki a felhasználót. A webapps könyvtárba másoljuk át a bináris examples könyvtárát, ugyanis ebben szerepel egy példa a session kezelésre, amivel tesztelhetjük majd a terheléselosztást, és fürtözést.&lt;/p&gt;&lt;h3&gt;Terheléselosztás Apache HTTP Serverrel&lt;/h3&gt;&lt;p&gt;Az Apache HTTP Server több moduljával is megoldhatjuk a feladatot. &lt;a href="http://www.tomcatexpert.com/blog/2010/06/16/deciding-between-modjk-modproxyhttp-and-modproxyajp"&gt; Mark Thomas: Deciding between mod_jk, mod_proxy_http and mod_proxy_ajp&lt;/a&gt; cikke alapján választhatunk a mod_jk, mod_proxy_http és mod_proxy_ajp között. A mod_proxy_ajp-vel elég sok problémája akadt, így azt nem javasolja. Helyette a mod_jk és mod_proxy_http között választhatunk. Mindkettő C/C++-ban implementált, az Apache HTTP Serverbe beépülő modul. Ha szabadon választhatunk, akkor inkább a mod_proxy_http ajánlott, mivel az az összes többi HTTP Server modulhoz hasonlóan konfigurálható, szemben a mod_jk-val ahol egy workers.properties állományt kell létrehoznunk. Amennyiben már használjuk az egyiket, és meg vagyunk vele elégedve, nem érdemes átállni a másikra. Ha a HTTP Server és a Tomcat közöt a kommunikációt titkosítani akarjuk, javasolt a mod_proxy_http alkalmazása, mert annak konfigurációja könnyebb. Ha az SSL-t a HTTP Server végződteti, de az SSL információkat a Tomcatnek tovább akarjuk passzolni, akkor javasolt a mod_jk. A Load Balancer HOW-TO is ezt a két megoldást említi. Vannak a neten még hivatkozások régebbi megoldásokra, azok már nem támogatottak.&lt;/p&gt;&lt;p&gt;Ezek miatt a mod_proxy_http konfigurálását fogom bemutatni.&lt;/p&gt;&lt;p&gt;A HTTP Server és a Tomcat között a HTTP és az AJP protokollt is választhatjuk. Az AJP (Apache JServ Protocol) egy csomag-alapú, bináris protokoll a TCP/IP felett, így hatékonyabb, mint a szöveges HTTP protokoll. Előnye, hogy képes a HTTP Server és a Tomcat közötti kapcsolatokat újra felhasználni, így nem kell minden kérésnél kiépíteni a TCP/IP kapcsolatot, csökkentve ezzel a latency-t. Mind a mod_jk, mind a mod_proxy képes AJP-n kommunikálni, aminak a másik oldala a Tomcat oldalon a Javaban implementált AJP Connector.&lt;/p&gt;&lt;p&gt;A mod_proxy_http konfigurálásához telepítsük fel az Apache HTTP Servert, majd a httpd.conf konfigurációs állományt szerkesszük meg. A moduloknál kapcsoljuk be a mod_proxy.so, mod_proxy_http.so és a mod_proxy_balancer.so modulokat. A terheléselosztához konfiguráljuk a következőket:&lt;/p&gt;&lt;pre&gt;&amp;lt;Location /balancer-manager&amp;gt;
SetHandler balancer-manager
&amp;lt;/Location&amp;gt;

ProxyRequests Off
ProxyPreserveHost On
ProxyPass /examples balancer://cluster/examples
ProxyPassReverse /examples balancer://cluster/examples
&amp;lt;Proxy balancer://cluster&amp;gt;
BalancerMember http://localhost:8081
BalancerMember http://localhost:9081
&amp;lt;/Proxy&amp;gt;
&lt;/pre&gt;&lt;p&gt;A balancer-manager szekció lehetővé teszi, hogy a böngészőbe a /balancer-manager címet beírva egy táblázatot kapunk a cluster tagok állapotáról.&lt;/p&gt;
&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_czKgycLvmNo/TB6AFN9BfmI/AAAAAAAAFTY/R5yXm8I2i_8/s1600/balancer-manager.png"&gt;&lt;img style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 320px; height: 212px;" src="http://2.bp.blogspot.com/_czKgycLvmNo/TB6AFN9BfmI/AAAAAAAAFTY/R5yXm8I2i_8/s320/balancer-manager.png" alt="" id="BLOGGER_PHOTO_ID_5484962223317155426" border="0" /&gt;&lt;/a&gt;&lt;p&gt;A ProxyRequests direktíva kikapcsolja a proxy-zást, kivéve a ProxyPass és ProxyPassReverse sorokban megadottaknál. A ProxyPreserveHost  direktíva bekapcsolja, hogy a kért host információit továbbadja a mod_proxy_http. A ProxyPass direktíva megmondja, hogy a /examples címre érkező kéréseket a balancerre irányítsa, melyet később konfigurálunk. A ProxyPassReverse lehetővé teszi az Apache-nak, hogy a HTTP válasz fejlécében a Location, Content-Location és URI értékeket átírja. Erre akkor lehet szükség, hogyha redirect van, és az alkalmazás nem tudja a szerver címét, melyen meg lett szólítva. Ilyenkor a HTTP Server írja át a megfelelőre. Ha ekkor meghívunk többször egymás után egy URL-t (/examples/servlets/servlet/SessionExample), láthatjuk, hogy a kérések mindkét Tomcat példányra beesnek. Az alapértelmezett elosztás a byrequests, kérésenként ide-oda oszt, de a ProxySet lbmethod=bytraffic direktívával mindig annak oszt, aki a legkevesebb adatot forgalmazta (súlyozva), a bybusyness esetén pedig a szerint, hogy éppen hol van a legkevesebb aktív kérés (szintén súlyozható).&lt;/p&gt;&lt;p&gt;A webes alkalmazásoknál a session kezelés nem magától érthetődő, mivel a HTTP szabvány állapotmentes, hanem általában cookie alapú. Ilyenkor a felhasználó böngészője felveszi a kapcsolatot a Tomcattel, míg az kiállít egy session azonosítót, és cookie-ban visszaküldi a böngészőnek (JSESSIONID néven), valamint a memóriában tárolja a felhasználóval kapcsolatos adatokat. A munkamenet során a böngésző minden esetben elküldi a Tomcatnek a session azonosítót, mely alapján előveszi a memóriából a felhasználóhoz tartozó adatokat. Amennyiben a cookie ki van kapcsolva a böngészőben, történhet úgy is, hogy a session id mindig URL paraméterként megy át. (Itt tetszett az egyik könyvben szereplő hasonlat, mikor a ruhatárban leadjuk a kabátunkat, kapunk egy bilétát. A nehéz kabát a ruhatárba marad, és mi csak a bilétát visszük magunkkal.) Ráadásul figyelnünk kell arra is, hogy a cookie domain névhez kötött, azaz ha egy jólirányzott redirecttel egy másik domainre irányítjuk át a felhasználót, amin ugyan elérhető az alkalmazás, a sessionje el fog veszni, mert a böngésző az új domainre nem fogja küldeni a cookie-t.&lt;/p&gt;&lt;p&gt;Amennyiben sticky sessiont is akarunk konfigurálni, két dolgot kell tennünk. Első körben be kell állítanunk a Tomcatben, hogy a session azonosítójába tegye bele a megfelelő példány azonosítóját. Ehhez a server.xml-ben az Engine tag jvmRoute attribútumába állítsuk be az első példányon a jvmRoute="s1", a második példányon a jvmRoute="s2" értéket. Ekkor ha közvetlenül szólítjuk a Tomcatet, láthatjuk, hogy a session azonosító postfix-e .s1 vagy .s2 lesz (pl. Session ID: 24ED67056B3213387399FE4DE4DBC3F0.s1). Következő lépésként a HTTP Server konfigurációjában kell beírnunk, hogy sticky sessiont alkalmazzon, és ehhez vegye figyelembe a JSESSIONID nevezetű header értéket, ahol az első példánynál az s1, második példánynál az s2 fog benne szerepelni.&lt;/p&gt;&lt;pre&gt;ProxyRequests Off
ProxyPreserveHost On
ProxyPass /examples balancer://cluster/examples stickysession=JSESSIONID
ProxyPassReverse /examples balancer://cluster/examples
&amp;lt;Proxy balancer://cluster&amp;gt;
BalancerMember http://localhost:8081 route=s1
BalancerMember http://localhost:9081 route=s2
&amp;lt;/Proxy&amp;gt;
&lt;/pre&gt;&lt;p&gt;Látható, hogy az előzőhöz képest a stickysession=JSESSIONID kulcs-érték, valamint a route=s1, és route=s2 kulcs-értékek változtak. Ez a konfiguráció mondja meg, hogyha a JSESSIONID kulccsal a fejlécben az érték s1-re végződik, akkor a hívást a http://localhost:8081 címre továbbítsa, s2 estén a http://localhost:9081 címre. Ekkor a példa program is helyesen fog működni, és megmaradnak a sessionbe tett értékek (/examples/servlets/servlet/SessionExample).&lt;/p&gt;&lt;h3&gt;Session replikáció Tomcatben&lt;/h3&gt;&lt;p&gt;A Tomcat a fürtözést a session replikációval támogatja. Ennek lényege, hogy a sessionbe tett adatok az összes többi futó példányban látszanak. A session replikációt különbözőképpen lehet megoldani. A Tomcat mentheti a session információkat közös fájlrendszerre, vagy mentheti adatbázisba, JDBC-n keresztül. Harmadik módszer lehet, hogy memóriában tárolhatja, és a  a példányok a hálózaton egymás között átadják az adatokat. Ez utóbbiból is két megoldás van a Tomcatben. Vagy a sessionök az összes példány között replikálódnak, vagy kinevezünk elsődleges példányt, és egy backup példányt, és a session adatok csak a backup példányra replikálódnak.&lt;/p&gt;&lt;p&gt;A session replikációnak szintén vannak hátrányai. Egyrészt nehezebben konfigurálható, üzemeltethető. Perzisztens sessionök esetén megnő a tárhely igény, valamint az alkalmazás lassabb lehet, hiszen a perzisztálás időbe telik. Ugyanígy memóriában tartott session esetén megnőhet a kommunikáció a különböző példányok között, amihez elegendő sávszélesség szükséges. Ez utóbbi esetben ráadásul, mivel a sessionök nincsenek a tárba mentve, nem él túl egy teljes leállást, vagy rendszer újraindítást.&lt;/p&gt;&lt;p&gt;Amennyiben fürtözést akarunk konfigurálni, először győződjünk meg arról, hogy a példányok órája szinkronban van, javasolt NTP szolgáltatás használata is az idő szinkronizálására.&lt;/p&gt;&lt;p&gt;Az, hogy a Tomcateket fürtbe kötjük, még nem elegendő a session replikáláshoz, ehhez alkalmazásoként meg kell mondani, hogy clusterezhetőek, méghozzá a web.xml-ben fel kell venni a &amp;lt;distributable/&amp;gt; taget. Ekkor azonban az alkalmazás fejlesztésekor is be kell tartanunk néhány szabályt.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;A klasszikus Singleton többé nem singleton, hiszen JVM-enként van egy példányunk.&lt;/li&gt;
&lt;li&gt;Mindennek, amit sessionbe rakunk, implementálnia kell a java.io.Serializable interfészt.&lt;/li&gt;
&lt;li&gt;Tartsuk a sessionben tárolt elemek méretét alacsonyan, minimalizáljuk a példányok közötti kommunikációs forgalmat.&lt;/li&gt;
&lt;li&gt;Ha változtatjuk a sessionben tárolt értéket, mindig hívjuk meg a setAttribute metódust.&lt;/li&gt;
&lt;li&gt;A klasszikus párhuzamos porgramozással kapcsolatos műveletek, mint pl. a lockolás szintén csak JVM-en belül működnek.&lt;/li&gt;
&lt;li&gt;Lehetőleg ne használjunk fájlrendszert, ha mégis, akkor megosztott fájlrendszert, melyhez minden példány hozzáfér.&lt;/li&gt;
&lt;li&gt;Ütemezett feladatoknál figyeljünk, hogy nehogy mind a két példány elindítsa ugyanabban az időpontban. A legelterjedtebb ütemezési könyvtár, a Quartz ezt úgy oldja meg, hogy adatbázis lockokat használ.&lt;/li&gt;
&lt;li&gt;A sessionön kívül más nem replikálható.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Ahhoz, hogy ne okozzunk magunknak sok fejtörést, javasolt mind hardver, mind szoftver szinten teljesen egyforma példányokat, konfigurációkat alkalmazni. A következő részletet kell beilleszteni a server.xml-be az Engine tag alá.&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"&amp;gt;

&amp;lt;Manager className="org.apache.catalina.ha.session.DeltaManager"
 expireSessionsOnShutdown="false"
 notifyListenersOnReplication="true"/&amp;gt;

&amp;lt;Channel className="org.apache.catalina.tribes.group.GroupChannel"&amp;gt;
&amp;lt;Membership
className="org.apache.catalina.tribes.membership.McastService"
address="239.255.0.3"
port="45564"
frequency="500"
dropTime="3000"/&amp;gt;

&amp;lt;Receiver
className="org.apache.catalina.tribes.transport.nio.NioReceiver"
address="192.168.10.10"
port="4000"
autoBind="0"
selectorTimeout="100"
maxThreads="6"/&amp;gt;

&amp;lt;Sender className="org.apache.catalina.tribes.transport.ReplicationTransmitter"&amp;gt;
&amp;lt;Transport className="org.apache.catalina.tribes.transport.nio.PooledParallelSender"/&amp;gt;
&amp;lt;/Sender&amp;gt;
&amp;lt;Interceptor className="org.apache.catalina.tribes.group.interceptors.TcpFailureDetector"/&amp;gt;
&amp;lt;Interceptor className="org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor"/&amp;gt;

&amp;lt;/Channel&amp;gt;

&amp;lt;Valve className="org.apache.catalina.ha.tcp.ReplicationValve"
 filter=".*\.gif;.*\.js;.*\.jpg;.*\.txt;"/&amp;gt;

&amp;lt;ClusterListener className="org.apache.catalina.ha.session.ClusterSessionListener"/&amp;gt;

&amp;lt;/Cluster&amp;gt;
&lt;/pre&gt;&lt;p&gt;Mindkét példánynál a Receiver tag address attribútumának értékét állítsuk a futtató gép ip-címére. Amennyiben ugyanazon a gépen futtatjuk a példányokat, a második példány esetén a Receiver tag port értékét állítsuk 4000-ről pl. 4001-re, ellenkező esetben a port ütközésre utaló hibaüzenetet kapunk (Caused by: java.net.BindException: Address already in use: bind).&lt;/p&gt;&lt;p&gt;A session replikációs fürtözés alapvetően az Apache Tribes keretrendszer használatával történik, melynek JAR állományai megtalálhatóak a Tomcat lib könyvtárában (catalina-ha.jar, catalina-tribes.jar). Az Apache Tribes un. communication groupokat definiál, melyekbe a clusterben lévő példányok tartoznak. Ezek multicast ping üzenetekkel  kommunikálnak egymással, a tagok heartbeat jelet küldenek, ezzel dinamikusan csatlakozni tudnak egy csoportba, vagy a heartbeat megszűnése esetén kikerülnek onnan. Ezért a hálózaton engedélyezni kell a multicastolást. Ezen kívül a Tribes biztos üzenettovábbítást is biztosít a tagoknak. A session átvitele már a példányok közötti pont-pont TCP/IP kapcsolaton keresztül történik.&lt;/p&gt;&lt;p&gt;A következőkben csak a fontosabb konfigurációkat írom le, a részletesebb elírás megtalálható a &lt;a href="http://tomcat.apache.org/tomcat-6.0-doc/cluster-howto.html"&gt;Clustering/Session Replication HOW-TO&lt;/a&gt; dokumentációban.&lt;/p&gt;&lt;p&gt;A Cluster tagen belüli className attribútum értéke jelenleg csak a SimpleTcpCluster lehet. A Manager tag megadása kötelező. Amennyiben a replikáció minden példánynak megy, a DeltaManager-t kell használni, amennyiben a példány csak a backup példányával replikál, használható a BackupManager. A notifyListenersOnReplication attribútum azt mondja meg, hogy replikáció esetén meg kell hívni a SessionListener implementációkat. A expireSessionsOnShutdown attribútum azt mondja meg, hogy le kell-e járatni a sessionöket és replikálni shutdownnál.&lt;/p&gt;&lt;p&gt;A Cluster tagen belül meg kell adni a Channel taget. Az Apache Tribes fogalma a csatorna, mely egy absztrakt hálózati végpont, hasonló a TCP/IP sockethez, melyen keresztül a csoport egy tagja tud üzenetet küldeni a csoportban lévő többi tagnak. Jelenleg a GroupChannel az egyetlen implementáció. A Membership tagen belül adható meg a csoporttagsággal kapcsolatos beállítások. Jelenleg csak a McastService implementáció adható meg. A address és port a multicast cím és port, melyen a tagok hallgatnak, az erre a címre küldött üzenetet az összes tag megkapja. A multicast cím 224.0.0.1 és 239.255.255.255 között bármennyi lehet, de a 224.* ésa 239.* címeket nem illik használni, mert a hálózat másra tarthatja fenn őket. A frequency adja meg ezredmásodpercben, hogy mennyi időközönként küldjön egy tag heartbeatet. A dropTime adja meg, hogy amennyiben egy tag ennyi ezredmásodpercig nem ad jelt magáról, a csoportból kizárásra kerül. A tagok a sessiont már pont-pont kapcsolaton viszik át. Ennek konfigurálására való a Receiver és Sender tag. A Receiver address és port attribútuma adja meg a címet és portot, amin egy tag fogadni fogja a session replikációs üzeneteket. Ha az autoBind 0, akkor implicit adunk meg a port tagben egy portot. Választható BioReceiver (blocking I/O), de nem ajánlott, csak azon régi JVM verzióknál, ahol a NIO-ban még sok bug volt. A selectorTimeout is egy régi bug kivédéséért van benne. A maxThreads adja meg, hogy hány szálon fogadja a session replikációs üzeneteket. Érdemes annyira állítani, amennyi tagból a cluster áll. A Sender tagben csak a ReplicationTransmitter javasolt, a Transport tagben a PooledMultiSender is választható, régebbi JVM-eknél javasolt.&lt;/p&gt;&lt;p&gt;Az Interceptor-ok láncolásával a channelhez további funkcionalitások adhatóak. Amennyiben nem érkezik heartbeat üzenet az egyik tagtól, a TcpFailureDetector megpróbálja felvenni vele a kapcsolatot, hogy megbizonyosodjon arról, hogy tényleg nem megy. A MessageDispatch15Interceptor asynchron message dispatcher, üzenetküldéskor aktiválódik. Van még a ThroughputInterceptor, mely INFO szinten képes naplózni a cluster üzeneteket. A Valve elemek un. szűrők, melyek a clusterezésnél a hálózati forgalmat hivatottak csökkenteni azáltal, hogy bizonyos esetekben nem engedik tovább a session replikációt. Jelenleg csak a ReplicationValve használható, és a filter attribútumban lehet megadni, hogy milyen kéréseknél ne legyen replikáció. A példában pl. képeknél, szöveges és JavaScript állományok lekérésénél. A Cluster tagen belül megadhatjuk a Deployer taget is, mely egyszerűsíti a konfigurációt azáltal, hogy egy példányra deploy-olt war-t szétoszt a többi példány között. A dokumentáció szerint ezt élesben még ne alkalmazzuk, mert erősen fejlesztés alatt áll. DeltaManager használata esetén konfigurálni kell a ClusterSessionListener-t is, mely továbbítja az üzeneteket a DeltaManager-nek.&lt;/p&gt;&lt;p&gt;A session replikáció működése nyomon követhető, ugyanis naplóz, ha a logging.properties-ben a org.apache.catalina.tribes.MESSAGES kulccsal megfelelő szintre állítjuk a naplózást. Ha elindítjuk az egyik Tomcatet, valami ilyesmit kell látnunk a catalina.log-ban:&lt;/p&gt;&lt;pre&gt;2010.06.20. 21:41:58 org.apache.coyote.http11.Http11Protocol init
INFO: Initializing Coyote HTTP/1.1 on http-8081
2010.06.20. 21:41:58 org.apache.catalina.startup.Catalina load
INFO: Initialization processed in 944 ms
2010.06.20. 21:41:58 org.apache.catalina.core.StandardService start
INFO: Starting service Catalina
2010.06.20. 21:41:58 org.apache.catalina.core.StandardEngine start
INFO: Starting Servlet Engine: Apache Tomcat/6.0.26
2010.06.20. 21:41:58 org.apache.catalina.ha.tcp.SimpleTcpCluster start
INFO: Cluster is about to start
2010.06.20. 21:41:58 org.apache.catalina.tribes.transport.ReceiverBase bind
INFO: Receiver Server Socket bound to:/192.168.68.102:4001
2010.06.20. 21:41:58 org.apache.catalina.tribes.membership.McastServiceImpl setupSocket
INFO: Setting cluster mcast soTimeout to 500
2010.06.20. 21:41:58 org.apache.catalina.tribes.membership.McastServiceImpl setupSocket
INFO: Setting cluster mcast TTL to 1
2010.06.20. 21:41:58 org.apache.catalina.tribes.membership.McastServiceImpl waitForMembers
INFO: Sleeping for 1000 milliseconds to establish cluster membership, start level:4
2010.06.20. 21:41:59 org.apache.catalina.tribes.membership.McastServiceImpl waitForMembers
INFO: Done sleeping, membership established, start level:4
2010.06.20. 21:41:59 org.apache.catalina.tribes.membership.McastServiceImpl waitForMembers
INFO: Sleeping for 1000 milliseconds to establish cluster membership, start level:8
2010.06.20. 21:42:00 org.apache.catalina.tribes.membership.McastServiceImpl waitForMembers
INFO: Done sleeping, membership established, start level:8
2010.06.20. 21:42:00 org.apache.catalina.startup.HostConfig deployDirectory
INFO: Deploying web application directory examples
2010.06.20. 21:42:01 org.apache.catalina.ha.session.DeltaManager start
INFO: Register manager /examples to cluster element Engine with name Catalina
2010.06.20. 21:42:01 org.apache.catalina.ha.session.DeltaManager start
INFO: Starting clustering manager at /examples
2010.06.20. 21:42:01 org.apache.catalina.ha.session.DeltaManager getAllClusterSessions
INFO: Manager [localhost#/examples]: skipping state transfer. No members active in cluster group.
2010.06.20. 21:42:02 org.apache.coyote.http11.Http11Protocol start
INFO: Starting Coyote HTTP/1.1 on http-8081
2010.06.20. 21:42:02 org.apache.catalina.startup.Catalina start
INFO: Server startup in 3825 ms
&lt;/pre&gt;&lt;p&gt;Amennyiben beindítjuk a másik Tomcat példányt, az első logjában valami hasonló fog megjelenni.&lt;/p&gt;&lt;pre&gt;2010.06.20. 21:43:51 org.apache.catalina.tribes.io.BufferPool getBufferPool
INFO: Created a buffer pool with max size:104857600 bytes of type:org.apache.catalina.tribes.io.BufferPool15Impl
2010.06.20. 21:43:52 org.apache.catalina.ha.tcp.SimpleTcpCluster memberAdded
INFO: Replication member added:org.apache.catalina.tribes.membership.MemberImpl[tcp://{192, 168, 68, 102}:4000,{192, 168, 68, 102},4000, alive=1016,id={48 -51 24 -48 -107 11 64 47 -94 -68 -110 -105 -15 21 -103 -51 }, payload={}, command={}, domain={}, ]
&lt;/pre&gt;&lt;p&gt;Ezután indítsuk el az Apache HTTP Servert, és próbáljuk meg a következő lépéseket.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Elindult az első Tomcat. Mivel a web.xml-ben a distributed tag be van állítva, a Tomcat meghívja a SimpleTcpCluster-t, hogy a StandardManager helyett DeltaManager-t példányosítson, ami majd a replikációt végzi. Majd beindulnak a multicast és unicast szolgáltatások.&lt;/li&gt;
&lt;li&gt;Beindul a második Tomcat példány, és bekerül a csoportba, és a többi példánytól elkéri a session állapotokat. Amennyiben 60 mp után a már futó Tomcat példány nem válaszol, hibaüzenet kerül a logba.&lt;/li&gt;
&lt;li&gt;Indítsuk el az Apache-ot is.&lt;/li&gt;
&lt;li&gt;Kérjük le a példa oldalt (/examples/servlets/servlet/SessionExample), és tegyünk el a sessionbe egy értéket. Session jön létre, melyet a ReplicationValve a válasz visszaadása előtt átküld a többi példánynak.&lt;/li&gt;
&lt;li&gt;Állítsuk le az első példányt, ekkor ez kikerül a csoportból, és a második példány logjában valami ilyesmit fogunk látni:
&lt;pre&gt;
2010.06.20. 21:58:14 org.apache.catalina.tribes.group.interceptors.TcpFailureDetector memberDisappeared
INFO: Verification complete. Member disappeared[org.apache.catalina.tribes.membership.MemberImpl[tcp://{192, 168, 68, 102}:4001,{192, 168, 68, 102},4001, alive=975391,id={-26 13 57 -111 103 111 70 81 -90 -112 -30 -61 39 -102 0 92 }, payload={}, command={66 65 66 89 45 65 76 69 88 ...(9)}, domain={}, ]]
2010.06.20. 21:58:14 org.apache.catalina.ha.tcp.SimpleTcpCluster memberDisappeared
INFO: Received member disappeared:org.apache.catalina.tribes.membership.MemberImpl[tcp://{192, 168, 68, 102}:4001,{192, 168, 68, 102},4001, alive=975391,id={-26
13 57 -111 103 111 70 81 -90 -112 -30 -61 39 -102 0 92 }, payload={}, command={66 65 66 89 45 65 76 69 88 ...(9)}, domain={}, ]
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;Kérjük le újra az oldalt. A kérést a második példány fogja kiszolgálni, és a sessionben láthatjuk, hogy benne maradt a hozzáadott érték.&lt;/li&gt;
&lt;li&gt;Az első példány visszaindításával az bekerül újra a csoportba, és induláskor lekéri a második példánytól a session állapotokat. A kéréseket újra az első példány fogja kiszolgálni.&lt;/li&gt;
&lt;li&gt;Session invalidáció kérésekor, vagy timeout esetén egy invalidációs üzenet megy a másik példányra.&lt;/li&gt;
&lt;/ol&gt;A Clusterhez tartoznak JMX MBean-ek is, melyhez a Tomcatet úgy kell indítani, hogy azok lekérdezhetőek legyenek. Ehhez a bin/setenv.bat állományba helyezzünk el a következő sorokat, és ezután akár JConsole-lal, akár JMX Ant taskokkal csatlakozni tudunk. Vigyázzunk, hogy a két példánynál különböző portokat adjunk meg, ha egy gépen futnak.
&lt;pre&gt;set CATALINA_OPTS=\
-Dcom.sun.management.jmxremote \
-Dcom.sun.management.jmxremote.port=9012 \
-Dcom.sun.management.jmxremote.ssl=false \
-Dcom.sun.management.jmxremote.authenticate=false
&lt;/pre&gt;&lt;p&gt;Hibakeresésben segíthet a netstat parancs, mely a nyitott portokat, hálózati kapcsolatokat képes kilistázni. Amiket mindenképpen látnunk kell, a postban konfigurált szoftver komponensek esetén (összes TCP kapcsolat, az utolsó kivételével, mely UDP):&lt;/p&gt;&lt;ul&gt;&lt;li&gt;8005: Tomcat 1. példány server port&lt;/li&gt;
&lt;li&gt;9005: Tomcat 2. példány server port&lt;/li&gt;
&lt;li&gt;8081: Tomcat 1. példány HTTP Connector&lt;/li&gt;
&lt;li&gt;9081: Tomcat 2. példány HTTP Connector&lt;/li&gt;
&lt;li&gt;8080: Apache HTTP Server&lt;/li&gt;
&lt;li&gt;4000: Tomcat 1. példány cluster unicast port&lt;/li&gt;
&lt;li&gt;4001: Tomcat 2. példány cluster unicast port&lt;/li&gt;
&lt;li&gt;9012: Tomcat 1. példány JMX port&lt;/li&gt;
&lt;li&gt;9013: Tomcat 1. példány JMX port&lt;/li&gt;
&lt;li&gt;45564: multicast port, melyen mindkét Tomcat hallgat&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;A fürtözéssel kapcsolatban ne felejtsük el a következőket. A web alkalmazásunk áteresztőképessége ugyan nőhet (kiszolgált kérések/idő), de egy kérés kiszolgálási ideje is nőni fog, a bonyolultabb architektúra miatt. Emiatt a fürtözés nem alkalmas performancia problémák megoldására. Ebben az esetben javasolt az alkalmazás valamilyen profile eszközzel való megvizsgálása, és optimalizálása, vagy valamilyen cache alkalmazása.&lt;/p&gt;&lt;p&gt;Meg kell még említeni azt is, hogy horizontális skálázás esetén különböző funkciókat különböző hardver elemeken futtatunk. A webes technológiák, a Tomcat nem nyújt erre beépített lehetőséget. Az EJB használata esetén azonban lehetséges, hogy kizárólag konfigurációval bizonyos beaneket más virtuális gépben futó alkalmazásszerverekre helyezzünk át. Ez a lokális transzparencia. Ekkor az átviteli protokoll az RMI lesz. A Spring is lehetőséget biztosít erre, itt viszont választhatunk különböző protokollok között, mint RMI, Hessian/Burlap, HTTPInvoker, JMS, SOAP, stb.&lt;/p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_czKgycLvmNo/TCB1PxYTSrI/AAAAAAAAFTo/IDjJSc8cDlc/s1600/cluster-workspace.png"&gt;&lt;img style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 320px; height: 194px;" src="http://1.bp.blogspot.com/_czKgycLvmNo/TCB1PxYTSrI/AAAAAAAAFTo/IDjJSc8cDlc/s320/cluster-workspace.png" alt="" id="BLOGGER_PHOTO_ID_5485513259951016626" border="0" /&gt;&lt;/a&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/3613942055503022824/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/06/cluster-ezes-altalaban-es-tomcat-en.html#comment-form' title='9 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3613942055503022824'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3613942055503022824'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/06/cluster-ezes-altalaban-es-tomcat-en.html' title='Clusterezés általában és Tomcaten'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://2.bp.blogspot.com/_czKgycLvmNo/TB6AFN9BfmI/AAAAAAAAFTY/R5yXm8I2i_8/s72-c/balancer-manager.png' height='72' width='72'/><thr:total>9</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-633786037997115640</id><published>2010-05-31T23:10:00.007+02:00</published><updated>2010-06-01T10:05:01.132+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Java EE'/><category scheme='http://www.blogger.com/atom/ns#' term='Spring'/><title type='text'>Tranzakciókezelés EJB 3 és Spring környezetben</title><content type='html'>&lt;p&gt;Az előző post-ban említett Spring In Action könyv olyan szépen tárgyalta a tranzakciókezelést, hogy muszáj írnom egy kicsit. Ebben a post-ban csupán megpróbálom összegyűjteni a és megnevezni a fogalmakat, összehasonlítani a Spring és EJB technológiát, nem célom a részletes bemutatás.&lt;/p&gt;&lt;p&gt;Először is definiálni kell a tranzakció fogalmát. Nagyon fontos, hogy tranzakció bár először adatbáziskezelő rendszerekben terjedt el, ma már egyéb rendszerek is ismerik a tranzakció fogalmát, mint pl. message oriented middleware (Java környezetben JMS provider). Ezeket tehát a továbbiakban erőforráskezelőknek fogom nevezni. A tranzakció logikailag összetartozó, és egy egységként kezelt műveletsor. A műveletsor több lépésből is állhat, de ezek összetartoznak, azaz vagy mindnek le kell futnia (commit), vagy egyiknek sem (rollback). Ezzel egyrészt biztosítható az adatbázis konzisztencia (ellentmondás mentesség), és eszköze a párhuzamos kiszolgálásnak is. A tranzakciónak rendelkeznie kell az ACID tulajdonságokkal, mely betűszó feloldása: Atomic (atomicitás), consistent (konzisztencia), izolated (izoláció), durable (tartósság). Az atomicitás azt jelenti, hogy a tranzakcióba tartozó minden műveletet el kell végezni, vagy egyiket sem. A konzisztencia jelentése, hogy az adatoknak a tranzakció után ellentmondás menteseknek kell maradniuk. Az izoláció szerint minden tranzakciónak úgy kell lefutnia, mintha egyedül lenne. A tartósság biztosítja, hogyha a tranzakció befejeződött, annak kifejtett hatása már nem "veszhet el".&lt;/p&gt;&lt;p&gt;Az unalomig emlegetett példa az átutalás, mikor az egyik bankszámláról pénzt emelünk le, és a másikra jóváírjuk, ugye nem jó, ha bármelyik művelet is "elveszik". (Egyszer hallottam, hogy a banknál a programozóknak nem szabad hinniük a tranzakciókezelésben, és úgy kell a programot megírniuk, a műveleteket sorba állítaniuk, hogyha nem működik a tranzakciókezelés, és az egyik művelet végrehajtódik, és a másik nem, akkor ez csak úgy történhessen, hogy a banknak legyen jó.)&lt;/p&gt;&lt;p&gt;Az izolációnál kell megemlíteni, hogy a probléma abból adódhat, hogyha párhuzamosan történnek a módosítások. Ekkor a következő problémák merülhetnek fel. Piszkos olvasásnak (dirty read) nevezzük, ha egy tranzakció által módosított, de még jóvá nem hagyott adatot olvas ki egy másik tranzakció. A megismételhetetlen olvasás (non-repetable read) az jelenti, hogy kétszer olvasunk ki egy adatot, de másodjára más eredményt kapunk, ugyanis egy másik jóváhagyott tranzakció módosította azt. A fantom olvasás (phantom read) az előbbi egy speciális esete, mikor kétszer olvasunk ki adatokat, de másodjára már több eredményt kapunk, ugyanis egy másik jóváhagyott tranzakció új adatot vitt fel. Ezen problémák megoldására vezették be az izolációs szinteket, melyeket az adatbáziskezelők biztosítják (nem mindegyik adatbáziskezelő ismeri mindegyik izolációs szintet, és a default izolációs szintek is eltérhetnek), és programból lehet állítani, akár tranzakciónként. A read uncommitted izolációs szint esetén a tranzakció hatása már a tranzakció közben látszik másik tranzakciónál. A többi izolációs szint mindegyike megoldja a soron következő izolációs problémát. A read commited izolációs szint megoldja a dirty read-et, csak a jóváhagyott módosításokat látja a másik tranzakció. A repeatable read garantálja, hogy egy sort a tranzakció közben újraolvasva ne változzon. A serializable a tranzakciókat sorosítja, így megszünteti az összes párhuzamosságból adódó problémát. De miért is nem állítjuk a legmagasabb izolációs szintet be, hogy ne legyen problémánk? Azért, mert a ahogy növeljük az izolációs szintet, úgy lassulhat be a kiszolgálás sok párhuzamos kérés esetén.&lt;/p&gt;&lt;p&gt;A tranzakciókezelésnél először meg kell különböztetni a lokális és a globális tranzakció (vagy más néven elosztott tranzakció) fogalmát. A lokális tranzakció, mikor egy erőforráskezelőn belül akarunk tranzakciót végezni. A globális/elosztott tranzakciók esetén egy tranzakció több erőforráskezelőn is átívelhet, pl. két adatbázison, vagy egy tranzakcióban akarunk pl. egy adatbázis sort módosítani, és egy üzenetet elküldeni. Ehhez azonban egy tranzakció koordinátort kell kinevezni, aki irányítja a tranzakciót. Itt jön képbe a 2PC, a two-phase commit protocol, ahol első körben az erőforráskezelők felkészülnek a tranzakcióra, és második körben hagyják jóvá azt. Minden erőforráskezelőnek vétó joga van. Az erőforráskezelők a tranzakció koordinátorral az X/Open XA protokollon keresztül kommunikálnak.&lt;/p&gt;&lt;p&gt;Ezen fogalmakat amúgy minden EJB könyv, így a magyar nyelven elérhető Szerk: Imre Gábor - Szoftverfejlesztés Java EE platformon című könyv is részletesen leírja.&lt;/p&gt;&lt;p&gt;Természetesen mind az EJB, mint a Spring támogatja a tranzakciókezelés, méghozzá mindkettő kétféleképpen. Adott a programozott tranzakciókezelés, mikor a fejlesztőnek kell meghívni a commit vagy rollback metódusokat, de lehetőség van deklarativ tranzakciókezelésre is, mikor a fejlesztő csak deklarálja a tranzakciókat, megszabja, hogy hol induljon a tranzakció és hol fejeződjön be (transaction demarcation, transaction boundaries), a tranzakciókezelést maga a környezet végzi.&lt;/p&gt;&lt;p&gt;EJB és Spring esetén is használhatunk lokális és elosztott tranzakciókat is. Elosztott tranzakciók használata esetén azonban mindenképp szükség van egy alkalmazásszerverre, ugyanis ezeknek a szabvány miatt kötelezően tartalmazniuk kell egy tranzakció koordinátort. Ekkor a Java Transaction API (JTA) működik a háttérben, de ezt mind az EJB, mind a Spring képes elrejteni előlünk.&lt;/p&gt;&lt;p&gt;EJB környezetben semmit nem kell konfigurálnunk, azonban tranzakciókat csak session bean-ben és message driven bean-ben (MDB) kezelhetünk. Az alapértelmezett a Container-Managed Transaction (CMT), azaz deklaratív tranzakciókezelés, míg a programozott tranzakciókezelést (Bean-Managed Transaction (BMT)) a @TransactionManagement(TransactionManagementType.BEAN) annotációval, vagy a vele ekvivalens deployment descriptor beállítással (&amp;lt;transaction-type&amp;gt;BEAN&amp;lt;transaction-type&amp;gt;) adhatjuk meg. A tranzakciókat az alkalmazásszerverben implementált Java EE transaction manager végzi. A programozott tranzakciókezelés esetén az EJBContext getUserTransaction metódusa által visszaadott UserTransaction példány begin(), commit() és rollback() metódusait hívhatjuk. Deklaratív esetben annotációt használhatunk. Ez esetben visszagörgetést az alkalmazásszerverrel az EJBContext.setRollbackOnly() metódussal kérhetünk, és ezt lekérdezni a getRollbackOnly() metódussal tudjuk. Az EJBContext példányhoz dependency injection-nel jutunk (@Resource).&lt;/p&gt;&lt;p&gt;Spring környezetben bármilyen POJO-ban definiálhatunk tranzakciót. Ehhez egy transaction manager-t kell választanunk, melyből több mint tíz áll rendelkezésre, köztük a DataSourceTransactionManager, JpaTransactionManager, vagy a JtaTransactionManager. Ezt az applicationContext.xml-ben kell konfigurálnunk. A programozott tranzakciókezelés a TransactionTemplate-tel történhet, míg a deklaratív tranzakciókezelés a TransactionProxyFactoryBean használatával vagy AOP-pal. Ez utóbbi esetben is van választási lehetőségünk, használhatjuk az applicationContext.xml-ben a tx névtérrel a Spring 2.0-ás konfigurációs elemeket, mint tx:advice, tx:attributes, tx:method. De használhatunk az EJB 3.0-hoz hasonlóan annotációkat is.&lt;/p&gt;&lt;p&gt;A Spring In Action könyvben van egy nagyon szemléletes ábra, hogy mire kell figyelni a deklaratív tranzakcióknál.&lt;/p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_czKgycLvmNo/TAQm6KEx76I/AAAAAAAAFSg/ewIcUvTFMaI/s1600/tranzakcio-kezeles1.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 242px; height: 213px;" src="http://4.bp.blogspot.com/_czKgycLvmNo/TAQm6KEx76I/AAAAAAAAFSg/ewIcUvTFMaI/s320/tranzakcio-kezeles1.png" border="0" alt="" id="BLOGGER_PHOTO_ID_5477545827368038306" /&gt;&lt;/a&gt;&lt;p&gt;Az izolációt már említettem az izolációs szinteknél. A JSR 220: Enterprise JavaBeans, Version 3.0 - EJB Core Contracts and Requirements specifikáció 13.3.2-es fejezete (324. old.) írja, hogy az izolációs szint beállítása az adott erőforráskezelőre jellemző, annak API-ja definiálja, így az EJB szabvány nem foglalkozik vele. A java.sql.Connection osztálynak van pl. setTransactionIsolation(int level) metódusa.&lt;/p&gt;&lt;p&gt;A Spring ezzel szemben a TransactionDefinition interfészben definiálja az izolációs szinteket az ISOLATION_ prefixszel rendelkező konstansokban. Ezt meg lehet adni paraméterül a TransactionProxyFactoryBean transactionAttributes attribútumának, vagy a tx:method konfigurációs elem isolation tulajdonságának, vagy a @Transactional annotáció isolation attribútumának.&lt;/p&gt;&lt;p&gt;A következő tulajdonság a read-only tulajdonság. Ezt csak a Spring definiálja, és ezt állítsuk true-ra csak olvasást végző műveleteknél, ha azt akarjuk, hogy bizonyos optimalizációkat elvégezzen az erőforráskezelő. Pl. Hibernate esetén a flush mode-ot FLUSH_NEVER-re állítja, ami azt jelenti, hogy a session állapotát, azaz a perzisztens példányokat nem írja ki az adatbázisba, tehát nem hívja meg a flush() függvényt. Ez csak olvasást végző tranzakcióknál sebességet növelhet. Ugyan a javax.sql.Connection osztálynak is van setReadOnly(boolean readOnly) metódusa, azonban máshogy valósíthatják meg a különböző adatbázis driver-ek. Az Oracle JDBC driver pl. abszolút nem valósítja meg ezt a metódust.&lt;/p&gt;&lt;p&gt;A következő az időtúllépés (timeout). Az EJB 3.0 szabvány programozott tranzakciókezelés esetén biztosítja a UserTransaction.setTransactionTimeout(int seconds) metódust.  Deklaratív esetben nem definiál erre megoldást, viszont az alkalmazásszerver gyártóknak van saját megoldásuk. Általában több helyen lehet megadni a timout értékét. Meg lehet adni globálisan valamilyen konfigurációs állományban, vagy meg lehet adni bean-re is. Ekkor vagy gyártófüggő deployment descriptor-ba kell írnunk valamit, vagy saját annotáció is létezhet rá. Pl. JBoss esetén a jboss-service.xml-ben kell keresni a vagy létezik a @TransactionTimeout.&lt;/p&gt;&lt;p&gt;A Spring biztosít lehetőséget a TransactionProxyFactoryBean transactionAttributes attribútumának, vagy a tx:method konfigurációs elem timeout tulajdonságának, vagy a @Transactional annotáció timeout attribútumának használatával.&lt;/p&gt;&lt;p&gt;A következő tulajdonság a propagáció, melynek a deklaratív tranzakciókezelésnél van értelme, hiszen a propagációs tulajdonságokkal adhatjuk meg egy metódusra, hogy hogyan vegyen részt egy tranzakcióban.&lt;/p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_czKgycLvmNo/TAQnABtmQnI/AAAAAAAAFSo/meFkUyrGyQI/s1600/tranzakcio-kezeles2.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 96px;" src="http://1.bp.blogspot.com/_czKgycLvmNo/TAQnABtmQnI/AAAAAAAAFSo/meFkUyrGyQI/s320/tranzakcio-kezeles2.png" border="0" alt="" id="BLOGGER_PHOTO_ID_5477545928202535538" /&gt;&lt;/a&gt;&lt;p&gt;Először nézzünk egy egyszerű esetet, mikor is egy kliens meghívja a Bean1 bean-ünk üzleti metódusát, ami meghívja a Bean2 bean-ünk üzleti metódusát. A tranzakciókezelés deklaratív, és a tranzakciókezelést az inversion of control miatt nem a bean-ek végzik, hanem pl. proxy objektumok, melyek a bean-ek előtt helyezkednek el. Amikor a Bean1 metódusát meghívjuk (proxy-n keresztül), a proxy észleli, hogy nincs tranzakció, ezért indít egyet. Majd meghívja a Bean1 bean-ünk metódusát, ami szintén proxy-n keresztül meghívja a Bean2 bean-ünk metódusát. Itt a proxy észleli, hogy már van nyitott tranzakció, így csatlakozik ehhez, majd meghívja a Bean2 bean-ünk metódusát (delegáció). Visszatéréskor a Bean2 proxy továbbengedi a visszatérési értéket, de a Bean1 proxy észleli, hogy ő nyitotta a tranzakciót, és ezért neki is kell valamit kezdenie vele, alapesetben így ő fogja a commit műveletet elvégezni. Ez az alapértelmezett működési mód, mely a legtöbb esetben elegendő nekünk, és ezt hívják REQUIRED propagációs attribútumnak.&lt;/p&gt;&lt;p&gt;Azonban vannak más tranzakciós attribútumok is, összegezve:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;REQUIRED (default): ha nincs tranzakció, indít egyet, ha van csatlakozik hozzá&lt;/li&gt;&lt;li&gt;REQUIRES_NEW: mindenképp új tranzakciót indít&lt;/li&gt;&lt;li&gt;SUPPORTS: ha van tranzakció, abban fut, ha nincs, nem indít újat&lt;/li&gt;&lt;li&gt;MANDATORY: ha van tranzakció, abban fut, ha nincs, kivételt dob&lt;/li&gt;&lt;li&gt;NOT_SUPPORTED: ha van tranzakció, a tranzakciót felfüggeszti, ha nincs, nem indít újat&lt;/li&gt;&lt;li&gt;NEVER: ha van tranzakció, kivételt dob, ha nincs, nem indít újat&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;A tranzakciós attribútumot az EJB-ben deployment descriptor-ban vagy a @TransactionAttribute annotáció attribútumaként is meg lehet adni. Spring-ben a TransactionProxyFactoryBean transactionAttributes attribútumának, vagy a tx:method konfigurációs elem propagation tulajdonságának, vagy a @Transactional annotáció propagation attribútumának lehet megadni. Az EJB-hez képesti különbség annyi, hogy a nevek elé elé kell tenni a PROPAGATION_ prefixet is.&lt;/p&gt;&lt;p&gt;A REQUIRED-en kívül a többit ritkán használjuk. A REQUIRES_NEW akkor jöhet jól, mikor egy olyan műveletet akarunk futtatni, aminek mindenképpen le kell futnia, a hívó tranzakció rollback-je esetén is. Gondoljunk el pl. egy audit naplózást. Az nem lehet, hogyha a művelet rollback-re fut, akkor a naplózás sem történik meg. A többi attribútumra már csak nagyon mondvacsinált példákat tudok hozni. A SUPPORTS read-only műveleteknél jó, mert ha nem jön tranzakció, akkor nem indít újat feleslegesen. A MANDATORY-t akkor használjuk, ha biztosak akarunk lenni abban, hogy egy rollback visszahat a hívó félre. A NOT_SUPPORTED akkor használható, ha pl. EJB környezetben az MDB-nk nem tranzakcionálisan kapcsolódik a JMS provider-hez. A NEVER-t használhatjuk akkor, ha nem tranzakcionális erőforrást piszkálunk, és tudatosítani akarjuk a hívó félben, hogy itt ne is számítson tranzakcionális működésre. Nektek van jobb példáitok?&lt;/p&gt;&lt;p&gt;A leggyakoribb hiba a tranzakciós attribútumokkal kapcsolatban, hogy van egy osztályon belül két metódus, ahol az egyik hívja a másikat, és más a tranzakciós attribútumuk. Normál esetben ugyanis azt tapasztaljuk, hogy a második metódus tranzakciós attribútuma hatástalan. Ez azért van, mert az egy példányon belüli hívás nem megy át a proxy-n, így nem tudja kezelni a tranzakciós attribútumot, tehát mintha ott sem lenne. A megoldás, hogy a hívást mindenképp átvezetjük valahogy a proxy-n. Vagy átszervezzük a kódot, és a két metódust külön bean-be tesszük. EJB esetén pl. a SessionContext.getEJBObject() metódus adja vissza a proxy objektumot. Spring esetén három megoldás közül is választhatunk. Vagy az ApplicationContext-től a getBean-nel név alapján lekérjük a proxy példányt, vagy az AopContext.currentProxy() metódusát hívjuk, de mindkettővel kötjük magunkat a Spring-hez. A harmadik megoldás az AspectJ weaving használata, mikor nem proxy végzi a tranzakciókezelést, hanem maga az objektum, ugyanis az AOP ekkor nem proxy-val valósul meg, hanem bytecode buherálással.&lt;/p&gt;&lt;p&gt;Az utolsó tulajdonság a visszagörgetési szabályok alkalmazása kivétel esetén, deklaratív környezetben. Az EJB-ben a következőképpen működik. Megkülönböztetünk rendszerszintű kivételeket (RuntimeException és RemoteException vagy leszármazottai), és alkalmazásszintű kivételeket (többi). Rendszerszintű kivételek esetén mindig rollback van, alkalmazás szintű kivételeknél commit, kivéve, ha meghívtuk a cache ágban a EJBContext.setRollbackOnly() metódust, vagy saját kivétel esetén rátettük a @ApplicationException(rollback = true) annotációt, mert ilyenkor itt is rollback lesz.&lt;/p&gt;&lt;p&gt;Spring esetében az alapértelmezett működés, hogy RuntimeException és leszármazottja esetén rollback, amúgy commit (az EJB-vel megegyező módon). Viszont itt finomabban szabályozható, ugyanis rollback-for (rollbackFor) attribútummal felsorolhatjuk a metódusnál azokat a kivételeket, melyekre rollback-et akarunk, és a no-rollback-for (noRollBackFor) attribútummal azon kivételeket, ahol ne történjen rollback. Azaz így meg tudunk adni metódusonként olyan RuntimeException leszármazottakat, amire ne legyen rollback, és olyan alkalmazás szintű kivételeket, melyekre rollback legyen.&lt;/p&gt;&lt;p&gt;És végezetül egy saját probléma megoldása. Szükségünk volt a Spring-ben több tranzakció menedzserre, adatforrásonként egyre. A Spring 2.5 esetén nem lehetett megadni, hogy az annotációval jelölt bean-eknél melyik tranzakciómenedzser legyen a nyerő, hanem globálisan lehetett csak megadni. Ezért a bean-ek egyik felét &lt;tx:advice&gt; módon, a másik felét @Transactional annotációval konfiguráltuk (persze lehetett volna mindet &lt;tx:advice&gt;-szal is. A Spring 3 egyik újdonsága, hogy a @Transactional annotációnak a value attribútumában meg lehet adni, hogy melyik tranzakciómenedzsert használja.&lt;/tx:advice&gt;&lt;/tx:advice&gt;&lt;/p&gt;&lt;p&gt;További források:&lt;/p&gt;&lt;p&gt;&lt;a href="http://denis-zhdanov.blogspot.com/2009/07/spring-aop-top-problem-1-aspects-are.html"&gt;Spring AOP top problem #1 - aspects are not applied&lt;/a&gt;
&lt;a href="http://www.ibm.com/developerworks/java/library/j-ts1.html"&gt;Transaction strategies: Understanding transaction pitfalls&lt;/a&gt;&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/633786037997115640/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/05/tranzakciokezeles.html#comment-form' title='4 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/633786037997115640'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/633786037997115640'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/05/tranzakciokezeles.html' title='Tranzakciókezelés EJB 3 és Spring környezetben'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://4.bp.blogspot.com/_czKgycLvmNo/TAQm6KEx76I/AAAAAAAAFSg/ewIcUvTFMaI/s72-c/tranzakcio-kezeles1.png' height='72' width='72'/><thr:total>4</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7575740467544252298</id><published>2010-05-29T00:31:00.005+02:00</published><updated>2010-05-31T23:20:28.929+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Spring'/><category scheme='http://www.blogger.com/atom/ns#' term='könyv'/><title type='text'>Spring In Action</title><content type='html'>&lt;p&gt;Most fejeztem be a &lt;a href="http://www.manning.com/walls3/"&gt;Spring In Action&lt;/a&gt; könyv olvasását. Bár a post alapvetően könyvismertetés, kitérek néhány itt megismert technológiára is. A könyv második kiadása a Spring 2.0-val foglalkozik. Előkészületben van a harmadik kiadás is, mely a 3.0-ás verzióval fog foglalkozni.&lt;/p&gt;&lt;p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.manning.com/walls3/walls3_cover150.jpg"&gt;&lt;img style="border: 0px; display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 150px; height: 188px;" src="http://www.manning.com/walls3/walls3_cover150.jpg" border="0" alt="Spring In Action" /&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;A könyv bevezetője alapján az In Action egyrészt utal arra, hogy példákon keresztül mutatja be a Spring használatát, másrészt a fejlesztők elfoglalt emberek lévén nem tudják végigolvasni a könyvet, csak belelapoznak, olvasság kicsit, majd leteszik.&lt;/p&gt;&lt;p&gt;A könyv három fő részre tagolódik, úgymint a Core Spring, Enterprise Spring és Client-side Spring.&lt;/p&gt;&lt;p&gt;A Core Spring négy fejezetet tartalmaz, melyből az első fejezet egy rövid elméleti bevezető, mely leírja az alapfogalmakat, úgymint dependency injection, valamint aspect-oriented programming (AOP). A második és harmadik fejezet leírja az alap és haladó bean wiring koncepciókat. A negyedik fejezet kizárólag az AOP-ról szól.&lt;/p&gt;&lt;p&gt;Az Enterprise Spring a különböző Enterprise technológiák illesztéséről ír, mint perzisztencia, adatbáziskezelés (JDBC, Hibernate, JPA, iBatis), tranzakciókezelés, biztonság, távoli elérés (RMI, Hessian/Burlap, HttpInvoker, web-szolgáltatások), JMS, EJB integráció, JNDI, JavaMail, ütemezés (Timer és Quartz) és JMX.&lt;/p&gt;&lt;p&gt;A client-side Spring ismerteti a Spring MVC-t, a view technológiák integrálását (JSP, Velocity, Freemarker, Tiles), de leírja, hogy kell nem HTML tartalmat megjeleníteni, pl. Excel, PDF, de akár saját formátumot is, amihez a Spring nem nyújt alapból támogatást, mint az RSS feed. Bemutatja a Spring Web Flow-t, és egyéb web framework-ök illesztését is (Struts, WebWork2/Struts 2, JSF, DWR).&lt;/p&gt;&lt;p&gt;A függelékek egy része a könyvben található, mely leírja egy Spring-es projekt felépítését, valamint a tesztelést. Másik része a web oldalon érhető el, pl. portletek és különböző referenciák (XML, JSP tag library, Web Flow), valamint hogy hogyan lehet saját custom element-eket definiálni (saját névtérrel rendelkező saját tag-ek a konfigurácós állományban). Ez egy &lt;a href="http://www.manning.com/walls3/WebXtras.pdf"&gt;ingyen letölthető 100 oldalas PDF&lt;/a&gt;, mely már nem fért a könyvbe.&lt;/p&gt;&lt;p&gt;Ebből a rövid tartalomjegyzékből is látható, hogy a könyv irgalmatlanul széles témakört ölel fel, nemhiába 730 oldalas. Nem csak a Spring-gel foglalkozik, hanem áttekintő szinten magyarázza a Spring-be integrálható technológiákat is, pl. a Spring messaging fejezetben elmagyarázza, hogy mi az a JMS, de ez igaz kivétel nélkül minden fejezetre is. Nem csak a Spring-ben található komponenseket említi, hanem olyan, Spring kiegészítéseket is megemlít, mint az autentikációért és authorizációért felelős Spring Security-t, a contract-first fejlesztési módszert támogató Spring-WS-t, valamint a bonyolultabb képernyőfolyamokkal rendelkező alkalmazások fejlesztésére javasolt Spring Web Flow-t.&lt;/p&gt;&lt;p&gt;A könyv alapvetően kezdőknek szól, minden technológiát megpróbál érinteni, de a Spring alapvető fogalmain kívül mindent csak felületesen tud érinteni, ezért a referencia használata e mellett a könyv mellett is kötelező. Bár több éve használok Spring-et, mégis bőven tudott a könyv újdonságokat mutatni. Ilyen pl. az Advanced bean wiring fejezetben leírt parent és child bean-ek deklarálási lehetősége, a method injection, postprocessing beans, event-ek, stb. Megemlíti, hogy hogyan lehet Ruby, Groovy és BeanShell szkriptnyelveket használni. Ezt a fejezetet érdemes haladó Spring fejlesztőknek is elolvasniuk, bár javasolt a Spring függőséget minimálisra csökkenteni az alkalmazásainkban.&lt;/p&gt;&lt;p&gt;Külön meglepetés volt, hogy a perzisztenciánál ír a cache-elésről is. A tranzakciókezelésről szóló fejezet kiváló.&lt;/p&gt;&lt;p&gt;A könyv természetesen sok helyen von párhuzamot az EJB technológiával, de egyáltalán nem bántó módon teszi ezt. Az EJB-től mindig is irigyeltem a lokális transzparencia fogalmát, azaz, hogy az alkalmazásomat szét tudom vágni, és külön node-okra tenni a különböző funkciókat, skálázva ezzel az alkalmazást. Ezt programozási oldalról minimálisan kell támogatni (remote interfész használatával), alapvetően konfigurációval megoldható. Természetesen a Spring is nyújt erre megoldásokat, de nem csak az alkalmazásszerverek által használt RMI-t lehet protokollként választani, hanem a Hessian, Burlap és HttpInvoker eszközöket is, melyek bevallom, számomra teljesen ismeretlenek voltak. A Hessian és a Burlap is egy Caucho Technology által kifejlesztett megoldás távoli metódushívásra, csak míg az RMI-nél a HTTP-n keresztüli kommunikációhoz trükközni kell, addig ezen megoldások natívan azt használják. A Hessian binárisan viszi át az adatot (RMI-vel ellentétben programozási nyelv független módon), a Burlap XML-ben. A HTTPInvoker a Spring saját megoldása, amikoris a kommunikáció HTTP-n zajlik, de az adatok átvitelére a Java szerializációt használja. A transzparenciát az interfészekkel való programozás biztosítja, ahol szerver oldalon egy Exporter-t kell használni, mely a szolgáltatást valamelyik módszerrel elérhetővé teszi, míg a kliens oldalon az interfész alapján proxy generálódik. Ugyanígy lehet XFire web szolgáltatásokat, és klienseket is definiálni. A legszebb az egészben, hogy protokollok között átállni egyszerű konfiguráció módosítással lehet. A metódushívás alatti technológia kódszinten szinte észrevehetetlen.&lt;/p&gt;&lt;p&gt;Megemlíti a Lingo-t is, mely szintén egy remoting technológia, távoli metódushívásra, ahol az átviteli közeg a JMS.&lt;/p&gt;&lt;p&gt;A Spring in Action könyv egy remek bevezető a Spring-gel foglalkozni kívánó Java programozóknak, részletesen elmagyarázza a dependency injection és aspect-oriented programming fogalmakat. A bevezetőben megfogalmazott elveknek a könyv tökéletesen meg is felel, amennyiben kitaláljuk, hogy egy technológiát használni szeretnénk, vegyük le a polcról a könyvet, és olvassuk el az oda illeszkedő fejezetet. Annak ellenére, hogy minden fejezet elején van egy vicces sztori, egy valóvilág-beli párhuzam a megértést segítendő, a könyv nem javasolt egyszeri végigolvasásra. Haladó Spring fejlesztőknek az Advanced bean wiring fejezetet javaslom, és azon fejezeteket, melyekben említett technológiákat még nem használaták, de be szeretnének vezetni.&lt;/p&gt;&lt;p&gt;A könyv hibája, hogy sokat markol, de keveset fog. Minden technológiát be szeretne mutatni, mindegyikről ír bevezetőt, hogyan kell bekonfigurálni Spring alatt, szóval csak a felszínt karcolja. Nagyon egyszerű alkalmazás fejlesztését viszi végig, mely ez esetben egy autósoknak szóló alkalmazás. Szerencsére nem mindig ragaszkodik hozzá. Nagyon hiányoztak a könyvből azok a fejezetek, amelyek gyakorlati tanácsokat adnak. Az EJB könyvek mindegyikében van egy olyan fejezet, hogy hogyan használjuk JÓL az EJB-t, hogyan lehet gyors alkalmazásokat írni, performance tuning, stb. Ebből a könyvből teljesen hiányoznak a konvenciók, bevált gyakorlatok, gyakorlati trükkök-tippek.&lt;/p&gt;&lt;p&gt;Nekem nagyon kilóg a Spring Web Flow fejezet is a könyvből. Én még nem használtam, de ezek után nem is fogom. Az alapprobléma alapvetően az, hogy a webes alkalmazásunkba be vannak égetve a controller-ekbe a view nevek, valamint a view-kba url-lel (linkben vagy form action paraméterben) pedig hogy milyen oldalakra lehet továbbmenni. Így a folyamat szét van szórva. Ugyan van egy AbstractWizardFormController, de erre inkább úgy tekintsünk, mintha egy form lenne széttördelve sok kis oldalra. A Spring Web Flow viszont definiál állapotokat (state), eseményeket (event) és átmeneteket (transition). És egy saját formátumú XML konfigurációs állományba kell leírnunk a állapotokat, mely lehet action (üzleti logika hívása), decision (elágazás), start (folyamat kiindulási pontja), end (folyamat vége), subflow (alfolyamat) és view (megjelenítés). Valamint azt, hogy milyen események hatására milyen átmenetek valósuljanak meg. Sajnos ez olyan öszvér megoldásokat eredményez, hogy XML-ben definiáljuk ezeket, de pl. metódusneveket kell bele írnunk, valamint a feltételeket is Java-ban kell megfogalmaznunk. Már a BPEL-t sem szerettem, mert egy XML nyelven kell üzleti logikát megfogalmazni. Nem tudom, miért gondolják sokan, hogy a Java fejlesztők Java programozás helyett XML-t szeretnek írni. Többségünk nem.&lt;/p&gt;&lt;p&gt;Én egy kicsit a tesztelésről szóló függeléktől is többet vártam. Igaz, leírja, hogyan lehet Spring MVC Controller-eket  mock objektumokkal tesztelni, hogyan lehet az adatbázis műveleteknél a tranzakciót szabályozni, a JdbcTemplate-et használni, hogyan lehet az integrációs teszteléshez az applicationContext.xml állományt betölteni. Megemlíti a JUnit 4-hez a Gienah tesztelést, de azóta hasonló már bekerült a Spring-be is, azaz teszt esetekben is működik a dependency injection. Mégsem hangsúlyozza megfelelően, hogy a Spring egyik fő célkitűzése a könnyű tesztelhetőség. Hiszen miért csak függelékben szerepel?&lt;/p&gt;&lt;p&gt;A könyv a 2.5-ös újdonságait sem tartalmazza, így hiányzik az annotációkkal való konfiguráció mind bean-ek, mind Spring MVC esetén, valamint a JAX-WS sem kerül megemlítésre.&lt;/p&gt;&lt;p&gt;Ezekkel együtt nagyon ajánlom a könyvet minden Spring-gel ismerkedőnek, illetve egy-egy fejezetét a haladó fejlesztőknek is.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/7575740467544252298/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/05/spring-in-action.html#comment-form' title='3 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7575740467544252298'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7575740467544252298'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/05/spring-in-action.html' title='Spring In Action'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>3</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-861864873460642612</id><published>2010-05-16T23:20:00.004+02:00</published><updated>2010-09-18T00:21:13.472+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='JPA'/><title type='text'>JPA XML mapping állományok</title><content type='html'>&lt;p&gt;Adott egy web alkalmazás, mely perzisztenciához Hibernate JPA provider-t és Oracle 10g adatbázist használ. A JPA nagy ígérete a platformfüggetlenség, azaz az alkalmazás minimális erőfeszítéssel futtatható másik adatbázison.&lt;/p&gt;&lt;p&gt;Ki is próbáltam, és a Hibernate specifikus databasePlatform beállítást org.hibernate.dialect.Oracle10gDialect értékről átírtam MySQL5Dialect-re (normál esetben ez a persistence.xml-ben van, de én Spring-ből használtam, így az applicationContext.xml-ben).&lt;/p&gt;&lt;p&gt;Ekkora következő hibaüzeneteket kaptam:&lt;/p&gt;&lt;pre&gt;Caused by: org.hibernate.MappingException: could not instantiate id generator
Caused by: org.hibernate.MappingException: Dialect does not support sequences&lt;/pre&gt;&lt;p&gt;Ez azért van, mert a forráskódban az entitás id attribútumán a következő annotáció szerepelt:&lt;/p&gt;&lt;pre class="brush: java"&gt;public class Employee {

  @Id
  @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "EmployeeSeq")
  @SequenceGenerator(name="EmployeeSeq", sequenceName = "seq_employee")
  private Long id;

...
}&lt;/pre&gt;&lt;p&gt;Ez azt jelenti, hogy az id értéke automatikusan generált, az EmployeeSeq generátor által, mely egy Oracle szekvencia, seq_employee néven.
Azonban a MySQL nem ismeri a szekvencia fogalmát, helyette a mezőnek egy tulajdonsága az auto increment.&lt;/p&gt;&lt;p&gt;Az automatikus azonosító generálásra a JPA a következő lehetőségeket biztosítja:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Table: ekkor egy tábla tartalmazza a kiosztható azonosítókat - ez minden adatbázison működő megoldás&lt;/li&gt;&lt;li&gt;Sequence: azonosító generálása szekvencia alapján - pl. az Oracle ismeri&lt;/li&gt;&lt;li&gt;Identity: elsődleges kulcs identity, vagy más néven autonumber vagy auto increment - a MySQL ezt ismeri&lt;/li&gt;&lt;li&gt;Auto: a provider választ&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Így tehát a kóddal, a forráskódban szereplő annotációkkal az adatbázishoz kötöttük magunkat, bukva a platformfüggetlenséget. Vagy mégsem?&lt;/p&gt;&lt;p&gt;A JPA-ban (ugyanúgy mint az EJB3-ban) ugyanis lehetőség van a konfiguráció megadására annotációként, és ezt felül lehet definiálni a kódon kívül XML konfigurációs állományokban (EJB esetén deployment descriptor-nak hívják). Ezek a konfigurációs állományok JPA esetén a JPA XML mapping állományok. Minden egyes annotációval megadható konfigurációt meg lehet adni XML konfigurációval is. Amennyiben nincs sem annotációval, sem XML-ben konfiguráció megadva, un. intelligens default értékek kerülnek alkalmazásra. Ilyen intelligens alapértelmezett érték pl. az, hogy a tábla neve megegyezik az entitás nevével, annyi oszlop van benne, amennyi nem tranziens attribútum.&lt;/p&gt;&lt;p&gt;Tehát a cél, hogy az alkalmazás kódjának módosítása nélkül képes legyen MySQL adatbázison is működni. Ehhez először a persistence.xml állományban kell megadni az XML konfigurációs állomány helyét. Legyen ez is a persistence.xml állomány mellett, mapping-mysql.xml néven (a WAR állományban a WEB-INF/classes/META-INF könyvtárban kell elhelyezni).&lt;/p&gt;&lt;p&gt;Ehhez módosítsuk a persistence.xml állományt a következő módon:&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;persistence-unit name="jtechlogPU" transaction-type="RESOURCE_LOCAL"&amp;gt;
      &amp;lt;mapping-file&amp;gt;META-INF/mapping-mysql.xml&amp;lt;/mapping-file&amp;gt;
&amp;lt;/persistence-unit&amp;gt;&lt;/pre&gt;&lt;p&gt;Az állomány helyét a CLASSPATH-hoz képest kell megadni.&lt;/p&gt;&lt;p&gt;A mapping-mysql.xml állományban definiáljuk, hogy az Employee osztály id attribútumának generátora identity típusú legyen:&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;

&amp;lt;entity-mappings xmlns="http://java.sun.com/xml/ns/persistence/orm"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:schemaLocation="http://java.sun.com/xml/ns/persistence/orm
               http://java.sun.com/xml/ns/persistence/orm_1_0.xsd"
               version="1.0"&amp;gt;
  &amp;lt;entity class="jtechlog.Employee"&amp;gt;
      &amp;lt;attributes&amp;gt;
          &amp;lt;id name="id"&amp;gt;
              &amp;lt;generated-value strategy="IDENTITY" /&amp;gt;
          &amp;lt;/id&amp;gt;
      &amp;lt;/attributes&amp;gt;
  &amp;lt;/entity&amp;gt;
&amp;lt;/entity-mappings&amp;gt;&lt;/pre&gt;&lt;p&gt;Ezzel a beállítással az alkalmazás azonnal képes volt MySQL adatbázison is működni. Már csak a build folyamatot kell úgy módosítani, hogy a persistence.xml állományban egy környezeti beállítás alapján helyezze el a mapping állomány hivatkozást.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/861864873460642612/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/05/jpa-xml-mapping-allomanyok.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/861864873460642612'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/861864873460642612'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/05/jpa-xml-mapping-allomanyok.html' title='JPA XML mapping állományok'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4550403846114418343</id><published>2010-04-28T23:44:00.007+02:00</published><updated>2014-02-02T16:32:15.794+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><title type='text'>Maven kezdőlépések</title><content type='html'>&lt;h3&gt;Bevezetés&lt;/h3&gt;&lt;p&gt;Lassan már az összes magyar Java-val foglalkozó blogger írt tapasztalatokat a Maven-ről, így hát én sem maradhatok ki a sorból. Túl vagyunk egy teljes egészében Maven-nel fejlesztett projekten, egy már létező projekt Maven-re átállításán, valamint jópár Maven oktatáson.&lt;/p&gt;&lt;p&gt;A blog statisztikája (Google Analytics) szerint a leglátogatottabb cikkek a bevezető jellegű cikkek, így a Maven-ről is egy ilyent írnék, tanácsokat egy kezdő számára, hogy merre érdemes elindulni, és néhány trükköt, amit ismerni érdemes. Nem magyarázom a fogalmakat, csupán jelzem, hogy mely fogalmakat kell ismerni. Amennyiben tapasztalt Maven olvasó vagy, kérlek jelezd a comment-ek között, ha valamit rosszul írtam, nem így használsz, vagy tipped, ötleted van.&lt;/p&gt;&lt;p&gt;A Maven-nel kapcsolatban a legtöbbet megfogalmazott kritika az, hogy a tanulási görbéje nem elég meredek, azaz ahhoz, hogy &lt;emp&gt;jól&lt;/emp&gt; használjuk, sokat kell tudni róla. Ezt tükrözik sajnos a publikus repository-kban található silány minőségű artifact-ok is, amiből látszik, hogy ugyan sokan használják a Maven-t, de nem ismerik. Ezzel azonban a többi fejlesztő dolgát keserítik meg.&lt;/p&gt;&lt;h3&gt;Források&lt;/h3&gt;&lt;p&gt;Ezért azt javaslom, hogy amennyiben valaki Maven-t akar használni, egy-két bevezető jellegű cikk után igenis olvasson el két könyvet. Az egyik az O'Reilly által is kiadott &lt;a href="http://oreilly.com/catalog/9780596517335"&gt;Maven: The Definitive Guide&lt;/a&gt;. A könyv egyik fő szerzője, a Maven első verzióját készítő Jason Van Zyl, aki jelenleg a &lt;a href="http://www.sonatype.com/"&gt;Sonatype&lt;/a&gt;-nál CTO. Azonban a papíron kiadott könyv már igencsak elavult, ugyanis a Sonatype honlapjáról mindig &lt;a href="http://www.sonatype.com/documentation/books"&gt;letölthető&lt;/a&gt; a legfrissebb verzió. A könyvet időközben két külön könyvre bontották, Maven by Example és Maven: The Complete Reference címmel.&lt;/p&gt;

&lt;a rel="lightbox[maven-kezdolepesek]" href="http://3.bp.blogspot.com/_czKgycLvmNo/TT8OoNqhjtI/AAAAAAAAFq4/SP2A7_Eh56E/s1600/sonatype_maven_the_complete_reference.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 246px; height: 320px;" src="http://3.bp.blogspot.com/_czKgycLvmNo/TT8OoNqhjtI/AAAAAAAAFq4/SP2A7_Eh56E/s320/sonatype_maven_the_complete_reference.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5566183748478799570" /&gt;&lt;/a&gt;

&lt;p&gt;Az első könyvbe az eredeti könyv Part II. része került, míg a második könyvbe pedig a többi. Ezen kívül rengeteg dologgal kiegészült időközben az eredeti könyvhöz képest:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Running Maven fejezet - a parancssori paramétereket, a Reactor paramétereit, valamint a Help Plugin használatát részletezi&lt;/li&gt;&lt;li&gt;Using Maven Archetypes - archetype-ok használatát, és saját archetype-ok készítését és publikálását részletezi&lt;/li&gt;&lt;li&gt;Developing with Flexmojos - fejlesztés a Flex pluginnal&lt;/li&gt;&lt;li&gt;Android Application Development with Maven - Android fejlesztés Maven-nel&lt;/li&gt;&lt;li&gt;stb.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Az eredeti könyvben szerepel egy-egy fejezet a Nexus-ról, illetve a m2eclipse Eclipse plugin-ról is. Ezekből szintén egy-egy könyv lett, Repository Management with Nexus és Developing with Eclipse and Maven néven. Érdemes figyelemmel kísérni a honlapot, mert gyakran frissül. A Sonatype-nak ezen kívül magyar vonatkozása is van, hiszen a Nexus elődjét Cservenák Tamás fejlesztette Proximity néven, és eztán kérte fel a Sonatype, hogy készítsen egy hasonló terméket, Nexus néven.&lt;/p&gt;&lt;p&gt;A másik könyv a &lt;a href="http://www.maestrodev.com/better-build-maven"&gt;Better Builds with Maven&lt;/a&gt;, mely szintén ingyenesen letölthető. Szintén a Maven fejlesztésében résztvevők írták, és most a MaestroDev tartja karban. Nem olyan részletes és jól karbantartott, mint az előbb említett könyvek, azonban mégis érdemes elolvasni, mert kicsit más oldalról közelíti meg a Maven-nel történő fejlesztést.&lt;/p&gt;&lt;h3&gt;Fogalmak&lt;/h3&gt;&lt;p&gt;A Maven definíció szerint "software project management and comprehension tool". Tehát nem egy egyszerű build tool, melyben az Ant-hoz hasonlóan leírjuk az egymás utáni lépéseket, hanem annál sokkal fejlettebb, magasabb szintű megoldás. Alapja a project object model (POM), melyet XML-ben leírva tudunk megadni (pom.xml), és ez alapján a Maven képes további leírások nélkül elvégezni a build folyamatot, különböző riportok, dokumentációk, gyakorlatilag a teljes projekt website-jának legenerálását. A Maven nem titkolt célja, hogy a Java fejlesztők körében egyfajta szabvány legyen, mely a konvenciók megtartását előnybe helyezi az egyéni konfigurációkkal szemben (convention over configuration). Sajnos a Java nagyon sokáig nem adott szabványt arra, hogy hogyan kell egy projektet felépíteni, a Maven ezt az űrt próbálja betölteni. Azaz ha tartjuk magunkat egy projekt struktúrához, azaz a különböző állományainkat a megfelelő könyvtárakba helyezzük el, a Maven képes lesz elvégezni a build folyamatot, a források lefordítását, a különböző erőforrás állományok megfelelő helyre másolását, és az alkalmazásunk összecsomagolását.&lt;/p&gt;&lt;p&gt;A Maven alapfogalma a projekt, mely a koordináták alapján van azonosítva, melyek a következők: groupId, artifactId, version, packaging, classifier. Pl. a legfrissebb Log4J esetén a groupId:log4j, artifactId:log4j, version:1.2.16. A többi megadása opcionális. A groupId megadásánál elterjedt az egyedi azonosítás miatt a domain név megadása, mint a Java package-eknél (pl. org.springframework). A projektek egymástól öröklődhetnek, valamint van lehetőség több modulból álló projektek megadására is (mindegyik modul saját pom.xml-lel). A pom.xml-ben lehet megadni a projektre jellemző olyan információkat is, mint a licence, szervezet, fejlesztők, közreműködők, valamint olyan fejlesztési környezet információkat is, mint a verziókezelő, issue management, continuous integration eszköz elérése, stb. Ráadásul a projektre jellemző POM, az un. effective POM több részből épül fel. Egyrészt a Super POM, mely a maven-[version]-uber.jar-ban szerepel org.apache.maven.project.pom-4.0.0.xml néven, a szülő POM-jából, valamint a projekthez tartozó POM-ból aggregálva.&lt;/p&gt;&lt;p&gt;A Maven nagy előnye ezen kívül, hogy beépített mechanizmus van a különböző projekt függőségek definiálására és feloldására (pl. tranzitív függőség, A projekt függ B-től, B projket függ C-től, akkor a C-re is szükség van). Itt fontos ismerni a scope fogalmát. Sokat segíthet a függőségi fa kirajzolása. A függőségek megadásánál használhatunk pontos verziószámokat, de akár verzióintervallumokat is (range). Megadhatóak opcionális függőségek is, melyeket nem muszáj igénybe vennünk.&lt;/p&gt;&lt;p&gt;A Maven build folyamat kimenetele az artifact. Ezen artifact 3rd party library esetén a JAR állomány, webes alkalmazás esetén a WAR állomány, nagyvállalati alkalmazás esetén az EAR állomány, stb. A Maven megkülönbözteti a release és snapshot fogalmát, ahol az előző a kiadható verzió, míg az utóbbi a fejlesztés közben használatos verzió.&lt;/p&gt;&lt;p&gt;Az artifact-okat egy központi helyen, un. repository-ban helyezi el, hierarchikus rendben. A legtöbb kritikai itt éri a Maven-t, hogy miért is nem jó a függő library-k tárolása egyszerűen a verziókövető rendszerben, miért kell ehhez egy külön repository-t használni. A Maven használhat publikus repository-kat, valamint használ az adott gépen egy lokális repository-t is, ez alapesetben a felhasználó home könyvtárában .m2/repository könyvtárában található. Ezen kívül a repository manager-ek elterjedésével (pl. Nexus vagy Artifactory) érdemes kialakítani egy cégen belül használatos belső repository-t is, melyben tárolhatóak a saját projektek állományai, valamint egyfajta proxy-ként működnek a publikus repository-k felé. Az alapértelmezett publikus repository a http://repo1.maven.org/maven2/. A repository-k is csoportosíthatók, hogy release vagy snapshot verziókat tárolnak-e.&lt;/p&gt;&lt;p&gt;A Maven teljesen moduláris felépítésű, minden un. Maven plugin-ben van megvalósítva. Ezen Maven plugin-ek is artifact-ok. Ezért van az, hogy a Maven telepítőcsomagja alig pár mega, az összes többi funkcionalitást biztosító plugin-t (artifact) akkor tölt le, amikor szükség van rá. Persze emiatt az első futtatás tovább tarthat, hiszen ekkor nagy mennyiségű artifact-ot kell letöltenie. A pom.xml-ben ezen plugin-eket konfigurálhatjuk is. A plugin-ek tulajdonképpen összetartozó goal-ok gyűjteménye, ahol egy goal egy egyedi, önmagában is futtatható funkció. Ilyen pl. a compiler plugin compile goal-ja, ami a forrás állományok fordításáért felelős. Valamint a Maven-ben vannak definiálva un. életciklusok (lifecycle). Pl. build lifecycle (default), site és clean lifecycle. Minden lifcycle fázisokból áll, és minden fázishoz alapértelmezetten tartozik egy vagy több plugin goal. Pl. a build lifecycle egyik fázisa package, mely a jar plugin jar goal-ját hívja meg bizonyos esetekben. Persze ezt magunk személyre is szabhatjuk. Első feladat megérteni a Maven tanulásakor, mikor kiadunk egy parancsot, mi is fut le, milyen életciklus milyen fázis, milyen plugin milyen goal-ja. A plugin-ek kaphatnak paramétereket.&lt;/p&gt;&lt;p&gt;A Maven előnye, hogy nagyban megkönnyíti a csapattagok kommunikációját, valamint a fejlesztésbe bekapcsolódást, ugyanis képes kigenerálni különböző riportokat (pom.xml-ben definiálandó), dokumentációt, a projekt site-ját (természetesen nagymértékben testreszabható módon). Ezért különösen elosztott, open source fejlesztésre különösen alkalmas.&lt;/p&gt;&lt;p&gt;A Maven-ben vannak un. profilok is, melyek a build folyamat portabilitását biztosítják különböző build környezetekben. Pl. lehet, hogy másképp kell, hogy működjön a build folyamat különböző architektúrákon, JDK verziókon és operációs rendszereken, teszt és élest környezetben, sőt akár &lt;a href="http://jhacks.anzix.net/space/maven/maven2/IDE+support"&gt;különböző fejlesztőeszközök használatakor&lt;/a&gt;. Lehetőség van arra, hogy mi adjuk meg parancssorból a profilt (-P kapcsolóval), de van profile activation is, ahol valamely környezeti beállítás hatására automatikusan egy profil kerül kiválasztásra.&lt;/p&gt;&lt;p&gt;A másik érdekesség az assembly-k használata. A Maven beépítetten ismeri a gyakoribb csomagolási módokat, a packaging-től függően JAR, WAR, EAR (bin). Képes arra is, hogy olyan distribution-t készítsen, amibe bele vannak csomagolva a függő osztályok is (jar-with-dependencies), valamint képes a teljes projektet becsomagolni (project), valamint csak a forráskódot kiadni (src). Ezen kívül saját assembly-t is definiálhatunk assembly descriptor megadásával.&lt;/p&gt;&lt;p&gt;A Maven-ben a személyes kedvencem az archetype. Az archetype egy projekt sablon, melyből létre lehet hozni egy üres projektet különböző paraméterek megadásával. Ha gyakran indítunk projektet, érdemes egy ilyent gyártanunk, mely a megfelelő kiindulási alapot biztosítja. Vannak beépített archetype-ok is, ezelből is sok öteletet lehet meríteni. Ezek is artifact-ok, azaz a repository-ban is elhelyezhetők.&lt;/p&gt;&lt;p&gt;A Maven-ben ezen kívül lehetőség van saját plugin-ek implementálására is. Egy goal-t egy mojo-ban implementálhatunk (Maven plain Old Java Object). Egy plugin mojo-k gyűjteménye.&lt;/p&gt;&lt;p&gt;A Maven könnyen integrálható az összes continuous integration eszközzel.&lt;/p&gt;&lt;h3&gt;Tippek és személyes tapasztalatok&lt;/h3&gt;&lt;p&gt;Ide a személyes tapasztalataimat próbálom összegyűjteni, és azokat a problémákat és megoldásaikat, melyekkel egy Maven felhasználó először találkozik. Ezek egy részével a &lt;a href="http://maven.apache.org/general.html"&gt;FAQ&lt;/a&gt; is foglalkozik.&lt;/p&gt;&lt;h4&gt;Java verzió&lt;/h4&gt;&lt;p&gt;Alapesetben a Maven compiler plugin a Java 1.4-re fordít, ahhoz, hogy az 1.5 újdonságait ki tudjuk használni, át kell ezt állítani, pl. a legfrissebb 1.6-os verzióra a pom.xml-ben.&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;build&amp;gt;
&amp;lt;plugins&amp;gt;
&amp;lt;plugin&amp;gt;
  &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
  &amp;lt;configuration&amp;gt;
    &amp;lt;source&amp;gt;1.6&amp;lt;/source&amp;gt;
    &amp;lt;target&amp;gt;1.6&amp;lt;/target&amp;gt;
  &amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;
&amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;&lt;/pre&gt;&lt;h4&gt;Kevés memória&lt;/h4&gt;&lt;p&gt;Amennyiben a Maven build vagy site generálás hibát dob (java.lang.OutOfMemoryError: Java heap space), hogy nincs elég memória, akkor be kell állítanunk a MAVEN_OPTS környezeti változót.&lt;/p&gt;&lt;pre&gt;MAVEN_OPTS="-Xmx1024m -Xms512m"&lt;/pre&gt;&lt;h4&gt;Karakterkódolás&lt;/h4&gt;&lt;p&gt;Az ékezetes karakterek használata itt is problémát okoz, így hogy ezt elkerüljük, mindenütt deklarálni kell a karakterkódolást. Javasolt az UTF-8 használata. Nagyon sok plugin-nak van encoding property-je, ezt kell állítani. Pl. ha a Java forrásállományokban ékezeteket használunk (pl. dokumentációs megjegyzésekben).&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;build&amp;gt;
&amp;lt;plugins&amp;gt;
&amp;lt;plugin&amp;gt;
  &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
  &amp;lt;configuration&amp;gt;
    &amp;lt;encoding&amp;gt;UTF-8&amp;lt;/encoding&amp;gt;
  &amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;
&amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/pre&gt;&lt;p&gt;De ezen kívül meg kell adnunk a maven-resources-plugin, maven-site-plugin (inputEncoding, outputEncoding néven), maven-checkstyle-plugin, maven-javadoc-plugin, maven-pmd-plugin, taglist-maven-plugin plugin-oknak. Amennyiben nem adjuk meg, a Maven warning-ot ír, hogy nincs megadva a karakterkódolás, emiatt build környezetfüggő, mert az operációs rendszer default kódolását használja.&lt;/p&gt;&lt;h4&gt;Hiányzó artifact&lt;/h4&gt;&lt;p&gt;Amennyiben egy artifact hiányzik a repository-ból, a következő paranccsal tudjuk oda installálni:&lt;/p&gt;&lt;pre&gt;mvn install:install-file
-Dfile=&lt;path-to-file&gt;
-DgroupId=&lt;group-id&gt;
-DartifactId=&lt;artifact-id&gt;
-Dversion=&lt;version&gt;
-Dpackaging=&lt;packaging&gt;
-DgeneratePom=true&lt;/packaging&gt;&lt;/version&gt;&lt;/artifact-id&gt;&lt;/group-id&gt;&lt;/path-to-file&gt;&lt;/pre&gt;&lt;p&gt;Azaz pl az Oracle jdbc driver esetén:&lt;/p&gt;&lt;pre&gt;mvn install:install-file
-Dfile=ojdbc6-11.2.0.1.0.jar
-DgroupId=com.oracle
-DartifactId=ojdbc6
-Dversion=11.2.0.1.0
-Dpackaging=jar
-DgeneratePom=true&lt;/pre&gt;&lt;p&gt;Utána persze ezen koordinátákkal kell hivatkozni rá a függőség megadásánál.&lt;/p&gt;&lt;h4&gt;Debug mód&lt;/h4&gt;&lt;p&gt;Futtassuk a Maven-t a -X kapcsolóval.&lt;/p&gt;&lt;h4&gt;Teszt esetek&lt;/h4&gt;&lt;p&gt;A Maven Surefire plugin-ja alapértelmezésben futtat JUnit és TestNG teszt eseteket is. A kizárólag teszteléshez szükséges függőségeket test scope-pal kell elhelyezni a függőségek között. Meg lehet adni, hogy amennyiben egy teszt eset hibázik, a build még folytatódjon (maven-surefire-plugin testFailureIgnore tulajdonsága). Valamint azt is meg lehet adni, hogy ne futtassa le a teszt eseteket (–Dmaven.test.skip=true vagy -DskipTests=true parancssori kapcsolóval, de a POM-ban is megadható maven-surefire-plugin skipTests property-jének állításával). Ha csak egy teszt esetet akarunk futtatni, használjuk a -Dtest=MyTest kapcsolót (csomag megadása nélkül).&lt;/p&gt;&lt;h4&gt;Artifact neve&lt;/h4&gt;&lt;p&gt;Alapesetben a Maven artifact neve a koordinátákból jön, azonban war állomány esetén ez nem lenne szerencsés, így felüldefiniálható a POM-ban a finalName tag-gel.&lt;/p&gt;&lt;h4&gt;Riportok generálása&lt;/h4&gt;&lt;p&gt;A site lifecycle része a riportok generálása is. Azonban, ha mi a site többi részére vagyunk kíváncsiak, és nem akarjuk a riportokat kigeneráltatni, akkor ezt megtehetjük a -DgenerateReports=false használatával.&lt;/p&gt;&lt;h4&gt;Repository manager&lt;/h4&gt;&lt;p&gt;Egy cégen belül mindenképp alkalmazzunk repository manager eszközt. Ez egyrészt tartalmazza a saját artifact-jainkat, másrészt egy proxy a publikus repositry-k felé. Webes felületen menedzselhetőek (artifact keresés és feltöltés), valamint mindenféle jogosultsági szinteket tudunk megadni, és képesek archiválni a repository-t. Érdemes az Artifactory és a Nexus közül választani, én az előbbire tettem le a voksom, és egyelőre nem tapasztaltam hiányosságot.&lt;/p&gt;&lt;h4&gt;Log4j 1.2.15&lt;/h4&gt;&lt;p&gt;A repository-k minőségét jellemzi a Log4J 1.2.15 verziója, melyben a javax.mail:mail, javax.jms:jms, com.sun.jdmk:jmxtools és a com.sun.jmx:jmxri artifact-ok kötelező függőségként voltak megadva. Ezen jar-ok használata pedig nem kötelező, csak akkor szükséges, ha a hozzájuk tartozó megfelelő appender-eket akarjuk használni, a JMX meg már része a JDK-nak. Szerencsére ezt azóta &lt;a href="http://svn.apache.org/viewvc?view=revision&amp;amp;revision=575804"&gt;javították&lt;/a&gt;.&lt;/p&gt;&lt;h4&gt;IDE integráció - NetBeans&lt;/h4&gt;&lt;p&gt;A Maven NetBeans integrációját gyakran használtam, és igen jónak tartom, nem ütköztem vele problémába. Kicsit féltem tőle, mert elsődleges szempont a gyors fejleszt-tesztel iterációs ciklus, és régebbi verzióval voltak gondjaim. Most ilyenről nem számolhatok be. Nem jelentősen lassabb a beépített Ant-ra épülő build folyamatnál, hiszen mindegyik egy külső, megfelelően integrált eszköz. A &lt;a href="http://wiki.netbeans.org/MavenBestPractices"&gt;MavenBestPractices&lt;/a&gt; cikk rengeteg jó tanácsot ad a NetBeans felhasználóknak.&lt;/p&gt;&lt;h4&gt;IDE integráció - Eclipse&lt;/h4&gt;&lt;p&gt;Az Eclipse esetén az &lt;a href="http://m2eclipse.sonatype.org/"&gt;m2eclipse&lt;/a&gt; hatékonyságáról hallottam rossz híreket, különösen nagy, több modulból álló projektek esetén, így azt nem próbáltam, helyette a &lt;a href="http://maven.apache.org/plugins/maven-eclipse-plugin/"&gt;maven-eclipse-plugin plugin&lt;/a&gt;-t használtam, mely a POM alapján képes módosítani az Eclipse projekt állományokat. A recept egyszerű:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Hozzuk létre az Eclipse workspace-t&lt;/li&gt;&lt;li&gt;A mvn eclipse:configure-workspace -Declipse.workspace=C:/workspace paranccsal konfiguráljuk a workspace-t (a C:\workspace\.metadata\.plugins\org.eclipse.core.runtime\.settings\org.eclipse.jdt.core.prefs állományban létrehoz egy org.eclipse.jdt.core.classpathVariable.M2_REPO=C\:\\Documents and Settings\\jtechlog\\.m2\\repository bejegyzést, szóval létrehoz egy M2_REPO változót, mely a repository helyére mutat)&lt;/li&gt;&lt;li&gt;A mvn eclipse:eclipse paranccsal generáltassuk le a projekt állományokat, melyekkel már megnyitható a projekt Eclipse-ben&lt;/li&gt;&lt;li&gt;Amikor webes projektet hoztam létre, még a következő konfigurációt is el kellett helyeznem a POM-ban.&lt;pre class="brush: xml"&gt;&amp;lt;plugin&amp;gt;
&amp;lt;artifactId&amp;gt;maven-eclipse-plugin&amp;lt;/artifactId&amp;gt;
&amp;lt;configuration&amp;gt;
  &amp;lt;wtpmanifest&amp;gt;true&amp;lt;/wtpmanifest&amp;gt;
    &amp;lt;wtpapplicationxml&amp;gt;true&amp;lt;/wtpapplicationxml&amp;gt;
    &amp;lt;wtpversion&amp;gt;2.0&amp;lt;/wtpversion&amp;gt;
&amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;&lt;/pre&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Számomra meglepően jól működött az, hogyha változott a POM-ban valami, csak újrafuttattam az eclipse:eclipse goal-t, majd az Eclipse-ben újraolvastattam a projektet. Ha a NetBeans nem Ant alapú lenne, ott is jobban preferálnám ezt a módot.&lt;/p&gt;&lt;h4&gt;Code complete&lt;/h4&gt;&lt;p&gt;Különösen meglepő volt számomra, hogy mind a NetBeans-ben, mint az Eclipse-ben elérhető a POM code complete, sőt, működik a dependency megadásnál is, ugyanis automatikusan felajánlja az elérhető artifact-ek koordinátáit. A NetBeans esetén alul a státuszsorban látszik, hogy a hálózathoz kapcsolódik, és átviszi a repository indexét.&lt;/p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_czKgycLvmNo/S9itjs4Z0wI/AAAAAAAAFQg/KmXZWGmTAxE/s1600/pom_code_complete.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 143px;" src="http://2.bp.blogspot.com/_czKgycLvmNo/S9itjs4Z0wI/AAAAAAAAFQg/KmXZWGmTAxE/s320/pom_code_complete.png" border="0" alt="" id="BLOGGER_PHOTO_ID_5465308976668857090" /&gt;&lt;/a&gt;
&lt;h4&gt;Provided&lt;/h4&gt;&lt;p&gt;Ha szükségünk van egy JAR-ra a fordításhoz, de nem akarjuk, hogy pl. webes alkalmazásnál a WAR-ba kerüljön, mert futtatáskor a konténer úgyis biztosítja azt a CLASSPATH-on ( ilyen pl. a servlet.jar, mail.jar stb.), akkor használjuk a provided scope-ot.&lt;/p&gt;&lt;h4&gt;Repository-k&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;A default repository a http://repo1.maven.org/maven2/. Azonban itt elég sokminden nincs fenn, így más publikus repository-kat is használnunk kell. Ezek pl. (a legtöbbjük az Artifactory-ban alapban konfigurálva van):&lt;/p&gt;&lt;ul&gt;&lt;li&gt;http://download.java.net/maven/1&lt;/li&gt;&lt;li&gt;http://download.java.net/maven/2&lt;/li&gt;&lt;li&gt;http://repository.jboss.com/maven2&lt;/li&gt;&lt;li&gt;http://repository.codehaus.org&lt;/li&gt;&lt;li&gt;http://maven.springframework.org/release&lt;/li&gt;&lt;li&gt;http://jasperreports.sourceforge.net/maven2/&lt;/li&gt;&lt;li&gt;http://stat-scm.sourceforge.net/maven2/&lt;/li&gt;&lt;li&gt;http://google-maven-repository.googlecode.com/svn/repository&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Ezeket beállíthatjuk a settings.xml-ünkben, de beállíthatjuk a POM-ban is. Az &lt;a href="http://subversion.jfrog.org/artifactory/public/trunk/pom.xml"&gt;Artifactory POM&lt;/a&gt;-jában láttam, hogy ott a repository-kat egy profile-ban adták meg, és ezt használva a -P kapcsolóval kell a profile-t megadni.&lt;/p&gt;&lt;h4&gt;Hiányzó artifact&lt;/h4&gt;&lt;p&gt;Abban az esetben, ha nem tudjuk a pontos koordinátákat a függőség megadásakor, érdemes valamilyen keresőt használni. Nekem ezek jöttek be:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;http://mvnrepository.com&lt;/li&gt;&lt;li&gt;http://repository.sonatype.org/&lt;/li&gt;&lt;li&gt;http://repository.apache.org&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;Servlet, JSP, JSTL&lt;/h4&gt;&lt;p&gt;A repo1-ben sokáig nem volt fenn a servlet, JSP és JSTL, &lt;a href="http://maven.apache.org/guides/mini/guide-coping-with-sun-jars.html"&gt;licence-elési okokból&lt;/a&gt;, és ezért azt javasolták, hogy helyette használjuk a Glassfish ide vonatkozó artifact-jait. Azonban ez megváltozott, ezen artifact-ok &lt;a href="http://repo1.maven.org/maven2/javax/servlet/"&gt;megtalálhatóak&lt;/a&gt; repo1-ben. Azonban, ha olyannal szembesülünk, ami nem található meg, akkor érdemes szétnézni a java.net-es repository-kban.&lt;/p&gt;&lt;h4&gt;Létező NetBeans projektről átállás&lt;/h4&gt;&lt;p&gt;Két projektben is a NetBeans projekt állományai mellé felvettem egy POM-ot is, hogy a Maven bevezethet legyen, de párhuzamosan mindkét build folyamat működjön. Ez azért körülményes, mert a könyvtárstruktúra nem a Maven konvencióinak felel meg. A cél az volt, hogy bitre megegyező war állományt állítson elő a NetBeans és a Maven. Az időm 90%-ában azon dolgoztam, hogy pont azokat a JAR-okat, és pont annyit tegyen oda, mint az eredeti projektben voltak. Az, hogy a könyvtárnevek eltértek, semmi gondot nem okozott. Három estém ment rá.&lt;/p&gt;&lt;p&gt;Egy kis statisztika:&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Technológia:&lt;/td&gt;&lt;td&gt;Spring, Struts, JSP&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JAR-ok száma az eredeti projektben:&lt;/td&gt;&lt;td&gt;35&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Dependency tag-ek a POM-ban:&lt;/td&gt;&lt;td&gt;30&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Exclusions tag-ek nélkül a JAR-ok száma:&lt;/td&gt;&lt;td&gt;62&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Exclusions tag-ek a POM-ban:&lt;/td&gt;&lt;td&gt;17 (!!!)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Egy repository-ban sem talált JAR-ok száma, melyeket kézzel kellett telepíteni:&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Ahhoz, hogy a NetBeans-es projekt azonnal leforduljon a Maven-nel is, a következő konfigurációkat kellett a POM-ban megtenni:&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;build&amp;gt;
 &amp;lt;!-- WAR neve --&amp;gt;
 &amp;lt;finalName&amp;gt;app&amp;lt;/finalName&amp;gt;
 &amp;lt;sourceDirectory&amp;gt;src/java&amp;lt;/sourceDirectory&amp;gt;
 &amp;lt;plugins&amp;gt;
 &amp;lt;!-- Fentebb említett 1.6-os Java és UTF-8 kódolások --&amp;gt;
  &amp;lt;plugin&amp;gt;
   &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;maven-war-plugin&amp;lt;/artifactId&amp;gt;
   &amp;lt;configuration&amp;gt;
    &amp;lt;warSourceDirectory&amp;gt;web&amp;lt;/warSourceDirectory&amp;gt;
   &amp;lt;/configuration&amp;gt;
  &amp;lt;/plugin&amp;gt;
 &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;&lt;/pre&gt;&lt;h3&gt;Zárszó&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Abba a vitába nem mennék bele, hogy mikor van értelme Maven-t használni, és mikor érdemes Ant-nál, vagy valami másnál maradni. A Maven-t ki kell próbálni. A Maven-t előbb-utóbb nem tudod elkerülni. Egy biztos, aki használni akarja, az ne vegye félvállról, mert a megítélése szerintem az ezen a területen félig képzett programozók miatt van. És érdemes igyekezni, mert nyakunkon a &lt;a href="http://java.dzone.com/articles/maven-3-rides-town"&gt;3-as verzió&lt;/a&gt;.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/4550403846114418343/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/04/maven-kezdolepesek.html#comment-form' title='6 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4550403846114418343'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4550403846114418343'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/04/maven-kezdolepesek.html' title='Maven kezdőlépések'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://3.bp.blogspot.com/_czKgycLvmNo/TT8OoNqhjtI/AAAAAAAAFq4/SP2A7_Eh56E/s72-c/sonatype_maven_the_complete_reference.png' height='72' width='72'/><thr:total>6</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3043347152348532729</id><published>2010-04-21T01:49:00.004+02:00</published><updated>2010-09-18T00:22:28.958+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='MQ'/><category scheme='http://www.blogger.com/atom/ns#' term='JMS'/><category scheme='http://www.blogger.com/atom/ns#' term='Spring'/><title type='text'>Mérgezett üzenetek</title><content type='html'>&lt;p&gt;Amennyiben aszinkron üzenetkezelést használunk, Java-ban tipikusan JMS API használatával, szembesülhetünk a poisoned message fogalmával. Amennyiben az egyik soron vagy témán kapunk egy üzenetet, és nem tudjuk feldolgozni, pl. valamilyen belső hiba történt (hibás az alkalmazás), dönthetünk, hogy mit kezdünk az üzenettel. Ezek a következők lehetnek:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Visszagörgetjük a tranzakciót&lt;/li&gt;&lt;li&gt;Eldobjuk az üzenetet&lt;/li&gt;&lt;li&gt;Magunk tároljuk a hibás üzenetet (pl. naplózzuk, adatbázisba mentjük, vagy áttesszük egy másik sorba), majd eldobjuk az üzenetet&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Legegyszerűbb megoldás, hogy tranzakciót visszagörgetjük (rollback), ekkor az üzenet visszakerül a sorba (pontosabban ki sem kerül onnan, csak a kliens megjelöli, hogy éppen feldolgozás alatt van, így más kliensek nem férhetnek hozzá). Ez után a JMS provider újra kioszthatja az üzenetet. Feltehetőleg az eddigi hiba magától nem javul meg, hiszen sem az alkalmazás, sem az üzenet nem változott, így újra hiba keletkezik, és újra visszakerül a sorba. Így hamar végtelenciklus alakulhat ki. Persze lehet az is, hogy közben az alkalmazás állapota változik, és ezért már be tudja fogadni az üzenetet, de ennek kicsi a valószínűsége, és amúgy is tervezési hibára utalhat.&lt;/p&gt;&lt;p&gt;Alkalmazásból is le tudjuk kérdezni, hogy az üzenet rollback-kel került már-e vissza a sorba, ekkor a javax.jms.Message getJMSRedelivered() metódusát kell meghívni. Sőt annak számát is le tudjuk kérdezni, hogy az üzenet hányszor került vissza a sorba, erre a getIntProperty("JMSXDeliveryCount") metódushívás való. Így akár alkalmazásból is kezelhetjük, ha ez elér egy határértéket, kezeljük másképp az üzenetet.&lt;/p&gt;&lt;p&gt;Azonban bizonyos JMS provider-ek képesek arra, hogy ezt automatikusan kezeljék. Az IBM WebSphere MQ pl. a "Backout" terminológiát használja a visszakerült üzenetre. Egy sornál meg lehet adni egy Backout threshold tulajdonságot, mely alapesetben 0, mely azt jelenti, hogy nem kezd semmit az ilyen üzenettel. Ha ezt egy nullánál nagyobb pozitív egész számra állítjuk (a sor BOTHRESH tulajdonságának állításával), akkor amennyiben az üzenet visszakerülését számláló tulajdonsát eléri ezt a küszöbértéket, az MQ az üzenetet eldobja. Azonban érdemes beállítani egy sort, ahova az üzenetet az MQ áttegye. Ezt a sor BOQNAME tulajdonságában lehet megadni, ahol a cél sor nevét kell megadni. Ez lehet pl. a dead letter queue (alapértelmezetten a SYSTEM.DEAD.LETTER.QUEUE nevet viseli), de én javaslok ezeknek az üzeneteknek egy külön sort létrehozni.&lt;/p&gt;&lt;p&gt;Így amennyiben a Backout threshold-ot 3-ra állítjuk, és a kapott üzenet hibás, rollback történik, az üzenet visszakerül a sorba. A JMS provider még kétszer megpróbálja kézbesíteni. Mivel az alkalmazásunk hibás, nincs felkészülve a kapott üzenetre, mindkétszer rollback történik. Ezt érdemes alkalmazásszinten is naplózni. Ekkor az MQ átteszi egy másik sorba az üzenetet. Amikor látjuk, a napló állományba, hogy hiba történt, vagy hogy a sorba üzenet került, kivizsgáljuk a hibát, és javítjuk az alkalmazást. Telepítés után a backout queue-ból az üzeneteket áttehetjük az eredeti sorba (pl. MQ esetén a &lt;a href="http://www-01.ibm.com/support/docview.wss?rs=977&amp;amp;context=SSKMAB&amp;amp;context=SS7J6S&amp;amp;context=SSKM8N&amp;amp;context=SSFKSJ&amp;amp;context=SSFKUX&amp;amp;context=SSWHKB&amp;amp;context=SSVLA5&amp;amp;dc=D410&amp;amp;q1=ih03&amp;amp;uid=swg24000637&amp;amp;loc=hu_HU&amp;amp;cs=utf-8&amp;amp;lang=en+hu"&gt;IH03: WebSphere Message Broker V7-Message display, test &amp;amp; performance utilities&lt;/a&gt; alkalmazással, mely SupportPac-ként ingyenesen letölthető).&lt;/p&gt;&lt;p&gt;Azonban a 7.0.1.1-es IBM WebSphere MQ-ban is van egy IBM által is ismert &lt;a href="http://www-01.ibm.com/support/docview.wss?uid=swg1IZ64620"&gt;hiba&lt;/a&gt;, mely szerint az MQ ugyan átteszi az üzenetet a backout queue-ba, de ott nem commit-olja. Ekkor azt vesszük észre, hogy a sor mélysége (queue depth) ugyan nő, de az üzenetet se browse-olni, sem kivenni nem tudjuk. Hotfix lehet, hogy az alkalmazás végzi el a megfelelő műveletet, és teszi át a hibát okozó üzenetet egy másik sorba, de akár egy külön agent is végezheti ezt. Azonban a 7.0.1.2-es verzióban már benne lesz a javítás. Mi felvettük a kapcsolatot az IBM Magyarországi Kft., és nagyon készségesek voltak, és jelezték, hogy az adott patch már létezik, és el is küldték nekünk egy napon belül. Ez tulajdonképpen a com.ibm.mq.jmqi.jar és com.ibm.mqjms.jar állományt érintette, ezek bemásolásával azonnal működött a funkció.&lt;/p&gt;&lt;p&gt;Persze más JMS provider-ek is tudják ezt, pl. a Glassfish-ben is lévő &lt;a href="https://mq.dev.java.net/"&gt;Open Message Queue&lt;/a&gt; (Sun Java System Message Queue) endpointExceptionRedeliveryAttempts tulajdonságát kell keresni, mely alapesetben 6, tehát nem kell végtelenciklusra számítani (ez oktatásnál sokszor jól jött), valamint a sendUndeliverableMsgsToDMQ tulajdonsága állítja be, hogy ezen üzenetek a dead message queue-ba kerüljenek-e. A JBoss új üdvöskéje, a &lt;a href="http://jboss.org/hornetq"&gt;HornetQ&lt;/a&gt; ezt Message Redelivery and Undelivered Messages néven ismeri, és a max-delivery-attempts, dead-letter-address tulajdonságokat kell használni. Nagyon jó ötlet, és nem értem, hogy a többi implementációnál miért nem szerepel, hogy meg lehet adni, hogy a sorba mennyi idő múlva kerüljön vissza (redelivery-delay). Ezzel csökkenteni lehet a CPU és hálózat terhelést, hiszen pl. egy nagy terhelésű rendszeren, ahol folyamatosan jönnek az üzenetek, és alkalmazásba hiba történik, csak a rengeteg üzenet újra és újra feldolgozása rengeteg erőforrást foglalhat le.&lt;/p&gt;&lt;p&gt;Egy &lt;a href="http://jtechlog.blogspot.com/2009/09/ibm-websphere-mq.html"&gt;előző postban&lt;/a&gt; már említettem, hogy hogyan kell a JMS QueueConnectionFactory-t és Destination-t (Queue) felvenni Tomcat-ben a JNDI, de most nézzük meg, hogy mi kell ahhoz, hogy ezt Spring-ből használni tudjuk.&lt;/p&gt;&lt;p&gt;A Spring definiálja a Message-Driven POJO fogalmát a Java EE Message-Driven Bean-hez (MDB) hasonlóan. Ez egy egyszerű bean, melynek implementálnia kell a javax.jms.MessageListener interfészt, és ennek onMessage(Message) metódusát fogja a Spring több szálon hívni. Ehhez az applicationContext.xml-ben a következőket kell felvenni.&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;!-- Bean az onMessage(Message) metódussal, mely megvalósítja a MessageListener interfészt --&amp;gt;
&amp;lt;bean id="messageListener" class="jtechlog.FooListener" /&amp;gt;

&amp;lt;!-- Message Listener Container --&amp;gt;
&amp;lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&amp;gt;
  &amp;lt;property name="connectionFactory"&amp;gt;
 &amp;lt;jee:jndi-lookup jndi-name="java:/comp/env/jms/myQueueConnectionFactory"/&amp;gt;
&amp;lt;/property&amp;gt;
  &amp;lt;property name="destination"&amp;gt;
 &amp;lt;jee:jndi-lookup jndi-name="java:/comp/env/jms/myQueue"/&amp;gt;
&amp;lt;/property&amp;gt;
  &amp;lt;property name="messageListener" ref="messageListener" /&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;p&gt;Természetesen ahhoz, hogy a poisoned message legyen, be kell állítanunk a tranzakciókezelést. Ehhez a DefaultMessageListenerContainer bean sessionTransacted attribútumát kell true-ra állítanunk, és ekkor lokális  tranzakciókezelés lesz megvalósítva, azaz a Spring külön tranzakciókat kezel a JMS műveleteken.&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&amp;gt;
  ...
&amp;lt;property name="sessionTransacted" value="true"/&amp;gt;
...
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;p&gt;Amennyiben azonban elosztott tranzakciókezelést akarunk használni, pl. egy tranzakcióba venni egy adatbázis és egy JMS provider műveletet, a DefaultMessageListenerContainer transactionManager attribútumát kell állítanunk.&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;bean id="transactionManager" class="org.springframework.transaction.jta.JtaTransactionManager"/&amp;gt;

&amp;lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&amp;gt;
  ...
  &amp;lt;property name="transactionManager" ref="transactionManager"/&amp;gt;
...
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;p&gt;&lt;a href="http://www.ibm.com/developerworks/websphere/library/techarticles/0405_titheridge/0405_titheridge.html"&gt;How WebSphere Application Server handles poison messages&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/jms.html"&gt;Spring Framework Reference - 21. JMS (Java Message Service)&lt;/a&gt;&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/3043347152348532729/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/04/mergezett-uzenetek.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3043347152348532729'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3043347152348532729'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/04/mergezett-uzenetek.html' title='Mérgezett üzenetek'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5721797742125265911</id><published>2010-03-08T00:40:00.005+01:00</published><updated>2014-01-05T21:27:55.069+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='open source'/><category scheme='http://www.blogger.com/atom/ns#' term='Tesztelés'/><category scheme='http://www.blogger.com/atom/ns#' term='JPA'/><title type='text'>Perzisztencia réteg tesztelése DbUnit-tal</title><content type='html'>&lt;p&gt;Frissítve: 2014. január 5.&lt;/p&gt;
&lt;p&gt;Felhasznált technológiák: DbUnit 2.4.9, Hibernate 4.3.0, HSQLDB 2.3.1, SLF4J 1.7.5, JUnit 4.11, Maven 3.0.3&lt;/p&gt;
&lt;p style="text-align: left;"&gt;Gyakran hajlamosak vagyunk a perzisztens rétegre úgy tekinteni (pl. Data Access Object
    - DAO J2EE tervezési minta), mint egy szükséges, magától érthetődő elemre, azonban ennek tesztelését sem szabad
    elfelejteni, különösen ha adatintenzív alkalmazásról, vagy egy egyszerű CRUD (create, read, update, delete)
    felületről van szó.
&lt;/p&gt;
&lt;p&gt;Azonban ez már nem a unit tesztelés témakörébe tartozik, hiszen itt nem magát a DAO osztály logikáját teszteljük,
    hanem annak hatását az adatbázisra. Így már legalább két komponens vesz részt aktívan a tesztelésben. Ezen kívül
    az adatbázis kapcsolatot is fel kell építeni, ami egy webes, vagy Java EE alkalmazás esetén JNDI-ből vett
    DataSource, vagy JPA esetén egy konténer által (alkalmazásszerver, vagy Spring) injektált EntityManager példány.
    Egyszerű teszteset írásakor azonban nincs sem JNDI, sem dependency injection, ezért fejlettebb eszközökhöz kell
    fordulnunk.
&lt;/p&gt;
&lt;p&gt;A perzisztens réteg tesztelésénél ugyanazt a módszert használjuk, mint általában a tesztelésnél, inicializáljuk
    az input adatokat, meghívjuk a tesztelendő kódot, majd ellenőrizzük az adatokat. Ezzel kapcsolatban több
    probléma is felmerül a perzisztencia esetén. Első, hogy az inicializálás jelen esetben adatbázisműveleteket
    jelent. Sőt, amennyiben egy klasszikus adatbázissal dolgozunk, lehetséges, hogy már vannak benne adatok, amelyek
    megzavarhatják a tesztet. De lehet, hogy törölni sem akarjuk őket, mert kellhetnek a teszteléshez. Második
    probléma a tesztelendő kód futtatásakor az előbb említett adatbázis kapcsolat kiépítése. Hiszen tesztelésnél ez
    teljesen másképpen történhet, mint futás közben. Harmadrészt az assert-ek megírása sem egyszerű feladat, hiszen
    lehetséges, hogy az adatbázis állapotát akarjuk ellenőrizni, akár több tábla több sorát.
&lt;/p&gt;
&lt;p&gt;Ezekben segít nekünk a &lt;a href="http://www.dbunit.org/"&gt;DbUnit&lt;/a&gt;, mely egy JUnit-ra épülő teszteléshez
    használható library. Segít nekünk az adatbázis inicializálásában (ottmaradt adatok törlése, input adatok
    betöltése), valamint a aktuális és az elvárt adatok összehasonlításában.
&lt;/p&gt;
&lt;p&gt;Ezeket un. Helper osztályokkal és metódusokkal teszi. Definiál egy IDataSet interfészt, mely több táblát
    tartalmazó adathalmaz, valamint egy ITable, mely egy tábla adatai. Azonban az IDataSet interfésznek több
    megvalósítását is biztosítja. Egyrészt természetesen lehetséges ennek betöltése adatbázisból, de lehetőség van
    arra, hogy a betöltés XML állományból (két fajta: flat, original), lekérdezésből (SQL select), Excel
    állományból, stb. történjen. Valamint különböző metódusokat biztosít ezek összehasonlítására.
&lt;/p&gt;
&lt;p&gt;Ezek felhasználásával egy tipikus teszteset a következőképpen nézhet ki. Definiálunk XML-ben egy DataSet-et, mely
    a teszt esethez szükséges pár tábla input adatait tartalmazza, és beszúrjuk ezeket. Lefuttatjuk a
    tesztelendő metódust, majd
    betöltjük XML állományból az elvárt állapotot is, és összehasonlítjuk magával az adatbázissal.
&lt;/p&gt;
&lt;p&gt;A DbUnit alapvetően a JUnit 3.x szériára épül, de lehetséges a használata a 4.x verziókban is. A DbUnit JAR
    állományán kívül az SLF4J API és valamelyik megvalósításának (Log4J, Commons Logging, java.util.logging) JAR
    állományát is be kell tenni a tesztelés classpath-jába.
&lt;/p&gt;
&lt;p&gt;Készítettem is egy példa projektet, mely &lt;a href="https://github.com/vicziani/jtechlog-dbunit"&gt;elérhető a GitHub-on&lt;/a&gt;,
    az "mvn test" parancs kiadásával indíthatóak a tesztesetek. Van egy Employee osztályt, melynek példányait le
    szeretnénk menteni és beolvasni, és egy EmployeeDao interfész, és
    ennek EmployeeDaoJpa implementációja.
&lt;/p&gt;
&lt;p style="text-align: center;"&gt;
    &lt;img src="http://yuml.me/diagram/scruffy;scale:80;/class/[Employee|-id:long;-name:String]-[EmployeeDao||+persistEmployee(Employee);+listEmployees():List]"/&gt;
&lt;/p&gt;
&lt;p&gt;A példában HSQLDB beépített adatbáziskezelőt használok. A JUnit 3.x széria esetén a JdbcBasedDBTestCase, DataSourceBasedDBTestCase
    vagy JndiBasedDBTestCase osztályokból kéne leszármaztatnuk az osztályunk, de amennyiben ez valami miatt nem
    lehetséges, mert mástól akarunk öröklődni, vagy JUnit 4-et használunk és nem szeretnénk leszármaztatni,
    elvégezhetjük az inicializációt mi magunk is. Itt hozzunk létre egy adatbázis kapcsolatot, és a JPA számára egy
    EntityManagerFactory-t. Majd töltsünk be egy XML
    állományt, mely az Employee tábla adatait tartalmazza, majd ürítsük az adatbázisból az Employee táblát, és
    szúrjuk be az előbb betöltött adatokat.
&lt;/p&gt;
&lt;pre class="brush: java"&gt;private static DataSource dataSource;
private static EntityManagerFactory emf;

private EntityManager entityManager;

private EmployeeDao employeeDao;

@BeforeClass
public static void init() throws Exception {
 Properties properties = new Properties();
 properties.put("url", "jdbc:hsqldb:mem:dbunittutor");
 properties.put("user", "sa");
 properties.put("password", "");

 dataSource = JDBCDataSourceFactory.createDataSource(properties);
 emf = Persistence.createEntityManagerFactory("dbunittutorPu");
}

@Before
public void setUp() throws Exception {
 IDatabaseConnection conn = 
  new DatabaseDataSourceConnection(dataSource);
 IDataSet data = new XmlDataSet(EmployeeDaoTest.class
  .getResourceAsStream("/employees.xml"));
 DatabaseOperation.CLEAN_INSERT.execute(conn, data);

 assertEquals(3, conn.getRowCount("employee"));

 entityManager = emf.createEntityManager();
 employeeDao = new EmployeeDaoJpa();
 ((EmployeeDaoJpa) employeeDao).setEm(entityManager);
}&lt;/pre&gt;
&lt;p&gt;A példában látható, hogy az adatbázis kapcsolatot egy IDatabaseConnection interfészt implementáló
    DatabaseDataSourceConnection osztály burkolja be, de az IDatabaseConnection interfésznek egyéb megvalósításai is
    vannak, pl. DatabaseConnection, melynek egy Connection példányt kell átadni.
&lt;/p&gt;
&lt;p&gt;A employees.xml írja le a kezdeti adatbázis tartalmát:&lt;/p&gt;
&lt;pre class="brush: xml"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
 &amp;lt;dataset&amp;gt;
 &amp;lt;table name=&amp;quot;employee&amp;quot;&amp;gt;
  &amp;lt;column&amp;gt;id&amp;lt;/column&amp;gt;
  &amp;lt;column&amp;gt;name&amp;lt;/column&amp;gt;
  &amp;lt;row&amp;gt;
   &amp;lt;value&amp;gt;1&amp;lt;/value&amp;gt;
   &amp;lt;value&amp;gt;name1&amp;lt;/value&amp;gt;
  &amp;lt;/row&amp;gt;
  ...
 &amp;lt;/table&amp;gt;
&amp;lt;/dataset&amp;gt;&lt;/pre&gt;
&lt;p&gt;A következő teszt eset a listEmployees() metódust teszteli.&lt;/p&gt;
&lt;pre class="brush: java"&gt;@Test
public void testListEmployees() {
    List&amp;lt;Employee&amp;gt; employees = employeeDao.listEmployees(1, 2);
    assertEquals(2, employees.size());
    assertTrue("A name prefixszel kell kezdodnie", 
        employees.get(0).getName().startsWith("name"));
}
&lt;/pre&gt;
&lt;p&gt;A következő metódus a mentést ellenőrzi, de úgy, hogy az adatbázis elvárt állapotát egy XML-ből tölti be, és
    összehasonlítja az adatbázis tényleges állapotával.
&lt;/p&gt;
&lt;pre class="brush: java"&gt;@Test
public void testListEmployees() {
    Employee employee = new Employee("name4");
    employeeDao.persistEmployee(employee);

    ITable tableDb = new DatabaseDataSourceConnection(ds)
        .createDataSet().getTable("employee");
    ITable tableXml = new XmlDataSet(EmployeeDaoTest.class
        .getResourceAsStream("/expectedEmployees.xml"))
        .getTable("employee");

    new DbUnitAssert().assertEquals(tableXml, tableDb);
}&lt;/pre&gt;
&lt;p&gt;Ehhez a expectedEmployees.xml már ki van egészítve a beszúrt Employee adataival.&lt;/p&gt;
&lt;p&gt;Ez lehet, hogy elsőre tökéletesen lefut, de több probléma is van vele. Második futtatásnál már hibát jelezhet a
    teszteset. A hiba szövege nagyon beszédes, leírja, hogy melyik tábla hanyadik sorában van az eltérés, és kiírja
    az aktuális és az elvárt értéket is. A hiba ott lehet, hogy egyrészt nem biztos, hogy a sorokat a megfelelő
    sorrendben kapjuk vissza. Ehhez van a SortedTable osztály, mely a dekorátor tervezési mintát valósítja meg.
    Ezzel valamelyik oszlopra lehet rendezni. Másrészt az id kiadása is egy szekvencia alapján történik, így erre
    sem kell ellenőrizni. Erre használjuk a DefaultColumnFilter osztályt, mellyel meg lehet mondani, hogy mely
    oszlopokat akarunk figyelembe venni az összehasonlításkor. Így a javított kód a következő.
&lt;/p&gt;
&lt;pre class="brush: java"&gt;ITable tableDb = new SortedTable(DefaultColumnFilter
    .includedColumnsTable(new DatabaseDataSourceConnection(ds)
    .createDataSet().getTable("employee"), new String[]{"name"}), 
    new String[]{"name"});

ITable tableXml = new SortedTable(DefaultColumnFilter
    .includedColumnsTable(new XmlDataSet(EmployeeDaoTest.class
    .getResourceAsStream("dataset_result.xml")).getTable("employee"),
    new String[]{"name"}), new String[]{"name"});
&lt;/pre&gt;
&lt;p&gt;Ez mindkét táblán szűrést és rendezést is végez, és ezután már össze lehet hasonlítani őket.&lt;/p&gt;
&lt;p&gt;Az ITable interfésznek egyéb Helper metódusai is vannak, melyeket érdemes használni, mert megkönnyítik a
    programozást. Egyrészt a getRowCount() metódus visszaadja a sorok számát, másrészt a getValue(0, "name")
    visszaadja a 0. sor name oszlopának értékét.
&lt;/p&gt;
&lt;p&gt;A perzisztens réget tesztelésekor a következő tanácsokat érdemes betartani:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Minden fejlesztő kapjon saját adatbázist, vagy használjunk embedded adatbázist. Ezzel kikerülhető az, hogy
        egyszerre többen használják, így összekeverednek az adatok.
    &lt;/li&gt;
    &lt;li&gt;Két stratégiát választhatunk teszteléskor: vagy minden teszteset után visszagörgetünk (rollback), vagy
        minden teszteset előtt inicializáljuk az adatbázist. Az elsőt használják többen is, de én a másodikat
        javaslom, mert mikor először próbálkoztam az első megközelítéssel, a teszt esetek sikeresen lefutottak, a
        kivétel pont a commit műveletnél jött. Az utóbbi esetében viszont szintén érdemes megfogadni két tanácsot.
        Egyrészt kis adathalmazokkal dolgozzunk, hogy a teszt lefutása gyors legyen. Másrészt nem kell a teszteset
        lefutása után cleanup, hiszen a teszt eseteket úgy kell megírni, hogy az inicializálás (@Before) úgy állítsa
        be az adatbázist, hogy azon azonnal le lehessen futtatni a tesztesetet. A tesztesetek között sorrendi
        függőség, állapotátmenet ne legyen lehetséges.
    &lt;/li&gt;
    &lt;li&gt;Amennyiben read-only adataink is vannak, melyet minden teszt eset használ, javasolt azokat osztályszintű
        inicializáláskor betölteni, szintén a gyorsítás végett.
    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Amennyiben a DataSource JNDI-ből való lekérését is tesztelni akarjuk, használhatunk stub/mock JNDI Context
    implementációt.
&lt;/p&gt;
&lt;p&gt;A DbUnit Ant-ból is használható, és Maven plugin-je is van, melynek goal-jai képesek integrációs tesztelés esetén
    az adatbázis inicializációjára, adatbázis adatainak xml-be exportálására, valamint DataSet-ek
    összehasonlítására.
&lt;/p&gt;
&lt;p&gt;Érdemes még megnézni az
    &lt;a href="http://sqlunit.sourceforge.net/"&gt;SQLUnit&lt;/a&gt;
    projektet is, melynek érdekessége, hogy a tesztesetek XML-ben van leírva, és szintén a perzisztencia
    tesztelésére szolgál. Inkább javasolt pl. tárolt eljárások tesztelésére. Sajnos fejlesztését befejezték, utolsó
    release 2006. júniusában volt.
&lt;/p&gt;
&lt;p&gt;Spring használata esetén kötelező olvasmány a &lt;a
        href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#testing"&gt;
    Reference Testing fejezete&lt;/a&gt;, különösen a tranzakciókezelés részre.
&lt;/p&gt;
&lt;p&gt;JPA esetén javasolt az Apress kiadásában készült Pro EJB 3 Java Persistence API könyv, melynek 12. fejezet a JPA
    teszteléséről szól. Itt a tesztelés különböző szintjeit tárgyalja. Első szint, mikor csak az entitást, mint
    POJO-t teszteled. Második szinten már a DAO-t teszteled, de adatbázis kapcsolat nélkül, stub/mock
    EntityManager-rel. Az integrációs teszt során kötöd össze a DAO-t ténylegesen az adatbázissal. Itt lehet
    trükközni azzal, hogy a teszteset futtatásakor honnan veszel EntityManager példányt (pl. factory), illetve felül
    lehet írni a teszteset futtatásakor az entitáson elhelyezett annotációkat xml konfigurációval. Különösen
    érzékeny terület itt is a tranzakciókezelés.
&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/5721797742125265911/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/03/dbunit.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/5721797742125265911'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/5721797742125265911'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/03/dbunit.html' title='Perzisztencia réteg tesztelése DbUnit-tal'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2956340460285563720</id><published>2010-02-20T01:11:00.008+01:00</published><updated>2011-08-08T22:48:34.160+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Library'/><category scheme='http://www.blogger.com/atom/ns#' term='Tesztelés'/><title type='text'>Mockito</title><content type='html'>&lt;p&gt;A héten JMS-en kommunikáló alkalmazást kellett tesztelnem. Azt kellett ellenőrizni, hogy a sorokon beérkező XML formátumú üzeneteket megfelelőképpen képes fogadni, feldolgozni, ellenőrizni. A választ szintén JMS-en küldi el. Ehhez nem akartam valami JMS provider (pl. WebSphre MQ) telepíteni, helyette csak a fogadást, feldolgozást és ellenőrzést végző modult (osztályt) szerettem volna teszteseteknek alávetni. A környezet Spring, a teszteseteket JUnit 4-ben implementáltam.&lt;/p&gt;&lt;p&gt;Használhattam volna a Mockrunner eszközt, mely egy teljes JMS provider-t szimulál, azaz a JMS API-t stub objektumokkal (lásd később) valósítja meg. Ez gyakorlatilag egy olyan megvalósítás, mely a Destination objektumokat (Queue, Topic) List-ekkel valósítja meg, melyekbe a JMS API hívásokkal lehet üzeneteket tenni, de vannak külön metódusok, melyekkel aztán ezeket ellenőrizni lehet a tesztesetben.&lt;/p&gt;&lt;p&gt;Ez azonban már inkább integrációs teszt lett volna, és nem az üzenetkezelést akartam tesztelni, csupán az üzeneteket feldolgozó logikát.&lt;/p&gt;&lt;p&gt;A JMS műveletek már külön osztályba voltak csoportosítva (JmsCommService), elválasztva a feldolgozástól, így csupán ezt kellett lecserélnem. A Spring-hez illeszkedve ezen osztály egy interfészt valósított meg (CommService), melyre a tesztelendő osztályom (DefaultProcessService implements ProcessService) dependency injection-nel hivatkozott. A komponensek ezen laza csatolása lehetővé teszi (hiszen az egyik csak a másiknak az interfészét ismeri), hogy a konténernek (jelen esetben a pehelysúlyú Spring) megadjuk, hogy JUnit tesztelésnél ne az alapértelmezett implementációt töltse be, hanem helyette egy tesztelésre előkészített osztályt.&lt;/p&gt;&lt;p&gt;Használhattam volna un. stub osztályt, ami az interfésznek (CommService) egy saját implementációja, és az adott tesztesetre van felkészítve. Ennek viszont több hátulütője is van. Egyrészt bizonyos logikát külön osztályba kell szervezni, így a teszt kód nem csak a JUnit tesztben van, így kevésbé átlátható. Valamint tesztesetenként (vagy legalábbis bizonyos csoportonként) különböző stub osztályokat kellett volna létrehoznom. Ekkor, ha egy interfésznek sok metódusa van, javasolt absztrakt Adapter osztályt készíteni a Swing-hez hasonlóan (nincs köze az adapter tervezési mintához), mely üres metódusokkal implementálja az interfészt, és ebből kell csak leszármaztatni, és a teszteléshez szükséges metódusokat implementálni.&lt;/p&gt;&lt;p&gt;Az "The art of unit testing" könyv megkülönbözteti a stub objektumtól a mock objektum fogalmát, mely a teszteset során azt ellenőrzi, hogy az adott objektummal történt-e tényleges interakció. A stub-nál annyival több, hogy saját magára is állapít meg feltételeket, melyeknek a teszt során teljesülnie kell, pl. milyen metódusai lettek meghívva, hányszor, milyen paraméterekkel, stb.&lt;/p&gt;

&lt;p&gt;Martin Fowler oldalán ennél &lt;a href="http://www.martinfowler.com/bliki/TestDouble.html"&gt;több definíció is található&lt;/a&gt;. Gerard Meszaros a "XUnit Test Patterns" könyvben ezen segéd objektumokat "Test double" gyűjtőnéven illeti, és a következő kategóriákba sorolja: dummy, fake, stub, spy, mock.&lt;/p&gt; 

&lt;p&gt;A Mockrunner framework elnevezéséből is látszik, hogy a fogalmakat gyakran keverik. A Mockrunner a JMS API interfészeit stub-olja. Ugyanígy pl. a spring-test modul korábbi neve spring-mock volt, pedig az is a Java EE interfészeit stub-olja.&lt;/p&gt;&lt;p&gt;A stub/mock objektumokat használhatjuk, ha&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Az eredeti objektum állapota nem megjósolható, külső tényezőktől függő&lt;/li&gt;&lt;li&gt;Az eredeti objektum felépítése bonyolult, lassú, sok erőforrás igénylő művelet&lt;/li&gt;&lt;li&gt;Az eredeti objektumok külső erőforrásokhoz fér hozzá, melyek állapotát nehéz befolyásolni. Pl. hálózati kapcsolatot használó objektum esetén mock objektum szimulálhatja a hálózat megszakadást, stb.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Mock framework használatával megtakaríthatjuk, hogy az interfészeket magunk implementáljuk. Ezt megteszi a framework, az általunk megadott szabályok alapján.
A két legelterjedtebb mock framework az EasyMock és jMock. A &lt;a href="http://mockito.org/"&gt;Mockito&lt;/a&gt; framework íróját is ezek ihlették, de ezeknél is egyszerűbb API-val rendelkező eszközt készített. Az előbbieket expect-run-verify library-knek nevezi. Azoknál először definiálni kell, hogy mit vársz el, majd lefuttatni a tesztet, és ellenőrizni az elvártakat. A Mockito-nál ezzel szemben a futtatás előtt stub-bolsz (adod meg, hogy hogy legyen a metódus implementálva), és az után teszel fel kérdéseket, azaz ellenőrzöl.&lt;/p&gt;&lt;p&gt;Az alkalmazás egyszerűsített osztálydiagramja az alábbi ábrán látható.&lt;/p&gt;&lt;p&gt;&lt;img src="http://yuml.me/diagram/scruffy/class/[CommService%7C%7CsendMessage(String%20text)]%5E-.-[JmsCommService],%20[ProcessService%7C%7CprocessMessage(TextMessage%20message)]%5E-.-[DefaultProcessService]" alt="Osztálydiagram" style="display: block; margin-top: 0px; margin-right: auto; margin-bottom: 10px; margin-left: auto; text-align: center; cursor: pointer; width: 533px" /&gt;&lt;/p&gt;&lt;p&gt;A DefaultProcessService kapja az üzenetet ("ping"), és meghívja a CommService sendMessage() metódusát, átadva egy szöveges üzenetet ("pong").&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Amennyiben a processService.processMessage() metódus egy String-et várna, egyszerű lenne a teszt metódusunk.&lt;/p&gt;&lt;pre class="brush: java"&gt;...
import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

public class ProcessServiceTest {

@Test
public void testProcessMessage() throws Exception {
 // Tesztelendő objektum előkészítése
 DefaultProcessService processService = new DefaultProcessService();

 // Mock objektum előállítása
 CommService commService = mock(CommService.class);

 // Mock objektumra hivatkozás beállítása
 processService.setCommService(commService);

 // Futtatás
 processService.processMessage("ping");

 // Ellenőrzés
 verify(commService).sendMessage(eq("pong"));
}

}&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Hogy a kód könnyebben olvasható legyen, statikusan importálva vannak a Mockito metódusai. Az egyszerűség kedvéért nem a Spring SpringJUnit4ClassRunner osztálya futtatja a tesztesetet, hanem szerepel benne a DefaultProcessService osztály példányosítása. A teszteset a CommService interfészből készít egy mock objektumot, és erre állítja a DefaultProcessService hivatkozását. Aztán lefuttatja a processMessage metódust. Ez a háttérben meghívja a a mock DefaultProcessService sendMessage() metódusát. Ezt követi az ellenőrzés. Ez azt mondja, hogy a hívás során meg kellett hívni a CommService sendMessage() metódusát úgy, hogy a paraméternek meg kellett egyeznie a "pong" szöveggel.&lt;/p&gt;&lt;p&gt;Nézzük a tesztesetet, ha a processMessage() TextMessage paramétert vár.&lt;/p&gt;&lt;pre class="brush: java"&gt;...
import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

public class ProcessServiceTest {

@Test
public void testProcessMessage() throws Exception {
 // Eredeti objektum példányosítása
 DefaultProcessService processService = new DefaultProcessService();

 // Mock objektum előállítása
 TextMessage message = mock(TextMessage.class);
 CommService commService = mock(CommService.class);

 // Mock objektumra hivatkozás beállítása
 processService.setCommService(commService);

 // Stub-bolás
 when(message.getText()).thenReturn("ping");

 // Futtatás
 processService.processMessage(message);

 // Ellenőrzés
 verify(commService).sendMessage(eq("pong"));
}

}&lt;/pre&gt;&lt;p&gt;Itt a teszteset a TextMessage interfészből is csinál egy mock objektumot, és ezután stub-bolja azt, méghozzá úgy, hogy amennyiben meghívják a getText() metódusát, adja vissza a "ping" String-et. &lt;/p&gt;&lt;p&gt;Amennyiben a sendMessage() metódus hívásának paraméterét egyéb ellenőrzéseknek is alá akarjuk vetni, az ArgumentCaptor-t kell használnunk.&lt;/p&gt;&lt;pre class="brush: java"&gt;ArgumentCaptor&lt;string&gt; argument = ArgumentCaptor.forClass(String.class);
verify(commService).sendMessage(argument);
String param = argument.getValue();
assertEquals("pong", param);&lt;/string&gt;&lt;/pre&gt;&lt;p&gt;A Mockito ezen kívül rengeteg egyéb dolgot is tud, konkrét osztályt is tud mock-olni, a when feltételben a paraméter értékétől függően adni vissza eredményt, a hívások számát és sorrendjét ellenőrizni, valamint akár nem mock-olt valós objektumok hívásait is lehallgatni (Spy), stb.&lt;/p&gt;&lt;p&gt;A mock objektumoknak persze hátulütőik is akadnak, könnyen beleeshetünk a csapdába, hogy nem black box tesztelést végzünk az interfész alapján, hanem az implementáció alapján nézzük meg, hogy melyik metódust kellett volna hívni, és hányszor. Így egy refaktoring után hibára futhatnak a teszteseteink, és ilyenkor azokat is karban kell tartani. Gyakorlatilag nem az objektum viselkedését teszteljük, hanem annak kölcsönhatásait más objektumokkal.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/2956340460285563720/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/02/mockito.html#comment-form' title='10 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2956340460285563720'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2956340460285563720'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/02/mockito.html' title='Mockito'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>10</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3404280541226145466</id><published>2010-02-07T12:13:00.004+01:00</published><updated>2012-11-16T12:42:38.940+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Utils'/><category scheme='http://www.blogger.com/atom/ns#' term='infrastruktúra'/><title type='text'>Kedvenc Java eszközök</title><content type='html'>&lt;p&gt;Az előző post-ban azon kedvenc Java library-ket mutattam be, melyeket gyakran használok webes alkalmazások fejlesztése közben. A mostaniban azon Java-s eszközöket szeretném bemutatni, melyek ugyan az alkalmazás futása közben nem kellenek, de nagyon hasznos segítséget nyújtanak a fejlesztés közben.&lt;/p&gt;&lt;p&gt;A megjegyzések között ti is több hasznos library-t írtatok, melyeket ezúttal is köszönök, és erre most is szeretnélek benneteket bátorítani, hogy írjátok ide kedvenc kipróbált és bizonyított eszközeiteket.&lt;/p&gt;&lt;p&gt;Most is megpróbálom ezeket hasznosság szerint sorrendbe szedni. Nem térek ki a tervezéshez használt eszközökre, valamint a különböző adatbázisokra, és hozzájuk kapcsolódó egyéb eszközökre.&lt;/p&gt;&lt;p&gt;&lt;a href="http://netbeans.org/"&gt;NetBeans&lt;/a&gt;: Régebben azért választottam, mert mindent tartalmazott, ami a fejlesztéshez szükséges volt, nagyon jó wizard-okkal rendelkezett. Az &lt;a href="http://www.eclipse.org/"&gt;Eclipse&lt;/a&gt;-et sokat kellett konfigurálni, hogy minden működjön, de ha időt szántál rá, sokkal jobban személyre tudtad szabni. Ez az Eclipse package-ek óta már nem így van (pl. a legfrissebb Galileo), az is tartalmazza az egymással kompatibilis, a fejlesztéshez szükséges legtöbb plugint. Régebben &lt;a href="http://www.oracle.com/technology/products/jdev/index.html"&gt;JDeveloper&lt;/a&gt;-t használtam, azt is nagyon szerettem, a GUI szerkesztője még máig is a legjobb, és ingyenes.&lt;/p&gt;&lt;p&gt;&lt;a href="http://ant.apache.org/"&gt;Apache Ant&lt;/a&gt;: A klasszikus build tool. Valahogy nem tudtak még a &lt;a href="http://maven.apache.org/"&gt;Maven&lt;/a&gt; hasznosságáról meggyőzni, de ez csak környezeti sajátosság lehet. Egyszerűen nem olyan bonyolultak a projektjeink, nem dolgozunk rajta annyian, nincs akkora szervezet, infrastruktúra, nem fejlesztünk open source eszközöket, stb. Az Ant azért már szerzett néhány bosszúságot, mert nem könnyű elsajátítani a deklaratív gondolkodását. Azonban pont most vezetjük be nem csak build folyamatra, hanem általánosabb folyamatirányításra, és meglepetésre a kiterjeszthetőségének hála remekül megállja a helyét. Erről szintén &lt;a href="http://vicziani.github.com/artifacts/ant.pdf"&gt;cikket&lt;/a&gt; írtam.&lt;/p&gt;&lt;p&gt;&lt;a href="http://tomcat.apache.org/"&gt;Apache Tomcat&lt;/a&gt;: Sokak szerint nem a leggyorsabb, és nem is a legjobb web konténer (servlet és JSP támogatás), de a legelterjedtebb, így bármi problémám van vele, azonnal találok rá valami megoldást a weben. Nagyon bevált, egyelőre nincs szükségem olyan funkcionalitásra, melyet nem biztosítana. Ahogy az előző post-omban írtam, nem bízom az alkalmazásszerverekben.&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.varaneckas.com/jad"&gt;JAD&lt;/a&gt;: Egyszerű, jól használható, parancssori Java Decompiler. Fejlesztése megszűnt, oldala eltűnt és már csak egy mirror van fenn.&lt;/p&gt;&lt;p&gt;&lt;a href="http://jakarta.apache.org/jmeter/"&gt;Apache JMeter&lt;/a&gt;: Terhelés tesztre kiváló, de ha csak gyorsan össze kell dobni egy integrációs teszt esetet, vagy akár csak monitorozni kell egy alkalmazást, a JMeter erre alkalmas, és könnyen bővíthető.&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.soapui.org/"&gt;SOAPUi&lt;/a&gt;: Web szolgáltatások tesztelésére remek eszköz. Nem csak web szolgáltatások felderítésére képes WSDL alapján, majd azok meghívására, hanem képes mock web szolgáltatásokat is biztosítani, ahol a konstans választ mi adhatjuk meg SOAP XML formátumban.&lt;/p&gt;&lt;p&gt;&lt;a href="https://hudson.dev.java.net/"&gt;Hudson&lt;/a&gt;: Continuous integration eszköz. Viszonylag új szerzemény, amire szükségünk volt, még mind tudta, mint release-ek kiadása, vagy telepítés előkészítése a teszt és éles környezetekre. Mivel a build eszközünk az Ant, illesztése könnyű volt.&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.atlassian.com/software/jira/"&gt;Atlassian JIRA&lt;/a&gt; és &lt;a href="http://www.atlassian.com/software/confluence/"&gt;Atlassian Confluence&lt;/a&gt;: Az előbbi egy issue tracker, az utóbbi egy wiki. Bár kereskedelmi alkalmazások, annyira szervesen beépültek a fejlesztési folyamatainkba, hogy nem hagyhatom ki őket. Nyílt forráskódú termékek fejlesztésekor ingyenesen használható.&lt;/p&gt;&lt;p&gt;&lt;a href="http://subversion.tigris.org/"&gt;Subversion&lt;/a&gt; és &lt;a href="http://tortoisesvn.tigris.org/"&gt;TortoiseSVN&lt;/a&gt;: Nem szorosan ide tartozik, azért került a végére. Verziókezelésre kizárólag ezt használom. A NetBeans is támogatja, de annak csak azt a képességét használom ki, hogy a forráskód szerkesztésekor a margón mutatja, hogy mi változott az Subversion-ben tárolt állományokhoz képest. A többi műveletet a TortoiseSVN-ből végzem. (Egy-két IDE-ben szerzett rossz tapasztalat után.) A &lt;a href="http://git-scm.com/"&gt;GIT&lt;/a&gt;-tel is szemezgetek, de a jelenlegi projektjeink mérete és a lineáris fejlesztési menete miatt még biztos nem váltanék.&lt;/p&gt;&lt;p&gt;Általam használt további, nem csak Java fejlesztéshez használt alkalmazásaimat is &lt;a href="http://vicziani.github.com/alkalmazasok.htm"&gt;összegyűjtöttem itt&lt;/a&gt;.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/3404280541226145466/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/02/kedvenc-java-eszkozok.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3404280541226145466'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3404280541226145466'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/02/kedvenc-java-eszkozok.html' title='Kedvenc Java eszközök'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2512148931421846139</id><published>2010-01-27T23:42:00.004+01:00</published><updated>2012-11-16T12:45:13.900+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='open source'/><category scheme='http://www.blogger.com/atom/ns#' term='Library'/><title type='text'>Kedvenc Java library-k</title><content type='html'>&lt;p&gt;Ebben a post-ban szeretném felsorolni azon Java library-ket, keretrendszereket, melyeket legszívesebben használok különböző webes alkalmazások fejlesztése közben. Ezekkel rengeteg tapasztalat gyűlt fel, és mindenkinek bátran ajánlhatom őket. Érdekes lesz visszanézni egy-két év múlva, hogy hol tartanak. Remélem ti is merítetek belőle hasznos ötleteket, és a véleményeteket is várom, hogy milyen eszközöket használtok, az általam használt stack mely elemeit lenne érdemes kicserélni Az eszközöket tetszési sorrendben írom, a kedvenceim elől, azok, melyekkel kényelmes fejleszteni, amelyekben keveset csalódtam.&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.springsource.org/about"&gt;Spring&lt;/a&gt;: Kvázi szabvány keretrendszer dependency injection-nel, inversion of control-lal. A J2EE kiváltására találták ki, annak bonyolultságának mellőzésével. Annak szolgáltatásait nagyrészt biztosítja (talán néha a lokális transzparencia hiányzik egyedül). Ugyan a Java EE 5 már sokkal egyszerűbb, a Spring-ből rengeteg elemet át is emelt, mégis a lassú szabványosítási folyamat miatt a Spring már elhaladt mellette. Legnagyobb előnye, hogy apró lépésekben is bevezethető (pl. több éves projektben pár nap alatt vezettük be a perzisztencia rétegbe), és nem igényel alkalmazásszervert, melyekkel rengeteg rossz tapasztalatom volt. Számomra az egyik legfontosabb szempont fejlesztés közben a nagyon rövid fejlesztési ciklus, azaz hogy egy módosítás max. 30 másodpercen belül kipróbálható legyen. JDBC esetén nagyon hasznos a JDBC abstraction layer, JPA estén inkább a standart JPA API-t használjuk.&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.springsource.org/about"&gt;Spring MVC&lt;/a&gt;: Webes keretrendszer, mely elég magas szintű, értelmes default konfigurációkkal rendelkező, annotációkkal konfigurálható a gyors haladás érdekében, de elég alacsony szintű is, ha kell, pl. a request, session, stb. objektumok is könnyen elérhetőek. Összevetve a JSF és &lt;a href="http://wicket.apache.org/"&gt;Wicket&lt;/a&gt; keretrendszerekkel talán kevésbé objektumorientált, kevésbé komponens alapú, de sajnos olyan tapasztalataink voltak az eddigi megrendelőkkel, hogy képesek a keretrendszerek határait feszegetni. A Spring MVC-vel mindent egyszerűen meg lehet csinálni, amire az amúgy silány HTTP protokoll és HTML formátum, és társai lehetőséget biztosítanak. E mellett a &lt;a href="http://struts.apache.org/"&gt;Struts&lt;/a&gt;-ot is szeretem, de ez jobban illeszkedik a Spring-hez. Ami külön tetszik, hogy sokszor voltam úgy, hogy dokumentáció nélkül elgondoltam, hogy így kéne működnie, kipróbáltam, és tényleg.&lt;/p&gt;&lt;p&gt;&lt;a href="http://logging.apache.org/log4j/"&gt;Apache Log4J&lt;/a&gt;: Apró és megbízható segítség a naplózáshoz. Ugyan jönnek a trónkövetelők, mint a &lt;a href="http://logback.qos.ch/"&gt;Logback&lt;/a&gt;, &lt;a href="http://www.slf4j.org/"&gt;SLF4J&lt;/a&gt;, azonban nem tudok elképzelni olyan funkciót, amiért váltanék, és még nem is annyira elterjedtek. Erről &lt;a href="http://vicziani.github.com/artifacts/log4j.pdf"&gt;cikket&lt;/a&gt; is írtam.&lt;/p&gt;&lt;p&gt;&lt;a href="http://velocity.apache.org/"&gt;Apache Velocity&lt;/a&gt;: Sablonozásra használjuk. Régebben ez volt a view réteg, de most inkább a JSP, mely jobban megköti az ember kezét. Nem csak alkalmazásokban használjuk, hanem pl. ügyfél számára interfész prototípus, sőt dokumentáció generálására is. Okosabb a &lt;a href="http://freemarker.org/"&gt;FreeMarker&lt;/a&gt;, de nem volt még szükség a funkcióira. Erről szóló &lt;a href="http://vicziani.github.com/artifacts/velocity.pdf"&gt;cikk&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;a href="http://lucene.apache.org/java/docs/"&gt;Apache Lucene&lt;/a&gt;: Most már mindegyik webes alkalmazásban szükség van a tartalom hatékony keresésére, erre tökéletes. Erről &lt;a href="http://vicziani.github.com/artifacts/lucene.pdf"&gt;cikket&lt;/a&gt; is írtam.&lt;/p&gt;&lt;p&gt;&lt;a href="http://static.springsource.org/spring-security/site/index.html"&gt;Spring Security&lt;/a&gt;: Autorizációra és autentikációra kizárólagosan ezt használjuk. Erről nemrég írtam a &lt;a href="http://jtechlog.blogspot.com/2010/01/spring-security.html"&gt;Spring Security&lt;/a&gt; post-omban.&lt;/p&gt;&lt;p&gt;JSP, JSTL: Szabványos view réteg, aminek ugyan vannak hiányosságai, de rákényszerít a helyes MVC használatra, és az IDE-k is ezt támogatják a legjobban.&lt;/p&gt;&lt;p&gt;&lt;a href="http://displaytag.sourceforge.net/1.2/"&gt;Display tag library&lt;/a&gt;: JSP tag library táblázatok megjelenítésére. Ami kellett, azt még mind tudta. Akár AJAX bővítménye is van. Van &lt;a href="http://jtechlog.blogspot.com/2008/11/tbb-tblzat-egy-oldalon-display-tag-gel.html"&gt;régebbi post&lt;/a&gt; erről is.&lt;/p&gt;&lt;p&gt;&lt;a href="http://www.junit.org/"&gt;JUnit&lt;/a&gt;: Unit test-ek fejlesztésére, az elterjedtsége miatt. A &lt;a href="http://testng.org/doc/index.html"&gt;TestNG&lt;/a&gt; is rendkívül szimpatikus, de egyelőre nincs olyan funkció, melyért váltanék, kockáztatva a támogatottságot.&lt;/p&gt;&lt;p&gt;&lt;a href="http://directwebremoting.org/dwr/index.html"&gt;Direct Web Remoting&lt;/a&gt;: Kellően alacsony szintű bridge a Java és a JavaScript világ között, AJAX-os funkciók megvalósítására.&lt;/p&gt;&lt;p&gt;&lt;a href="http://jquery.com/"&gt;jQuery&lt;/a&gt;: Bár alapjában véve gyűlölöm a JavaScript-et, ez a library nagyon hasznos segítségnek bizonyult. A &lt;a href="http://www.prototypejs.org/"&gt;Prototype&lt;/a&gt; annyira nem hatott meg.
&lt;/p&gt;&lt;p&gt;&lt;a href="http://jasperforge.org/projects/jasperreports"&gt;JasperReports&lt;/a&gt; és &lt;a href="http://jasperforge.org/projects/ireport"&gt;iReport&lt;/a&gt;: Riport generálásra használatos library és NetBeans alapú riport tervező eszköz. No ez már jó pár napom megkeserítette, de még mindig ez a legszimpatikusabb. Az XSL-FO általában ágyúval verébre, és iszonyatosan lassú és erőforrás igényes. A másik versenyző a &lt;a href="http://www.eclipse.org/birt/phoenix/"&gt;BIRT&lt;/a&gt;, amivel nem sok tapasztalatom van, és amúgy is az Eclipse ökoszisztéma tagja.&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.hibernate.org/"&gt;Hibernate&lt;/a&gt;: Az egyik legelterjedtebb ORM megvalósítás. Történelmi okok miatt nem váltottunk az EclipseLink-re, de nem vagyok elkötelezett híve, mert sok nehéz pillanatot szerzett. Kizárólag JPA provider-ként használom.&lt;/p&gt;&lt;p&gt;A listából is látható, hogy olyan eszközöket igyekszem választani, melyek vagy szabványosak, vagy kvázi szabványosak. Egy konkrét problémát célozzanak meg, és elég egyszerűek ahhoz, hogy probléma esetén akár a forrását tanulmányozva, vagy debug-olva előrébb lehessen jutni (az nyílt forráskódú szoftverek legnagyobb előnye, ha már a dokumentációjuk hagy némi kívánnivalót maga után). Jelentős forrásanyag (tutorial, projekt reports, dokumentáció, példakódok, cikkek, könyvek), felhasználótábor (hírek, fórum, levelezési lista, issue tracker) legyen körülötte. Külön fontos, hogy nagyon egyszerűen, lépésekben bevezethető, könnyen tanulható legyen, hogy hamar sikerélményt biztosítson. És szép legyen a weboldala.&lt;/p&gt;&lt;p&gt;A következő post-ban az általam leggyakrabban használt Java-s tool-okat, eszközöket fogom bemutatni.&lt;/p&gt;&lt;p&gt;Ti milyen library-ket, keretrendszereket javasoltok? Főleg olyanok érdekelnek, melyeket éles projektben használtatok, beváltak, újabb projektekben is bevetnétek, és több hónap után is szívesen nyúltok hozzá vissza.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/2512148931421846139/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/01/kedvenc-java-library-k.html#comment-form' title='8 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2512148931421846139'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2512148931421846139'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/01/kedvenc-java-library-k.html' title='Kedvenc Java library-k'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>8</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-291084979601166581</id><published>2010-01-18T23:35:00.007+01:00</published><updated>2010-09-18T00:24:39.080+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Struts'/><title type='text'>Struts felviteli es szerkesztő képernyő</title><content type='html'>&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_czKgycLvmNo/S1TjWS96FJI/AAAAAAAAE5U/eXVaLJa5wZ8/s1600-h/struts_szekvencia.png"&gt;&lt;/a&gt;&lt;p&gt;A legtöbb projektünkben ugyan Spring MVC-t használunk, de van egy-két régebbi alkalmazás, melyet Struts-ban (még nem Struts 2-ben) fejlesztünk.
Gyakran vissza kell hozzá nyúlni, és mindig keresgélnem kell, hogy hogyan is kell a képernyőket felépíteni, ígyhát inkább leírom ide, hátha másnak is hasznára válik.&lt;/p&gt;&lt;p&gt;Ezen probléma ismerős lehet más webes keretrendszereknél is, és lehetséges, mint pl. a Spring MVC esetén, hogy sokkal szofisztikáltabb megoldást adnak rá, mégis érdemes az alapelvekkel tisztában lenni. A bonyolultabb, komponens alapú keretrendszereknél, mint JSF vagy Wicket, már kevésbé kell ennyire a kérésekkel/válaszokkal foglalkozni.&lt;/p&gt;&lt;p&gt;Egy CRUD (Create-Read-Update-Delete) alkalmazást tipikus képernyőfolyama, mikor a felhasználó a listázó képernyőről indul. Itt vagy új tételt vesz fel, vagy kiválaszt egy tételt módosításra, vagy töröl egy tételt. Az első két esetben mindenképp megjelenik egy űrlap (form), az első esetben üresen, módosítás esetén már feltöltve adatokkal. Az űrlapot elküldve megtörténik a mentés, visszakerül a felhasználó a listázó képernyőre, valamilyen üzenettel. &lt;/p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_czKgycLvmNo/S1TjGlRd9LI/AAAAAAAAE5M/c93rR0NfguI/s1600-h/struts_kepernyok.png"&gt;&lt;img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 87px;" src="http://2.bp.blogspot.com/_czKgycLvmNo/S1TjGlRd9LI/AAAAAAAAE5M/c93rR0NfguI/s320/struts_kepernyok.png" border="0" alt="" id="BLOGGER_PHOTO_ID_5428213153112388786" /&gt;&lt;/a&gt;&lt;p&gt;A&lt;a href="http://wiki.apache.org/struts/DataEntryForm"&gt; szakirodalom&lt;/a&gt; ezt DataEntryForm-nak nevezi. Két fázisból áll, ahol az első fázis az űrlap megjelenítése (render/output/setup phase), a második fázis az elküldött űrlap feldolgozása (post/submit phase). Az első fázis az alapján dönti el, hogy új felvitel, vagy módosítás van, hogy URL paraméterben kapott-e valamilyen tétel azonosítót (id). Nézzük a felviteli/módosító képernyőt, hogy hogyan érdemes megvalósítani.&lt;/p&gt;&lt;p&gt;A következő követelményeket sorolhatjuk fel:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Az oldal http GET-re, ha nem kap id-t, adja vissza az űrlapot&lt;/li&gt;&lt;li&gt;Az oldal http GET-re, ha id-t kap, kitöltve visszaadja az űrlapot&lt;/li&gt;&lt;li&gt;Mindkét esetben a megjelenítendő, űrlapot tartalmazó oldalt fel kell készíteni, feltölteni dinamikus adatokkal&lt;/li&gt;&lt;li&gt;Az oldal http POST-ra (az űrlap elküldésekor, POST metódust használunk, hiszen a szerver oldalon történik üzleti adat változtatás) lefuttatja az ellenőrzéseket&lt;/li&gt;&lt;li&gt;Amennyiben az ellenőrzés nem sikerül, újra kapjuk vissza az űrlapot, és különösen fontos, hogy a kitöltött értékekkel, a hibásakat megjelölve&lt;/li&gt;&lt;li&gt;Amennyiben az ellenőrzés sikerül, a redirect after post elv szerint átirányítás történjen egy másik oldalra, amin meg kell jeleníteni a művelet eredményét (sikeres mentés)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Sajnos a Struts nem ad arra tanácsot, hogy hogyan lehetne ezen összefüggő oldalakat egyszerűen megvalósítani, inkább az oldalakat külön egységnek tekinti.&lt;/p&gt;&lt;p&gt;A Struts belső logikáját és osztályait kevésbé ismerve a feladatot megoldhatjuk úgy, hogy külön Action-t veszünk fel az űrlap alapértékekkel való feltöltésére, és külön Action-t veszünk fel, ami a POST-ot feldolgozza, két külön URL-len. Akár mindegyikhez külön ActionForm-ot is készíthetünk.&lt;/p&gt;&lt;p&gt;Ennek a megközelítésnek több problémája is van:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Két Action osztály, a logika szétszórva, két külön URL, két bejegyzés a struts-config.xml-ben.&lt;/li&gt;&lt;li&gt;A legtöbb probléma az adatok ellenőrzésénél van. Ha az ellenőrzés elbukik, és a Struts autovalidation van bekapcsolva, az csak JSP oldalra tud vinni. Ebben az esetben viszont nem hívódik meg az a kód, ami az űrlap előkészítésekor az első Action-ben van. Ilyenek pl. azon elemek feltöltése, melyek nem szerepelnek a Form-ban. Az űrlap az első fázisban más URL-en szerepel, mint hibás esetben.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Ahhoz, hogy hatékonyabb megoldást találjunk, a következőket érdemes megfogadni:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Használjuk az &lt;a href="http://wiki.apache.org/struts/EventActionDispatcher"&gt;EventActionDispatcher&lt;/a&gt; osztályt. Ezt használva egy Action-be több metódust is implementálhatunk, és a Dispatcher a struts-config.xml-ben lévő parameter attribútum értéke alapján a megfelelő metódust hívja meg. Pontosan ez úgy történik, hogy definiálhatjuk, hogy amennyiben egy paraméter szerepel a kérésben, vagy egy megadott paraméter a megadott értéket veszi fel, mely metódus kerüljön meghívásra. Különösen több gomb esetén érdemes használni.&lt;/li&gt;&lt;li&gt;Az űrlap kizárólag az ActionForm adatai alapján töltődjön fel, nem érdemes mindenféle request vagy session attribútumokat használni. Használhatjuk a ActionForm-ot az első fázis paramétereinek értelmezésére is, pl. a tétel azonosítójának tárolására. Minden esetben a Struts példányosítja az ActionForm-ot, ha a struts-config.xml-ben szerepel a name attribútum. Ezt a példányosított ActionForm-ot tölthetjük fel utána értékkel.&lt;/li&gt;&lt;li&gt;Az autovalidation-t ajánlott kikapcsolni, és manuálisan hívni az ellenőrzést. Az autovalidation során az irányítás kicsúszik a kezünkből, és hiba esetén a struts-config.xml-ben megadott input attribútumban definiált JSP-re kerülhet csak a vezérlés. Ha mi végezzük az ellenőrzést, akkor dönthetünk másképp is, a legtöbb esetben nem elég a JSP, a hozzá tartozó Action-t is le kell futtatnunk.&lt;/li&gt;&lt;li&gt;Amennyiben az ellenőrzés elbukik, vissza kell irányítani a felhasználót az űrlapra. Ajánlott az Action-re, és nem a view-ra (JSP), így az Action elő tudja készíteni az űrlapot tartalmazó oldalt. Az Action a getErrors metódussal tudja eldönteni, hogy a hiba ágon van-e épp a vezérlés. Az átirányítás történhet forward-dal, de történhet redirect-tel is. Az előbbi esetén a felhasználó ha frissít a böngészőjében, az megerősítést fog kérin, az újra elküldésnél. Ez szerintem belefér, hiszen nem szokás egy ellenőrzés eredményét újratölteni. Ha mégis, használhatunk redirect-et is, de itt az ellenőrzés eredményét vagy URL-ben, vagy session-ben át kell adni. Ezeket a technikákat action reloading-nak nevezik.&lt;/li&gt;&lt;li&gt;Sikeres esetben mindig egy Action-re redirect-áljunk. A redirect after post elv miatt is hasznos (a böngészőben való frissítés esetén így nem küldi el újra az űrlapot, és a böngésző sem tesz fel kérdéseket, hogy újra akarjuk-e küldeni). Ezen kívül érdemes betartani az alapszabályt, hogy mindegyik view-hoz (JSP) tartozzon saját, dedikált Action, de egy Action-höz több view is tartozhat. Így egy 1:n kapcsolat alakul ki, nem érdemes egy view-hoz több Action-t is rendelni, hiszen az m:n kapcsolat már jóval átláthatatlanabb, és az Action-ökben kódduplikáláshoz vezethet.&lt;/li&gt;&lt;li&gt;Az előző következménye, hogy valahogy át kell a művelet eredményét adni a redirect során. Ez történhet URL paraméterrel (ActionForward használatával), vagy pl. a Struts képes az ActionMessages objektumot session-be is menteni, majd a standard módon, tag-gel onnan elővenni.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Figyeljünk arra, hogy a törlés is POST legyen, hiszen üzleti adatokat módosít.&lt;/p&gt;&lt;p&gt;Nézzünk is meg egy példát, amikor van egy Employee osztályunk, és egy olyan Action-t szeretnénk írni, mely képes vagy új Employee felvitelére, vagy létező Employee módosítására.&lt;/p&gt;&lt;p&gt;Nézzük az Employee és ActionForm osztályokat:&lt;/p&gt;&lt;pre class="brush: java"&gt;public class Employee {
private Long id;

private String name;

// Getter és setter metódusok
}

public class EmployeeForm extends ActionForm {
private Employee employee = new Employee();

private String saveButton;

@Override
public ActionErrors validate(ActionMapping mapping, HttpServletRequest request) {
   ActionErrors errors = new ActionErrors();
 if (StringUtils.isEmpty(employee.getName())) {
  errors.add("employee.name", new ActionMessage("empty_name"));
 }
 return errors;
}

// Getter és setter metódusok
}&lt;/pre&gt;&lt;p&gt;Itt azt a trükköt érdemes megfigyelni, hogy az Employee osztályt tartalmazó EmployeeForm-ot hoztunk létre, és ilyenkor az űrlapban a employe.id és employe.name nevekkel hivatkozhatunk annak mezőire. A validate metódus hibát ad vissza, ha a név üres.&lt;/p&gt;&lt;p&gt;Majd nézzük az Action osztályunkat:&lt;/p&gt;&lt;pre class="brush: java"&gt;public class EmployeeAction extends Action {
private final static String VIEW = "view";
private final static String ERROR = "error";
private final static String SUCCESS = "success";

@Resource
private EmployeeService employeeService;

private ActionDispatcher dispatcher =
       new EventActionDispatcher(this);
 
@Override
public ActionForward execute(ActionMapping mapping, ActionForm form,
       HttpServletRequest request, HttpServletResponse response)
       throws Exception {
   if (getErrors(request) != null &amp;amp;&amp;amp; !getErrors(request).isEmpty()) {
       return view(mapping, form, request, response);
   }
 else {
  return dispatcher.execute(mapping, form, request, response);
 }
}

public ActionForward view(ActionMapping mapping,
  ActionForm form,
       HttpServletRequest request,
       HttpServletResponse response)
       throws IOException, ServletException {
 if (((getErrors(request) == null) || getErrors(request).isEmpty()) &amp;amp;&amp;amp;  ((EmployeeForm) form).getEmployee().getId() != null) {
  ((EmployeeForm) form).setEmployee(employeeService.findEmployeeById());
 }
 return mapping.findForward(VIEW);
}

public ActionForward save(ActionMapping mapping,
       ActionForm form,
       HttpServletRequest request,
       HttpServletResponse response)
       throws IOException, ServletException {
 ActionErrors errors = form.validate(mapping, request);
 if (!errors.isEmpty()) {
       saveErrors(request, errors);
       return mapping.findForward(ERROR);
   }
 else {
  employeeService.saveEmployee(((EmployeeForm) form).getEmployee());
  ActionMessages messages = new ActionMessages();
  messages.add(null, new ActionMessage("successful_save"));
  saveMessages(request.getSession(), messages);
  return mapping.findForward(SUCCESS);
 }
}
}
&lt;/pre&gt;&lt;p&gt;Az EmployeeAction az Action leszármazottja, így implementálnia kell az execute metódust. Ennek az első sora megvizsgálja, hogy hiba ágon kerültünk-e erre az Action-re. Ha igen, a view() metódust hívja. A továbbiakban használja az ActionDispatcher-t, hogy eldöntse, hogy melyik metódust kell meghívni, ha nem hiba ágon vagyunk. A hiba ágat azért nem bízhatjuk rá, mert a Form itt ki lesz töltve, hiszen az ellenőrzés ezen futott, és ezért a save() metódusra vinne.&lt;/p&gt;&lt;p&gt;A view() metódus egyszerűen megvizsgálja, hogy a hiba ágon van-e. Ha nem a hiba ágon van, és kapott paraméterben azonosítót, akkor betölt egy Employee példányt, és beteszi az ActionForm-ba.&lt;/p&gt;&lt;p&gt;A save() metódus meghívja manuálisan az ellenőrzést, hiszen az autovalidate ki van kapcsolva, és ha hibát talál, akkor az "error" nevű átirányításra visz (ez nem a JSP, hanem az Action lesz a view ágon). Ha nem talál hibát, elmenti az ActionFormba lévő Employee-t, és a session-be tesz egy üzenetet a mentés sikerességéről.&lt;/p&gt;&lt;p&gt;Az Action-höz tartozó struts-config.xml részlet:&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;form-bean name="EmployeeForm" type="jtechlog.EmployeeForm" /&amp;gt;
...
&amp;lt;action path = "/employee"
name = "EmployeeForm"
type = "jtechlog.EmployeeAction"
parameter = "saveButton=save, default=view"
validate = "false"
scope = "request"
&amp;gt;
&amp;lt;forward name="view" path="/WEB-INF/jsp/employee.jsp" /&amp;gt;
&amp;lt;forward name="error" path="/employee.do" /&amp;gt;
&amp;lt;forward name="success" path="/listEmployees.do" redirect="true" /&amp;gt;
&amp;lt;/action&amp;gt;&lt;/pre&gt;&lt;p&gt;Ez a konfiguráció definiálja az EmployeeAction Action-t, mely a /employee.do címen érhető el új felvitel esetén, és /employee.do?id=1 címen módosítás esetén. Amennyiben a lekérés esetén a saveButton paraméter ki van töltve, az EventActionDispatcher a save metódusra fog vinni, egyébként a view metódusra. (Ide akár bármennyi metódust felsorolhatnánk.) Az autovalidation ki van kapcsolva. Az ActionForm-ot elegendő a request-be tenni, így erőforráskímélő is, mert nem kell a session-be tenni.&lt;/p&gt;&lt;p&gt;Az employee.jsp állítja elő az űrlapot. Hibás esetben önmagát hívja meg újra az Action. Sikeres esetben egy átirányítás történik a redirect after post alapján, mely az üzenetet is meg fogja jeleníteni.&lt;/p&gt;&lt;p&gt;És végül lássuk a JSP részletet:&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;html:form method="post" action="employee.do"&amp;gt;
&amp;lt;html:errors /&amp;gt;

&amp;lt;html:hidden property="employee.id" /&amp;gt;
&amp;lt;html:text property="employee.name" /&amp;gt;
&amp;lt;html:submit property="saveButton"&amp;gt;Save&amp;lt;/html:submit&amp;gt;
&amp;lt;/html&amp;gt;&lt;/pre&gt;&lt;p&gt;A teljes hívási láncot a következő szekvenciadiagram mutatja, mely három részből áll. Első az űrlap lekérése (felvitel vagy módosítás), második az űrlap elküldése hibákkal és a harmadik az űrlap elküldése hibák nélkül.&lt;/p&gt;&lt;p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_czKgycLvmNo/S1TjWS96FJI/AAAAAAAAE5U/eXVaLJa5wZ8/s1600-h/struts_szekvencia.png" style="text-decoration: none;"&gt;&lt;img src="http://2.bp.blogspot.com/_czKgycLvmNo/S1TjWS96FJI/AAAAAAAAE5U/eXVaLJa5wZ8/s320/struts_szekvencia.png" border="0" alt="" id="BLOGGER_PHOTO_ID_5428213423076414610" style="display: block; margin-top: 0px; margin-right: auto; margin-bottom: 10px; margin-left: auto; text-align: center; cursor: pointer; width: 320px; height: 318px; " /&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Látható, hogy a Struts gyermekbetegséggekkel szenved, melyből sokat tanultak a későbbi keretrendszerek fejlesztői.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/291084979601166581/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/01/struts-felviteli-es-szerkeszto-kepernyo.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/291084979601166581'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/291084979601166581'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/01/struts-felviteli-es-szerkeszto-kepernyo.html' title='Struts felviteli es szerkesztő képernyő'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://2.bp.blogspot.com/_czKgycLvmNo/S1TjGlRd9LI/AAAAAAAAE5M/c93rR0NfguI/s72-c/struts_kepernyok.png' height='72' width='72'/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4371095092719584281</id><published>2010-01-10T22:27:00.006+01:00</published><updated>2014-12-31T22:11:27.404+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Servlet'/><category scheme='http://www.blogger.com/atom/ns#' term='open source'/><category scheme='http://www.blogger.com/atom/ns#' term='JSP'/><category scheme='http://www.blogger.com/atom/ns#' term='biztonság'/><category scheme='http://www.blogger.com/atom/ns#' term='Spring'/><title type='text'>Spring Security</title><content type='html'>&lt;p&gt;Frissítve: 2014. december 31.&lt;/p&gt;

&lt;p&gt;Technológiák: Spring Framework 4.1.4, Spring Security 3.2.5&lt;/p&gt;

&lt;p&gt;A &lt;a href="http://projects.spring.io/spring-security/"&gt;Spring Security&lt;/a&gt; egy Apache license alatt futó projekt Java alkalmazások autentikációjának és autorizációjának megvalósítására. Az előbbi azt jelenti, hogy a felhasználó tesz egy állítást, hogy ő kicsoda, és azt bizonyítja is. A legtöbbször ez felhasználónév és jelszó párossal történik, de lehet bonyolultabb megoldás, mint tanúsítvány (akár hardver tokenen), ujjlenyomat, stb. Az utóbbi az erőforráshoz való hozzáféréskor ellenőrzi, hogy a felhasználónak van-e hozzá jogosultsága. A Spring Security független projektként indult Acegi Security néven. Legkönnyebben Springes alkalmazásokkal integrálható, de nem kötelező a Spring használata. Persze az összes Springes technológiához illeszthető. Főleg webes alkalmazásoknál szokták használni, de működik vastag klienses környezetben is. Ez alapján egyszerűen beépíthető egy Spring + Spring MVC alkalmazásba, de használható többek között Struts-cal, Swinggel, de gyakorlatilag bármilyen Java alkalmazásban.&lt;/p&gt;

&lt;p&gt;Előnye, hogy nem függ a környezettől (pl. alkalmazásszerver), nem kell az üzleti logikát átfűzni a jogosultságkezelést végző kóddal (, hanem aspektus-orientált módon adható meg). Egyszerű módon (XML-lel) konfigurálható, és a legtöbb beállításnak van alapértelmezett értéke is, mellyel működik a biztonság, de tetszőleges mértékben testre szabható, a legtöbb osztály akár saját implementációra is kicserélhető (pluginelhetőség). Implementálva van benne hozzáférési listák kezelése (Access Control Lists).&lt;/p&gt;

&lt;p&gt;Támogatja a HTTP BASIC, HTTP Digest és form alapú autentikációt, valamint az OpenID-t és a X.509 tanúsítványt.&lt;/p&gt;

&lt;p&gt;A felhasználók és a hozzá kapcsolódó szerepkörök tárolhatóak properties vagy XML állományban, adatbázisban, LDAP-ban, de saját implementáció is megadható. Támogatja a jelszó kódolását pl. SHA vagy MD5 algoritmussal. A felhasználóval kapcsolatos információkat képes cache-elni is. Különböző eseményekre eseménykezelőket lehet aggatni, pl. bejelentkezés, így könnyen megoldható pl. audit naplózás. Könnyen illeszthető a &lt;a href="http://jasig.github.io/cas/4.0.x/index.html"&gt;CAS single sign on&lt;/a&gt; megoldáshoz.&lt;/p&gt;

&lt;p&gt;Kompatibilis a Servlet Security API-val, használhatóak vele az EJB 3 annotációi, valamint a WSS-hez (korábban WS-Security) is illeszthető. Képes a security propagation-re, azaz az alkalmazások különböző rétegei között átvinni a security context-et (pl. a vastag kliensről a szerverre).&lt;/p&gt;

&lt;p&gt;Webes környezetben egy filtert kell a &lt;code&gt;web.xml&lt;/code&gt;-be betenni. Képes mindarra, amire a &lt;code&gt;web.xml&lt;/code&gt;-ben definiálható biztonság, de azt rengeteg egyéb funkcióval egészíti ki, mint pl. a védett URL-eket nem csak a Servlet specifikációban megadott korlátozott URL mintákkal lehet megadni, hanem használható az Ant féle megadási mód is. Konfigurálható, hogy védet tartalmak esetén történjen https-re átirányítás. Alapból implementálva van benne két Remember-Me (Persistent Login) megoldás is, azaz a böngésző cookie-ban jegyezze meg a bejelentkezés tényét. A Spring Security tag library-t is biztosít funkcióinak elérésére JSP oldalból.&lt;/p&gt;

&lt;p&gt;Ebben a posztban egy egyszerű Spring MVC-s webes alkalmazásba illesztését fogom bemutatni. A poszthoz egy példa projekt is tartozik, mely &lt;a href="https://github.com/vicziani/jtechlog-spring-security"&gt;elérhető a GitHub-on&lt;/a&gt;, és a teljes forrás akár egy zip fájlban is letölthető. Egyszerű Spring MVC-s webes alkalmazás JPA perzisztens réteggel.&lt;/p&gt;

&lt;p&gt;Első lépésként szerkesszük meg az &lt;code&gt;web.xml&lt;/code&gt; állományt, és adjuk meg a Spring Security-t konfiguráló &lt;code&gt;applicationContext-security.xml&lt;/code&gt; állományt (a jó elkülöníthetőség kedvéért konfigurálom külön állományban), valamint a filtert, mely a http(s) kéréseket elkapja, és ellenőrzi.&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="tag"&gt;&amp;lt;context-param&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;param-name&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;contextConfigLocation&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/param-name&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;param-value&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; 
     WEB-INF/applicationContext.xml
     WEB-INF/applicationContext-security.xml
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/param-value&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/context-param&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;

&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;filter&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;filter-name&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;springSecurityFilterChain&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/filter-name&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;filter-class&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;org.springframework.web.filter.DelegatingFilterProxy
        &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/filter-class&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/filter&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;

&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;filter-mapping&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;filter-name&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;springSecurityFilterChain&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/filter-name&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;/*&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/filter-mapping&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A következő lépésben írjuk meg az &lt;code&gt;applicationContext-security.xml&lt;/code&gt; állományt.&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="tag"&gt;&amp;lt;beans:beans&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;xmlns&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"http://www.springframework.org/schema/security"&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="atn"&gt;xmlns:beans&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"http://www.springframework.org/schema/beans"&lt;/span&gt;&lt;span class="pln"&gt; 
    &lt;/span&gt;&lt;span class="atn"&gt;xmlns:xsi&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"http://www.w3.org/2001/XMLSchema-instance"&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="atn"&gt;xsi:schemaLocation&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/security 
        http://www.springframework.org/schema/security/spring-security.xsd"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;

    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;http&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;auto-config&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"true"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;intercept-url&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;pattern&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"/"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;access&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"ROLE_USER, ROLE_ADMIN"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;intercept-url&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;pattern&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"/index.html"&lt;/span&gt;&lt;span class="pln"&gt; 
            &lt;/span&gt;&lt;span class="atn"&gt;access&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"ROLE_USER, ROLE_ADMIN"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;intercept-url&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;pattern&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"/addUser.html"&lt;/span&gt;&lt;span class="pln"&gt; 
            &lt;/span&gt;&lt;span class="atn"&gt;access&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"ROLE_ADMIN"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;logout&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/http&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;

    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;authentication-manager&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;alias&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"authenticationManager"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;authentication-provider&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;password-encoder&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;hash&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"md5"&lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;user-service&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
                &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;user&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"jtechlog"&lt;/span&gt;&lt;span class="pln"&gt; 
                    &lt;/span&gt;&lt;span class="atn"&gt;password&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"26b91b96e2e8adc37cd26cff6a6b2eba"&lt;/span&gt;&lt;span class="pln"&gt; 
                    &lt;/span&gt;&lt;span class="atn"&gt;authorities&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"ROLE_USER"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/user-service&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/authentication-provider&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;     
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/authentication-manager&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/beans:beans&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Az &lt;code&gt;auto-config&lt;/code&gt; tulajdonság egy rövidítés, a következő alapértelmezett beállításokat tartalmazza:&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="tag"&gt;&amp;lt;http&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
  &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;form-login&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
  &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;http-basic&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
  &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;logout&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/http&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Az &lt;code&gt;authentication-provider&lt;/code&gt; elemben az XML szerepel egy &lt;code&gt;jtechlog&lt;/code&gt; nevű felhasználó, akinek a jelszava MD5-tel kódolva szerepel (&lt;code&gt;jtechlog12&lt;/code&gt;). Ezzel készen is van. Az alkalmazásunkat elindítva bármelyik URL-re egy (Spring Security által generált) bejelentkezési form jön be, hiszen deklarálva lett, hogy a &lt;code&gt;/&lt;/code&gt; URL megtekintéséhez a felhasználónak rendelkeznie kell a &lt;code&gt;ROLE_USER&lt;/code&gt; vagy &lt;code&gt;ROLE_ADMIN&lt;/code&gt; szerepkörrel, a &lt;code&gt;/addUser.html&lt;/code&gt;-hez &lt;code&gt;ROLE_ADMIN&lt;/code&gt; szerepkörrel (lásd &lt;code&gt;intercept-url&lt;/code&gt; elem). Az azonosítás formon, jelszóval történik (&lt;code&gt;form-login&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;security&lt;/code&gt; névtérben a következőkre adhatunk meg konfigurációkat:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Web/HTTP Security&lt;/li&gt;
&lt;li&gt;Business Object (Method) Security&lt;/li&gt;
&lt;li&gt;AuthenticationManager&lt;/li&gt;
&lt;li&gt;AccessDecisionManager&lt;/li&gt;
&lt;li&gt;AuthenticationProviders&lt;/li&gt;
&lt;li&gt;UserDetailsService&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Amennyiben kijelentkezést is meg akarunk valósítani, a JSP-ben csak helyezzük el a következő linket:&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="pln"&gt;&amp;lt;a href="&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;c:url&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;value&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;'/j_spring_security_logout'&lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;"&amp;gt;Kijelentkezés&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Következő lépésként implementáljuk magunk a felhasználó adatbázisból való betöltését, méghozzá pl. JPA segítségével. Ehhez kell egy &lt;code&gt;User&lt;/code&gt; entitás, melynek különlegessége, hogy implementálnia kell a &lt;code&gt;UserDetails&lt;/code&gt; interfészt, és annak több metódusát. Pl.:&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="lit"&gt;@Entity&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;class&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;User&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;implements&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;UserDetails&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;Serializable&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;

   &lt;/span&gt;&lt;span class="lit"&gt;@Id&lt;/span&gt;&lt;span class="pln"&gt;
   &lt;/span&gt;&lt;span class="lit"&gt;@GeneratedValue&lt;/span&gt;&lt;span class="pln"&gt;
   &lt;/span&gt;&lt;span class="kwd"&gt;private&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;Long&lt;/span&gt;&lt;span class="pln"&gt; id&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;

   &lt;/span&gt;&lt;span class="kwd"&gt;private&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pln"&gt; username&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;

   &lt;/span&gt;&lt;span class="kwd"&gt;private&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pln"&gt; password&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;

   &lt;/span&gt;&lt;span class="kwd"&gt;private&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pln"&gt; roles&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;

    &lt;/span&gt;&lt;span class="lit"&gt;@Override&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;Collection&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&lt;/span&gt;&lt;span class="typ"&gt;GrantedAuthority&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; getAuthorities&lt;/span&gt;&lt;span class="pun"&gt;()&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="typ"&gt;Collection&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&lt;/span&gt;&lt;span class="typ"&gt;GrantedAuthority&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt; authorities &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; 
            &lt;/span&gt;&lt;span class="kwd"&gt;new&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;ArrayList&lt;/span&gt;&lt;span class="pun"&gt;&amp;lt;&lt;/span&gt;&lt;span class="typ"&gt;GrantedAuthority&lt;/span&gt;&lt;span class="pun"&gt;&amp;gt;();&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="kwd"&gt;for&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pln"&gt; s&lt;/span&gt;&lt;span class="pun"&gt;:&lt;/span&gt;&lt;span class="pln"&gt; roles&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;split&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;", "&lt;/span&gt;&lt;span class="pun"&gt;))&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
            authorities&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;add&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="kwd"&gt;new&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;SimpleGrantedAuthority&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;
                &lt;/span&gt;&lt;span class="str"&gt;"ROLE_"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;+&lt;/span&gt;&lt;span class="pln"&gt; s&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;toUpperCase&lt;/span&gt;&lt;span class="pun"&gt;()));&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="kwd"&gt;return&lt;/span&gt;&lt;span class="pln"&gt; authorities&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;

   &lt;/span&gt;&lt;span class="lit"&gt;@Override&lt;/span&gt;&lt;span class="pln"&gt;
   &lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pln"&gt; getPassword&lt;/span&gt;&lt;span class="pun"&gt;()&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
       &lt;/span&gt;&lt;span class="kwd"&gt;return&lt;/span&gt;&lt;span class="pln"&gt; password&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;
   &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;

   &lt;/span&gt;&lt;span class="lit"&gt;@Override&lt;/span&gt;&lt;span class="pln"&gt;
   &lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pln"&gt; getUsername&lt;/span&gt;&lt;span class="pun"&gt;()&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
       &lt;/span&gt;&lt;span class="kwd"&gt;return&lt;/span&gt;&lt;span class="pln"&gt; username&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;
   &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;

   &lt;/span&gt;&lt;span class="lit"&gt;@Override&lt;/span&gt;&lt;span class="pln"&gt;
   &lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;boolean&lt;/span&gt;&lt;span class="pln"&gt; isAccountNonExpired&lt;/span&gt;&lt;span class="pun"&gt;()&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
       &lt;/span&gt;&lt;span class="kwd"&gt;return&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;true&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;
   &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;

   &lt;/span&gt;&lt;span class="lit"&gt;@Override&lt;/span&gt;&lt;span class="pln"&gt;
   &lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;boolean&lt;/span&gt;&lt;span class="pln"&gt; isAccountNonLocked&lt;/span&gt;&lt;span class="pun"&gt;()&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
       &lt;/span&gt;&lt;span class="kwd"&gt;return&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;true&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;
   &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;

   &lt;/span&gt;&lt;span class="lit"&gt;@Override&lt;/span&gt;&lt;span class="pln"&gt;
   &lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;boolean&lt;/span&gt;&lt;span class="pln"&gt; isCredentialsNonExpired&lt;/span&gt;&lt;span class="pun"&gt;()&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
       &lt;/span&gt;&lt;span class="kwd"&gt;return&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;true&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;
   &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;

   &lt;/span&gt;&lt;span class="lit"&gt;@Override&lt;/span&gt;&lt;span class="pln"&gt;
   &lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;boolean&lt;/span&gt;&lt;span class="pln"&gt; isEnabled&lt;/span&gt;&lt;span class="pun"&gt;()&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
       &lt;/span&gt;&lt;span class="kwd"&gt;return&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;true&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;
   &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;

   &lt;/span&gt;&lt;span class="com"&gt;// Többi getter és setter metódus&lt;/span&gt;&lt;span class="pln"&gt;
   &lt;/span&gt;&lt;span class="com"&gt;// ...&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Valamint definiáljunk egy &lt;code&gt;UserService&lt;/code&gt; nevű &lt;code&gt;@Repository&lt;/code&gt; osztályt, és a trükk csak annyi, hogy implementálnia kell a &lt;code&gt;UserDetailsService&lt;/code&gt; interfészt.&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="lit"&gt;@Repository&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"userService"&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="lit"&gt;@Transactional&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;class&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;DefaultUserService&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;implements&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;UserDetailsService&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;

   &lt;/span&gt;&lt;span class="lit"&gt;@PersistenceContext&lt;/span&gt;&lt;span class="pln"&gt;
   &lt;/span&gt;&lt;span class="kwd"&gt;private&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;EntityManager&lt;/span&gt;&lt;span class="pln"&gt; em&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;

   &lt;/span&gt;&lt;span class="lit"&gt;@Override&lt;/span&gt;&lt;span class="pln"&gt;
   &lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;UserDetails&lt;/span&gt;&lt;span class="pln"&gt; loadUserByUsername&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pln"&gt; username&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; 
        &lt;/span&gt;&lt;span class="kwd"&gt;throws&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;UsernameNotFoundException&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;DataAccessException&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
       &lt;/span&gt;&lt;span class="kwd"&gt;try&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
           &lt;/span&gt;&lt;span class="kwd"&gt;return&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;UserDetails&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; em
                &lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;createQuery&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"select u from User u"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;+&lt;/span&gt;&lt;span class="pln"&gt;
                    &lt;/span&gt;&lt;span class="str"&gt;" where u.username = :username"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;User&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="kwd"&gt;class&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt;
                &lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;setParameter&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"username"&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; username&lt;/span&gt;&lt;span class="pun"&gt;).&lt;/span&gt;&lt;span class="pln"&gt;getSingleResult&lt;/span&gt;&lt;span class="pun"&gt;();&lt;/span&gt;&lt;span class="pln"&gt;
       &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;
       &lt;/span&gt;&lt;span class="kwd"&gt;catch&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;EntityNotFoundException&lt;/span&gt;&lt;span class="pln"&gt; enfe&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
           &lt;/span&gt;&lt;span class="kwd"&gt;throw&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;new&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;UsernameNotFoundException&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;
                &lt;/span&gt;&lt;span class="str"&gt;"A felhasznalo nem talalhato: "&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;+&lt;/span&gt;&lt;span class="pln"&gt; username&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; enfe&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;span class="pln"&gt;
       &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;
   &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;

   &lt;/span&gt;&lt;span class="com"&gt;// Többi üzleti metódus&lt;/span&gt;&lt;span class="pln"&gt;
   &lt;/span&gt;&lt;span class="com"&gt;// ...&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mivel az &lt;code&gt;applicationContext.xml&lt;/code&gt;-ben &lt;code&gt;context:annotation-config&lt;/code&gt; van beállítva, ami a &lt;code&gt;@Repository&lt;/code&gt; annotáció miatt példányosítja a &lt;code&gt;DefaultUserService&lt;/code&gt; osztályunkat.&lt;/p&gt;

&lt;p&gt;A Spring Security-ben az &lt;code&gt;AuthenticationProvider&lt;/code&gt; is cserélhető, és ebben az esetben a &lt;code&gt;DaoAuthenticationProvider&lt;/code&gt;-t kell használnunk. Ennek megadhatunk egy &lt;code&gt;userDetailsService&lt;/code&gt; tulajdonságot, melynek a &lt;code&gt;UserDetailsService&lt;/code&gt;-t kell implementálnia, és ennek fogja meghívni a &lt;code&gt;loadUserByUsername&lt;/code&gt; metódusát. Ezt egy rövidebb konfigurációval is megadhatjuk az &lt;code&gt;applicationContext-security.xml&lt;/code&gt; állományban a következő módon:&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="tag"&gt;&amp;lt;authentication-provider&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;user-service-ref&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"userService"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Egy &lt;code&gt;authentication-manager&lt;/code&gt;-en belül több &lt;code&gt;authentication-provider&lt;/code&gt;-t is megadhatunk. Ekkor sorban nézi végig a providereket, és ahol először sikerül az autentikáció, az nyer. Így előbb az XML-ben szereplő felhasználókat, majd az adatbázisban szereplő felhasználókat fogja alapul venni, a &lt;code&gt;User&lt;/code&gt; entitásunk alapján. Ekkor a jelszó még plain textben kerül letárolásra, de ha mi MD5-öt szeretnénk, konfiguráljuk így:&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="tag"&gt;&amp;lt;authentication-provider&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;user-service-ref&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"userService"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
   &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;password-encoder&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;hash&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"md5"&lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/authentication-provider&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Java kódból ezután a következőképpen kérhetjük le a bejelentkezés után a felhasználót:&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="typ"&gt;SecurityContextHolder&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getContext&lt;/span&gt;&lt;span class="pun"&gt;().&lt;/span&gt;&lt;span class="pln"&gt;getAuthentication&lt;/span&gt;&lt;span class="pun"&gt;().&lt;/span&gt;&lt;span class="pln"&gt;getPrincipal&lt;/span&gt;&lt;span class="pun"&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;Context&lt;/code&gt; &lt;code&gt;ThreadLocal&lt;/code&gt; változó, így szálanként egyedi. A metódus visszatérési értékét kényszeríthetjük a saját &lt;code&gt;User&lt;/code&gt; osztályunkra.&lt;/p&gt;

&lt;p&gt;JSP-ben használhatunk tag library-t is, melynek definíciója:&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="pun"&gt;&amp;lt;%@&lt;/span&gt;&lt;span class="pln"&gt; taglib prefix&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="str"&gt;"security"&lt;/span&gt;&lt;span class="pln"&gt; 
    uri&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="str"&gt;"http://www.springframework.org/security/tags"&lt;/span&gt;&lt;span class="pln"&gt; %&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Az &lt;code&gt;authentication&lt;/code&gt; tag visszaadja az &lt;code&gt;Authentication&lt;/code&gt; objektumot, és annak tulajdonságait tudjuk lekérni:&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code&gt;&lt;span class="tag"&gt;&amp;lt;security:authentication&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;property&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"principal.username"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Valamint az &lt;code&gt;authorize&lt;/code&gt; tag törzse csak a feltétel teljesítésekor jelenik meg. A feltételek a következők lehetnek: &lt;code&gt;ifAllGranted&lt;/code&gt; - vesszővel megadott szerepkörök mindegyikével rendelkezik, &lt;code&gt;ifAnyGranted&lt;/code&gt; - vesszővel megadott szerepkörök egyikével rendelkezik, &lt;code&gt;ifNotGranted&lt;/code&gt; - vesszővel megadott szerepkörök egyikével sem rendelkezik.&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="tag"&gt;&amp;lt;security:authorize&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;ifAllGranted&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"ROLE_ADMIN"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
       &lt;/span&gt;&lt;span class="com"&gt;&amp;lt;!-- Felhasználók felvételére szolgáló form. --&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/security:authorize&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ez esetben még mindig nem vagyunk megelégedve a Spring Security által biztosított alapértelmezett bejelentkező képernyővel, emiatt szabjuk azt testre. Az &lt;code&gt;intercept-url&lt;/code&gt;-lel kell megadni a védendő URL-eket. Természetesen többet is megadhatunk, egy URL-hez több szerepkört is megadhatunk vesszővel elválasztva, valamint használhatunk Ant típusú mintákat. A Spring Security használatakor a leggyakoribb hiba, hogy a bejelentkezési képernyőt is letiltjuk, így végtelen ciklus alakulhat ki. Erre a Spring Security egy üzenettel figyelmeztet is: &lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="pln"&gt;org.springframework.security.config.FilterChainProxyPostProcessor: Anonymous access to the login page doesn't appear to be enabled. This is almost certainly an error. Please check your configuration allows unauthenticated access to the configured login page. (Simulated access was rejected: org.springframework.security.AccessDeniedException: Access is denied).&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ekkor be kell állítani, hogy a &lt;code&gt;login.html&lt;/code&gt; oldalhoz ne kelljen bejelentkezés. Sikertelen bejelentkezés esetén történjen átirányítás a &lt;code&gt;/login.htm?login_error=1&lt;/code&gt; oldalra, sikeres bejelentkezés esetén a &lt;code&gt;/&lt;/code&gt; oldalra. Kijelentkezés után ismét a &lt;code&gt;/login.htm&lt;/code&gt; oldal jön be. A konfiguráció a következőképpen alakul:&lt;/p&gt;

&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="tag"&gt;&amp;lt;http&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;auto-config&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"true"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;intercept-url&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;pattern&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"/login.html"&lt;/span&gt;&lt;span class="pln"&gt; 
        &lt;/span&gt;&lt;span class="atn"&gt;access&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"IS_AUTHENTICATED_ANONYMOUSLY"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;intercept-url&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;pattern&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"/"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;access&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"ROLE_ADMIN, ROLE_USER"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;intercept-url&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;pattern&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"/addUser.html"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;access&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"ROLE_ADMIN"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;form-login&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;login-page&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"/login.html"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;default-target-url&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"/"&lt;/span&gt;&lt;span class="pln"&gt; 
        &lt;/span&gt;&lt;span class="atn"&gt;authentication-failure-url&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"/login.htm?login_error=1"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;logout&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;logout-success-url&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"/login.html"&lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/http&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Majd nézzük a bejelentkező formot tartalmazó JSP részletet:&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="tag"&gt;&amp;lt;c:if&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;test&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"${not empty param.login_error}"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    Sikertelen bejelentkezés
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/c:if&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;

&amp;lt;form action="&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;c:url&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;value&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;'/j_spring_security_check'&lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;" method="POST"&amp;gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;input&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;type&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"text"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"j_username"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;value&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;""&lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;input&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;type&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"password"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"j_password"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;value&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;""&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;input&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;type&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"submit"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;value&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"Bejelentkezés"&lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A formot a &lt;code&gt;j_spring_security_check&lt;/code&gt; címre kell postolni, amit a filter fogad. Tartalmaznia kell egy &lt;code&gt;j_username&lt;/code&gt; és &lt;code&gt;j_password&lt;/code&gt; mezőt. Amennyiben nem sikerült a bejelentkezés, a sessionben egy változó lesz &lt;code&gt;SPRING_SECURITY_LAST_EXCEPTION&lt;/code&gt; néven.&lt;/p&gt;

&lt;p&gt;Régebbi verziókban a sessionbe sikertelen bejelentkezés esetén beletett egy &lt;code&gt;SPRING_SECURITY_LAST_USERNAME&lt;/code&gt; nevű változót is, melyet a felhasználónév mezőbe visszaírva nem kellett a felhasználónak beírnia újra a nevét. Azonban ez deprecated lett.&lt;/p&gt;

&lt;p&gt;Ennek megoldására a &lt;code&gt;form-login&lt;/code&gt; taghez írni kell egy &lt;code&gt;authentication-failure-handler-ref&lt;/code&gt; attribútumot egy saját implementációval. A saját osztályunk terjessze ki a &lt;code&gt;SimpleUrlAuthenticationFailureHandler&lt;/code&gt; osztályt, és önmaga tegye a felhasználónevet a session scope-ba. Utána a bejelentkező oldalon ezt ki kell venni.&lt;/p&gt;

&lt;p&gt;A következő változott tehát az &lt;code&gt;applicationContext-security.xml&lt;/code&gt; állományban.&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="tag"&gt;&amp;lt;form-login&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;login-page&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"/login.html"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;default-target-url&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"/"&lt;/span&gt;&lt;span class="pln"&gt; 
    &lt;/span&gt;&lt;span class="atn"&gt;authentication-failure-handler-ref&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="atv"&gt;"usernameInUrlAuthenticationFailureHandler"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;

...

&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;beans:bean&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;id&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"usernameInUrlAuthenticationFailureHandler"&lt;/span&gt;&lt;span class="pln"&gt; 
        &lt;/span&gt;&lt;span class="atn"&gt;class&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"jtechlog.springsecurity.service.
            UsernameInUrlAuthenticationFailureHandler"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;beans:property&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;name&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"defaultFailureUrl"&lt;/span&gt;&lt;span class="pln"&gt; 
        &lt;/span&gt;&lt;span class="atn"&gt;value&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"/login.html?login_error=1"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/beans:bean&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;UsernameInUrlAuthenticationFailureHandler&lt;/code&gt; implementációja:&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;class&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;UsernameInUrlAuthenticationFailureHandler&lt;/span&gt;&lt;span class="pln"&gt; 
        &lt;/span&gt;&lt;span class="kwd"&gt;extends&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;SimpleUrlAuthenticationFailureHandler&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;

    &lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;static&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;final&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pln"&gt; LAST_USERNAME_KEY &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="str"&gt;"LAST_USERNAME"&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;

    &lt;/span&gt;&lt;span class="kwd"&gt;private&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;UsernamePasswordAuthenticationFilter&lt;/span&gt;&lt;span class="pln"&gt; 
        usernamePasswordAuthenticationFilter&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;

    &lt;/span&gt;&lt;span class="lit"&gt;@Autowired&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;UsernameInUrlAuthenticationFailureHandler&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="typ"&gt;UsernamePasswordAuthenticationFilter&lt;/span&gt;&lt;span class="pln"&gt; 
            usernamePasswordAuthenticationFilter&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="kwd"&gt;this&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;usernamePasswordAuthenticationFilter &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; 
            usernamePasswordAuthenticationFilter&lt;/span&gt;&lt;span class="pun"&gt;;&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;

    &lt;/span&gt;&lt;span class="lit"&gt;@Override&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;void&lt;/span&gt;&lt;span class="pln"&gt; onAuthenticationFailure&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="typ"&gt;HttpServletRequest&lt;/span&gt;&lt;span class="pln"&gt; request&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;HttpServletResponse&lt;/span&gt;&lt;span class="pln"&gt; response&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="typ"&gt;AuthenticationException&lt;/span&gt;&lt;span class="pln"&gt; exception&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt;
            &lt;/span&gt;&lt;span class="kwd"&gt;throws&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;IOException&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;ServletException&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;

        &lt;/span&gt;&lt;span class="kwd"&gt;super&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;onAuthenticationFailure&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;request&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; response&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; exception&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;span class="pln"&gt;

        &lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pln"&gt; usernameParameter &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt;
                usernamePasswordAuthenticationFilter&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getUsernameParameter&lt;/span&gt;&lt;span class="pun"&gt;();&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pln"&gt; lastUserName &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; request&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getParameter&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;usernameParameter&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;span class="pln"&gt;

        &lt;/span&gt;&lt;span class="typ"&gt;HttpSession&lt;/span&gt;&lt;span class="pln"&gt; session &lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="pln"&gt; request&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getSession&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="kwd"&gt;false&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="kwd"&gt;if&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;session &lt;/span&gt;&lt;span class="pun"&gt;!=&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;null&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;||&lt;/span&gt;&lt;span class="pln"&gt; isAllowSessionCreation&lt;/span&gt;&lt;span class="pun"&gt;())&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
            request&lt;/span&gt;&lt;span class="pun"&gt;.&lt;/span&gt;&lt;span class="pln"&gt;getSession&lt;/span&gt;&lt;span class="pun"&gt;().&lt;/span&gt;&lt;span class="pln"&gt;setAttribute&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="pln"&gt;LAST_USERNAME_KEY&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; 
                lastUserName&lt;/span&gt;&lt;span class="pun"&gt;);&lt;/span&gt;&lt;span class="pln"&gt;
        &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;
    &lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Valamint a megváltozott form:&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-xml"&gt;&lt;span class="pln"&gt;&amp;lt;input type="text" name="j_username" 
    value='&lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;c:if&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;test&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"${not empty param.login_error}"&lt;/span&gt;&lt;span class="tag"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
               &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;c:out&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;value&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"${sessionScope.LAST_USERNAME}"&lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;
           &lt;/span&gt;&lt;span class="tag"&gt;&amp;lt;/c:if&amp;gt;&lt;/span&gt;&lt;span class="pln"&gt;'/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ezen kívül a Spring Security képes arra is, hogy különböző metódusok meghívása esetén is végezzen jogosultság ellenőrzést. Ezt deklaratív módon, annotációval is meg lehet adni. Ekkor egyrészt deklarálni kell, hogy metódus szintű hozzáférés ellenőrzést szeretnénk, ekkor a következőt kell elhelyezni az &lt;code&gt;applicationContext-security.xml&lt;/code&gt;-ben:&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code&gt;&lt;span class="tag"&gt;&amp;lt;global-method-security&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="atn"&gt;pre-post-annotations&lt;/span&gt;&lt;span class="pun"&gt;=&lt;/span&gt;&lt;span class="atv"&gt;"enabled"&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="tag"&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Valamint használjuk a &lt;code&gt;@PreAuthorize&lt;/code&gt; annotációt a védendő metóduson:&lt;/p&gt;



&lt;pre style="" class="prettyprint prettyprinted"&gt;&lt;code class="language-java"&gt;&lt;span class="lit"&gt;@PreAuthorize&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="str"&gt;"hasRole('ROLE_ADMIN')"&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="kwd"&gt;public&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="kwd"&gt;void&lt;/span&gt;&lt;span class="pln"&gt; addUser&lt;/span&gt;&lt;span class="pun"&gt;(&lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pln"&gt; name&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pln"&gt; password&lt;/span&gt;&lt;span class="pun"&gt;,&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="typ"&gt;String&lt;/span&gt;&lt;span class="pln"&gt; roles&lt;/span&gt;&lt;span class="pun"&gt;)&lt;/span&gt;&lt;span class="pln"&gt; &lt;/span&gt;&lt;span class="pun"&gt;{&lt;/span&gt;&lt;span class="pln"&gt;
  &lt;/span&gt;&lt;span class="com"&gt;// ...&lt;/span&gt;&lt;span class="pln"&gt;
&lt;/span&gt;&lt;span class="pun"&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/4371095092719584281/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/01/spring-security.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4371095092719584281'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4371095092719584281'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/01/spring-security.html' title='Spring Security'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1461810755938682590</id><published>2010-01-03T23:31:00.005+01:00</published><updated>2010-09-18T00:26:59.096+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Ant'/><title type='text'>Ant listener és logger osztályok</title><content type='html'>&lt;p&gt;Az Ant (, a bejegyzés írásakor a legfrissebb verzió a 1.7.1) lehetőséget biztosít arra, hogy futását monitorozzuk, és a folyamat különböző eseményeihez különböző műveleteket rendeljünk. Ehhez a BuildListener és BuildLogger interfészeket kell implementálni, az abban definiált metódusokat megvalósítani, és az Ant-ot úgy indítani, hogy igénybe vegye ezeket. Ezekről a &lt;a href="http://ant.apache.org/manual/listeners.html"&gt;kézikönyvön&lt;/a&gt; kívül a Manning kiadónál megjelent Erik Hatcher, Steve Loughran: Java Development with Ant könyv 20.2 Listeners and loggers című fejezete is részletesen ír.&lt;/p&gt;&lt;p&gt;Ezekből léteznek az Ant-ban már implementációk, de írhatunk sajátokat is egyszerű időmérésre, saját naplózás megvalósítására, de akár bonyolultabb műveletekre is, mint pl. IDE fejlesztésekor a fejlesztőeszközzel való kapcsolattartásra, vagy ha az Ant-hoz grafikus felületet fejlesztünk, ezek adhatnak hírt a build folyamat pillanatnyi állásáról.&lt;/p&gt;&lt;p&gt;A BuildListener interfész leszármazottja a BuildLogger interfész, ahogy a következő UML osztálydiagram is mutatja.&lt;/p&gt;&lt;div&gt;
&lt;/div&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://yuml.me/diagram/scruffy/class/dir:td/%5BBuildListener%7C%7CbuildStarted%28%29;buildFinished%28%29;targetStarted%28%29;targetFinished%28%29;taskStarted%28%29;taskFinished%28%29;messageLogged%28%29]%5E[BuildLogger%7C%7CsetEmacsMode%28%29;setErrorPrintStream%28%29;setOutputPrintStream%28%29;setMessageOutputLevel%28%29]"&gt;&lt;img src="http://yuml.me/diagram/scruffy/class/dir:td/%5BBuildListener%7C%7CbuildStarted%28%29;buildFinished%28%29;targetStarted%28%29;targetFinished%28%29;taskStarted%28%29;taskFinished%28%29;messageLogged%28%29]%5E[BuildLogger%7C%7CsetEmacsMode%28%29;setErrorPrintStream%28%29;setOutputPrintStream%28%29;setMessageOutputLevel%28%29]" border="0" alt="" style="display: block; margin-top: 0px; margin-right: auto; margin-bottom: 10px; margin-left: auto; text-align: center; cursor: pointer; width: 533px; height: 213px; " /&gt;&lt;/a&gt;&lt;p&gt;A BuildListener interfészben a build folyamat különböző lépéseinek elindításához és elvégzéséhez is tartozik egy metódus, melyet az Ant hív meg. Így meghívja a build folyamat indításakor a buildStarted() metódust, és a végén a buildFinished() metódust. Ugyanígy vannak metódusok a target és a task futtatásához is. Mindegyik paramétere a BuildEvent osztály egy példánya, melytől le lehet kérni az éppen feldolgozás alatt álló projektet (BuildEvent.getProject()), target-et (BuildEvent.getTarget()) és task-ot (BuildEvent.getTask()). Természetesen aminek nincs értelme, null-t ad vissza, pl. a buildStarted() esemény esetén a target és a task még null. Külön megjegyzendő, hogy a build folyamat kezdetekor, mikor esemény generálódik (buildStarted() metódus hívásakor) még nem dolgozta fel a build.xml állományt, így a BuildEvent.getProject() is null-t fog visszaadni. Ezen események bekövetkeztekor a BuildEvent.getException() metódussal a kivételt is lekérdezhetjük. A messageLogged() metódus akkor hívódik meg, mikor az Ant üzenetet naplóz. Ekkor az üzenetet a BuildEvent.getMessage() metódussal tudjuk lekérni, és az üzenet prioritását a BuildEvent.getPriority() metódussal. Fontos, hogy a messageLogged() metódusban ne használjuk közvetlen System.out, vagy System.err stream-ekre írást, mivel az Ant úgy működik, hogy ezen stream-ek felett átveszi az irányítást, és ami ezekre kiírásra kerül, azt adja tovább a BuildListener-nek. Így ha ebből ezekre a stream-ekre írunk, végtelenciklus lesz a vége. Az inicializációs kódot javasolt a konstruktorban elhelyezni.&lt;/p&gt;&lt;p&gt;Írjunk is meg egy egyszerű BuildListener-t, mely azt méri, hogy mely target futása mennyi ideig tartott, névvel együtt.&lt;/p&gt;&lt;pre class="brush: java"&gt;package jtechlog.ant;

import org.apache.tools.ant.BuildEvent;
import org.apache.tools.ant.BuildListener;

public class MeasureBuildListener implements BuildListener {
private long startedAt;
public void buildStarted(BuildEvent be) {
}

public void buildFinished(BuildEvent be) {
}

public void targetStarted(BuildEvent be) {
  startedAt = System.currentTimeMillis();
}

public void targetFinished(BuildEvent be) {
  System.out.println("A " + be.getTarget().getName() + " target futási ideje: " + (System.currentTimeMillis() - startedAt) + " ms");
}

public void taskFinished(BuildEvent be) {
}

public void taskStarted(BuildEvent be) {
}

public void messageLogged(BuildEvent be) {
} 
}&lt;/pre&gt;&lt;p&gt;Ahhoz, hogy ezt le is futtassuk, a saját osztályunkat el kell helyezni az Ant classpath-jában, melyre a legegyszerűbb megoldás a -lib kapcsoló használata. Ezen kívül a saját osztályunkat meg kell adni indítási paraméterként a -listener kapcsolóval. Azaz a parancssor, ha az osztályunk a lib/jtechlog-listeners.jar fájlban van, indítsuk így az Ant-ot:&lt;/p&gt;&lt;pre&gt;ant -lib lib -listener jtechlog.ant.MeasureBuildListener&lt;/pre&gt;&lt;p&gt;Ekkor a classpath-hoz a lib könyvtárban található összes jar állományt hozzá fogja adni, és így már megtalálja a jtechlog.ant.MeasureBuildListener osztályt is.&lt;/p&gt;&lt;p&gt;A BuildLogger interfész annyival egészíti ki a BuildListener-t, hogy képes hozzáférni a standard output-hoz, valamint error-hoz. Ezen kívül megkapja a naplózás szintjét, valamint a emacs módot. Indítani a -logger kapcsolóval lehet. Ha ilyent nem adunk meg, a BuildLogger interfészt megvalósító DefaultLogger osztály fog elindulni. Ez egyrészt a naplózás szintje alapján szűri az üzeneteket, valamint az emacs mód is használható, mely arra való, hogy az IDE-k ezt a naplóformátumot könnyen tudják feldolgozni. Egy Ant projekthez csak egy logger kapcsolható, hiszen direkt hozzáférése van az output és error stream-hez. A -emacs kapcsolóval állítható az emacs mód, és a naplózás szintje pedig a -quiet (kevés napló), -verbose (több napló) és -debug (még több napló) kapcsolókkal. Előfordulhat olyan eset is, mikor még a BuildLogger nem kapja meg az üzeneteket, pl. hibás inicializáció esetén, ha hiányzik a build.xml állomány. Ilyenkor az üzenet a konzolra vagy fájlba mehet.&lt;/p&gt;&lt;p&gt;Több beépített naplózó is van, érdemes ezeket is megvizsgálni, saját írása esetén ezek forráskódját is:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;DefaultLogger: alapértelmezett naplózó&lt;/li&gt;&lt;li&gt;NoBannerLogger: nem írja ki a target-ek neveit&lt;/li&gt;&lt;li&gt;MailLogger: e-mail-t küld a build befejezésekor, a különböző beállítások property-kkel adhatóak meg&lt;/li&gt;&lt;li&gt;AnsiColorLogger: a különböző üzeneteket színkódokkal együtt írja ki, melyeket pl. az XTerm és a Win9x Console is tud értelmezni. A színkódokat felül is lehet definiálni egy properties fájlban, melynek helye property-ben adható meg.&lt;/li&gt;&lt;li&gt;Log4jListener (ant-apache-log4j.jar állományban): nagyon hasznos naplózó, képes a Log4J-t használni naplózáshoz (ha benne van a CLASSPATH-ban), és ekkor egy log4j.properties állománnyal konfigurálhatjuk, és kihasználható a Log4J teljes funkcionalitása, mint a Layout-ok, Appender-ek, stb.&lt;/li&gt;&lt;li&gt;XmlLogger: naplózás XML-be&lt;/li&gt;&lt;li&gt;TimestampedLogger: kiírja az időpontokat is&lt;/li&gt;&lt;li&gt;BigProjectLogger: nagy projekteknél alkalmazható, pl. minden task nevénél kiírja a projekt nevét is. Ennek akkor van értelme, ha egy build.xml a subant task-kal egy másik build.xml állományt hív meg.&lt;/li&gt;&lt;li&gt;CommonsLoggingListener (ant-commons-logging.jar állományban): a Commons Logging-ot használja naplózáshoz, ami meg a Log4J-t, ha benne van a classpath-ban&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Ezen naplózók is a -logger kapcsolóval használhatóak, pl.&lt;/p&gt;&lt;pre&gt;ant -logger org.apache.tools.ant.NoBannerLogger&lt;/pre&gt;&lt;p&gt;A naplózás szinkron, azaz a lassú naplózás lassíthatja a build folyamatot. Persze ez kivédhető Log4J esetén az AsyncAppender használatával.&lt;/p&gt;&lt;p&gt;Az itt említett property-k az ANT_OPTS környezeti változóban megadott -D kapcsolóval adhatóak meg, vagy a build.xml-ben az init target-ben megadott &lt;property&gt; tag-gel.&lt;/property&gt;&lt;/p&gt;&lt;p&gt; A BuildListener-nek van egy SubBuildListener leszármazottja is, ami olyan metódusokat definiál, melyek akkor hívódnak meg, ha egy gyermek build folyamat elindul vagy befejeződik (pl. ant, subant, antcall task-kal).&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/1461810755938682590/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2010/01/ant-listener-es-logger-osztalyok.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1461810755938682590'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1461810755938682590'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/01/ant-listener-es-logger-osztalyok.html' title='Ant listener és logger osztályok'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2978305213591579409</id><published>2009-12-27T11:56:00.005+01:00</published><updated>2014-01-12T16:45:14.048+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='SOA'/><category scheme='http://www.blogger.com/atom/ns#' term='JAX-RS'/><title type='text'>RESTful web szolgáltatások Jersey-vel</title><content type='html'>&lt;p&gt;Frissítve: 2014. január 12.&lt;/p&gt;

&lt;p&gt;Felhasznált technológiák: Java 7, Jersey 2.5.1, JQuery 1.8.3, Jackson 1.9.13, JUnit 4.11, Maven 3.0.3, Jetty 9.1.0&lt;/p&gt;

&lt;p&gt;Az általam is már többször részletezett, nehézsúlyú, bonyolult SOAP alapú web szolgáltatások és API-k összetettségét ellensúlyozva jelent meg Roy Fielding PhD dolgozata alapján a REST fogalom.&lt;/p&gt;

&lt;p&gt;Most egy egyszerű kliens-szerver alkalmazást kellett írnom, ahol különböző eseményeket kellett küldenem a szerver oldalra. Az RMI-t elvetettem, hiszen bonyolultabban vezethető át a protokollja a tűzfalon, és csak Java-ból használható, a SOAP-ot ágyúnak éreztem, képbe került még az XML-RPC, mely nem szabványos, így választásom a JAX-RS-re esett, mellyel Java-ban lehet RESTful web szolgáltatásokat építeni.&lt;/p&gt;

&lt;p&gt;A JAX-RS egy specifikáció (JSR 311), melynek több implementációja is létezik, köztük a referencia implementáció, a Jersey.&lt;/p&gt;

&lt;p&gt;A REST egy szoftver architektúra, mely létező, bevált protokollokra, szabványokra építkezik, ahelyett, hogy újat találjon ki. Úgynevezett erőforrásokból (resource) építkezik, és mindegyik ilyen erőforrásnak van egyedi azonosítója, és ezeket össze is lehet linkelni. A kliens ezen erőforrásokat kéri le, azok azonosítója alapján, de lehetőség van új erőforrás hozzáadására, módosítására, törlésére is. A kérések egymástól függetlenek, nem létezik munkamenet (session) fogalom, a kliens mindig az adott erőforrás egy adott állapotát kapja vissza. (Emiatt egyszerűbb az architektúra, könnyen megoldható a gyorsítótárazás - cache, valamint a terhelés elosztás.) Az erőforrásokat különböző módon lehet megjeleníteni, pl. egy számsort magával a számok sorozatával, de akár egy grafikonnal. Ezen tulajdonságok alapján jött a rövidítés: representational state transfer.&lt;/p&gt;

&lt;p&gt;A felhasznált létező szabványok az URI, mellyel az erőforrások azonosítója adható meg. Az erőforrások különböző megjelenítési módjait MIME type-pal lehet megadni, ami lehet egyszerű szöveg, html, xml, vagy manapság az egyre divatosabb JSON is, vagy speciálisabb esetekben pl. kép is. A leggyakrabban használt protokoll a HTTP, hiszen ez biztosítja a kliens-szerver architektúrát, állapotmentességet, cache-elhetőséget, különböző rétegek kialakítását (akár transzarens módon a titkosítást, lásd https), valamint ez van átengedve a legtöbb hálózati eszközön, tűzfalon. A HTTP metódusaival a CRUD műveleteket is megvalósíthatóak, a legtöbbet használt GET, POST mellett létezik a PUT és DELETE is. Ugyanúgy, ahogy a klasszikus web szolgáltatások esetében, más protokoll is választható.&lt;/p&gt;

&lt;p&gt;A JAX-RS a JAX-WS-hez hasonlóan egyszerű POJO-kkal dolgozik, melyekre annotációkat kell használni.&lt;/p&gt;

&lt;p&gt;Használatának demonstrálására egy példa projektet készítettem, mely könyvjelzők nyilvántartását végzi, és &lt;a href="https://github.com/vicziani/jtechlog-rest"&gt;elérhető a GitHub-on.&lt;/a&gt; A következő URL-eket definiáltam:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;/bookmarks: GET esetén XML vagy JSON formátumban adja vissza az eddig elküldött eseményeket, POST esetén az eseményt várja XML vagy JSON formátumban, melyet elment&lt;/li&gt;
  &lt;li&gt;/bookmarks/14: XML vagy JSON formátumban adja vissza a 14-es azonosítójú eseményt&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Első esetben a visszaadott XML:&lt;/p&gt;

&lt;pre class="brush: xml"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; standalone=&amp;quot;yes&amp;quot;?&amp;gt;
&amp;lt;bookmarks&amp;gt;
 &amp;lt;bookmark&amp;gt;
  &amp;lt;id&amp;gt;1&amp;lt;/id&amp;gt;
  &amp;lt;url&amp;gt;http://jtechlog.blogspot.hu&amp;lt;/url&amp;gt;
  &amp;lt;title&amp;gt;JTechLog&amp;lt;/title&amp;gt;
 &amp;lt;/bookmark&amp;gt;
&amp;lt;/bookmarks&amp;gt;&lt;/pre&gt;

&lt;p&gt;Ugyanez JSON-ben:&lt;/p&gt;
&lt;pre class="brush: javascript"&gt;[{
 "id": 1,
 "url": "http://jtechlog.blogspot.hu",
 "title": "JTechLog"
}]&lt;/pre&gt;

&lt;p&gt;Amennyiben egy könyvjelzőt szeretnénk lekérdezni, vagy felküldeni, csak a bookmark tag tartalma használandó. Amennyiben nem XML-lel akarunk dolgozni, használható az "application/xml" helyett pl. az "application/json" MIME type is.&lt;/p&gt;

&lt;p&gt;Először készítsük el az eseményt reprezentáló osztályt:&lt;/p&gt;

&lt;pre class="brush: java"&gt;@XmlRootElement
public class Bookmark {
 private Long id;

 private String url;

 private String title;

 // konstruktorok, getter/setter metódusok
}&lt;/pre&gt;

&lt;p&gt;Figyeljük meg a @XmlRootElement annotációt! Utána készítsük el az erőforrást reprezentáló osztályt:&lt;/p&gt;

&lt;pre class="brush: java"&gt;@Path(&amp;quot;/bookmarks&amp;quot;)
public class BookmarkResource {

    private static BookmarkDao bookmarkDao = BookmarkDao.getBookmarkDao();

    @GET
    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    public List&amp;lt;Bookmark&amp;gt; listBookmarks() {
        return bookmarkDao.listBookmarks();
    }

    @GET
    @Path(&amp;quot;/{id}&amp;quot;)
    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    public Bookmark findBookmark(@PathParam(&amp;quot;id&amp;quot;) long id) {
        Bookmark bookmark = bookmarkDao.findBookmark(id);
        if (bookmark == null) {
            throw new WebApplicationException(Response.Status.NOT_FOUND);
        }
        return bookmark;
    }

    @POST
    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    @Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    public Response createBookmark(Bookmark bookmark) {
        Bookmark createdBookmark = bookmarkDao.createBookmark(bookmark);
        return Response.status(Response.Status.CREATED).entity(createdBookmark).build();
    }
}&lt;/pre&gt;

&lt;p&gt;Látható, hogy az erőforrásban három metódust definiáltunk, rendre a következő funkciókkal: könyvjelzők betöltése, könyvjelző betöltése, könyvjelzők mentése. Mindhárom a /bookmarks címen érhető el, mint az osztályon lévő @Path annotáció mutatja. Az első két funkció GET metódussal érhető el, és XML és JSON kimenetet is képes gyártani (@Produces annotáció), a harmadik POST metódussal, és képes XML és JSON bemenetet is fogadni (@Consumes annotáció). A második metódusnál figyeljük meg, hogy az URL-ben megadhatók változók is, melyre később a @PathParam annotációval hivatkozunk.&lt;/p&gt;

&lt;p&gt;Ahhoz, hogy a kérés ki is legyen szolgálva, elegendő egy @ApplicationPath annotációval ellátott osztályt készíteni:&lt;/p&gt;&lt;pre class="brush: java"&gt;@ApplicationPath("resources")
public class JtechlogRestApplication extends ResourceConfig {

    public JtechlogRestApplication() {
        register(org.glassfish.jersey.jackson.JacksonFeature.class);
        packages("jtechlog.rest");
    }
}&lt;/pre&gt;

&lt;p&gt;És most nézzük a teszt esetet, mondjuk az események lekérdezését. Érdekessége, hogy elindít egy inmemory konténert, és azon keresztül történik a hívás.&lt;/p&gt;

&lt;pre class="brush: java"&gt;@Test
public void testListBookmark() {
 // Given
 BookmarkDao.getBookmarkDao().createBookmark(createBookmark(&amp;quot;http://jtechlog.blogspot.hu&amp;quot;, &amp;quot;JTechLog&amp;quot;));
 BookmarkDao.getBookmarkDao().createBookmark(createBookmark(&amp;quot;https://github.com/vicziani&amp;quot;, &amp;quot;GitHub&amp;quot;));

 // When
 List&amp;lt;Bookmark&amp;gt; bookmarks = target(&amp;quot;bookmarks&amp;quot;).request().accept(MediaType.APPLICATION_JSON_TYPE).get(new GenericType&amp;lt;List&amp;lt;Bookmark&amp;gt;&amp;gt;(){});

 // Then
 assertEquals(2, bookmarks.size());
 assertEquals(&amp;quot;JTechLog&amp;quot;, bookmarks.get(0).getTitle());
}&lt;/pre&gt;

&lt;p&gt;Látható, hogy ez a RESTful web szolgáltatások használata nem csak az API ismeretét igényli, hanem egy másfajta gondolkodásmódot is.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/2978305213591579409/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/12/restful-web-szolgaltatasok-jersey-vel.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2978305213591579409'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2978305213591579409'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/12/restful-web-szolgaltatasok-jersey-vel.html' title='RESTful web szolgáltatások Jersey-vel'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7702941157953822693</id><published>2009-12-27T11:45:00.003+01:00</published><updated>2009-12-27T11:55:46.863+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='oo'/><category scheme='http://www.blogger.com/atom/ns#' term='könyv'/><title type='text'>Matt Weisfeld: The object-oriented thrught process</title><content type='html'>&lt;div style="text-align: left;"&gt;Egy oktatás miatt olvastam el az Addison Wesley kiadásában megjelent Matt Weisfeld: The object-oriented thrught process könyvet. A harmadik kiadásnál tartó könyv megcélzott olvasóközönsége azon vezetők, tervezők, fejlesztők, akik el szeretnék sajátítani az objektumorientált (oo.) gondolkodásmód alapjait, mindezt programozási nyelv és technológia függetlenül.&lt;/div&gt;&lt;p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_czKgycLvmNo/Szc878bfQ3I/AAAAAAAAEzg/xKoKce6rar0/s1600-h/oo_book"&gt;&lt;img src="http://4.bp.blogspot.com/_czKgycLvmNo/Szc878bfQ3I/AAAAAAAAEzg/xKoKce6rar0/s320/oo_book" border="0" alt="" id="BLOGGER_PHOTO_ID_5419867677095052146" style="display: block; margin-top: 0px; margin-right: auto; margin-bottom: 10px; margin-left: auto; text-align: center; cursor: pointer; width: 164px; height: 210px; " /&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Az első kilenc fejezet az oo. alapfogalmait mutatja be: objektumok, osztályok, egységbezárás (encapsulation), információrejtés elve (data hiding), újrafelhasználhatóság módjai (öröklődés és aggregáció), kiterheszthetőség, karbantarthatóság, többalakúság (polymorphism), absztrakt osztályok és interfészek, konstruktorok, metódus túlterhelés (overloading). A könyv több oldalról közelíti meg a black box technikát, mely szerint elegendő ismerni az interfészt (melyet javasolt mindig az azt felhasználó szemszögéből megtervezni, és minél szűkebbre venni, és iteratív módon bővíteni) és az ahhoz tartozó szemantikát (ő szerződésnek - contract nevezi, gyakorlatilag az API-ról és annak dokumentációjáról van szó), az implementáció maradjon rejtve. Így az osztályaink között laza kötés lesz, az implementációt változtathatjuk anélkül, hogy azt az interfészen keresztül használó osztályainkat módosítani kéne, növelve ezzel az átláthatóságot, karbantarthatóságot, robosztusságot, tesztelhetőséget. Előjönnek az oo. világban unalomig használt példák, mint a síkidom, és leszármazottjai, a kutyafajták, az autó és annak részei, és az általam is oly gyakran emlegetett alkalmazott osztály.&lt;/p&gt;&lt;p&gt;Ezen blokknak kicsit kilógó eleme a 6. fejezet (Designing with Objects), mely a témát egy fejlesztési folyamaton keresztül kívánja szemléltetni, a követelményelemzéstől a tervezésig (CRC kártyák használatával, UML osztálydiagrammok előállításáig). Kicsit elnagyolt rész ez, ahol kevés kitekintés van a különböző módszertanokra, valamint azok többi részére (pl. az agilis módszertanok megemlítésre sem kerülnek).&lt;/p&gt;&lt;p&gt;A 10. fejezet (Creating Object Models with UML) az UML osztálydiagrammjának pár elemét mutatja be, de nagyon alap szinten. Nagyon jó ötletnek tartottam a 11. (Objects and Portable Data: XML) és 12. fejezet (Persistent Objects: Serialization and Relational Databases) témáját, amivel oo-val foglalkozó könyvek keveset írnak. Sajnos amennyire jó a témaválasztás, annyira rossz a kivitelezése. Az író az eddigi Java példákról átváltott a .NET-es példákra, feltehetőleg nem ismerte a JAXB technológiát, melynek C#-os változatát ismerhetjük meg ebben a fejezetben, valamint a prezisztenciánál kizárólag a szerializáció lett megemlítve, és tévesen az object-relational mapping (ORM) néven a JDBC. Valódi ORM-ről szó sem esik, mint pl. a JPA, mely tényleg objektumorientált megközelítés, szemben a JDBC-vel, ami inkább procedúrális megközelítés.&lt;/p&gt;&lt;p&gt;A következő két fejezet (Objects and the Internet, Objects and Client/Server Applications) az elosztott alkalmazásoknál alkalmazott oo. technológiákat ismerteti, először a JavaScript oo. lehetőségeit, majd részletesebben a CORBA-t, és felületesen a web szolgáltatásokat. Két egyszerű kliens/szerver alkalmazás is bemutatásra kerül, az első szerializálva viszi át az adatokat, a második XML-ben, TCP socket-en keresztül.&lt;/p&gt;&lt;p&gt;Az utolsó fejezet (Design Patterns) a tervezési mintákról szól, a tervezési minták három csoportjából (creational, structural és behavioral) mutat egyet-egyet (singleton, adapter és MVC), áttekintő szinten.&lt;/p&gt;&lt;p&gt;A könyvet így azoknak tudom ajánlani, akiknek az oo. fogalomrendszer nem ismert. Így kiváló lehet pl. azoknak, akik még csak most tanulják ezeket (pl. főiskolai vagy egyetemi tárgy ajánlott olvasmányának), vagy akik most váltanak struktúrális programozásról oo. programozásra (pl. COBOL-ról, PL/SQL-ről, C-ről). A könyv egy hétvége alatt elolvasható. Azoknak azonban, akiknek az ebben a bejegyzésben leírt fogalmak ismertek, azaz már legalább egy fél éve programoznak valamilyen oo. programozási nyelven, a könyv nem fog sok újdonságot mutatni. Demonstráióként főleg UML diagrammok és Java programok szerepelnek, de olyan egyszerűek, hogy programozási ismeretek nélkül is megérthetőek (és a legtöbb példa átirata is szerepel a fejezet végén C# és VB nyelven). Sajnos a Java kód minősége nem éppen megfelelő, gyakran a legalapvetőbb konvenciók sincsenek betartva (pl. váltózó vagy metódus nevek kisbetűvel).&lt;/p&gt;&lt;p&gt;Nagy várakozással vettem kezembe a könyvet, mert ugyanezen sorozatban (Developer's Library) jelent meg egyik kedvenc könyvem (Agile Java Development with Spring, Hibernate and Eclipse), és valami hasonlót vártam itt is. Összességében elmondható, hogy a könyv első kilenc fejezete kiváló, szájbarágós, bevezető anyag az oo. gondolkodásba, sok ismétléssel, így gyakorlatilag beleveri az emberbe a tudást. A többi fejezet témája is nagyon jó ötlet, de nem jól megvalósított. Az UML-ből több is belefért volna (ugyanennyi oldalon az UML Distilled sokkal több információt ad át), az egyéb fejlettebb oo. technológiákból elegendő lett volna a szerializáció, XML-binding, az ORM és a CORBA (sőt, inkább az RMI) elméleti alapjait kifejteni, mintsem a valóságtól távol álló tutorial szagú kódrészleteket mutatni. Ezekre inkább ezért más könyveket javaslok.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/7702941157953822693/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/12/matt-weisfeld-object-oriented-thrught.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7702941157953822693'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7702941157953822693'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/12/matt-weisfeld-object-oriented-thrught.html' title='Matt Weisfeld: The object-oriented thrught process'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://4.bp.blogspot.com/_czKgycLvmNo/Szc878bfQ3I/AAAAAAAAEzg/xKoKce6rar0/s72-c/oo_book' height='72' width='72'/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-603861174982151559</id><published>2009-11-30T22:32:00.006+01:00</published><updated>2014-01-20T14:17:20.961+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='StAX'/><title type='text'>StAX</title><content type='html'>&lt;p&gt;Frissítve: 2014. január 20.&lt;/p&gt;

&lt;p&gt;Technológiák: JAXP 1.4, StAX 1.0&lt;/p&gt;

&lt;p&gt;Ha már a web szolgáltatásokról volt szó, mely szorosan kapcsolódik az XML-hez, nézzük, hogy mi újítást hozott a JDK 6-ban bevezetett JAXP 1.4. A legnagyobb újdonság a StAX bevezetése, mely egy nagy teljesítményű stream alapú XML feldolgozó szűréssel (filter), mely támogatja a módosítást is.&lt;/p&gt;

&lt;p&gt;A JAXP-ben már a W3C által definiált SAX és DOM feldolgozási modell régóta létezett. A SAX esetében esemény alapú feldolgozást lehet megvalósítani, ahol a feldolgozó (parser) hívja az osztályainkat (parser client). Ezt hívják un. push parser-nek, mikor a parser megy végig az XML-elen, és tolja nekünk az adatokat. Ezt viszonylag nehéz programozni, mert tárolni kell az állapotot, manuálisan kell pl. vermet kezelni, hogy tároljuk, hol tartunk a feldolgozásban. A DOM a teljes XML-t betölti egy faként a memóriába, melyen lehet fabejárást is végezni, sőt tetszőlegesen módosítható is. Ez könnyen használható, a fa adatszerkezetet is a legtöbben ismerik, viszont rengeteg memóriára van szüksége. Ennek feloldására a BEA kezdett el kidolgozni egy API-t, mely a JSR 173 specifikációban lett megfogalmazva, Streaming API for XML címmel.&lt;/p&gt;

&lt;p&gt;Célja, hogy egyszerűbben programozható legyen, mint a SAX, de kevesebb memóriát fogyasszon, mint a DOM. Streaming API-nak nevezik, mert a parser XML dokumentumnak csak egy részét látja egyszerre. Itt jön képbe a consume (felemészt) fogalom is, ami azt jelenti, hogy a stream-en nem haladhatunk visszafele, így ha egyszer átment rajta a parser, akkor a stream beolvasásra került, tehát ha újra fel akarjuk dolgozni, valamilyen módon biztosítani kell a stream újra rendelkezésre állását (pl. klónozás). Ezen kívül a parser-t pull parser-nek nevezik, mert a kliens irányítja, ő kéri el az adatokat. Ennek több előnye is van, pl. egyszerre több dokumentumot is lehet párhuzamosan feldolgozni, akár összefésülni az eredményeket, valamint a szálat teljes kontroll alatt lehet tartani, ugyanis akkor szüneteltetjük a végrehajtást, mikor akarjuk. A library is kisebb lesz, és a kliens kód is kisebb lesz.&lt;/p&gt;

&lt;p&gt;A StAX további előnye, hogy nem csak olvasni (pl. SAX) képes a dokumentumokat, hanem írni is képes azokat. A StAX alapvetően két API-val is rendelkezik, az egyik a cursor API, a másik az iterator API. E mögötti meggondolás az, hogy inkább két egyszerű API-t készítenek, mint egy bonyolultat. Az előbbihez az XMLStreamReader, és XMLStreamWriter osztályok tartoznak, míg a másodikhoz az XMLEventReader és XMLEventWriter osztályok.&lt;/p&gt;

&lt;p&gt;A példa projekt &lt;a href="https://github.com/vicziani/jtechlog-xml"&gt;letölthető a GitHubról&lt;/a&gt;. Nézzük is a cursor API használatával hogyan dolgoznánk fel a következő XML fájlt:&lt;/p&gt;

&lt;pre class="brush:xml"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;

&amp;lt;catalog&amp;gt;
    &amp;lt;book isbn10=&amp;quot;059610149X&amp;quot;&amp;gt;
        &amp;lt;title&amp;gt;Java and XML&amp;lt;/title&amp;gt;
        &amp;lt;author&amp;gt;Brett McLaughlin, Justin Edelson&amp;lt;/author&amp;gt;
        &amp;lt;publisher&amp;gt;O'Reilly Media&amp;lt;/publisher&amp;gt;
        &amp;lt;year&amp;gt;2006&amp;lt;/year&amp;gt;
    &amp;lt;/book&amp;gt;
    &amp;lt;book isbn10=&amp;quot;1590597060&amp;quot;&amp;gt;
        &amp;lt;title&amp;gt;Pro XML Development with Java Technology&amp;lt;/title&amp;gt;
        &amp;lt;author&amp;gt;Ajay Vohra&amp;lt;/author&amp;gt;
        &amp;lt;publisher&amp;gt;Apress&amp;lt;/publisher&amp;gt;
        &amp;lt;year&amp;gt;2005&amp;lt;/year&amp;gt;
    &amp;lt;/book&amp;gt;
    &amp;lt;book isbn10=&amp;quot;1449365116&amp;quot;&amp;gt;
        &amp;lt;title&amp;gt;Java Web Services: Up and Running&amp;lt;/title&amp;gt;
        &amp;lt;author&amp;gt;Martin Kalin&amp;lt;/author&amp;gt;
        &amp;lt;publisher&amp;gt;O'Reilly Media&amp;lt;/publisher&amp;gt;
        &amp;lt;year&amp;gt;2013&amp;lt;/year&amp;gt;
    &amp;lt;/book&amp;gt;
&amp;lt;/catalog&amp;gt;
&lt;/pre&gt;

&lt;p&gt;A kód, mely ezt feldolgozza cursor API használatával:&lt;/p&gt;

&lt;pre class="brush:java"&gt;List&amp;lt;Book&amp;gt; catalog = new ArrayList&amp;lt;&amp;gt;();
XMLInputFactory f = XMLInputFactory.newInstance();
XMLStreamReader r = f.createXMLStreamReader(source);
Book book = null;
while (r.hasNext()) {                
 if (r.getEventType() == XMLStreamConstants.START_ELEMENT) {
  if (&amp;quot;book&amp;quot;.equals(r.getName().getLocalPart())) {
   book = new Book();
   catalog.add(book);
   book.setIsbn10(r.getAttributeValue(null, &amp;quot;isbn10&amp;quot;));
  }
  else if (&amp;quot;title&amp;quot;.equals(r.getName().getLocalPart())) {
   book.setTitle(r.getElementText());
  }
 }
 r.next();
}
return catalog;
&lt;/pre&gt;

&lt;p&gt;Látható, hogy először gyártatunk egy &lt;code&gt;XMLInputFactory&lt;/code&gt; példányt, majd egy &lt;code&gt;XMLStreamReader&lt;/code&gt; példányt. Amíg tart a feldolgozás, addig feldolgozzuk az adatokat, de mindig mi lépünk a következő adatra a &lt;code&gt;next()&lt;/code&gt; metódus segítségével (pull API). Az adat típusa, melyen a reader éppen áll, az XML-nél megszokottak lehetnek: XML deklaráció, nyitó tag, záró tag, karakterek, megjegyzések, stb. Attól függően, hogy mi, hívhatjuk meg a reader többi metódusát. Pl. nyitó tag esetén lekérdezhető a &lt;code&gt;getName&lt;/code&gt; metódussal a neve, vagy &lt;code&gt;getText&lt;/code&gt;metódussal a tartalma, sőt a &lt;code&gt;getAttribute*&lt;/code&gt; kezdetű metódusokkal az attribútumai is. A &lt;code&gt;XMLStreamException&lt;/code&gt; kivételt kezelni kell.&lt;/p&gt;

&lt;p&gt;Nézzük, hogyan írjunk ki egy hasonló XML dokumentumot:&lt;/p&gt;&lt;div class="se-section-delimiter"&gt;&lt;/div&gt;

&lt;pre class="brush:java"&gt;StringWriter sw = new StringWriter();
XMLOutputFactory output = XMLOutputFactory.newInstance();
XMLStreamWriter writer = output.createXMLStreamWriter(sw);
writer.writeStartDocument();
writer.writeStartElement(&amp;quot;catalog&amp;quot;);
for (Book book: catalog) {
 writer.writeStartElement(&amp;quot;book&amp;quot;);
 writer.writeAttribute(&amp;quot;isbn10&amp;quot;, book.getIsbn10());
 writer.writeStartElement(&amp;quot;title&amp;quot;);
 writer.writeCharacters(book.getTitle());
 writer.writeEndElement();
 writer.writeEndElement();
}
writer.writeEndElement();
writer.flush();
return sw.toString();&lt;/pre&gt;

&lt;p&gt;Nézzük az XML feldolgozást most az iterator API segítségével:&lt;/p&gt;

&lt;pre class="brush:java"&gt;List&amp;lt;Book&amp;gt; catalog = new ArrayList&amp;lt;&amp;gt;();
XMLInputFactory f = XMLInputFactory.newInstance();
XMLEventReader r = f.createXMLEventReader(source);
Book book = null;
while (r.hasNext()) {
 XMLEvent event = r.nextEvent();
 if (event.getEventType() == XMLStreamConstants.START_ELEMENT) {
  if (event instanceof StartElement) {
   StartElement element = (StartElement) event;
   if (&amp;quot;book&amp;quot;.equals(element.getName().getLocalPart())) {
    book = new Book();
    catalog.add(book);
    book.setIsbn10(element.getAttributeByName(new QName(&amp;quot;isbn10&amp;quot;)).getValue());
   }
   else if (&amp;quot;title&amp;quot;.equals(element.getName().getLocalPart())) {
    book.setTitle(r.getElementText());
   }
  }
 }
}
return catalog;
&lt;/pre&gt;

&lt;p&gt;Itt látható, hogy nem közvetlenül a &lt;code&gt;reader&lt;/code&gt; példányt szólítjuk meg, hanem az &lt;code&gt;event&lt;/code&gt; példányt. Ezt aztán a megfelelő típusra kényszeríteni kell, és már el is érhetjük a megfelelő metódusait.&lt;/p&gt;

&lt;p&gt;Ahhoz, hogy eldöntsük, hogy a kettő közül melyiket érdemes választani, érdemes a következőket a fejben tartani:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Az iterator API XMLEvent osztályai nem módosíthatóak, a parse-olás után is megőrzik az értéküket&lt;/li&gt;
&lt;li&gt;Emiatt többlépéses (bővíthető, plug-in-elhető) feldolgozásokat is könnyebben ki lehet dolgozni ezen példányok továbbadásával&lt;/li&gt;
&lt;li&gt;A fentiekből következik, hogy a cursor API kevesebb memóriát használ, és a példányosítások hiánya miatt gyorsabb is&lt;/li&gt;
&lt;li&gt;Az &lt;code&gt;XMLEvent&lt;/code&gt; interfészt akár magunk is implementálhatjuk, akár teljesen új eseményt hozhatunk létre, akár egy meglévőt egészíthetünk ki utility metódusokkal&lt;/li&gt;
&lt;li&gt;Az iterator API esetén módosítani is lehet a stream-et &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Összességében, ha nem a teljesítmény az elsődleges szempont, érdemes a magasabb szintű iterator API-t használni.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/603861174982151559/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/11/stax.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/603861174982151559'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/603861174982151559'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/11/stax.html' title='StAX'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6117870073201976470</id><published>2009-11-23T00:05:00.008+01:00</published><updated>2014-02-01T23:11:19.923+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='JAXB'/><category scheme='http://www.blogger.com/atom/ns#' term='JAX-WS'/><category scheme='http://www.blogger.com/atom/ns#' term='Java SE'/><category scheme='http://www.blogger.com/atom/ns#' term='Java EE'/><title type='text'>JAX-WS mélyvíz</title><content type='html'>&lt;p&gt;Frissítve: 2014. február 1.&lt;/p&gt;

&lt;p&gt;Ezzel a címmel tartottam előadást a &lt;a href="http://wiki.javaforum.hu/display/JAVAFORUM/JUM0911"&gt;JUM XII. alkalmán&lt;/a&gt;, mely a ustream.tv-nek köszönhetően &lt;a href="http://www.ustream.tv/flash/video/2585433"&gt;utólag is megnézhető&lt;/a&gt;, és a &lt;a href="http://vicziani.github.com/artifacts/JUM12-Viczian-Istvan-JAX-WS-melyviz.pdf" onclick="pageTracker._trackPageview('/pdf/JUM12-Viczian-Istvan-JAX-WS-melyviz.pdf');"&gt;diák is letölthetőek&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Az előadás kapcsán beszéltem a JAXB és JAX-WS referencia implementációval éles projektben szerzett tapasztalatokról, melyeket itt is összefoglalnék. Megpróbálok általános tippeket is adni, melyet egy SOA bevezetés során figyelembe kell venni.
&lt;/p&gt;&lt;p&gt;A web szolgáltatásokkal kapcsolatban az egyik legnagyobb félreértés az szokott lenni, hogy kizárólag a HTTP(S)/SOAP web szolgáltatásokat értjük alatta. Ez nincs teljesen így, a W3C definíciója szerint a web szolgáltatások hálózaton keresztüli gép-gép együttműködést támogató szoftverrendszerek. Ez elég sok mindenre ráillik. Igaz azonban, hogy a leggyakrabban használt kombináció tényleg a HTTP(S)/SOAP, ahol a HTTP(S) az átviteli (transzport) protokoll, a SOAP az üzenet formátum, de mindkettő lecserélhető, pl. JMS protokollra, vagy JSON üzenetformátumra.&lt;/p&gt;&lt;p&gt;Amennyiben nem saját rendszereink kommunikálnak, már a SOAP-pal kapcsolatban is sok mindenben meg kell egyezni a kommunikáló partnerrel, mely lehet a web szolgáltatást nyújtó, és a web szolgáltatást igénybe vevő fél is. Erről a &lt;a href="http://jtechlog.blogspot.com/2008/11/web-szolgltatsokkal-kapcsolatos.html"&gt;Web szolgáltatásokkal kapcsolatos szabványok&lt;/a&gt; című előző post-omban írok. A WS-I-n kívül meg kell említeni a WS-Security (web szolgáltatások biztonsága), WS-Reliability (biztonságos pontosan egyszeri üzenetküldés web szolgáltatásokkal) és a WS-Transaction (tranzakciókezelés web szolgáltatásokkal, itt a kompenzáló tranzakciókat érdemes megjegyezni) szabványokat is.&lt;/p&gt;&lt;p&gt;Az implementáció lehet bottom up, mikor már létező kódunk próbáljuk web szolgáltáson keresztül is elérni, top down, mikor a WSDL-ből indulunk ki, és fejlesztjük mögé a funkcionalitást, és meet in the middle is, mikor a már létező funkciókat kell egy meghatározott interfészen keresztül kiajánlani - értelemszerűen ez a legbonyolultabb, hiszen nem feltétlenül ugyanaz az interfészben definiált struktúra, mint amit a rendszerünkben már kialakítottunk. Az utóbbi esetben különösen, de amúgy is érdemes nem az üzleti funkcióinkat közvetlenül kiajánlani web szolgáltatásokként, hanem egy külön web szolgáltatás réteget kialakítani. Ez segít nekünk az interfész és az üzleti logika elválasztásában, és az interfészek verziókezelése is egyszerűbb. Persze ebben az esetben számolnunk kell a két réteg közötti adatátvitel miatti többlet munkával (hasonlóan mint mikor az üzleti adatokat DTO-kba másoljuk).&lt;/p&gt;

&lt;p&gt;A webszolgáltatások alapját nyújtó JAXP API-ról a &lt;a href="http://jtechlog.blogspot.hu/2014/01/java-es-az-xml.html"&gt;Java és az XML posztban&lt;/a&gt; írok.&lt;/p&gt;

&lt;p&gt;Szorosan a webszolgáltatásokhoz tartozó API-k közül meg kell említeni a SAAJ API-t (JSR 67 - Java APIs for XML Messaging része), mely a SOAP üzenetek alacsony szintű, DOM faként történő kezelésére való, az JAX-RPC 1.1 API-t (JSR 101), mely egy legacy/deprecated API, távoli eljáráshívás web szolgáltatásokkal, és az ebből kialakúló JAX-WS 2.0 API-t (JSR 224): mely már nem csak RPC-re, hanem dokumentum alapú web szolgáltatások implementálására és hívására is használható. Ezekből a JAXP már régóta a Java SE része, de a többi részlegesen csak a Java SE 6-ban jelent meg. A Java EE 5 már mindet teljes mértékben tartalmazza.&lt;/p&gt;

&lt;p&gt;A JAX-WS követi az EJB3 alapelveket, hogy minél egyszerűbben lehessen programozni, és annotációkkal konfigurálható legyen. A protokoll HTTP(S), de le lehet cserélni JMS-re, SMTP-re, de akár lokális metódushívásokra is (In-VM). A JAX-WS az XML binding-ot JAXB-vel oldja meg, de ezt akár le is lehet cserélni a referencia implementációban (pl. JSON-ra). De akár &lt;code&gt;Source&lt;/code&gt;, &lt;code&gt;SOAPMessage&lt;/code&gt; vagy &lt;code&gt;DataSource&lt;/code&gt; példányként is kezelhetjük az beérkező XML-t, ekkor a &lt;code&gt;Provider&amp;lt;T&amp;gt;&lt;/code&gt; interfészt kell implementálni, ez gyakorlatilag a SEI dinamikus alternatívája szerver oldalon. A payload mód esetén a SOAP boríték belseje kerül átadásra, ellenkező esetben a teljes boríték. Kliens esetében a &lt;code&gt;Dispatch&amp;lt;T&amp;gt;&lt;/code&gt; példányt kell a Service factory-vel gyártani, ami a kliens oldali proxy dinamikus megfelelője.&lt;/p&gt;&lt;p&gt;Fontos fogalom a SEI (Service Endpoint Interface), mely a web szolgáltatásként meghívható metódusokat definiálja. Használata nem kötelező, ekkor implicit SEI generálódik. Kliens oldalon proxy-t kell használni, mely becsomagolja a hívást és áttolja a hálózaton, valamint a választ feldolgozza (marshall/unmarshall). Érdemes még a handlerek ismerete, melyek lehetnek protokoll független (logikai) handlerek, valamint protokollfüggő (pl. SOAP) handlerek is. Ezeket úgy kell elképzelni, mint servletek esetén a filtereket, képesek elkapni a hívásokat, és a válaszokat, és akár módosítani is azt. Tipikusan jók biztonságra, tranzakciókezelésre, naplózásra, AOP web szolgáltatás szinten.&lt;/p&gt;&lt;p&gt;Az inout típusú paramétereket a &lt;code&gt;Holder&lt;/code&gt; osztállyal lehet kezelni.&lt;/p&gt;&lt;p&gt;A JAX-WS aszinkron hívást is támogat, ilyenkor a kliens egy külön szálon hívja a web szolgáltatást, és az alkalmazás futhat tovább blokkolás nélkül. Lehet később visszakérdezni, hogy hogy áll, valamint eseményfigyelőt is lehet a web szolgáltatás hívásának befejezésére definiálni.&lt;/p&gt;&lt;p&gt;A fenti betűszavak csak specifikációk, ezeknek különböző megvalósításai is vannak, a Sun biztosítja a GlassFish projekt keretében a referencia implementációkat. A web szolgáltatásokkal kapcsolatos projektek a Metro gyűjtőprojekt alatt szerepelnek:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;GlassFish &gt; JAXP Reference Implementation&lt;/li&gt;&lt;li&gt;GlassFish &gt; Metro &gt; JAXB Reference Implementation&lt;/li&gt;&lt;li&gt;GlassFish &gt; Metro &gt; SAAJ Standard Implementation&lt;/li&gt;&lt;li&gt;GlassFish &gt; Metro &gt; JAX-WS Reference Implementation&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Sajnos az összes projektet a java.dev.net hosztolja, melynek rendelkezésre állása tragikus. A támogatással sem voltam megelégedve, szemben a SOAPUi gyors reakciójával, ugyanis belefutottam abba a hibába, hogy a SEI-ben nem lehet konstansokat definiálni. A fórumban megkédeztem, hogy miért, hiszen egyik specifikációban sem láttam (, valószínűleg JAX-RPC örökség), és forráskódot is csatoltam. Azóta sem érkezett válasz.
&lt;/p&gt;&lt;p&gt;A legfontosabb dolog, melyre a fejlesztés során rájöttem, hogy nem elegendő a JDK-ban lévő eszközökkel dolgozni, mindig a legfrissebb eszközöket kell használni, mivel mind iszonyú iramban fejlődik, és rengeteg hiba található régebbi verziókban. A &lt;code&gt;schemagen.exe –version&lt;/code&gt; paranccsal lehet a JAXB verzióját lekérdezni, mely a jdk1.6.0_17-ban JAXB 2.1.10 in JDK 6, a JAX-WS-t a &lt;code&gt;wsimport –version&lt;/code&gt; paranccsal, melynek verziója ugyanezen JDK-ban JAX-WS RI 2.1.6 in JDK 6. Mostanában akár update verziónál is változik a JDK-ban lévő JAXB vagy JAX-WS implementáció, ezzel kapcsolatos bonyodalmakkal az előbb is említett posztom foglalkozik. Azóta kiderült, hogy a régebbi verzió az &lt;code&gt;ANY&lt;/code&gt; típusú tag-et sem megfelelően kezelte, valamint az Axis által küldött mime fejléccel is problémái voltak. A verziófrissítés mindkét problémát megoldotta (az utóbbinál a teljes JDK-t kellett).&lt;/p&gt;&lt;p&gt;A JAXB és JAX-WS parancssori eszközök mindegyikének van Ant task párja is.
&lt;/p&gt;&lt;p&gt;Teszteléshez mindenképp a SOAPUi eszközt javaslom, mely képes nem csak web szolgáltatásokat meghívni, hanem szimulálni is. Erre is érvényes a verziókkal kapcsolatos megállapításom. Az attachment kezeléssel belefutottam egy hibába a 3.0.1-es verzióval (Exception, üres kérést generált), amit &lt;a href="http://www.eviware.com/forums/index.php?topic=2570.0"&gt;jelentettem is&lt;/a&gt; a fórumon. Másnap jött a válasz, hogy próbáljam meg a nightly build-del, amivel tényleg ment.&lt;/p&gt;&lt;p&gt;A fejlesztés között a verziókon kívül a legtöbb problémám az &lt;code&gt;ANY&lt;/code&gt;típusú tagekkel volt. Példaként nézzünk is egy ilyen részletet:&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;xs:complexType name="AnyType"&amp;gt;
  &amp;lt;xs:sequence&amp;gt;
    &amp;lt;xs:any minOccurs="0" maxOccurs="unbounded"
        namespace="##any" processContents="skip" /&amp;gt;
  &amp;lt;/xs:sequence&amp;gt;
&amp;lt;/xs:complexType&amp;gt;
&lt;/pre&gt;&lt;p&gt;Ebben az esetben a belső tartalmon nem végzi el a JAX unmarshallt, hanem DOM-ot kapunk. Ezt nekünk kell manuálisan unmarshallolni. A JAXB File, Stream és DOM-on kívül képes unmarshallolni bármilyen &lt;code&gt;Source&lt;/code&gt;-ból, valamint a StAX-os &lt;code&gt;XMLStreamReader&lt;/code&gt;-ből és &lt;code&gt;XMLEventReader&lt;/code&gt;-ből is. &lt;code&gt;ANY&lt;/code&gt; esetén egy olyan hibába is beleütköztem, hogyha más névtérben volt a belső tartalom, és az nem volt prefix-szel megjelölve, akkor annak elrontotta a névterét. A &lt;code&gt;setPrefix&lt;/code&gt; hívás segített.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;JAXBContext&lt;/code&gt;-et érdemes cache-elni, hiszen szálbiztos.&lt;/p&gt;&lt;p&gt;A &lt;code&gt;JAXBElement&lt;/code&gt; a JAXB 2.0-ban jelent meg. Az XJC, ha az adott típus nem használható más néven, akkor egy POJO-t generál. Azonban ha használható, akkor &lt;code&gt;JAXBElement&lt;/code&gt; példányba burkolva lehet használni. Ezt kikerülhetjük, ha használjuk a gyártófüggő &lt;code&gt;&amp;lt;xjc:simple /&amp;gt;&lt;/code&gt; konfigurációt, vagy mi példányosítunk  &lt;code&gt;new JAXBElement(new QName("uri","local"), MessageType.class, messageType)&lt;/code&gt; módon.&lt;/p&gt;&lt;p&gt;Alapesetben webszolgáltatás híváskor teljesítmény okok miatt nem történik validáció, de ezt a &lt;code&gt;com.sun.xml.ws.developer.SchemaValidation&lt;/code&gt; annotációval bekapcsolhatjuk a &lt;code&gt;@WebService&lt;/code&gt; annotációt tartalmazó osztályon.
&lt;/p&gt;&lt;p&gt;Attachmentet &lt;a href="https://jax-ws.dev.java.net/guide/Binary_Attachments.html"&gt;kezelhetünk&lt;/a&gt; SwA (SOAP with attachment), és MTOM szabvány szerint is. Mivel az előbbi már kevésbé támogatott, az utóbbit érdemes használni. Az MTOM (SOAP Message Transmission Optimization Mechanism) egy szabvány arra, hogyan tud egy SOAP kommunikációban a két kommunikáló fél megegyezni abban, hogy kihasználva az átviteli közeg előnyeit vigyen át adatokat. Ennek egy megvalósítása a XOP-ra (XML-binary Optimized Packaging) épülő Optimized MIME Multipart/Related Serialization of SOAP Messages). Ez gyakorlatilag azt jelenti, hogy egy állományt hatékonyabban lehet átvinni, ugyanis nem a szöveges kommunikációba lesz bekódolva BASE64-gyel, ami 33%-kkal növeli a hosszt, hanem az e-mail-hez hasonlóan az üzenet két különböző mime type-ú részre van osztva, egy szövegesre, mely hivatkozik az állományra (&lt;code&gt;xop:Include&lt;/code&gt; tag-gel), és egy binárisra, mely tartalmazza az állományt. JAX-WS-ben az &lt;code&gt;@MTOM&lt;/code&gt; annotációval lehet kihasználni. Az XML &lt;code&gt;xop:Include&lt;/code&gt; hivatkozást fog tartalmazni. Sajnos nekem az előbbit kellett használnom, ahol az &lt;code&gt;attachment&lt;/code&gt;-et kötelező megadni, sajnos a másik fél, nem alkalmazkodott a szabványhoz, így 0 bájtos állományokat kellett küldenünk.&lt;/p&gt;&lt;p&gt;A WSDL-lel kapcsolatban is belefutottunk egy &lt;a href="https://jax-ws.dev.java.net/issues/show_bug.cgi?id=627"&gt;hibába&lt;/a&gt;, a &lt;code&gt;wsdlLocation&lt;/code&gt; beállítása relatív, protokoll nélkül nem működött (CLASSPATH-ról resource). A 2.2-es JAX-WS-ben javítva.
&lt;/p&gt;&lt;p&gt;Sajnos a NetBeans-sel is voltak problémáim. Amennyiben az interfész nem volt megfelelő (pl. &lt;code&gt;BARE = "unwrapped"&lt;/code&gt; módnál több paraméter megadása, vagy &lt;code&gt;List&lt;/code&gt; típusú visszatérési érték), nagyon szűkszavú hibaüzenet írt ki: &lt;code&gt;Error starting wsgen:&lt;/code&gt;. Ebből nem lehetett rájönni a hiba okára, a megoldás a &lt;code&gt;jaxws-build.xml&lt;/code&gt;-ben a &lt;code&gt;wsgen&lt;/code&gt; Ant task-nál a &lt;code&gt;verbose="true" fork="true"&lt;/code&gt; paraméterek elhelyezése. Ezt beírva a hibaüzenetek már beszédesebbek, több paraméter esetén:
&lt;/p&gt;&lt;pre&gt;Exception in thread "main" com.sun.xml.ws.model.RuntimeModelerException:
runtime modeler error: SEI [osztály neve] has method [metódus neve] annotated as
BARE but it has more than one parameter bound to body. This is invalid.
Please annotate the method with annotation:
@SOAPBinding(parameterStyle=SOAPBinding.ParameterStyle.WRAPPED)
&lt;/pre&gt;&lt;p&gt;List visszatérési érték esetén:&lt;/p&gt;&lt;pre&gt;Exception in thread "main" com.sun.xml.ws.model.RuntimeModelerException:
runtime modeler error: SEI [osztály neve] has method [metódus neve] annotated as
BARE but it has more than one parameter bound to body. This is invalid.
Please annotate the method with annotation:
@SOAPBinding(parameterStyle=SOAPBinding.ParameterStyle.WRAPPED)&lt;/pre&gt;&lt;p&gt;Sajnos a NetBeans-ben a WSDL validáció sem működik, ha szerepel benne az attachment miatt &lt;code&gt;&amp;lt;mime:multipartRelated&amp;gt;&lt;/code&gt; tag. Hibaüzenet: &lt;code&gt;"ERROR: At least one &amp;lt;soap:body&amp;gt; element is required per input/ouput message in a soap operation."&lt;/code&gt;
&lt;/p&gt;&lt;p&gt;A JAX-WS Spring-gel is használható, a GlassFish &gt; Metro &gt; JAX-WS commons &gt; Spring support projekttel. Sajnos ebbe is hibába futottam, ugyanis ha a WSDL-t kézzel akarjuk megadni (sajnos a megoldás nem szimmetrikus, WSDL alapján gyártott osztályok nem mindig ugyanazt a WSDL-t generálják ki), akkor nem lehet több erőforrás megadni a Spring névteres módon, hanem trükközni kell. Álljon itt egy Spring &lt;code&gt;applicationContext.xml&lt;/code&gt; részlet erre.&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;bean id="metadata" class="java.util.ArrayList" &amp;gt;
  &amp;lt;constructor-arg&amp;gt;
    &amp;lt;list&amp;gt;
      &amp;lt;value&amp;gt;/WEB-INF/wsdl/1.xsd&amp;lt;/value&amp;gt;
      &amp;lt;value&amp;gt;/WEB-INF/wsdl/2.xsd&amp;lt;/value&amp;gt;
    &amp;lt;/list&amp;gt;
   &amp;lt;/constructor-arg&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean id="loggingHandler" class="jtechlog.LoggingHandler"/&amp;gt;

&amp;lt;wss:binding url="/service"&amp;gt;
  &amp;lt;wss:service&amp;gt;
    &amp;lt;ws:service bean="#mySIB"&amp;gt;
      &amp;lt;ws:handlers&amp;gt;
        &amp;lt;ref bean="loggingHandler" /&amp;gt;
      &amp;lt;/ws:handlers&amp;gt;
      &amp;lt;property name="metadata" ref="metadata" /&amp;gt;       
    &amp;lt;/ws:service&amp;gt;
  &amp;lt;/wss:service&amp;gt;
&amp;lt;/wss:binding&amp;gt;&lt;/pre&gt;&lt;p&gt;A NetBeans-nek nem lehet megmagyarázni, hogy Spring-gel akarom használni a web szolgáltatást, ő mindenképp generálni akarja a szabvány JAX-WS-es dolgokat.&lt;/p&gt;&lt;p&gt;A naplózásra érdemes még kitérni. &lt;code&gt;Handler&lt;/code&gt;-rel próbáltam megoldani. Először is összeakadt a Handler, Tomcat, Log4J hármas, lefagyott tőle a Tomcat, de csak kivétel esetén (persze rendesen le volt kezelve) - valahogy a konzolra írás és olvasás deadlock-kolt. A NetBeans forrásában látott &lt;code&gt;Thread.sleep(100);&lt;/code&gt; megoldotta a problémát. Ezen kívül nem érdemes erre használni a standard handler-eket, ugyanis van benne DOM parse-olás, inkább javasolt a gyártófüggő &lt;code&gt;com.sun.xml.ws.api.handler.MessageHandler&lt;/code&gt; használata. Sajnos itt is több problémába ütköztem. Érdemes még arra is gondolni, hogy a viszonylag nagyméretű XML-eket érdemes aszinkron naplózni.&lt;/p&gt;&lt;p&gt;Összegzésként azt kell megállapítanom, hogy a Sun ígéretei, miszerint a szabványokat és az eszközeiket úgy alkotják meg, hogy ne kelljen az infrastruktúrával foglalkozni, csupán az üzleti logikára koncentrálni, nem teljesen igaz.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/6117870073201976470/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/11/jax-ws-melyviz.html#comment-form' title='1 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6117870073201976470'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6117870073201976470'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/11/jax-ws-melyviz.html' title='JAX-WS mélyvíz'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-62691511742121495</id><published>2009-11-01T19:34:00.004+01:00</published><updated>2014-02-02T16:33:44.386+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='open source'/><category scheme='http://www.blogger.com/atom/ns#' term='infrastruktúra'/><category scheme='http://www.blogger.com/atom/ns#' term='Community'/><title type='text'>Szabad Szoftver Konferencia</title><content type='html'>&lt;p&gt;Ma volt a Free Software Foundation Hungary Alapítvány által szervezett &lt;a href="http://konf.fsf.hu/cgi-bin/ossc"&gt;Szabad Szoftver Konferencia és Kiállítás 2009&lt;/a&gt;. Úgy látszik, mostanában főleg konferenciabeszámolókat írok, de mostanában nagy a termés, érdemes ellátogatni ezekre, nyomon követni a trendeket. Figyeljétek a jobb oldali Google Naptárat, melybe minden Java-val kapcsolatos hazai eseményt megpróbálok felvenni. A mostani konferenciáról is a meglátogatott előadásokról fogok írni, címszavakban az érdekességekről. A rendezők ígérete szerint legy egy PDF-ben letölthető több, mint 100 oldalas kiadvány, mely minden előadásról 4-5 oldalt fog tartalmazni, valamint a videók is fenn lesznek a &lt;a href="http://videos.flosszine.org/"&gt;FLOSS videóblog&lt;/a&gt; oldalon.&lt;/p&gt;Dr. Szentiványi Gábor A felhőkön túl című előadásából kiderült, hogy az előadó kicsit szkeptikus a felhők jelenlegi felhasználását illetően. A semmibe vezető hídhoz hasonlította a jelenlegi állapotot. Számolni kell a vendor lock-in-nel, a kisebb versenyzők a "nagyokat" (Amazon, Google) követve próbálnak felemelkedni, nincs kiforrott, all-in-one üzleti modell. Érdemes figyelni, merre tartanak, de merészség teljes lendülettel beszállni.
&lt;h3&gt;Trencséni Márton: Skálázható elosztott rendszerek&lt;/h3&gt;A kulcs-érték alapú adatbázisokról, MapReduce-ról, CouchDB-ről már írtam egy &lt;a href="http://jtechlog.blogspot.com/2009/10/web-konferencia-2009.html"&gt;előző postban&lt;/a&gt;.
&lt;dl&gt;&lt;dt&gt;&lt;a href="http://scalien.com/keyspace/"&gt;Keyspace&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Az előadó cége (Scalien) által BSD alatt fejlesztett kulcs-érték adatbázis. A NoSQL irányvonal megtestesítője, mely azon adatbázisok gyűjtő neve, melyek használatához nem szükséges SQL. C/C++-ban íródott, BerkleyDB-n alapul, de a következő verzióban ezt szeretnék kiváltani. Alapvetően konzisztenciát tart, de minden műveletnek van egy un. dirty párja, mely könnyen párhuzamosítható, de sérülhet a konzisztencia. Szóba került még a &lt;a href="http://en.wikipedia.org/wiki/Paxos_algorithm"&gt;Paxos&lt;/a&gt; és a &lt;a href="http://en.wikipedia.org/wiki/Vector_clock"&gt;Vector Clock&lt;/a&gt; algoritmusok is.&lt;/dd&gt;&lt;dt&gt;&lt;a href="http://en.wikipedia.org/wiki/Shared_nothing_architecture"&gt;Shared nothing architektúra&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Az SN egy olyan elosztott architektúra, ahol nincs verseny egy közös erőforrásért, mint pl. egy központi adatbázis. Most a webes fejlesztéseknél, valamint a felhők világában különösen fontos, hiszen nagyon jól skálázható, újabb alacsony költségű gépek beállításával növelhető a teljesítmény, és nincs szűk keresztmetszet, illetve olyan meghibásodási pont, mely a teljes rendszert megbénítaná (single point of failure). Ezt a Google is bebizonyította, az ilyen típusú adattárolást sharding-nak hívja, aminek lényege, hogy az adatokat valamilyen osztályozás szerint külön tárolja (horizontális partícionálás), ezáltal egyszerre kisebb adatmennyiségen kell dolgozni.&lt;/dd&gt;&lt;dt&gt;Eventual consistency&lt;/dt&gt;&lt;dd&gt;Olyan konzisztencia modell (elosztott rendszerek esetén használatos, van-e ellentmondás a tárolt adatok között), melynek használatával lehetséges, hogyha egy adatot módosítunk, majd visszaolvasunk, nem a módosított értéket kapjuk. Ez úgy lehetséges, hogy a konzisztenciát feláldozzuk a teljesítmény oltárán, azaz nem blokkoljuk a módosítást addig, míg az szét nem terjed a replikátumokon. Pl. egy közösségi oldal képfeltöltésénél elfogadható, de banki rendszernél ne használjuk. Hátránya, hogy amikor inkonzisztencia lép fel, nem kezelhető automatikusan, hanem az alkalmazást kell rá felkészíteni, ami vagy feloldja, vagy a felhasználóra bízza a konfliktus feloldását.
&lt;/dd&gt; &lt;dt&gt;Distributed lock manager&lt;/dt&gt;&lt;dd&gt;A megosztott erőforráshoz való hozzáféréseket vezérli.&lt;/dd&gt;&lt;dt&gt;&lt;a href="http://www.danga.com/memcached/"&gt;Memcached&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Nagy teljesítményű, elosztott, memóriában helyet foglaló cache rendszer, mely nagyszerűen tehermentesítheti az adatbázist. Legnagyobb felhasználója pl. a Facebook, ahol a tartalom 95%-a cache-ből jön.&lt;/dd&gt;&lt;dt&gt;&lt;a href="http://code.google.com/p/redis/"&gt;Redis&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;A Memcached-hez hasonló, memóriában tartott kulcs-érték adatbázis, azzal a különbséggel, hogy az adatokat bizonyos időközönként képes aszinkron módon lemezre menteni, valamint szövegen kívül halmazokat és listákat is kezel, valamint képes replikációra.&lt;/dd&gt;&lt;dt&gt;&lt;a href="http://memcachedb.org/"&gt;MemcacheDB&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Bár nevében hasonlít a Memcache-re, és másra asszociálnánk, nem egy cache, hanem egy BerkleyDB-t használó perzisztens megoldás, mely API szinten nagyon hasonlít a Memcache-re, és C-ben lett megírva.&lt;/dd&gt;&lt;dt&gt;Google stack&lt;/dt&gt;&lt;dd&gt;Google File System (GFS), Chubby distributed lock manager, BigTable adatbázis kezelő és a MapReduce.&lt;/dd&gt;&lt;dt&gt;Hypertable&lt;/dt&gt;&lt;dd&gt;Nyílt forráskódú adatbázis a BigTable hasonlatosságára, C++-ban.&lt;/dd&gt;&lt;dt&gt;Dynamo&lt;/dt&gt;&lt;dd&gt;Az Amazon kulcs-érték adatbázisa.&lt;/dd&gt;&lt;dt&gt;&lt;a href="http://github.com/cliffmoon/dynomite/tree/master"&gt;Dynomite&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Dynamo klón, nyílt forráskóddal, Erlang-ban megvalósítva.&lt;/dd&gt;  &lt;dt&gt;&lt;a href="http://hadoop.apache.org/"&gt;Apache Hadoop&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;A Yahoo! által használt nyílt forráskódú, Java-ban fejlesztett szoftverek gyűjtőprojektje a megbízható, skálázható, elosztott rendszerek fejlesztéséhez. Része a HBase, mely egy nyílt forrású BigTable klón.&lt;/dd&gt;&lt;dt&gt;PNUTS&lt;/dt&gt;&lt;dd&gt;A Yahoo! által használt elosztott adatbázis, mely nem nyílt.&lt;/dd&gt;&lt;dt&gt;Cassandra&lt;/dt&gt;&lt;dd&gt;Facebook mögött lévő adatbázis, Java-ban.&lt;/dd&gt;&lt;dt&gt;&lt;a href="http://project-voldemort.com/"&gt;Project Voldemort &lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;LinkedIn mögött lévő kulcs-érték adatbázis, Java-ban.&lt;/dd&gt;    &lt;dt&gt;&lt;a href="http://www.mongodb.org/display/DOCS/Home"&gt;MongoDB&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Nyílt forráskódú, dokumentum-orientált adatbázis, C++-ban.&lt;/dd&gt;&lt;dt&gt;&lt;a href="http://1978th.net/tokyocabinet/"&gt;Tokyo Cabinet&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Egy újabb kulcs-érték adatbázis, C-ben.&lt;/dd&gt;&lt;dt&gt;&lt;a href="http://neo4j.org/"&gt;Neo4j&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Beágyazható, lemezre perzisztáló, tranzakcionált gráf alapú adatbázis.&lt;/dd&gt;&lt;dt&gt;&lt;a href="http://open.eucalyptus.com/"&gt;Eucalyptus&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Amazon API kompatibilitást ígérő nyílt forráskódú megoldás.&lt;/dd&gt;&lt;dt&gt;&lt;a href="http://hail.wiki.kernel.org/index.php/Main_Page"&gt;Hail&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Célja nyelv- és platformfüggetlen, felhő építését lehetővé tévő, nyílt forráskódú infrastruktúra szolgáltatások kifejlesztése.&lt;/dd&gt;&lt;dt&gt;&lt;a href="http://deltacloud.org/"&gt;Deltacloud&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;Egységes REST API a különböző felhők (cloud) kezelésére, megszabadulva ezzel a vendor lock-in-től. Jelenleg támogatott felhők: EC2, RHEV-M, RackSpace; VMWare ESX.&lt;/dd&gt;  &lt;p&gt;Elég sok szó esett a kulcs-érték alapú adatbázisokról, itt található egy rövid &lt;a href="http://www.metabrew.com/article/anti-rdbms-a-list-of-distributed-key-value-stores/"&gt;összehasonlítás&lt;/a&gt;. Személyes véleményem, hogy még nagyon nagy kavar van, nem árt kicsit várni, míg kitisztul a kép.&lt;/p&gt;&lt;h3&gt;Szántó Iván: A KVM helye a virtualizáció világában&lt;/h3&gt;&lt;p&gt;Egy korábbi &lt;a href="http://jtechlog.blogspot.com/2009/09/glassfish-tavoli-szerveren.html"&gt;postban&lt;/a&gt;, és a Tumblr-en is &lt;a href="http://jtechlog.tumblr.com/post/216218309/virtualization-for-dummies"&gt;írtam&lt;/a&gt; már a virtualizációról, és ez az előadás is erről szólt. Szó esett a CPU virtualizációról, ahol érdemes ismerni az x86-os architektúrában alkalmazott gyűrűk (ring) fogalmát. A gyűrűk bevezetése a biztonságot nyújtják. 0. gyűrű a kernelé, és korlátlanul hozzáférhet a CPU-hoz, memóriához és egyéb erőforrásokhoz, az 1. és 2. a meghajtó programoké, és a 3. az alkalmazásoké. A supervisor mód jelzi egy task-ról, hogy hozzáférhet a védett erőforrásokhoz. A hypervisor a CPU-k hardveres virtualizáció támogatásával jelent meg. Segítségével a vendég operációs rendszerek 0. gyűrűben végrehajtható utasításokat futtathatnak. A CPU virtualizáció három formája a full virtualizáció, a paravirtualizáció, valamint a virtualizáció hardveres támogatással. Az első esetben a virtualizált operációs rendszer hívásait egy szoftver fordítja át. Ekkor az operációs rendszert nem kell módosítani. Paravirtualizáció esetén az operációs rendszert megváltoztatják, így ez a megoldás csak nyílt forráskódú operációs rendszereknél jöhet szóba, viszont kétségkívül gyorsabb, mint a szoftveres megoldás. A harmadik eset az előző kettő előnyeit ötvözi. A virtualizáció lehet host/guest alapú, amikor is egy operációs rendszeren felhasználói programként fut a virtualizációs megoldás, és abban a virtuális operációs rendszer, valamint lehet hypervisor/os alapú, mikor alul nem egy operációs rendszer, hanem egy hypervisor üzemel. Ebben az esetben azonban ki kell jelölni egy elsődleges operációs rendszert, mely direkt hozzáférést kap az erőforrásokhoz.&lt;/p&gt;&lt;p&gt;A memóriavirtualizáció során a virtuális operációs rendszer lapjait le kell képezni a virtuális gép lapjaira (page tables), és azt tovább le kell képezni a fizikai memória lapjaira (shadow tables). Az IO eszközök virtualizációja történhet full virtualizációval, paravirtualizált operációs rendszerrel, paravirtualizált driver-rel, vagy pass-through driver-rel (direkt hozzáférés).&lt;/p&gt;&lt;p&gt;A &lt;a href="http://www.linux-kvm.org/page/Main_Page"&gt;KVM&lt;/a&gt;, melynek neve is mutatja, kernelen alapuló virtualizáció, fő ötlete, hogyha a Linux kernelben úgyis meg van valósítva az ütemezés, erőforrás kezelést, stb., akkor azt továbbra is oldja meg a kernel, és csak a többi problémával foglalkozzon a virtualizáltságot biztosító szoftver. A QEMU-n alapul, mely egy nyílt forráskódú processzor emulátor. Elhangzott egy olyan trükk is, hogy azonos operációs rendszerek futtatásakor sok azonos memóriaterület lehet, ezt nem tárolja többször, hanem összeolvasztja (Kernel Sam Page Merging), és amennyiben az egyik virtuális gép mégis módosítani akarja, különválasztja (COW - copy on write). Említésre került a SPICE (Simple Protocol for Independent Computing Environments) is, mely egy virtualizációra optimalizált távoli adatátvitelt biztosító protokoll, melynek tulajdonságai az akár 30 fps-es video és Flash átvitel, kétirányú audio és video átvitel, valamint egy trükk, mely megvizsgálja a távoli és lokális gép videokártyáját, és a gyorsabbon renderel. A KVM  kezelhető grafikus eszközzel (virt-manager) és parancssori eszközzel (virsh) is. A libguestfs is jó ötlet, a virtuális gép disk-je a virtuális gép elindítása nélkül írható/olvasható. Menedzsment eszköz a Redhat RHEV-M is.&lt;/p&gt;&lt;h3&gt;Mátó Péter:
Adatbiztonság és üzembiztonság mindenkinek? Egy frappáns válasz: uDS&lt;/h3&gt;&lt;p&gt;A uDS projekt lényege röviden összefoglalható: a belső winchester és egy USB pendrive RAID-1-be kötése, titkosítással. Mire is jó ez? Ha azt akarjuk, hogy ne kelljen manuálisan menteni az adatainkat, ezzel megoldható, hogy pl. a home könyvtárunk módosítása automatikusan, titkosítottan a pendrive-ra is átkerüljön. Ezzel meg van oldva a backup, és másik gépre átvíve azonnal szinkronizációs megoldás is. Az előadás a felmerült problémákról, és megoldásukról szólt, mint pl. a pendrive lassú sebessége (aszinkron írással kiküszöbölhető), valamint a pendrive különösen érzékeny a sok írásra (terítési algoritmus).&lt;/p&gt;&lt;h3&gt;Höltzl Péter:
Központosított napló gyűjtés, classifikáció és előfeldolgozás syslog-ng OSE és más szabad eszközökkel&lt;/h3&gt;&lt;p&gt;Ez az előadás a syslog-ng-ről szól. Pont úgy működik, ahogy azt az ember egy naplózó rendszertől elvárja. Vannak források (source), amin bejön a napló (fájl, legacy syslog UDP - borzasztó formátum, kerüljük, TLS (Transport Layer Security) - SSL elődje, titkosított, stb.), valamint vannak célok, ahova kiírja azokat (destination). Definiálhatók filter-ek, melyek szűrik a napló bejegyzéseket. Mindkettő nevesített, és a log path köti össze őket. Probléma ugye a különböző formátumok kezelése. Erre template-eket lehet definiálni, melyek a naplót formázzák kiíráskor, valamint parser-eket, amik a bejövő naplókat elemzik. Ekkor un. makrók jönnek létre, melyeket használni lehet. Ezt elérési útban is meg lehet adni, így megoldható vele az archiválás is (havonta másik könyvtárba tesszük). Erre jól jöhet a logrotate is, ami már nem nevezgeti át az állományokat. Érdemes figyelni, hogy a napló állományba a szerver időpecsétje kerüljön, nehogy a kliens óra eltérése miatt ne lehessen az naplókat összefésülni. A napló bejegyzéseket át is lehet írni (rewrite). Támogatja a napló bejegyzések klasszifikációját is minta adatbázis alapján, valamint szó esett az artificial ignorance-ról, ahol nem a rossz dolgok vannak mintaként az adatbázisban, amire a rendszer riaszt, hanem a normális eseményeknek és minden attól eltérő kivizsgálásra kerül. A klasszifikáció nem regexp alapján történik, mivel az lassú, és on-the-fly történik, és nem batch jelleggel. Konkurrencia: Logcheck, Rsyslog. Lásd még RFC 5424 (The Syslog Protocol), RFC 3164 (The BSD syslog Protocol).&lt;/p&gt;&lt;h3&gt;Czakó Krisztián:
Virtualizáció &amp;amp; HA cluster: szeparált, egyszerű és biztos működik&lt;/h3&gt;&lt;p&gt;Az előadás első része a &lt;a href="http://xen.org/"&gt;XEN-ről&lt;/a&gt; szólt, mely egy hypervisor alapú virtualizáció, mely a hardveres támogatást is ki tudja használni. Képes a live migrációra, mikor menet közben, egy kis döccenővel tudunk átállni az egyik gépen futó virtuális gépről a másikra. (Úgy működik, hogy egyre kisebb differenciákat visz át, és a legutolsónál van a pillanatnyi leállás.) Le lehet állítani, majd újraindítani a hypervisor-t úgy, hogy a virtuális gépeket nem kell leállítani, gyakorlatilag a leállásból azok semmit nem vesznek észre (suspend/resume). Hasznos eszköz lehet az OpenQRM GPL alatt, mellyel több virtualizációs megoldást is lehet menedzselni. High availability a tervezett és nem tervezett rendszer leállások minimalizálása, a fault tolerance esetén a rendszer hiba esetén is működik tovább, anélkül, hogy ezt a felhasználó észrevenné. A Linux-HA projekt alakult a Linux alatti HA megvalósítások implementálására, melynek fő terméke a Heartbeat. Jelenleg azonban a honlapja átirányít a &lt;a href="http://www.clusterlabs.org/wiki/Main_Page"&gt;Pacemaker&lt;/a&gt; honlapjára, mely egy cluster infrastruktúra, mely képes OpenAIS és Heartbeat felett is működni. A cluster működhet SAN felett (AOE, iSCSI, FiberChannel), páratlan számú node-dal, hiszen itt a lényeg a többségi cluster, és DRBD felett, mely tulajdonképpen egy szoftveres RAID 1 megoldás TCP/IP felett, de csak két node-ot támogat. Az előadás konklúziója, hogy a XEN Heartbeat támogatása igen erős, kész script-ek vannak, így aki pl. egy Apache HA-t már kialakított Heartbeat-tel, annak nem lesz különösebben bonyolult ugyanezt virtuális gépekkel megoldania.&lt;/p&gt;&lt;p&gt;Ígérem, a következő bejegyzés teljesen Java-s lesz.&lt;/p&gt;&lt;/dl&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/62691511742121495/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/11/szabad-szoftver-konferencia.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/62691511742121495'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/62691511742121495'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/11/szabad-szoftver-konferencia.html' title='Szabad Szoftver Konferencia'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6053182487627786968</id><published>2009-10-16T16:29:00.006+02:00</published><updated>2014-02-02T16:34:13.253+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='scjp'/><title type='text'>SCJP</title><content type='html'>&lt;p&gt;A mai nap sikeresen letettem a &lt;a href="http://www.sun.com/training/catalog/courses/CX-310-065.xml"&gt;Sun Certified Programmer for the Java Platform, Standard Edition 6 (CX-310-065)&lt;/a&gt;, rövid nevén SCJP vizsgát. Már rég meg kellett volna lépnem, a voucher is már majdnem egy éve megvan, de most tudtam rászánni magam. Leírnám a tapasztalataimat, hátha más is tudja kamatoztatni.&lt;/p&gt;&lt;h3&gt;Felkészülés&lt;/h3&gt;Szinte kizárólag Katherine Sierra, Bert Bates: SCJP Sun Certified Programmer for Java 6 Exam 310-065 könyvet használtam felkészülésre. A könyv tíz fejezetből áll, és kifejezetten a vizsgára koncentrál, nagyon kevés plusz tudnivalót ír le, bár így is a tananyaggal foglakozó rész kb. 800 oldal. Azért érdemes ezt választani, mert írói részt vettek a vizsgakérdések kidolgozásában, egyértelműen definiálja a tananyagot, és példa teszt sorok is járnak hozzá. A könyvet mindig frissítették, ahogy új verziók jöttek ki a vizsgából.&lt;p&gt;&lt;/p&gt;&lt;p&gt;
&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_czKgycLvmNo/StiELlgzvQI/AAAAAAAAEw8/mY6ogUFPd48/s1600-h/scjp_book.jpg"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 246px; height: 320px;" src="http://4.bp.blogspot.com/_czKgycLvmNo/StiELlgzvQI/AAAAAAAAEw8/mY6ogUFPd48/s320/scjp_book.jpg" alt="" id="BLOGGER_PHOTO_ID_5393205888359316738" border="0" /&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;A könyv egy bevezetéssel indul, mely a vizsga lebonyolításáról szól, hogyan kell jelentkezni, hogyan zajlik a vizsga, stb. Majd mindegyik fejezet hosszasan kifejti a tananyagot, tudnivalókat. A szöveg közben vannak un. Exam Watch keretes írások, melyek azt írják le, hogy mire kell a vizsgán odafigyelni, és viszonylag kevés On The Job keretes írás, hogy az ismeretett témakört hogyan érdemes a gyakorlatban alkalmazni. Mindegyik fejezet leírja Certification Objective fejezethez tartozó részét, azaz a Sun által kiadott témakörökre való hivatkozásokat.
Mindegyik fejezet végén van egy összefoglaló, egy Two-Minute Drill mely felsorolásszerűen tartalmazza a fontosabb tudnivalókat (nevükkel ellentétbe nekem darabjának áttanulmányozása vagy 15 percig tartott). Itt vannak még a témakörhöz kapcsolódó példa kérdések és válaszok is (nagyon zavaró, mikor a kérdés felénél, a forráskódban van a sortörés). Különösen kiakasztott, hogy olyanokra kérdezett rá, melyeket az előző fejezetben nem írt le.&lt;/p&gt;&lt;p&gt;A CD mellékleten található két teljes vizsgasor is. Ezt meg lehet oldani úgy is, mintha a vizsgán lennénk (MasterExam), ugyanazokkal a feltételekkel, valamint quiz-szerűen is (Quiz). A CD mellékleten lévő vizsga  72 kérdéssel számol és 210 perccel. A quiz esetén 90 perc van a maximum 70 kérdésre, ez ne zavarjon meg minket, és ne keseredjünk el, reménytelen annyi idő alatt. A vizsga azonban nemrég változott, csak 60 kérdés van, melyeket 180 perc alatt kell megválaszolni.  A program nagyon nem tetszett. Egyrészt nincsenek benne drag&amp;amp;drop kérdések, melyek a valós tesztben vannak. Ha egy teljes tesztet végigcsinálunk, akkor van lehetőség riport nyomtatására. A riport csak a jó válaszokat tartalmazza, és nem tartalmazza, hogy mi mit válaszoltunk, szóval csak a memóriánkra hagyatkozhatunk. Így a riport tanulásra teljesen alkalmatlan. Ehelyett alkalmazzuk a quiz-t, open book-kal, ilyenkor tippet is kapunk, valamint a választ megadva azonnal láthatjuk a helyes válaszokat, meg is magyarázva. A program honlapján regisztrálva állítólag még egy példa tesztet le lehet tölteni, de ezt nem próbáltam.&lt;/p&gt;&lt;p&gt;Én a teljes vizsgára kb. 30 órát készültem. Ebben benne van a könyv végigolvasása, a Two-Minute Drill-ek kétszeri végigolvasása, a fejezetek végén lévő tesztek megoldása, valamint a két példateszt végigpróbálása, és a válaszok kielemzése. Ennek bőven elég kell lennie. A vizsga a könyv kérdéseihez képest sokkal egyszerűbb, szóval ha az előbbin átmegyünk, nem lesz gondunk az éles vizsgán sem.
Hasznos lehet még a JavaRanch.com-on lévő &lt;a href="http://faq.javaranch.com/java/ScjpFaq"&gt;JSCP FAQ&lt;/a&gt;, valamint a Sun &lt;a href="http://java.sun.com/docs/books/tutorial/extra/certification/index.html"&gt;felkészítő anyaga&lt;/a&gt;. Bevallom, én a CD mellékleten kívül egy szabadon elérhető tesztsort sem vittem végig. Amit még elolvastam, ismétlő jelleggel &lt;a href="http://palacsint.hu/blog/20090221/scjp-csapdak"&gt;Palacsint blogjában található SCJP csapdák&lt;/a&gt; bejegyzés, mely nagyon jól használható. Innen vettem az ötletet, hogy én is összeírom a szerintem fontos dolgokat, melyet listaszerűen a bejegyzés végén találsz.&lt;/p&gt;&lt;p&gt;Amire nagyon oda kell figyelni, az szerintem a collections, generics és concurrency.
&lt;/p&gt;&lt;h3&gt;Körítés&lt;/h3&gt;&lt;p&gt;A vizsgára a voucher-t a Sun-nál lehet megrendelni, jelenleg 300$, ehhez semmiféle járulékos költség nem adódik. A vizsgát valamelyik Prometric vizsgaközpontban lehet letenni, természetesen én a SZÁMALK-ot válaszotottam, a vizsga előtt kb. két héttel jelentkeztem be. A vizsgán feleletválasztós kérdések (egy helyes válasz esetén rádiógomb, több esetén meg van adva a helyes válaszok száma - szemben a könyvvel) és pár drag&amp;amp;drop kérdés van (kódrészleteket kell kódrészletbe behuzigálni - egyet akár többször is, és nem kötelező mindet felhasználni). A rendelkezésre álló idő 180 perc, a 60 kérdésből 35-öt kell eltalálni a sikeres vizsgához (58.33 %). A vizsgára nem lehet íróeszközt, szatyrot, tárcát, telefont, kabátot bevinni, ezeket elzárják. Letörölhető jegyzettömböt adnak. Mindenképp érdemes vizet bevinni. Az idő nem kevés, én minden kérdésen még egyszer át tudtam menni. Ezt érdemes is megtenni, 4-5 kérdést biztos javítottam. A teszt közben ha valamelyik kérdésben nem vagy biztos, érdemes megjelölni, sőt a jegyzettömbre felírni, hogy melyik válaszra gyanakszol. A drag&amp;amp;drop-ról sokan mondták, hogyha újból megjeleníted, elveszted a már beírt dolgokat, így nem is kísérleteztem vele, de szerencsére nagyon egyszerűek voltak, nem akartam őket újra átnézni. A vizsga eredménye nem jelenik meg a képernyőn, hanem ki kell nyomtatni, és kinn adja oda az adminisztrátor.&lt;/p&gt;&lt;h3&gt;Vélemény&lt;/h3&gt;&lt;p&gt;Kérdés, hogy mennyi értelme van letenni az SCJP vizsgát? Sajnos itthon nem annyira elfogadott, álláskereséskor inkább a céget képviselő programozó kérdéseire, általa összeállított tesztsorra kell válaszolgatni. Kint jobb a helyzet, németeknél pl. sokat számít a papír. Magam részéről úgy gondolom (, régebben gyakrabban felvételiztettem), hogy az SCJP vizsgától még nem lesz jó programozó az emberből, de jobb programozó lesz, és mindenképp becsülendő, hogyha valaki időt és pénzt áldozott a felkészülésre és a vizsga megcsinálására. Ha egy cégnél dolgozunk, akkor szép juttatás lehet a vizsga, és arra való felkészülésnek a biztosítása.&lt;/p&gt;&lt;p&gt;És a végén az általam összegyűjtött dolgok, melyre érdemes odafigyelni:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Publikus osztályt nem tartalmazó állományt bárhogy elnevezhetünk.&lt;/li&gt;&lt;li&gt;Default hozzáféréssel rendelkező osztályok elérhetőek az ugyanabban a csomagban lévő osztályokból.&lt;/li&gt;&lt;li&gt;A példánymetódusok felüldefiniálásakor (override) az új metódus nem dobhat bővebb (broader, azaz nem azonos vagy leszármazott) ellenőrzött (checked) kivételeket.&lt;/li&gt;&lt;li&gt;A strictfp módosító osztályra és metódusra is alkalmazható.&lt;/li&gt;Az enum deklaráció végén opcionális a pontosvessző.Ha egy statikus metódust hívunk egy változón keresztül, a fordító a változó deklarációjában szereplő osztályra cseréli ki.&lt;li&gt;Java 5-től kezdve a metódus felüldefiniálásakor a visszatérési érték lehet az eredeti visszatérési érték, vagy annak leszármazottai (covariant return)&lt;/li&gt;&lt;li&gt;Laza kötésre (loose coupling) és magas kohézióra (high cohesion) kell törekedni.&lt;/li&gt;&lt;li&gt;Az értékadó operátorok (pl. +=) automatikus típuskényszerítést végezhetnek&lt;/li&gt;&lt;li&gt;Az == használata autoboxing esetén trükkös, ugyanis byte, és -128 és 127 közötti Short, Integer értékek között egy pool van, így igazat fog visszaadni, e felett viszont hamist.&lt;/li&gt;&lt;li&gt;Egyenlőségvizsgálatnál ha két különböző
osztályhierarchiában lévő osztály típusú változót hasonlítunk össze, már fordításkor elszáll&lt;/li&gt;&lt;li&gt;A switch esetén a case paraméterének fordítási időben kiszámolhatónak kell lennie&lt;/li&gt;&lt;li&gt;Ha byte típust adok át egy switch-nek, és a case után nem fér bele a szám byte-ba, fordítási hiba keletezik&lt;/li&gt;&lt;li&gt;A default block középen is lehet&lt;/li&gt;&lt;li&gt;System.exit-nél nem fut le a finally&lt;/li&gt;&lt;li&gt;Assert Java 1.4-től van&lt;/li&gt;&lt;li&gt;Nem szerializálható ősosztályok konstruktora, inicializációja lefut deszerializáláskor. Statikus változó sosem kerül szerializálásra.&lt;/li&gt;&lt;li&gt;A StringBuffer equals() metódusa nincs felüldefiniálva, nem az értéket hasonlítja&lt;/li&gt;&lt;li&gt;A megtanulandó printf flag-ek: -, +, 0, "," , és (, formátumok:  %b, %c, %d, %f, %s. A %b boolean-ra, true-t ad minden non-null vagy non-boolean értékre.&lt;/li&gt;&lt;li&gt;Autoboxing esetén az equals() csak akkor igaz, ha a primitív típusok és az értékek is megegyeznek.&lt;/li&gt;&lt;li&gt;Queue interfész, PriorityQueue osztály&lt;/li&gt;&lt;li&gt;NavigableSet, NavigableMap interfészek: Java 6&lt;/li&gt;&lt;li&gt;A HashMap beenged null-t, a Hashtable nem&lt;/li&gt;&lt;li&gt;LinkedHashMap sorrendje: beszúrás vagy utolsó hozzáférés&lt;/li&gt;&lt;li&gt;equals metódusnál kötelező az Object típusú paraméter, compareTo-nál nem&lt;/li&gt;&lt;li&gt;headSet, subSet, tailSet - boolean paraméter - inclusive, ha nincs boolean, a kezdő mindig inclusive&lt;/li&gt;&lt;li&gt;Natural order: space, nagybetűk, kisbetűk&lt;/li&gt;&lt;li&gt;Generikus esetében a deklarációban és az értékadásban a generikus típusának pontosan meg kell egyeznie, amennyiben nem használunk wildcard karaktereket, azaz a List&amp;lt;Animal&amp;gt; aList = new ArrayList&amp;lt;Dog&amp;gt;(); nem fordul le, hiába a Dog az Animal leszármazottja
&lt;/dog&gt;&lt;/animal&gt;&lt;/li&gt;&lt;li&gt;Példányosításnál generics wildcard nem használható&lt;/li&gt;&lt;li&gt;new MyOuter().new MyInner(); vagy MyOuter.MyInner inner = mo.new MyInner();&lt;/li&gt;&lt;li&gt;MyOuter.this&lt;/li&gt;&lt;li&gt;A vizsga szempontjából metóduson belül definiált osztály módosítója vagy abstract vagy final.&lt;/li&gt;&lt;li&gt;JAR készítésekor az a könyvtár is belekerül, melyet paraméternek megadunk, nem csak az az alatti könyvtárak, állományok&lt;/li&gt;&lt;li&gt;A Runnable példánynak nincs referenciája a szálra, ami futtatja, ezt lehet elkérni a Thread.currentThread() metódussal&lt;/li&gt;&lt;li&gt;Ha egy szál el lett indítva, nem lehet többet újra elindítani&lt;/li&gt;&lt;li&gt;sleep, yield: statikus metódusok&lt;/li&gt;&lt;li&gt;sleep-nél nem vesznek el a lock-ok&lt;/li&gt;&lt;li&gt;Console a java.io csomagban van&lt;/li&gt;&lt;li&gt;Polimorfizmus csak a példánymetódusokra vonatkozik, se a statikus metódusokra, se bármilyen típusú változókra&lt;/li&gt;&lt;li&gt;A Throwable az osztály&lt;/li&gt;&lt;li&gt;Szerializációkor a pontos metódus: private void readObject(ObjectInputStream is) throws IOException, ClassNotFoundException&lt;/li&gt;&lt;/ul&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/6053182487627786968/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/10/scjp.html#comment-form' title='10 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6053182487627786968'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6053182487627786968'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/10/scjp.html' title='SCJP'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://4.bp.blogspot.com/_czKgycLvmNo/StiELlgzvQI/AAAAAAAAEw8/mY6ogUFPd48/s72-c/scjp_book.jpg' height='72' width='72'/><thr:total>10</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4084766187948911501</id><published>2009-10-06T23:31:00.004+02:00</published><updated>2009-10-07T11:16:52.042+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Community'/><title type='text'>Magyarországi Web Konferencia 2009</title><content type='html'>&lt;p&gt;2009. október 3-án, szombaton volt a &lt;a href="http://web.conf.hu/2009"&gt;Magyarországi Web Konferencia 2009&lt;/a&gt;. Rengeteg jó téma és előadás volt, ezért szeretnék ezekről egy összefoglalót írni. Nem csak Java-val kapcsolatos, de alapvetően webes témakörökben. Négy szekció volt, ezek közül kellett mindig a legérdekesebb előadást kiválasztani. Az általam legjobban becsült magyarországi projektek: &lt;a href="http://prezi.com/"&gt;Prezi.com&lt;/a&gt;, &lt;a href="http://moly.hu/"&gt;Moly&lt;/a&gt; és a &lt;a href="http://ustream.tv/"&gt;Ustream&lt;/a&gt;. Szerencsére mindegyiktől volt valaki, aki előadást tartott, így azokra beültem. Ha valaha saját projektet indítanék, a Moly oldalt fejlesztő Nagy Bence lelkesedésével, és a Ustream-esek technológiai profizmusával szeretném megtenni.&lt;/p&gt;&lt;p&gt;Első előadást, melyre bementem Halácsy Péter, a Prezi.com alapító technológiai igazgatója tartotta. Előadásának címe &lt;span style="font-style: italic;"&gt;HTML5: a Flash halála vagy csak újabb fejezet a böngészőháborúban?&lt;/span&gt;. Mivel kicsit később érkeztem, már nem fértem be a terembe, akkora volt az érdeklődés. A HTML 5-öt eddig nem követtem figyelemmel, de pont a napokban jelent meg az Editor's Draft 4. Sőt, most jött ki a Google Wave is, mely már HTML 5-ben készült, melyet az összes modern böngésző támogat, kivéve az Internet Explorer (ezért próbálja nyomatni a Google a &lt;a href="http://code.google.com/chrome/chromeframe/"&gt;Google Chrome Frame&lt;/a&gt; IE plugin-t). A HTML 5-nek nem titkolt célja, hogy használatával RIA alkalmazásokat lehessen összedobni, mellőzve a manapság terjedő Adobe Flash, Microsoft Silverlight, és Sun JavaFX technológiákat. Ennek érdekében a HTML 4 felturbósításán kívül teljesen új API-k is megjelentek, mint canvas 2d rajzolásra, időzített média lejátszás, offline adatbázis, dokumentum szerkesztés, drag-and-drop (akár op. rendszerből is), dokumentumok közötti üzenetváltás, böngésző előzményeinek kezelése, MIME típus és protokoll kezelők. Az előadó főleg az elsőt vizsgálta meg abból a szempontból, hogy a Prezi.com-ot mennyire lenne egyszerű HTML 5-ben fejleszteni. Összefoglalva talán annyi mondható, hogy a HTML nem tartalmaz forradalmi ötleteket, sebessége még elmarad a Flash-től, sok minden hiányzik belőle (pl. klikkelésnél nem mondja meg, hogy melyik elemen történt az esemény, double buffer hiányzik), és várhatóan mint eddig a kompatibilitással is lesznek problémák (ahogy a HTML 4 esetén is még mindig vannak, és az IE még nem kezeli a HTML 5-öt). Viszont ahogy a konferencián is megmutatkozott, rengeteg ember kíváncsi a HTML 5-re, látatlanban is megjósolható, hogy nagyobb lesz a felhasználói bázisa, mint a többi technológiának, így ezért fejlődni fog, fejlódnie kell. Jelenleg még nem alternatíva. Valamint a Flash mellett hozható fel a professzionális, bár nem olcsó eszközök is. Meg lett pl. említve az Adobe Flash Catalyst, mellyel a designer-ek dolgozhatnak, beimportálhatnak Photoshop vagy Illustrator állományokat, interaktív felhasználói felületeket hozhatnak létre, ami mögé a fejlesztő Adobe Flash Builder-ben mögérakja a funkcionalitást.&lt;/p&gt;&lt;p&gt;Még gyorsan sikerült átcsusszannom &lt;span style="font-style: italic;"&gt;Silverlight 3 platform innovációk&lt;/span&gt; című előadásra, melyet &lt;a href="http://batorfizsolt.spaces.live.com/"&gt;Bátorfi Zsolt&lt;/a&gt; tartott, kinek lelkesedése minden előadásából átjön. Néha úgy érzem, hogy érdemes lenne kipróbálni, hogy milyen lehet egy olyan gépezet, mint a Microsoft előnyeit kihasználni. Brutális marketing, integrált eszközök, hatalmas támogatás (lásd pl. a konferencián is átadott egy DVD-nyi oktató anyag). Az előadás volt a Silverlight 3 magyarországi bejelentése is. Újdonság a HD videó támogatása, adaptive streaming, plusz grafikai képességek (hardware gyorsítás, pixel shader), elmozdulás abba az irányba, hogy komoly üzleti alkalmazásokat is lehessen fejleszteni, böngészőn kívül futó alkalmazások (out of the browser), szóval minden, ami a RIA-ban most pörög. Itt is van egy eszköz, az &lt;a href="http://www.microsoft.com/expression/products/Blend_Features.aspx"&gt;Expression Blend 3-ban&lt;/a&gt; bevezetett SketchFlow, mellyel Photoshop-ból lehet importálni, és a designer képes programozás nélkül GUI-t összerakni, példa adatbázist készíteni, és ezt a programozónak átnyújtani, akinek sokkal kevesebb dolga van ezzel, mintha képekből kéne kiindulnia. Bár itt egyedi megoldásként hangzott el, a párhuzamos előadáson esett szó a konkurrencia előbb is említett Adobe Flash Catalyst-jéről.&lt;/p&gt;&lt;p&gt;A következő előadásként &lt;span style="font-style: italic;"&gt;Nagy Attila Gábor: Termék életciklus és verziókezelés&lt;/span&gt; előadására ültem be. Itt a CVS-ről, Subversion-ről és az újabb, elosztott verziókezelők közül a Git, Mercurial, Bazaar eszközökről esett szó. Elhangoztak best practice-ek a verziókezelők használatáról, a fejlesztői, teszt és éles környezetek használatáról. Pl. felejtsük el a CVS-t, használjunk Subversion-t. A Subversion-ben is az 1.5 előtt nehézkes volt a merge, erre van egy Python-ban írt &lt;a href="http://www.orcaware.com/svn/wiki/Svnmerge.py"&gt;Svnmerge.py&lt;/a&gt; eszköz, mely segít ebben. Az 1.5-ben bevezették a mergeinfo-t, de az előbb említett eszköz még mindig többet tud (ui. trunk -&gt; branch irányba a Subversion eszköz bármikor tud merge-ölni, de az ellentétes irányba már csak egyszer). Linus-nak van egy &lt;a href="http://www.youtube.com/watch?v=4XpnKHJAok8"&gt;Git térítő videója&lt;/a&gt;, azt érdemes megnézni. Ugye a Git-et is Linus tervezte és fejlesztette a Linux fejlesztéséhez. Alap kijelentés: "a merge a lényeg, branch-elni mindenki tud". Fontos, hogy tartsuk magunkat ahhoz, hogy minden változtatást külön branch-ben hozzunk létre (feature branch), így ha az ügyfél egyesével válogatja össze, hogy milyen feature-ökre van szüksége, könnyebben összeszedhető (határozatlan ügyfél). Persze ez a projekt indításakor nem megoldható, inkább csak a későbbi karbantartásnál. Itt hangzott el a cherry pick fogalma is. Összességében elmondható, hogy a Subversion kezelése már alap elvárás, de a Git bevezetése nem könnyű feladat, hosszabb betanulási idővel is jár. Érdemes még commit hookokat használni, mellyel eseményekhez (commit) lefuttatandó alkalmazásokat rendelhetünk, mint pl. forráskód, konvenciók ellenőrzése, change log generálása, issue manager eszközökkel való integráció, code review támogatása (pl. értesítések).&lt;/p&gt;&lt;p&gt;Ez után &lt;span style="font-style: italic;"&gt;Micsik András: Hogyan mixeljünk össze webszolgáltatásokat, ontológiákat és ágenseket&lt;/span&gt; című előadását hallgattam meg. A SZTAKI munkatársa egy olyan projektet mutatott be, melynek során megvalósították a címben leírtakat. Ehhez használták az Apache CFX webszolgáltatás keretrendszert, a Jade, leggyakrabban alkalmazott multiágens keretrendszert, a Jena szemantikus web keretrendszert. Az előbbi kettő integrálására készítettek is egy &lt;a href="http://brein.dsd.sztaki.hu/JadeSoapMTP/"&gt;Web Service Integration Toolkit-et&lt;/a&gt;, mely a projekt honlapjáról elérhető. Segítségével az ágensek kéepesek web szolgáltatásokat nyújtani és igénybe venni. A Belief Desire Intention (BDI) modellt alkalmazták. Ez azt jelenti, hogy minden ágensnek van egy képe a világról, vannak céljaik, és vannak eszközeik, hogy ezt a célt elérjék. Ennek egyik megvalósítása a Jadex következtető gép. Ezen kívül használták a Pellet nevű következtető gépet. Ez így elég tudományosan hangzik, feltehetően a példa, mely megoldására a projekt is létrejött, szemléltetni fogja. Egy repülőtéren a gépről leszálló, gépre felszálló utasok szállítására mozgó lépcsőket és buszokat alkalmaznak. Ezek vezérlésére írt program remekül működik addig, míg minden a terv szerint halad. Ha azonban elkezdenek késni a gépek, váratlan helyzetek következnek be, a klasszikus megoldások csődöt mondanak, azonnal kell reagálni a helyzetre. Erre jöhet jól az ágens technológia, ahol minden közlekedési eszközt egy ágens képvisel. Egymással képesek egyszerűen kommunikálni, de az ágensek világában bonyolultabb kommunikációs formák is vannak, egyezkednek, pl. aukciókon vesznek részt. Az ágensek világról alkotott képét a technológiák összekapcsolásával akár szemantikus módon lehet leírni, és következtető gépet alkalmazni. A valós helyzetekre, problémákra elosztottan, jobban tudnak reagálni, így megoldani a közlekedési problémát. A bonyolultabb tudáskészleten végzett következtetések viszonylag lassúak, így az ágens technológia az ágensekbe szétosztott tudásával akár megoldhatja ezt a problémát. Még csak kísérleti fázisban van a projekt, és a bevezetése után is először inkább csak tanácsokat, tippeket tud adni, amit az irányító személy akár felül is bírálhat.&lt;/p&gt;&lt;p&gt;A következő előadást úgy választottam, hogy mostanában nagy hype az alternatív adatbázisok használata, gondoltam kicsit megismerkedem velük. &lt;span style="font-style: italic;"&gt;Érdi Bálint CouchDB, a webre termett adatbázis&lt;/span&gt; előadása azonban tökéletesen meggyőzött, hogy ezen eszközöknek igen is helyük van a modern web 2.0-ás alkalmazások fejlesztésekor. A &lt;a href="http://couchdb.apache.org/"&gt;CouchDB&lt;/a&gt; egy Apache berkekben fejlesztett, nyílt forráskódú dokumentum orientált adatbázis, ahol a lekérdezéseket MapReduce módon, JavaScript nyelven lehet megfogalmazni. A MapReduce a Google által kifejlesztett keretrendszer, hatalmas adatbázisok cluster-es kezelését oldja meg. Az alapötet, hogy van egy Map függvény, mely a problémát részproblémákra vágja, és kiadja megoldásra, amiket szintén szét lehet vágni. A Reduce függvény összeszedi és összegzi a válaszokat. Ezáltal nagyon szépen párhuzamosíthatóak a műveletek. Igaz ugyan, hogy egy szekvenciális programhoz képest kevésbé hatékony, azonban cluster-en sokkal gyorsabban kaphatunk eredményt. A CouchDB a funkcionális Erlang programozási nyelvben lett megvalósítva, mely különösen alkalmas konkurens programok fejlesztésére. Az adatokat JSON dokumentumként lehet megadni, mindegyiknek egyedi azonosítót ad (UUID típusú _id néven), és mindegyikhez eltárolja a verzióját is (_rev). Séma nincs, így pl. a séma update problémája fel sem merül. Remek példa erre pl. a névjegykártya, amire mindenki más mezőket helyez el, ennek tárolása a CouchDB-nek nem probléma. A CouchDB RESTful JSON API-n keresztül érhető el. Ezekből is látható, hogy maximálisan webes technológiákat felvonultató megoldás. Nem kezel lock-olást, optimista megközelítést alkalmaz. Szerkesztés esetén betölti a dokumentumot, módosítja, majd elmenti. Ha közben más is ugyanezt a dokumentumot módosítja (a verziószámot is át kell adni, és ha ez nem az utolsó) a mentéskor hiba keletkezik, amit programból kezelni kell (utolsó dokumentum betöltése, ezen a változtatások elvégzése, majd újra mentése). A CouchDB sosem ír felül commit-ált adatot, ezért ez egy “crash-only” design, ami azt jelenti, hogy nem kell shutdown, futása egyszerűen megszakítható. A Multi-Version Concurrency Control (MVCC) modellt alkalmazza, ami azt jelenti, hogy minden kliens az adott adatbázis egy állapotát látja az olvasás elejétől a végéig. A dokumentumokat btree-be tárolja, és írás kizárólag az állomány végére történik. Persze nem nő a végtelenbe, hanem bizonyos időközönként kompaktálás történik, ami a valós adatok más állományba másolása, majd sikeres esetben átállás arra. Persze közben az adatbázis végig elérhető.&lt;/p&gt;&lt;p&gt;A CouchDb-ben nézeteket kell definiálni a lekérdezésekhez. Ezek a dokumentumokon dolgoznak, és JavaScript-ben lehet ezeket megadni, un. design dokumentumban. A nagy sebességet úgy éri el, hogy folyamatosan egy indexet tart fenn, és ahogy egy új dokumentum kerül be, vagy módosul, módosítja az indexet, és mindig ez alapján adja vissza a dokumentumokat. Az index írása is kizárólag az állomány végére történik (, ha írás közben áll le, akkor bármikor újraépíthető az index). Az adatbázisban a dokumentumokat formázni show és list függvények segítségével lehet (JSON-ből akár HTML formára konvertálni), így akár az adatbázison belül lehet alkalmazást írni, ilyen pl. a beépített adminisztrációs felülete, a Futon is. Ezen függvények eredménye ráadásul jól cache-elhető. Ezen függvények dokumentumként tárolása miatt az alkalmazás így tetszőlegesen replikálható, akár offline alkalmazásként.&lt;/p&gt;&lt;p&gt;Elhangzott a CAP elv is, ami azt jelenti, hogy a consistency, availability és partition tolerance követelményekből egyszerre csak kettő teljesíthető. A CauchDB szerint a konzisztenica az, amiből valamennyit fel lehet adni. A CouchDB elosztott, cluster-es működésre lett kitalálva, és inkrementális replikációt biztosít a futó példányok között (ahol egy példány lehet egy aktív cluster tag, de lehet egy offline-ba vitt adatbázis is), azaz két példány között csak a különbségeket viszi át. Kétirányú konfliktus kezelés van beépítve. Amennyiben két node-on egyszerre történt a változás, akkor a replikációs során "conflicted" állapotba kerül, és a két verzió közül determinisztikusan az egyik nyertesként kiválasztásra kerül, és hivatkozást tartalmaz az előző verzióra. A konfliktus feloldását végezheti az alkalmazás automatikusan időbélyeg alapján, vagy ha más mezők frissültek. Ha egyik sincs, a felhasználónak kell döntenie.&lt;/p&gt;&lt;p&gt;Eztán &lt;span style="font-style: italic;"&gt;Tolmács Márk Ustream.tv - Bepillantás egy közösségi elővideó site működésébe&lt;/span&gt; előadást hallgattam meg, mely során megismerhettük a ustream.tv architektúráját. Jelmondat a "Facebook clean, YouTube simple" volt. Jelenleg mértek 2 millió látogató/nap, 168000 lekérés/perc értékeket. E mögött lévő infrastruktúra: 6 web front-end szerver, 2 cache server, 2 statikus tartalmat kiszolgáló web szerver, 2 master + 3 slave MySQL adatbázis, 16 Flash media szerver. És persze az egész meg van bolondítva egy kis &lt;a href="http://en.wikipedia.org/wiki/Content_delivery_network"&gt;CDN-nel&lt;/a&gt; (pl. Akamai). Fejlesztéshez multi-master SVN-t használnak, ehhez saját commit hook-okat implementáltak. A telepítés rsync-el történik. A webes alkalmazás PHP-ban készült, saját keretrendszerrel (oop, MVC). Erősen használják a JavaScript-et, igyekeznek a legtöbb logikát kliens oldalra tolni. A JavaScript, CSS tartalmakat csoportosítva kezelik, másolják egybe, tömörítik. JavaScript framework a jQuery, nem ragaszkodnak minden áron az objektumorientált szemlélethez. Igyekeznek újrafelhasználható komponenseket, widget-eket gyártani. CSS sprite-okat használnak. Az adatbázis rétegben (DAO) kézzel hangolt SQL-ek, többszintű cache dolgozik. Újdonságok, hogy egyrészt elkezdik nyomni a mobilről való stream-elést, másrészt próbálnak nyitni a fejlesztők felé, platformot biztosítani, API-t adni.&lt;/p&gt;&lt;p&gt;Utolsóként a JavaFX volt a téma, &lt;span style="font-style: italic;"&gt;Simon Géza: JavaFX alapok és újdonságok&lt;/span&gt; előadásán. Itt igazából sok visszautalást kaphattunk az előző évben tartott előadására (JavaFX külön nyelv, objektumorientált, deklaratív, szkript, de mégis szigorúan tipizált, fordított, de Java-val könnyedén integrálható), itt már inkább a haladó témakörök voltak terítéken. JavaFX-nél is hangsúlyozni kell, hogy lépnek abba az irányba, hogy komoly üzleti alkalmazásokat is meg lehessen vele valósítani. Ezért ellátták egyszerű XML-t és JSON-t egyaránt támogató API-val, valamint aszinkron HTTP hívással. Kulcsszavak: HttpRequest, HttpResponse, PullParser. Sajnos engem egy új XML/JSON feldolgozó API nem nagyon hoz már lázba, ezért érdekesebbnek tartottam azt a videót, mely egy új vizuális &lt;a href="http://sellmic.com/blog/2009/06/05/javafx-authoring-tool-demo-at-javaone-2009-with-video/"&gt;Java FX fejlesztő eszközt&lt;/a&gt; mutatott be. Neten csak JavaFX authoring tool-ként fut, egyelőre keveset lehet tudni róla, még beta sincs belőle. A demó alapján kezelhető benne majd a timeline, binding, sőt egyszer összerakjuk az alkalmazást, majd különböző eszközökre (monitor, mobil, stb.) szabhatjuk. Reméljük ezzel már tényleg tudni fog annyit, mint a konkurensek, használható dokumentációval, weben található példákkal, és kevesebb buggal fog rendelkezni. A sokakat érdekló Oracle SUN felvásárlással kapcsolatban nem hangzott el semmi, viszont annyi igen, hogy nem tisztázott, hogy az Oracle mennyire fogja nyomni a JavaFX-et. Emiatt még várok vele.
&lt;/p&gt;&lt;p&gt;Érdekes, hogy majd minden előadó Mac-en nyomta, azonban a slide-okon még mindig feltűnnek a nem azonos betűtípussal írt, tipográfiailag borzasztóan oda nem illő ő betűk. Hihetetlen, hogy 2009-ben még mindig itt tartunk. Tőlem lehet bármilyen csilli-villi a prezentáció (persze nem az, mert én a Powerpoint-oshoz képest nem láttam eltérést), ha a szép magyar betűinket nem tudja normálisan megjeleníteni.&lt;/p&gt;&lt;p&gt;Összefoglalásképp egy jó előadásokkal teli, jól szervezett konferencia volt, amin biztos, hogy jövőre is megpróbálok részt venni, és amit mindenkinek nagyon ajánlok.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/4084766187948911501/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/10/web-konferencia-2009.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4084766187948911501'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4084766187948911501'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/10/web-konferencia-2009.html' title='Magyarországi Web Konferencia 2009'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1485120607241271708</id><published>2009-10-01T00:26:00.010+02:00</published><updated>2013-11-13T15:16:00.143+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Java SE'/><category scheme='http://www.blogger.com/atom/ns#' term='Oktatás'/><category scheme='http://www.blogger.com/atom/ns#' term='Java EE'/><title type='text'>Java források tanuláshoz</title><content type='html'>Sokan kérdezik tőlem, hogy milyen internetes dokumentáció vagy könyv alapján, milyen magyar vagy angol nyelv alapján érdemes megtanulni a Java programozási nyelvet, illetve platformot és az ahhoz tartozó technológiákat. Ebben a postban megpróbálom ezeket összegyűjteni, hogy nekem mik váltak be, mi alapján tanítunk, mi az, amihez többször visszanyúlok, a teljesen kezdő szinttől  a haladó témakörökig. Megpróbálom ezt a postot folyamatosan karbantartani, frissíteni. A könyvek az Internetről már hamar beszerezhetők, de az itt említetteknél javaslom a papír alapú beszerzését.&lt;p&gt;A legnehezebb a helyzet, ha még egy programozási nyelvet sem ismer az ember, ugyanis ekkor meg kell ismerni a számítógép belső működését, adat- és vezérlési szerkezeteket. Legjobb választás a magyar nyelvű kétkötetes Angster Erzsébet: Objektumorientált tervezés és programozás - JAVA könyv, mely a programozással, objektum orientáltsággal és a Java alapjaival ismertet meg. Hasznos lehet még Dr. Juhász István, Vég Csaba: Java - start ! könyve is. Mindannyiukat személyesen ismerem, főiskolai, egyetemi tanárok, rengeteg tapasztalattal rendelkező kiváló oktatók, így könyveik mindenképpen javasolt.&lt;/p&gt;&lt;div style="text-align: center;"&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_czKgycLvmNo/SsPbLtwBoFI/AAAAAAAAEus/DV1EsGdyEh0/s1600-h/angster1.jpg"&gt;&lt;img style="margin: 0px auto 10px; text-align: center; cursor: pointer; width: 157px; height: 200px;" src="http://1.bp.blogspot.com/_czKgycLvmNo/SsPbLtwBoFI/AAAAAAAAEus/DV1EsGdyEh0/s320/angster1.jpg" alt="" id="BLOGGER_PHOTO_ID_5387390573571317842" border="0" /&gt;&lt;/a&gt; &lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_czKgycLvmNo/SsPbTY7BAKI/AAAAAAAAEu0/Obm9SjJ4otY/s1600-h/angster2.jpg"&gt;&lt;img style="margin: 0px auto 10px; text-align: center; cursor: pointer; width: 160px; height: 199px;" src="http://4.bp.blogspot.com/_czKgycLvmNo/SsPbTY7BAKI/AAAAAAAAEu0/Obm9SjJ4otY/s320/angster2.jpg" alt="" id="BLOGGER_PHOTO_ID_5387390705419223202" border="0" /&gt;&lt;/a&gt;&lt;/div&gt; &lt;p&gt;Amennyiben már rendelkezünk programozási ismeretekkel, a legteljesebb, gördülékenyen olvasható könyv &lt;a href="http://www.horstmann.com/corejava.html"&gt;Cay S. Horstmann, Gary Cornell: Core Java: Volume I, Fundamentals&lt;/a&gt;, valamint ennek második kötete a Core: Java: Volume II, Advanced Features. Legnagyobb előnye, hogy a Sun adja ki, és mindig követi a nyelv változásait, jelenlegi 8. kiadás tartalmazza a Java SE 6 minden újdonságát. Mi is ez alapján tanítunk. Jó választás az angol nyelvű &lt;a href="http://www.mindview.net/Books/TIJ/"&gt;Bruce Eckel: Thinking in Java&lt;/a&gt;, mely harmadik kiadása ingyenesen letölthető, negyedik kiadását viszont már meg kell vásárolni. A legteljesebb magyar nyelvű kétkötetes könyv a &lt;a href="http://ecoop2001.inf.elte.hu/"&gt;Nyékyné Gaizler Judit (szerk.): Java 2 útikalauz programozóknak 5.0&lt;/a&gt;, de ehhez az előzőleg felsorolt könyvek valamelyikén már mindenképp legyünk túl, főleg referencia jellegű, amikor egy konkrét API-val, témával ismerkedtem, akkor vettem elő, nem érdemes az elejétől a végéig elolvasni. Minden (legalább céges) polcon legyen ott egy példány. Remek, több, mint 250 oldalas letölthető jegyzet &lt;a href="http://nagygusztav.hu/java-programozas"&gt;Nagy Gusztáv: Java programozás 1.3&lt;/a&gt; című munkája, mely Kecskeméti Főiskola GAMF Karán tanuló műszaki informatikus hallgatóknak készült. Auth Gábor munkáját dícséri a magyar nyelvű &lt;a href="http://www.javaforum.hu/javaforum/10/java_suli"&gt;JavaForum Java-Suli&lt;/a&gt;. Reméljük jön folytatás. A JavaGrund-on is található egy ingyenes bevezetés &lt;a href="http://www.javagrund.hu/web/java/learn/kezdo/javatanfolyam"&gt;Bevezetés a programozásba a Jáva nyelven keresztül&lt;/a&gt; címmel, de mivel 2001-es, pár rész már igen elavult. Ingyen végignézhetőek a &lt;a href="http://java.sun.com/docs/books/tutorial/"&gt;Sun tutorial-jai&lt;/a&gt; is, bár nem adnak egységes képet, szintén egy téma elsajátításakor érdemes az adott fejezetet elővenni.&lt;/p&gt;&lt;p&gt;A feltelepített JDK-ban is találunk érdekes anyagokat. Javasolt tanulmányozni a JAVA_HOME/src.zip állományt, melyben a teljes Java osztálykönyvtár forráskódja megtalálható. Valamint a demókat is feltelepítve elérhető a JAVA_HOME/demo/jfc/SwingSet3/readme.html állomány, mellyel elindítható a SwingSet3 alkalmazás, mely bemutatja a Swing lehetőségeit, az összes komponenst, forráskóddal együtt.&lt;/p&gt;&lt;p&gt;Sajnos már a tanuláskor le kell tenni a voksot egy fejlesztőeszköz mellett. A két nagy a Sun támogatását élvező NetBeans és az IBM által támogatott Eclipse. Mi próbáltuk oktatásban mindkettőt, és meg kell mondani, a visszajelzések alapján a NetBeans jobb választásnak tűnt, az Eclipse inkább profi programozók szeretik jobban. NetBeans esetén rengeteg példa található a &lt;a href="http://www.netbeans.org/kb/trails/java-se.html"&gt;General Java Development Learning Trail&lt;/a&gt; oldalon, érdemes a &lt;a href="http://www.netbeans.org/kb/docs/java/quickstart.html"&gt;NetBeans IDE Java Quick Start Tutorial-lal&lt;/a&gt; kezdeni, valamint sok videót is találunk a &lt;a href="http://www.netbeans.org/kb/docs/screencasts.html"&gt;All Video Tutorials and Demos of NetBeans IDE 6.x&lt;/a&gt; oldalon. Az Eclipse-et választóknak is indult egy &lt;a href="http://eclipsetutorial.sourceforge.net/"&gt;Eclipse And Java: Free Video Tutorials&lt;/a&gt; projekt, ahol szintén videók érhetők el, teljesen kezdő Java programozóknak javasolt a &lt;a href="http://eclipsetutorial.sourceforge.net/totalbeginner.html"&gt;Eclipse and Java for Total Beginners&lt;/a&gt;. Ez utóbbinak elkészült a &lt;a href="http://sourceforge.net/projects/eclipsetutorial/files/1.%20Total%20Beginners-Hungarian/"&gt;magyar fordítása&lt;/a&gt; is &lt;a href="http://eclipsefelfedezo.blogspot.com/"&gt;Dorothy&lt;/a&gt; jóvoltából.&lt;/p&gt;&lt;p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_czKgycLvmNo/SsPcjIew_6I/AAAAAAAAEvU/-MOWQ_zaEvE/s1600-h/se_utikalauz.jpg"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 207px; height: 200px;" src="http://2.bp.blogspot.com/_czKgycLvmNo/SsPcjIew_6I/AAAAAAAAEvU/-MOWQ_zaEvE/s320/se_utikalauz.jpg" alt="" id="BLOGGER_PHOTO_ID_5387392075395301282" border="0" /&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Az ingyen letölthető &lt;a href="http://java.sun.com/docs/books/jls/"&gt;The Java Language Specification&lt;/a&gt; a Java nyelv specifikációja, de bevallom, nagyon ritkán néztem bele.&lt;/p&gt;&lt;p&gt;Aki a SCJP vizsgát akarja letenni, annak kötelező darab az SCJP vizsgasorokat is fejlesztők könyve: Sun Certified Programmer for Java 6 Study Guide, CD melléklettel, egy csomó példa teszttel. Mivel nagyon trükkös kérdések vannak, érdemes átolvasni annak is, aki biztos a Java tudásában, hogy mire kell figyelni.&lt;/p&gt;&lt;p&gt;Aki profibb, de még mindig a Java SE-ről akar többet tudni, annak javasolt a &lt;a href="http://java.sun.com/docs/books/effective/"&gt;Joshua Bloch: Effective Java&lt;/a&gt; (magyarul is megjelent Hatékony Java címmel). Ez már nagyon mélyen tárgyalja a Java nyelvet, és 78 tippet ad ahhoz, hogy hatékonyabb Java kódot írjunk.&lt;/p&gt;&lt;p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_czKgycLvmNo/SsPbtQOR8ZI/AAAAAAAAEu8/jXywA4vSZns/s1600-h/hatekony_java.jpg"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 158px; height: 200px;" src="http://4.bp.blogspot.com/_czKgycLvmNo/SsPbtQOR8ZI/AAAAAAAAEu8/jXywA4vSZns/s320/hatekony_java.jpg" alt="" id="BLOGGER_PHOTO_ID_5387391149760704914" border="0" /&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Aki az elméletet is szereti, annak ajánlom &lt;a href="http://www.mindview.net/Books/TIPatterns/"&gt;Bruce Eckel: Thinking in Patterns with Java&lt;/a&gt; ingyen letölthető könyvét, valamint Steven John Metsker, William C. Wake: Design Patterns in Java című könyvét a tervezési mintákról Java-ban történő megvalósításáról (a klasszikus Design Patterns: Elements of Reusable Object-Oriented Software könyv ugye C++ mintákat tartalmaz, ami magyarul is megjelent Programtervezési minták címmel. Valamint érdekes Martin Fowler: Refactoring: Improving the Design of Existing Code könyve (magyarul Refactoring - Kódjavítás újratervezéssel).&lt;/p&gt;&lt;p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_czKgycLvmNo/SsPb8LxwOgI/AAAAAAAAEvE/G7ZjjZEO2fQ/s1600-h/refactoring.jpg"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 159px; height: 200px;" src="http://2.bp.blogspot.com/_czKgycLvmNo/SsPb8LxwOgI/AAAAAAAAEvE/G7ZjjZEO2fQ/s320/refactoring.jpg" alt="" id="BLOGGER_PHOTO_ID_5387391406265350658" border="0" /&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Aki a webes fejlesztés irányába akar elmenni, az Java nyelven nem kerülheti ki a Servlet és JSP technológiát. Ebben a témakörben a következő könyveket tudnám kiemelni: Jason Hunter: Java Servlet Programming, Hans Bergsten: JavaServer Pages. Mindkettő megjelent magyar nyelven is, a Servlet esetén javaslom, de a JSP esetén semmiképp sem, mert nem a legfrissebb kiadás, és nagyon sok minden változott azóta. Mindkét könyv főleg a Tomcat web konténert használja. Sun-os Core sorozat tagja, a &lt;a href="http://pdf.coreservlets.com/"&gt;Marty Hall, Larry Brown: Core Servlets and JavaServer Pages&lt;/a&gt; ingyen letölthető, szintén Tomcat-tel. A &lt;a href="http://java.sun.com/javaee/5/docs/tutorial/doc/"&gt;Eric Jendrock, Jennifer Ball, Debbie Carson, Ian Evans, Scott Fordin, Kim Haase: The Java EE 5 Tutorial&lt;/a&gt; második fejezete szintén ezt a témakört tárgyalja, NetBeans fejlesztőeszközzel és Glassfish alkalmazásszerverrel. Itt már megjelenik a JSF technológia, melyről jó könyv a &lt;a href="http://horstmann.com/corejsf/"&gt;David Geary, Cay Horstmann: Core JavaServer Faces&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Aki a Java EE teljes világát szeretné felfedezni, annak az előbb említett tutorial szintén kötelező darab, de már gyakran olvasgatni kell a különböző specifikációkat a &lt;a href="http://www.jcp.org/en/home/index"&gt;Java Community Process&lt;/a&gt; honlapján. A két legjobb könyv az ingyen letölthető &lt;a href="http://www.theserverside.com/news/1369778/Free-Book-Mastering-Enterprise-JavaBeans-30"&gt;Rima Patel Sriganesh, Gerald Brose, Micah Silverman: Mastering Enterprise JavaBeans 3.0&lt;/a&gt;, valamint az Debu Panda, Reza Rahman, Derek Lane: EJB 3 in Action, melyből szintén oktatunk. Ide kapcsolódik a Mike Keith, Merrick Schincariol: Pro EJB 3 Java Persistent API című könyv is. Java EE témában megjelent Imre Gábor (szerk.): Szoftverfejlesztés Java EE platformon könyv, ami nagyon jó elméleti bevezető (servlet, JSP, JSF is van benne), de aki ezeket a technológiákat élesben akarja használni, annak nem elég, még egy másik könyvet is el kell olvasnia. Van a J2EE Útikalauz Java Programozóknak zöld könyv is, de az csak a J2EE 1.4-es szabványt tárgyalja, ezért csak annak lehet érdekes, aki ezen a verzión beragadt alkalmazást fejleszt.&lt;/p&gt;&lt;p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_czKgycLvmNo/SsPcOsR0wgI/AAAAAAAAEvM/-_EdsJKMRvQ/s1600-h/javaee.jpg"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 139px; height: 200px;" src="http://4.bp.blogspot.com/_czKgycLvmNo/SsPcOsR0wgI/AAAAAAAAEvM/-_EdsJKMRvQ/s320/javaee.jpg" alt="" id="BLOGGER_PHOTO_ID_5387391724227445250" border="0" /&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Kiemelném még Anil Hemrajani: Agile Java Development with Spring, Hibernate and Eclipse könyvét, ami nem csak azért jó, mert bevezet az agilis programozás alapjaiba, de rengeteg Java-val kapcsolatos szoftvert bemutat, és azok együttműködését, gyakorlatilag egy "software ecosystem"-et, mint pl. Spring, Spring MVC, Eclipse, Hibernate, Log4J, JUnit, stb.&lt;/p&gt;&lt;p&gt;Web szolgáltások és SOA témakörben: Steve Graham, Doug Davis, ...: Building Web Services with Java: Making Sense of XML, SOAP, WSDL, and UDDI, ez nagyon részletes és rengeteg szabványt ecsetel, magyar kiadása is van, de azt semmiképp nem ajánlom, mert nagyon elavult. Ennél sokkal olvasmányosabb, emészthetőbb a &lt;a href="http://soabook.com/"&gt;Mark D. Hansen: SOA Using Java Web Services&lt;/a&gt; című könyv.&lt;/p&gt;&lt;p&gt;Alapvetően azonban hiszek az oktatás hatékonyságában is (, különben miért is oktatnék), egy hét intenzív Java tanfolyam alatt sok mindent meg lehet tanulni, főleg, ha az ember felkészülve megy oda, és mindent ki akar hozni az egy hétből. Azért is jó, mert akkor az embernek egy hete erre van dedikálva, ami munka mellett ritkán adatik meg. Oktatóink a SZÁMALK-nál éles projektekben dolgozó szakemberek, akik nem csak szárazon adják le az elméleti anyagot, hanem rengeteg gyakorlat van, és valós életből vett tapasztalatokat is megosztanak.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/1485120607241271708/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/10/java-forrasok-tanulashoz.html#comment-form' title='4 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1485120607241271708'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1485120607241271708'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/10/java-forrasok-tanulashoz.html' title='Java források tanuláshoz'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://1.bp.blogspot.com/_czKgycLvmNo/SsPbLtwBoFI/AAAAAAAAEus/DV1EsGdyEh0/s72-c/angster1.jpg' height='72' width='72'/><thr:total>4</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4180001514533033810</id><published>2009-09-27T21:33:00.007+02:00</published><updated>2010-09-18T00:29:56.818+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='JMS'/><category scheme='http://www.blogger.com/atom/ns#' term='Java EE'/><category scheme='http://www.blogger.com/atom/ns#' term='EAI'/><title type='text'>IBM WebSphere MQ</title><content type='html'>&lt;p&gt;A Java mellett az egyik fő érdeklődési területem az alkalmazásintegráció. Ez utóbbi egyik első, és legelterjedtebb eszköze az &lt;a href="http://www-01.ibm.com/software/integration/wmq/"&gt;IBM WebSphere MQ&lt;/a&gt; (korábban MQSeries) az üzenetkezelő middleware-ek családjába tartozó (message oriented middleware - MOM) üzenetsorakoztató middleware. Persze nem független a Java-tól, hiszen JMS provider-ként tud üzemelni. A múlt héten az IBM WebSphere MQ V7 System Administration tanfolyamon voltam, ezzel kapcsolatban írnék a JMS-ről, valamint az MQ-ról. A bejegyzés eleje mindenkinek szól, a vége inkább már csak azoknak, akik használnak, vagy használni terveznek MQ-t (különösen Java-ból). A post-hoz tartozik egy 46 oldalas magyar nyelvű cikk is a WebSphere MQ-ról.&lt;/p&gt;&lt;p&gt;A JMS-t a &lt;a href="http://jcp.org/aboutJava/communityprocess/final/jsr914/index.html"&gt;JSR 914&lt;/a&gt; specifikálja, a Java EE része, de természetesen külön is használható. A JMS csak egy egységes API-t definiál, melyel üzenetkezelést lehet megvalósítani, és a különböző gyártók különböző megvalósítást adhatnak (JMS provider), hasonlóan az adatbázis-kezeléshez, amihez a JDBC az egységes API. A Java EE alkalmazásszerverekben kötelező JMS megvalósításnak lennie.&lt;/p&gt;&lt;p&gt;A JMS üzenetek küldésére és fogadására használható. Ezzel kialakítható aszinkron kommunikáció, mikor az alkalmazás végzi a saját feladatát, és mikor üzenetet kell küldeni, elhelyezi egy sorban, és halad tovább. Nem várja meg, míg a címzett alkalmazás azt megkapja, és feldolgozza. Persze szinkron kommunikáció is kialakítható, amikor ezt megvárja, de ekkor pont a lényege veszik el. Bár biztonságossága miatt szinkron kommunikációra is alkalmazni szokták, szemben pl. a megbízhatatlanabb, de kisebb infrastruktúrát követelő web szolgáltatások helyett. Az aszinkronitáshoz kapcsolódó fogalom a kommunikáció iránya, ami lehet egyirányú, vagy kérés-válasz típusú is. Ez utóbbi esetben alakítható ki szinkron kommunikáció, mikor a küldő alkalmazás addig nem halad tovább, míg a választ meg nem kapja. De hatékonyabb, ha külön küldi el az alkalmazás az üzeneteit, és külön dolgozza fel a válaszokat. A kérés és a választ úgy lehet egymásnak megfeleltetni, hogy minden üzenet kap egy azonosítót (message id), és a válaszban a kérés üzenet azonosítóját kell egy másik, un. correlation id mezőbe bemásolni.&lt;/p&gt;&lt;p&gt;A JMS-sel kialakítható pont-pont kommunikáció, mikor két alkalmazás közvetlenül küldözget üzeneteket egymásnak (e-mail típusú kommunikáció), valamint kialakítható publish and subscribe kommunikáció is (levelezési lista kommunikáció). Az utóbbi esetben az előfizetők feliratkoznak egy témára (topic, melyek felépítése hierarchikus is lehet), míg a közzétevők erre a témára küldenek üzenetet. Ekkor az összes témára feliratkozott megkapja azt. Ezzel csökkenthető a kapcsolat szorossága, és bármikor új alkalmazásokat kapcsolhatunk az adott témára.&lt;/p&gt;&lt;p&gt;Egy üzenetnek van fejléce és lehet törzse. A törzsben különböző információk utazhatnak, mint szöveges, bináris, map típusú, stb. Az üzenetnek van perzisztenciája, azaz vagy le kell írni lemezre, hogy a JMS provider újraindítása után is megmaradjon, vagy elegendő memóriában tárolni. Az üzenetek prioritással, lejárattal rendelkezhetnek.&lt;/p&gt;&lt;p&gt;Jelenleg a JMS 1.0.2b és 1.1 szabvány a legfrissebb, a kettő között a legnagyobb különbség, hogy a pont-pont és publish and subscribe kommunikációt ugyanúgy lehet kezelni, ugyanis az előbbit reprezentáló Queue interfész, és az utóbbit reprezentáló Topic interfész közös ősinterfészt kapott Destination névvel. Így a modellt nem az alkalmazás dönti el, hanem attól függetlenül konfigurációval állítható.&lt;/p&gt;&lt;p&gt;Az IBM WebSphere MQ jó helyen volt jó időben. Elterjedtségét magas ára ellenére annak köszönheti, hogy ez volt az első, megbízható, és a legtöbb platformon támogatott üzenetsorakoztató middleware. Nem csak az aszinkroniztása miatt, hanem platformfüggetlensége (hardver, operációs rendszer, hálózati protokoll) miatt is kedvelték, hiszen pillanat alatt össze lehetett kötni egy Sun Solaris-on futó C alkalmazást, egy IBM RS/6000-on, AIX operációs rendszeren futó COBOL alkalmazással, ami akkor, mikor a web szolgáltatásoknak nyoma sem volt, igen kemény feladat volt. Ma már a banki, sőt a közigazgatási szférában is kvázi standard.&lt;/p&gt;&lt;p&gt;Apropó ár. Az IBM WebSphere MQ &lt;a href="http://www-01.ibm.com/software/lotus/passportadvantage/pvu_licensing_for_customers.html"&gt;Processor Value Unit [PVU]&lt;/a&gt; alapján licencelődik, ami azt jelenti, hogy minden típusú processzorhoz (, akár meghoz) egy értéket rendelnek, amit aztán be kell szorozni az árral. Pl. egy Intel Xeon (Nehalem) 70 PVU/processzor mag. Ez egy négy processzoros, Quad-core processzorokkal felszerelt gép esetén 4 * 4 * 70 = 1120, ahol Magyarországra a PVU ára egy éves support-tal 66,65 dollár, az majdnem 75 ezer dollár. A PVU azért jó, mert ha kevesebb processzormagot dedikálunk, kevesebbet kell fizetni.&lt;/p&gt;&lt;p&gt;Persze vannak nyílt forráskódú változatok is, mint pl. a Apache ActiveMQ (mely a Geronimo-ban a JMS provider), OpenJMS, JBossMQ (JBoss JMS provider), OpenMQ (Glassfish JMS provider, support-ált változata a Sun Java System Message Queue), stb. Amit tudni kell, hogy a JMS csak egy közös interfész, melyet mindegyiknek implementálnia kell, de ezen felül rengeteg szolgáltatást biztosítanak. Valamint, ahogy említettem, az alkalmazásszervereknek is JMS provider-nek kell lenniük. Persze több kereskedelmi termék is van, mint pl. Oracle Advanced Queuing.&lt;/p&gt;&lt;p&gt;A WebSphere MQ a pontosan egyszeri biztos üzenetküldést garantálja. Ezt úgy oldja meg, hogy mind a küldő oldalon, mind a fogadó oldalon el kell indítani egy szoftver komponenst (Queue Manager), mely addig tárolja lokálisan az üzeneteket, míg a másik oldalra át nem vitte. Ezzel az alkalmazás fejlesztőjének nem kell foglalkoznia. Használható, ha a hálózati kapcsolat megbízhatatlan, a hívott fél lassan válaszol, vagy megbízhatatlan, a platform különbségek áthidalására és terheléselosztásra. Használatával így lazán kapcsolt rendszerek alakíthatóak ki.&lt;/p&gt;&lt;p&gt;Az MQ-nak két programozási interfésze is van, az egyik az MQI, mely hasonlóan van implementálva az összes programozási nyelven, és az MQ összes speciális szolgáltatását ki tudjuk használni, valamint a JMS, ami provider független, így az tetszőlegesen cserélhető.&lt;/p&gt;&lt;p&gt;Az MQ-ról annak idején írtam már egy cikket, melyet most teljes egészében közzéteszek. Ebből az alapok elsajátíthatóak, itt már csak a tanfolyam által bemutatott újdonságokat, és a Java specifikus dolgokat mutatnám be.&lt;/p&gt;&lt;p style="text-align: center;"&gt;&lt;a href="http://delfin.unideb.hu/%7Evicziani/pdf/ws_mq_middleware.pdf" onclick="pageTracker._trackPageview('/pdf/ws_mq_middleware.pdf');"&gt;Teljes IBM Websphere MQ cikk letöltése&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Az MQ-val kapcsolatos összes kézikönyv publikus, és elérhető a &lt;a href="http://publib.boulder.ibm.com/infocenter/wmqv7/v7r0/index.jsp"&gt;IBM WebSphere MQ V7 information center-ben&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Amire vigyázni kell JMS használata esetén, hogy az üzeneteket próbáljuk egymástól teljesen függetleníteni, egy üzenetben az összetartozó információk utazzanak, és ne legyenek szétosztva több üzenetre. Ugyanis egyrészt nem biztosított az üzenetek sorrendje, erre külön oda kell figyelni, másrészt terheléselosztás esetén nem biztos, hogy ugyanaz a komponens kap két egymás utáni üzenetet.&lt;/p&gt;&lt;p&gt;A JMS lehetőséget biztosít tranzakciókezelésre, akár lokálisra (JMS provider-en belül), akár globálisra (több erőforrás kezelő részvételével). Ez utóbbi esetben megoldható pl. hogy egy tranzakcióba tartozzon egy adatbázis módosítás és egy JMS művelet. Itt különösen kell vigyázni arra, hogyha kiveszünk a sorból egy üzenetet, és nem sikerül feldolgozni, és rollback történik, akkor az üzenet visszakerül a sorba. Ekkor az alkalmazás újra fel akarja dolgozni, és újra hiba történik. Így remek végtelen ciklus alakulhat ki, amire figyelni kell. Vagy alkalmazásban kell kivételt kezelni, és figyelni, hogy ne legyen rollback, vagy az üzenettől le lehet kérni, hogy hányszor került már vissza a sorba. Ha ez elér egy határértéket, máshogy kell kezelni. A JMS provider-ek is tudhatnak olyant, hogy pl. valamennyi visszakerülés után vagy eldobják az üzenetet, vagy átteszik egy másik sorba. Ennek megvalósításáról egy remek cikk jelent meg &lt;a href="http://java.dzone.com/articles/handling-poison-messages"&gt;Handling Poison Messages With Glassfish&lt;/a&gt; címmel. A tranzakciókezelésnél az egyik leggyakoribb hiba, hogy a programozó egy tranzakcióban próbál üzenetet küldeni, és a választ is abban fogadni. Ekkor remek kis deadlock alakul ki, hiszen a commit-ig nem megy ki a kérés üzenet, így a hívott fél válaszolni sem tud, így hiába vár a hívó fél a válaszra.&lt;/p&gt;&lt;p&gt;Java EE-ben nem lehet szálakat indítani. Viszont szükség lehet olyanra, hogy egy hosszú folyamatot kell elindítani, de nem kell megvárni a választ, hanem valami státuszt kell visszaadni bizonyos időközönként. Ez megoldható úgy is, hogy a web konténerben dobunk szálat, de megoldható JMS-sel is. Ez az aszinkron tervezési minta, azaz egy üzenetet beteszünk a sorba, amelynek a másik végén egy Message Driven Bean figyel, és elindítja egy folyamatot. A szál, amelyik betette az üzenetet a sorba, nem vár válaszra, folytathatja a futását, visszaadhatja a választ a felhasználónak. A Bean meg végzi a feladatát. Figyeljünk ilyenkor ilyen timeout-okra, ugyanis lehet, hogy az alkalmazásszerver egy idő után lecsapja a folyamatot.&lt;/p&gt;&lt;p&gt;Nézzük, hogy mit érdemes még tudni az MQ-ról adminisztrátori oldalról, mely számomra is új volt, és nem tartalmaz a fenti dokumentáció.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Az üzenet biztonságát az MQ úgy biztosítja, mint a relációs adatbázisok. Egyrészt egy külön állományban tartja a sorokban lévő üzeneteket (queues könyvtár), másrészt egy napló állományt is fenntart (log könyvtár), amit folyamatosan vezet. commit esetén addig nem megy tovább a végrehajtás, míg a log fájlba a módosítások kiírásra nem kerültek. Amennyiben a sort tartalmazó állomány megsérül, vagy nem történt meg a cache-elés miatt az írás, és az MQ elszáll, a log alapján mindig vissza lehet állítani az üzeneteket (strmqm -r paranccsal). Így pl. az adatok és a naplók külön disk-en tartása nem csak a sebességet, de a biztonságot is növeli. A checkpoint az a művelet, mikor kiírja a sorokat is a disk-re, így annak állapota megegyezik a naplóban rögzítettel. Cirkuláris és lineáris naplózás is beállítható. A cirkuláris esetén a régebbi napló állományokat felülírja, lineáris esetén az összes előzmény megmarad. Az utóbbi sokkal biztonságosabb, de több adminisztrációs tevékenységgel jár, hiszen folyamatosan archiválni kell a régi napló állományokat.&lt;/li&gt;
&lt;li&gt;A WebSphere MQ client ingyenes, és arra való, hogy a távoli sorkezelővel tartja a kapcsolatot, így az alkalmazásnak elegendő lokális hívásokat végrehajtani. Ez nem véd a hálózat megszakadásától. Java esetén az MQ kliens csak pár JAR állomány.&lt;/li&gt;
&lt;li&gt;A listener az a komponens, mely a hálózati hívásokat figyeli, és amennyiben ilyen jön, elindítja a megfelelő receiver channel-t, amennyiben szükséges. Őt vagy az inetd indítja, vagy manuálisan kell (runmqlsr parancs, vagy a START LISTENER MQSC parancs). Az is beállítható, hogy a sorkezelővel együtt induljon. A channel a két sorkezelő közötti kapcsolatért felelős, és egyirányú. A channel két végén a message channel agent van. Az egyszerű mód, mikor az üzenetet küldő indítja a kommunikációt (sender - receiver). Azonban tűzfalas megfontolások miatt (pl. a DMZ-ből ne indítson kifele kapcsolatot a sorkezelő) lehet olyan is, hogy a fogadó fél beszól, hogy mostmár küldheti az adatokat a küldő (requester - server).&lt;/li&gt;
&lt;li&gt;Nem csak közvetlen kapcsolatban álló sorkezelőre, hanem távolabbi sorkezelőre is küldhetünk üzenetet. ezt hívják multi-hopping-nak.&lt;/li&gt;
&lt;li&gt;Adminisztrátori eszköz egy Eclipse 3.3-ra épülő plugin, mellyel távoli sorkezelőkhöz is lehet kapcsolódni.&lt;/li&gt;
&lt;li&gt;Amennyiben hibát kapunk, általában csak egy kód jelenik meg (reason code - RC). Ezt feloldani nem kell a dokumentációt megnyitni, hanem az MQRC paranccsal a kódhoz lekérdezhető a leírás.&lt;/li&gt;
&lt;li&gt;Maximálisan átvihető méret 100 megabyte. Amennyiben ennél többet akarunk átvinni, szegmentálnunk kell. Ezt az MQ tudja, viszont a JMS API nem. Így nekünk kell úgy leprogramoznunk, hogy speciális üzenetfejléc értékeket állítunk be.&lt;/li&gt;
&lt;li&gt;Az üzenet csoportok valók arra, hogy a logikailag egybe tartozó üzeneteket összekössünk, valamint biztosítsuk azok sorrendjét, ami alapban nem biztosított. Szintén fejlécekkel kezelhető.&lt;/li&gt;
&lt;li&gt;Az IBM WebSphere MQ-ban az adminisztrációs felületről (WebSphere MQ Explorer) egyszerűbben lehet a publish and subscribe módot megadni, sorkezelő csoportokat definiálhatunk a könyebb adminisztráció érdekében, valamint a JNDI objektumokat is könnyen kezelhetjük, ha Java-ban programozunk.&lt;/li&gt;
&lt;li&gt;Az MQ egy közös kódbázisra alapul, mely a platformok között hordozható. Erre épülnek a speciális platformhoz kapcsolódó részek, mint pl. Windows esetén a GUI. A z/OS teljesen külön állatfajta, az teljesen külön ág.&lt;/li&gt;
&lt;li&gt;Konfigurációs adatok az mqs.ini állományban, Windows esetén a registry-ben találhatóak.&lt;/li&gt;
&lt;li&gt;Az IBM WebSphere MQ-hoz un. &lt;a href="http://www-01.ibm.com/support/docview.wss?rs=977&amp;amp;uid=swg27007205"&gt;SupportPacs-ek&lt;/a&gt; tölthetőek le, melyek lehetnek kereskedelmi termékek, ingyenesek és támogatottak, ingyenesek, de nem támogatottak és 3rd party termékek is. Ezek közül szinte van, ami kötelező darab. Az &lt;a href="http://www-01.ibm.com/support/docview.wss?rs=977&amp;amp;context=SSKMAB&amp;amp;context=SS7J6S&amp;amp;context=SSKM8N&amp;amp;context=SSFKSJ&amp;amp;context=SSFKUX&amp;amp;context=SSWHKB&amp;amp;context=SSVLA5&amp;amp;dc=D410&amp;amp;q1=ms03&amp;amp;uid=swg24000673&amp;amp;loc=hu_HU&amp;amp;cs=utf-8&amp;amp;lang=en+hu"&gt;MS03&lt;/a&gt; egy sorkezelőben definiált objektumokat tudja létrehozó script-ként elmenteni. Így egy frissen telepített sorkezelőn futtatva a kapott script-et meg fog egyezni az eredeti konfigurációjával. Kiváló mentésre. A különböző event üzenetek speciális formátumban kerülnek a sorba, mely nem olvasható. Ezen segít az &lt;a href="http://www-01.ibm.com/support/docview.wss?rs=977&amp;amp;context=SSKMAB&amp;amp;context=SS7J6S&amp;amp;context=SSKM8N&amp;amp;context=SSFKSJ&amp;amp;context=SSFKUX&amp;amp;context=SSWHKB&amp;amp;context=SSVLA5&amp;amp;dc=D410&amp;amp;q1=MS0P&amp;amp;uid=swg24011617&amp;amp;loc=hu_HU&amp;amp;cs=utf-8&amp;amp;lang=en+hu"&gt;MS0P&lt;/a&gt; SupportPacs. Az &lt;a href="http://www-01.ibm.com/support/docview.wss?rs=977&amp;amp;context=SSKMAB&amp;amp;context=SS7J6S&amp;amp;context=SSKM8N&amp;amp;context=SSFKSJ&amp;amp;context=SSFKUX&amp;amp;context=SSWHKB&amp;amp;context=SSVLA5&amp;amp;dc=D410&amp;amp;q1=MH03&amp;amp;uid=swg24014179&amp;amp;loc=hu_HU&amp;amp;cs=utf-8&amp;amp;lang=en+hu"&gt;MH03&lt;/a&gt; SupportPacs-szel az SSH konfigurációt tudjuk ellenőrizni. A legfontosabb, az &lt;a href="http://www-01.ibm.com/support/docview.wss?rs=977&amp;amp;context=SSKMAB&amp;amp;context=SS7J6S&amp;amp;context=SSKM8N&amp;amp;context=SSFKSJ&amp;amp;context=SSFKUX&amp;amp;context=SSWHKB&amp;amp;context=SSVLA5&amp;amp;dc=D410&amp;amp;q1=ih03&amp;amp;uid=swg24000637&amp;amp;loc=hu_HU&amp;amp;cs=utf-8&amp;amp;lang=en+hu"&gt;IH03&lt;/a&gt; SupportPacs, mellyel üzeneteket tudunk browse-olni, kivenni, visszarakni, fejléct módosítani, stb. Az &lt;a href="http://www-01.ibm.com/support/docview.wss?rs=977&amp;amp;context=SSKMAB&amp;amp;context=SS7J6S&amp;amp;context=SSKM8N&amp;amp;context=SSFKSJ&amp;amp;context=SSFKUX&amp;amp;context=SSWHKB&amp;amp;context=SSVLA5&amp;amp;dc=D410&amp;amp;q1=soap&amp;amp;uid=swg24006280&amp;amp;loc=hu_HU&amp;amp;cs=utf-8&amp;amp;lang=en+hu"&gt;MA0R&lt;/a&gt; Axis és .NET keretrendszer számára biztosítja, hogy SOAP átviteli protokoll legyen az MQ. A &lt;a href="http://www-01.ibm.com/support/docview.wss?rs=977&amp;amp;context=SSKMAB&amp;amp;context=SS7J6S&amp;amp;context=SSKM8N&amp;amp;context=SSFKSJ&amp;amp;context=SSFKUX&amp;amp;context=SSWHKB&amp;amp;context=SSVLA5&amp;amp;dc=D410&amp;amp;q1=http+bridge&amp;amp;uid=swg24016142&amp;amp;loc=hu_HU&amp;amp;cs=utf-8&amp;amp;lang=en+hu"&gt;MA0Y&lt;/a&gt; gyakorlatilag egy servlet, mely lehetővé teszi, hogy az MQ funkcionalitását REST-en keresztül, egyszerű HTTP hívásokkal érjük el.&lt;/li&gt;
&lt;li&gt;A 6-os verziótól kezdve elérhető a File Transfer Application is. Hiszen ha kialakítottunk egy MQ vonalat, miért ne vihetnénk át egyszerűen fájlokat is át. Ezt megtehetjük GUI felületen a mqftapp használatával, de akár parancssorból is a mqftsnd, mqftrcv parancsokkal.&lt;/li&gt;
&lt;li&gt;Létezik egy trace route utility (dspmqrte), mellyel végig lehet követni egy üzenet útját, csak a legutolsó művelet visszavonásra kerül, így az alkalmazások nem veszik észre ezt a speciális üzenetet. Ez könnyen elemezhető szöveges formában írja ki a különböző aktivitásokat, azon belül pedig az operációkat. A WebSphere MQ Explorer-ből az MS0P SupportPacs telepítése után használhatjuk.&lt;/li&gt;
&lt;li&gt;Amennyiben hiba  keletkezik, érdemes benézni az errors könyvtárba. Az itt található log állományok egyszerű szöveges állományok. Belső hiba esetén FFST (first failure support technology) un. FDC állományokat generál, melyre az errors log is hivatkozik. Trace-elni is lehetséges (strmqtrc, endmqtrc, dspmqtrc), de ezt igazából már tényleg csak akkor használjuk, ha a support kéri.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Amennyiben Java EE-ből akarjuk használni a JMS-t, nem érdemes beégetni a sorkezelő elérési paramétereit, sőt még konfigurálhatóvá tenni sem, hanem ezt oldja meg az alkalmazásszerver. Ezt megoldhatjuk úgy, hogy a JNDI fájába bejegyezzük az un.  administered object-eket, ilyen a Connection Factory és a Destination. A Connection Factory, mint a neve is mutatja, a kapcsolódási beállításokat tartalmazza, és ennek segítségével lehet konkrét kapcsolatokat kiépíteni, míg a Destionation a sorok és témák reprezentációja. JNDI-be bejegyezni egyeket az objektumokat a JMSAdmin utility segítségével is lehet, ekkor a classpath-ba be kell állítani a Connection Factory osztályt, és meg kell adni a JNDI url-jét.&lt;/p&gt;&lt;p&gt;Tomcat esetén ez máshogy történik. Első lépésként a következő JAR állományokat kell bemásolni a Tomcat lib könyvtárába: com.ibm.mq.jar, com.ibm.mqjms.jar, connector.jar, jms.jar. Ezen kívül a server.xml-be fel kell venni a Connection Factory-t és a Destination-öket a GlobalNamingResources tag alá.&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;Resource
name="MyConnectionFactory"
auth="Container"
type="com.ibm.mq.jms.MQQueueConnectionFactory"
factory="com.ibm.mq.jms.MQQueueConnectionFactoryFactory"
description="JMS Queue Connection Factory"
HOST="jtechlog.hu"
PORT="1414"
TRAN="1"
QMGR="MY_QM"        
CCS="437"
/&amp;gt;
&lt;/pre&gt;&lt;p&gt;A TRAN a TRANSPORT, ami lehet BIND, CLIENT és DIRECT a dokumentáció szerint. A dokumentációval ellentétben itt azonban csak számot lehet megadni, az 1 a CLIENT transport-ot adja meg. A CSS a character code set.&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;Resource
name="MyQueue"
auth="Container"
type="com.ibm.mq.jms.MQQueue"
factory="com.ibm.mq.jms.MQQueueFactory"
description="JMS Queue"
QU="MY_Q"
TC="1"/&amp;gt;
&lt;/pre&gt;&lt;p&gt;A TC a TARGCLIENT, ami megadja, hogy JMS-sel kapcsolódó kliensnek, vagy egyéb kliensnek akarunk üzenetet küldeni. A TC=1 azt mondja, hogy nem JMS-es kliensnek, így nem rak az üzenetbe JMS fejléc információkat.&lt;/p&gt;&lt;p&gt;Ekkor a context.xml-ben vegyük fel az erőforrás linkeket.&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;ResourceLink global="MyConnectionFactory" name="jms/MyConnectionFactory" type="javax.jms.QueueConnectionFactory"/&amp;gt;
&amp;lt;ResourceLink global="MyQueue" name="jms/MyQueue" type="javax.jms.Queue"/&amp;gt;
&lt;/pre&gt;&lt;p&gt;Ezek után az alkalmazásból egyszerű JNDI lookup-pal lekérhető a java:/comp/env/jms/MyConnectionFactory és java:/comp/env/jms/MyQueue neveken.&lt;/p&gt;&lt;p&gt;A cikk írásakor &lt;a href="http://www-01.ibm.com/common/ssi/cgi-bin/ssialias?infotype=an&amp;amp;subtype=ca&amp;amp;supplier=897&amp;amp;letternum=ENUS209-245"&gt;jelent meg&lt;/a&gt; a 7.0.1-es verzió.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/4180001514533033810/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/09/ibm-websphere-mq.html#comment-form' title='9 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4180001514533033810'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4180001514533033810'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/09/ibm-websphere-mq.html' title='IBM WebSphere MQ'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>9</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1505444562967745195</id><published>2009-09-19T23:05:00.004+02:00</published><updated>2012-11-02T23:35:38.777+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Java SE'/><title type='text'>Java monitorozás és menedzsment</title><content type='html'>&lt;p&gt;Technológiák: Servlet 3.0, JMX&lt;/p&gt;

&lt;p&gt;Sajnos fejlesztés közben viszonylag kevés figyelmet fordítunk arra, hogy könnyen üzemeltethető alkalmazásokat készítsünk. Pedig a Java technológia lehetőséget biztosít, csak kicsit jobban oda kell figyelnünk, kicsit jobban ki kell használni az eszközöket és az API-kat.&lt;/p&gt;

&lt;p&gt;Hogy erre felhívjam a figyelmet, 2009. szeptember 16-án a SZÁMALK Aktuális 2009 rendezvényén előadást tartottam "Hol a határ? - Java alkalmazások üzemeltetéséről fejlesztőknek és üzemeltetőknek" címmel.&lt;/p&gt;&lt;p&gt;&lt;object id="prezi_gmyp8jz3v3aw" name="prezi_gmyp8jz3v3aw" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" height="400" width="550"&gt; &lt;param name="movie" value="http://prezi.com/bin/preziloader.swf"&gt;  &lt;param name="allowfullscreen" value="true"&gt;  &lt;param name="allowscriptaccess" value="always"&gt;  &lt;param name="bgcolor" value="#ffffff"&gt;  &lt;param name="flashvars" value="prezi_id=gmyp8jz3v3aw&amp;amp;lock_to_path=1&amp;amp;color=ffffff&amp;amp;autoplay=no"&gt;  &lt;embed id="preziEmbed_gmyp8jz3v3aw" name="preziEmbed_gmyp8jz3v3aw" src="http://prezi.com/bin/preziloader.swf" type="application/x-shockwave-flash" allowfullscreen="true" allowscriptaccess="always" bgcolor="#ffffff" flashvars="prezi_id=gmyp8jz3v3aw&amp;amp;lock_to_path=1&amp;amp;color=ffffff&amp;amp;autoplay=no" height="400" width="550"&gt;&lt;/embed&gt;  &lt;/object&gt;&lt;/p&gt;

&lt;p&gt;Az előadás során végigvettem egy fejlesztési életciklust, valamint egy tipikus n-rétegű alkalmazás architektúrát, és elemeztem a fejlesztők és az üzemeltetők feladatait, valamint a lehetséges konfliktus forrásokat.&lt;/p&gt;

&lt;p&gt;Konklúzióként levonható, hogy a technológia már nagyon jó eszközöket ad a kezünkbe, a probléma mindig emberi oldalon szokott jelentkezni.&lt;/p&gt;&lt;p&gt;Java szempontjából talán a következőket érdemes kiemelni:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Vastag kliens esetén a telepítés és a frissítések kezelésére érdemes a Java Web Start technológiát használni, mely alapban a JRE része.&lt;/li&gt;&lt;li&gt;Hasznos eszköz a JConsole, mely a JDK része, és a futó Java alkalmazásokhoz képes hozzákapcsolódni, és azok állapotát lekérdezni.&lt;/li&gt;&lt;li&gt;Hasznos API a Java Management Extensions (JMX), mely használatával könnyen üzemeltethető alkalmazásokat tudunk készíteni.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;A JMX a Java SE 5.0-tól a platform része, olyan szabványos programozói interfész (&lt;a href="http://jcp.org/en/jsr/detail?id=3"&gt;JSR 3&lt;/a&gt;), melyel monitorozható és menedzselhető alkalmazásokat tudunk készíteni. A JMX alapját egy vagy több Java objektum, un. managed bean (MBean) képviseli. Az MBean-eket az MBean szerverbe kell regisztrálni, hogy a kliensek el tudják érni. Egy MBean-nek lehetnek attribútumai, melyeket lehet írni és/vagy olvasni, lehetnek műveletek (operations), melyeket meg lehet hívni, valamint bizonyos értesítéseket küldhetnek. Ezáltal az MBean-eken keresztül megfigyelhető egy alkalmazás állapota, közbe lehet avatkozni, és bizonyos eseményekről is értesítést kaphat az üzemeltető. Az MBean-ek lokálisan, de távolról is elérhetőek (&lt;a href="http://jcp.org/en/jsr/detail?id=160"&gt;JSR 160, Java Management Extensions Remote API&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Amennyiben elindítunk egy Java programot, és elindítjuk a JConsole alkalmazást, információt kaphatunk a memóriafogyasztásról, futó szálakról, betöltött osztályokról, stb. Az utolsó, MBeans nevezetű fülön jelennek meg az MBean-ek. Látható, hogy minden konfiguráció nélkül is van pár MBean, melyek a JVM-ről adnak információkat (memóriahasználat, szemétgyűjtő, osztálybetöltő, operációs rendszer környezet, stb.), valamint a JVM működésébe lehet beavatkozni (pl. java.lang/Memory - gc művelet).&lt;/p&gt;

&lt;p&gt;A legtöbb alkalmazásszerver menedzsmentje is a JMX-re épül. Ilyen a Tomcat is, mely szintén JMX-en biztosítja a &lt;a href="http://tomcat.apache.org/tomcat-6.0-doc/monitoring.html"&gt;monitorozást és a menedzsmentet&lt;/a&gt;. Ekkor amint csatlakozunk a JConsole-lal a Tomcat-et futtató JVM-hez, az MBeans fülön megjelenik a Catalina és a Users folder. Ezekben rengeteg MBean-t találhatunk. A Tomcat olyan szinten biztosít információkat, mint pl. egy servlet betöltési ideje, meghívásának száma, legkisebb és legnagyobb lefutási idő, összes idő, mennyit hibázott, stb (Catalina/Servlet folder).&lt;/p&gt;

&lt;p&gt;Nézzünk is egy példát, írjunk egy egyszerű webes alkalmazást. Letölthető a &lt;a href="https://github.com/vicziani/jtechlog-jmx"&gt;https://github.com/vicziani/jtechlog-jmx&lt;/a&gt; címről. Jettyn is megy, Maven-nel build-elhető, és a letöltést követően a 'mvn jetty:run' paranccsal futtatható. Az alkalmazás egy servletből áll, mely egy számlálót növel minden egyes meghívásakor. Ezt szeretnénk kiajánlani JMX-en. A számlálóhoz készítsünk egy külön osztályt Counter néven.&lt;/p&gt;

&lt;pre class="brush: java"&gt;public class Counter
    implements CounterMBean {

private long value;

public long getValue() {
    return value;
}

public void setValue(long value) {
    this.value = value;
}

public void storno() {
    value = 0;
}

synchronized public void incrementCounter() {
    value++;
}
}&lt;/pre&gt;

&lt;p&gt;Ennek incrementCounter metódusát hívja a szerver. Ahogy látható, implementálja a CounterMBean interfészt, melyen keresztül a JMX-en ki lesz ajánlva.&lt;/p&gt;

&lt;pre class="brush: java"&gt;public interface CounterMBean {
public long getValue();
public void setValue(long counter);
public void storno();
}
&lt;/pre&gt;

&lt;p&gt;Eztán már csak egy ServletContextListener-t kell implementálni, mely az induláskor regisztrálja az MBean-t, leálláskor meg megszünteti a regisztrációt.&lt;/p&gt;

&lt;pre class="brush: java"&gt;
@WebListener
public class InitServletListener implements ServletContextListener {
public void contextInitialized(ServletContextEvent sce) {
    try {
        MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
        CounterMBean counter = new Counter();
        mbs.registerMBean(counter, 
    new ObjectName("jtechlog:type=Counter"));
    
        sce.getServletContext().setAttribute("counter", counter);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

public void contextDestroyed(ServletContextEvent sce) {
    try {
     MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
     mbs.unregisterMBean(new ObjectName("jtechlog:type=Counter"));
    } catch (Exception e) {
        e.printStackTrace();
    }
}
}
&lt;/pre&gt;

&lt;p&gt;A web alkalmazást, majd a JConsole-t elindítva láthatjuk, hogy megjelent a jtechlog folder, és azon belül a Conter MBean. Lekérdezhetjük vagy beállíthatjuk a value értékét, vagy meghívhatjuk a storno műveletet.&lt;/p&gt;

&lt;p&gt;Amennyiben értesítést is szeretnénk kapni a számláló értékének változásáról, a NotificationBroadcasterSupport osztályból kell származtatni, implementálni kell a getNotificationInfo metódust, majd meghívni a sendNotification metódust.&lt;/p&gt;

&lt;pre class="brush: java"&gt;...
synchronized public void incrementCounter() {
    value++;
    Notification n =
        new AttributeChangeNotification(this,
        sequenceNumber++,
        System.currentTimeMillis(),
        "Counter value has changed",
        "Counter value",
        "long",
        value - 1,
        value);

        sendNotification(n);
}

@Override
public MBeanNotificationInfo[] getNotificationInfo() {
    String[] types = new String[]{
        AttributeChangeNotification.ATTRIBUTE_CHANGE
    };
    String name = AttributeChangeNotification.class.getName();
    String description = "An attribute of this MBean has changed";
    MBeanNotificationInfo info =
            new MBeanNotificationInfo(types, name, description);
    return new MBeanNotificationInfo[]{info};
}
...
&lt;/pre&gt;

&lt;p&gt;A legjobb, hogy ezeket az értékeket nem csak JConsole-ról tudjuk lekérdezni, hanem parancssorból is, a Tomcat Ant task-okat definiál erre. (Használatához a catalina-ant.jar-t kell a $CATALINA_HOME/lib könyvtárból az $ANT_HOME/lib könyvtárba másolni.) A következő build.xml részlettel lehet lekérni a számláló értékét.&lt;/p&gt;

&lt;pre class="brush: xml"&gt;&amp;lt;jmx:open
host="${jmx.server.name}"
port="${jmx.server.port}"/&amp;gt;
&amp;lt;jmx:get
name="jtechlog:type=Counter"
attribute="Value"
resultproperty="value"
echo="false"
/&amp;gt;
&amp;lt;echo message="${value}" /&amp;gt;&lt;/pre&gt;

&lt;p&gt;Ez azért nagyszerű, mert így bármilyen monitorozó vagy menedzsment eszközbe (pl. Munin, Nagios) könnyen be tudjuk kötni.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/1505444562967745195/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/09/java-monitorozas-es-menedzsment.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1505444562967745195'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1505444562967745195'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/09/java-monitorozas-es-menedzsment.html' title='Java monitorozás és menedzsment'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1731600722043428800</id><published>2009-09-15T01:34:00.005+02:00</published><updated>2010-09-18T00:31:31.165+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Oktatás'/><category scheme='http://www.blogger.com/atom/ns#' term='Java EE'/><category scheme='http://www.blogger.com/atom/ns#' term='NetBeans'/><title type='text'>Glassfish távoli szerveren</title><content type='html'>&lt;p&gt;Szintén egy oktatás alkalmával szerettem volna demonstrálni a Java platformfüggetlenségét, és a Java EE lokális transzparenciáját. Írtam egy egyszerű Java EE alkalmazást, megy egy Stateless Session Bean-ből állt, valamint egy Message Driven Bean-ből. Valamint írtam hozzá egy kliens osztályt, mely egyrészt távolról meghívja a Session Bean metódusát, valamint egy üzenetet elhelyez abban a JMS sorban, melyen az MDB hallgat.&lt;/p&gt;&lt;p&gt;A cél az volt, hogy az elkészült EAR-t egy Solaris szerveren futó alkalmazásszerverre telepítsem, és a kliens alkalmazás azt távolról hívja meg.&lt;/p&gt;&lt;p&gt;Erről a postot egyrészt azért írom meg, hogy az itt szerzett tapasztalatok másnak is jól jöhetnek, másrészt feltehetőleg még meg kell ismételnem későbbi oktatásokon, ezért magamnak is jól fog még jönni. Fontos, hogy nem vagyok Solaris adminisztrátor, így nem biztos, hogy mindent úgy állítok be, ahogy egy szerveren kéne, viszont egy fejlesztői környezet működésre bírásához elegendő.&lt;/p&gt;&lt;p&gt;Használt verziók:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Solaris 10 5/08 s10x_u5wos_10 x86&lt;/li&gt;&lt;li&gt;Java SE Development Kit 6u13, pontosabban 1.6.0_13-b03&lt;/li&gt;&lt;li&gt;NetBeans 6.5.1&lt;/li&gt;&lt;li&gt;Glassfish v2.1, melyet a Netbeans Java bundle is tartalmaz, pontos száma v2.1 b60e Promoted Build&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Első feladatként egy működő Solaris-t kellett szerezni. Kaptam egy előre telepített VirtualBox VDI (Virtual Disk Image ) állományt, így azt már csak hálózatba kellett kapcsolni. NAT-tal semmiképp nem tudtam elindítani, így maradt a bridge-elt kártya, PCnet-Fast III virtuális hálózati kártyával. Amíg nem sikerültek a beállítások, a Solaris már boot-oláskor a következő hibaüzenetet adta:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;Failed to plumb IPv4 interface(s): pcn0
Failed to configure IPv4 DHCP interface(s): pcn0
Sep 13 08:33:29 svc.startd[7]: svc:/network/physical:default: Method "/lib/svc/method/net-physical" failed with exit status 96.
Sep 13 08:33:29 svc.startd[7]: network/physical:default misconfigured: transitioned to maintenance (see 'svcs -xv' for details)&lt;/pre&gt;&lt;p&gt;Amennyiben a hálózati kártya helyesen lett beállítva, megjelent a pcn0 interfész, de nem kapott a DHCP-től új ip-címet. Új cím kéréséhez a következő parancsokat kellett kiadni:&lt;/p&gt;&lt;pre&gt;ifconfig pcn0 dhcp release
ifconfig pcn0 dhcp start&lt;/pre&gt;&lt;p&gt;Ekkor a ifconfig –a parancs valami hasonlót adott, amin már látszik a jó ip-cím:&lt;/p&gt;&lt;pre&gt;lo0: flags=2001000849&lt;up,loopback,running,multicast,ipv4,virtual&gt; mtu 8232 index 1
inet 127.0.0.1 netmask ff000000
pcn0: flags=1004843&lt;up,broadcast,running,multicast,dhcp,ipv4&gt; mtu 1500 index 2
inet 192.168.68.107 netmask ffffff00 broadcast 192.168.68.255
ether 8:0:27:7b:8e:7c&lt;/up,broadcast,running,multicast,dhcp,ipv4&gt;&lt;/up,loopback,running,multicast,ipv4,virtual&gt;&lt;/pre&gt;&lt;p&gt;Amíg a hálózat nem jól volt beállítva, csak az első sor jelent meg, vagy a második is, rossz ip-címmel.&lt;/p&gt;&lt;p&gt;Ezután a /etc/hosts fájlban is megjelent a következő sor:&lt;/p&gt;&lt;pre&gt;192.168.68.107  unknown # Added by DHCP&lt;/pre&gt;&lt;p&gt;Az unknown lett a host neve, amit meg kell jegyezni, mert később szükség lesz rá (ezt persze már boot közben is kiírja). Amint van hálózat, javasolt nem a VirtualBox-ban bejött konzolon tevékenykedni, hanem pl. putty-tyal SSH-n keresztül bejelentkezve.&lt;/p&gt;&lt;p&gt;A következő feladat a JDK feltelepítése volt a /opt könyvtárba. Ehhez a jdk-6u13-solaris-i586.sh állományt töltöttem le, mely egy önkicsomagoló állomány. Letöltés után állítsuk futtathatóra (chmod +x), és indítsuk el. Én elkövettem azt a klasszikus hibát, hogy szöveges módban scp-ztem fel a Windows-os gépről a Solaris-ra (az sh kiterjesztés miatt az alapértelmezett mód), és így állandóan hibát jelzett (megsérült az állomány - corrupted), és az állomány mérete sem egyezett. Ezen túllendülve létrejött a jdk1.6.0_13 könyvtár. Ezután a .bash_profile-ba beállítottam a megfelelő környezeti változókat:&lt;/p&gt;&lt;pre&gt;export JAVA_HOME=/opt/jdk1.6.0_13
export PATH=$JAVA_HOME/bin:/usr/local/bin:$PATH&lt;/pre&gt;&lt;p&gt;Ezután következett a Glassfish telepítése. Ehhez a glassfish-installer-v2.1-b60e-sunos_x86.jar állományt töltöttem le. Először próbálkoztam a V2 UR2 verzióval is, de nagyon rejtélyes kivételeket kaptam, mire rájöttem, hogy a V2 UR2, és a NetBeans-emmel telepített 2.1 nem kompatibilis egymással, így a távoli metódushívás nem jött össze. Telepíteni a java -Xmx256m -jar glassfish-installer-v2.1-b60e-sunos_x86.jar parancs kiadásával kell, a 256 mega memória megadása nélkül nem sikerült. Ezt is a /opt könyvtárban indítottam. Mégegy érdekesség, hogy csak parancssort használva képtelen volt elindulni, a következő hibaüzenetet dobta:&lt;/p&gt;&lt;pre&gt;X connection to localhost:10.0 broken (explicit kill or server shutdown).&lt;/pre&gt;&lt;p&gt;Igen, egy X-et kellett hozzá indítani, csak azért, hogy kitegye a Licence Agreement képernyőt.&lt;/p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_czKgycLvmNo/Sq7TZzn0DqI/AAAAAAAAEsI/DqQDb_KHokY/s1600-h/licence_agreement.png"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 320px; height: 274px;" src="http://4.bp.blogspot.com/_czKgycLvmNo/Sq7TZzn0DqI/AAAAAAAAEsI/DqQDb_KHokY/s320/licence_agreement.png" alt="" id="BLOGGER_PHOTO_ID_5381471045061709474" border="0" /&gt;&lt;/a&gt;Ezután konfigurálni kellett Ant alapú eszközzel a Glassfish-t a következő parancsok kiadásával:&lt;pre&gt;cd glassfish
chmod -R +x lib/ant/bin
lib/ant/bin/ant -f setup.xml&lt;/pre&gt;&lt;p&gt;Eztán már csak el kellett indítani a /opt/glassfish könyvtárban:&lt;/p&gt;&lt;pre&gt;bin/asadmin start-domain domain1&lt;/pre&gt;&lt;p&gt;Leállítása:&lt;/p&gt;&lt;pre&gt;bin/asadmin stop-domain domain1&lt;/pre&gt;&lt;p&gt;A napló állomány a /opt/glassfish/domains/domain1/logs/server.log. A webes adminisztrációs felületet a http://unknown:4848 címen lehet elérni, ahol a default felhasználónév "admin", és a default jelszó "adminadmin".&lt;/p&gt;&lt;p&gt;Az alkalmazás egy NetBeans-ben létrehozott Enterprise Application, ami a következőkből állt. Távoli interfész:&lt;/p&gt;&lt;pre class="brush: java"&gt;@Remote
public interface HelloEJB {
public String sayHello(String name);
}&lt;/pre&gt;&lt;p&gt;Stateless session bean:&lt;/p&gt;&lt;pre class="brush: java"&gt;@Stateless
public class HelloEJBBean implements HelloEJB {
public String sayHello(String name) {
    System.out.println("Invoking sayHello");
    return "Hello " + name;
}
}
&lt;/pre&gt;&lt;p&gt;És a Message driven bean:&lt;/p&gt;&lt;pre class="brush: java"&gt;@MessageDriven(mappedName = "jms/MyQueue", activationConfig = {
@ActivationConfigProperty(propertyName = "acknowledgeMode", propertyValue = "Auto-acknowledge"),
@ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue")
})
public class HelloMDB {

public void onMessage(Message message) {
    try {
        System.out.println(((TextMessage) message).getText());
    } catch (JMSException jmse) {
        jmse.printStackTrace();
    }
}
}
&lt;/pre&gt;&lt;p&gt;Ez utóbbihoz létre kellett hozni az adminisztrációs felületen (Resources/JMS Resources/Connection Factories és Destination resources) egy jms/MyConnectionFactory és egy jms/MyQueue JNDI néven található JMS objektumokat.&lt;/p&gt;&lt;p&gt;Az alkalmazást a NetBeans EAR-ba csomagolta, amit a következő módok egyikén lehet telepíteni:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;EAR bemásolása a /opt/glassfish/domains/domain1/autodeploy könyvtárba&lt;/li&gt;&lt;li&gt;Webes adminisztrációs felületen: Applications/Enterprise Applications képernyőn a deploy gombbal&lt;/li&gt;&lt;li&gt;Meglepően jól működik a NetBeans távoli deploy szolgáltatása is. Ekkor fel kell venni egy új szervert (Tools/Servers képernyő Add server gomb), ki kell választani a lokális telepítési könyvtárat, majd a Register Remote Domain rádiógombot, majd meg kell adni a távoli szerver ip címét és az admin portját (4848). Az alkalmazásnál a Properties ablakban válasszuk ki ezt az alkalmazásszervert, és a projekten a jobb gomb/deploy-ra nyomva települ az alkalmazás a távoli alkalmazásszerverre. Az alkalmazásszerver a Services fülön is megjelenik, ahol alapvető információkat kapunk róla, és alap műveleteket el tudunk végezni.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Ha telepítettük az alkalmazást, érdemes megnézni, hogy sikerült-e, pl. a globális JNDI nevek megjelentek-e a JNDI fában. Ezt a webes felületen az Application Server képernyőn a JNDI browsing gombra kattintva lehet előhívni. Itt a session bean nevének meg kell jelennie: jtechlog.HelloEJB.&lt;/p&gt;&lt;p&gt;A kliens elkészítéséhez két megoldás közül választhattam volna. Vagy egy Application Client Container-ben (ACC) futó alkalmazást készíthettem volna, vagy egy különálló alkalmazást. Az előbbinél a deployment descriptor-okban kell leírni, hogy hol vannak a távoli erőforrások, és egy pehelysúlyú alkalmazásszerverben fut. Az utóbbi esetén csak a JNDI context-et kell definiálni, lookup műveletekkel lekérni a távoli referenciákat, és egy egyszerű JVM-ben fut. Emiatt az utóbbira esett a választásom. Tehát a NetBeans-ben elegendő volt egy Java Application projektet létrehozni. Ehhez persze a távoli interfészt is a projektbe kellett másolni. A kliens alkalmazás így nézett ki:&lt;/p&gt;&lt;pre class="brush: java"&gt;public class Main {
public static void main(String[] args) throws Exception {
Context ic = new InitialContext();
HelloEJB helloEJBBean = (HelloEJB) ic.lookup("jtechlog.HelloEJB");
System.out.println(helloEJBBean.sayHello("jtechlog"));
}
}&lt;/pre&gt;&lt;p&gt;Ehhez persze el kellett helyezni a következő JAR állományokat is a CLASSPATH-ban: $GLASSFISH_HOME/lib/appserv-rt.jar, $GLASSFISH_HOME/lib/javaee.jar (, ahol értelemszerűen a $GLASSFISH_HOME a lokális GlassFish telepítési könyvtára). Ekkor a appserv-rt.jar-ban lévő jndi.properties miatta localhost-hoz csatlakozna, így a következő jndi.properties állományt kellett elhelyezni a CLASSPATH-ban:&lt;/p&gt;&lt;pre&gt;java.naming.factory.initial=com.sun.enterprise.naming.SerialInitContextFactory
java.naming.factory.url.pkgs=com.sun.enterprise.naming
java.naming.factory.state=com.sun.corba.ee.impl.presentation.rmi.JNDIStateFactoryImpl
org.omg.CORBA.ORBInitialHost=192.168.68.107&lt;/pre&gt;&lt;p&gt;Ahol az utolsó sor mutatja a szerver ip címét. Ezután már a Solaris-on futó alkalmazásszerverbe telepített EJB meghívása egy Windows-os kliensről tökéletesen müködött.&lt;/p&gt;&lt;p&gt;A következő feladat a JMS beállítása volt. Ehhez a következővel egészítettem ki a kliens alkalmazást:&lt;/p&gt;&lt;pre name="code" class="java"&gt;ConnectionFactory connectionFactory = (ConnectionFactory) ic.lookup("jms/MyConnectionFactory");
Queue queue = (Queue) ic.lookup("jms/MyQueue");
Connection connection = connectionFactory.createConnection();
Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
MessageProducer messageProducer = session.createProducer(queue);
TextMessage message = session.createTextMessage();
message.setText("Message");
messageProducer.send(message);
messageProducer.close();
session.close();
connection.close();&lt;/pre&gt;&lt;p&gt;Az import-ok és a kivételkezelés az olvasó feladata. Ezt elindítva a következő osztályt hiányolta: java.lang.NoClassDefFoundError: org/netbeans/modules/schema2beans/BaseBean. Melyet kicsit furcsálok, hogy mit keres benne netbeans-es osztály. A megoldáshoz a következő JAR állományokat kellett még a CLASSPATH-ba tennem: $GLASSFISH_HOME/lib/appserv-admin.jar, $GLASSFISH_HOME/lib/appserv-ws.jar, $GLASSFISH_HOME/lib/install/applications/jmsra/imqjmsra.jar. Ez után a futtatás a következő hibával szállt el:&lt;/p&gt;&lt;pre&gt;May 19, 2009 1:36:24 PM com.sun.messaging.jms.ra.ResourceAdapter start
INFO: MQJMSRA_RA1101: SJSMQ JMS Resource Adapter starting...
May 19, 2009 1:36:26 PM com.sun.messaging.jmq.jmsclient.ExceptionHandler throwConnectionException
WARNING: [C4003]: Error occurred on connection creation [unknown:7676]. - cause: java.net.UnknownHostException: unknown&lt;/pre&gt;&lt;p&gt;Ez ugye azt jelenti, hogy a visszaadott JNDI referencia tartalmazza a JMS server host nevét, ami jelen esetben az unknown. Ezt a /opt/glassfish/domains/domain1/config/sun-acc.xml tartalmazza, valami ilyen formában:&lt;/p&gt;&lt;pre&gt;&amp;lt;target-server name="unknown" address="unknown" port="3700"/&amp;gt;&lt;/pre&gt;&lt;p&gt;Ebben a sorban az address értékét kicseréltem a megfelelő ip címre, de ez nem segített, így egyszerűen a Windows host fájljába felvettem a unknown nevet a Solaris virtuális gép ip-címére.&lt;/p&gt;&lt;p&gt;Ennek megoldására ezen a &lt;a href="http://forums.sun.com/thread.jspa?threadID=5283256&amp;amp;tstart=0"&gt;fórumon&lt;/a&gt; kaptam tippet.&lt;/p&gt;&lt;p&gt;Így az alkalmazás lefutott, de a kapcsolat bezárása után sem lépett ki, folyamatosan futott. A futó szálakat elemzve kiderült, hogy imqConnectionFlowControl és iMQReadChannel nevű szálak sokasága fut, melyek miatt nem tud leállni a kliens alkalmazás.&lt;/p&gt;&lt;p&gt;Erről több írás is van a weben, &lt;a href="http://forums.java.net/jive/thread.jspa?threadID=37143"&gt;ez a legérdekesebb fórum&lt;/a&gt;, valamint itt van felvéve &lt;a href="https://glassfish.dev.java.net/issues/show_bug.cgi?id=1429"&gt;egy Glassfish bug&lt;/a&gt; és &lt;a href="https://glassfish.dev.java.net/issues/show_bug.cgi?id=636"&gt;mégegy Glassfish bug&lt;/a&gt;. Sajnos javítás rájuk még nem érkezett. Addig is a javasolt megoldás a System.exit metódus hívása.&lt;/p&gt;&lt;p&gt;Összegzésként megállapítható, hogy még mindig nem hiszek az alkalmazásszerverekben, szerintem egy ilyen egyszerű demonstrációnak sokkal gördülékenyebben kellett volna mennie, hiszen nagyon egyszerű alkalmazást próbáltam, és az alkalmazásszerver nagyon alap funkcionalitását szerettem volna kipróbálni. Sajnos az utolsó problémára megoldást sem találtam.&lt;/p&gt;&lt;p&gt;Hivatkozások:&lt;/p&gt;&lt;p&gt;&lt;a href="http://java.sun.com/javase/6/webnotes/install/jdk/install-solaris.html"&gt;JavaTM SE 6 Release Notes Solaris Operating System Installation (32-bit)&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href="https://glassfish.dev.java.net/downloads/v2.1-b60e.html"&gt;GlassFish Project - v2.1 FinalBuild&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="http://docs.sun.com/app/docs/doc/819-3659/beakt?a=view"&gt;Sun Java System Application Server Platform Edition 9 Developer's Guide, Chapter 11 Developing Java Clients&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://glassfish.dev.java.net/javaee5/ejb/EJB_FAQ.html"&gt;EJB FAQ&lt;/a&gt;
&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/1731600722043428800/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/09/glassfish-tavoli-szerveren.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1731600722043428800'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1731600722043428800'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/09/glassfish-tavoli-szerveren.html' title='Glassfish távoli szerveren'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://4.bp.blogspot.com/_czKgycLvmNo/Sq7TZzn0DqI/AAAAAAAAEsI/DqQDb_KHokY/s72-c/licence_agreement.png' height='72' width='72'/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7294342172766860875</id><published>2009-09-09T00:15:00.007+02:00</published><updated>2009-09-09T14:29:26.419+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Utils'/><title type='text'>Virtualizáció fejlesztői gépen</title><content type='html'>&lt;p&gt;Manapság a virtualizáció nagyon divatos irány, így én sem maradhattam ki belőle. Egyelőre nézzük az egyszerű munkaállomásokon futtatható virtualizációt. Mikor is lehet erre szüksége egy egyszerű fejlesztőnek:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Jelenlegi operációs rendszere feladása nélkül ki akar próbálni egy másik operációs rendszert.&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; A fejlesztett alkalmazás célplatformja eltérő lesz, mint a fejlesztési platform.&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; Ki akar próbálni egy szoftvert, de feltelepítésével nem a saját környezetét akarja veszélyeztetni.&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; Az előbbi speciális esete, mikor fejlesztési munkához szükséges. Pl. most több hardver elemet kell programoznom, aminek driver-eit, fejlesztőeszközeit nem akarom a jelenlegi környezetemre telepíteni. Különösen akkor, mikor az adott munkán csak ritkán kell dolgozni, de jó, ha mindig rendelkezésre áll.&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; Egy szoftverhez csak egy számítógépre érvényes licence-et kap, mégis több fejlesztő akar vele dolgozni. Nem jogtalan használatra gondolok.&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; Egy teljes infrastruktúra működését kell letesztelni, pl. egy különálló adatbázisszervert, alkalmazásszervert, webszervert, mindezeket duplázva, cluster-be kötve. Persze a teljesítménye sokkal alacsonyabb lesz, de az architektúra, alkalmazás működése tesztelhető.&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;Egy fejlesztési környezetet több fejlesztő között is el kell osztani. Pl. egy felépített adatbázist. Persze senkinek nem ajánlom, hogy a virtuális gépen fejlesszen.&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; Környezetek hordozhatóságának biztosítására. Otthoni laptopon elkészítettem egy virtuális gépet, melyet átmásoltam az irodai gépemre, és azonnal elérhetővé váltak az arra telepített szolgáltatások.&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; Oktatási, prezentációs célokra. Jobb, ha egy előadáson, vagy egy videón nem a jelenlegi környezetemet mutatom a sok feltelepített programmal, ikonnal, hanem egy szűz környezetet, amin csak a demózni kívánt alkalmazás szerepel.&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; Más platform oktatásakor. Pl. a SZÁMALK-nál az egyik oktatáson Windows-on fejlesztettünk, de a Java EE platformfüggetlenségét bizonyítandó telepíteni kellett az alkalmazást egy Solaris szerverre is.&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; Oktatás esetén infrastruktúra biztosítására. Pl. az egyik oktatáson az oktatói gépen futó virtuális gépen volt feltelepítve a Subversion szerver, a wiki és az issue tracking rendszer.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Ezekben az esetekben nem kell külön hardvert szereznünk, hanem a virtualizációs szoftverrel egy külön hardvert emulálunk, és erre telepítjük rá az operációs rendszert és a különböző alkalmazásainkat. Így gyakorlatilag egy ablakban futtathatunk egy másik operációs rendszert. A magyar elnevezés szerint az eredeti operációs rendszer a hordozó (host), az ezen belül futó operációs rendszer a vendég (guest) operációs rendszer. Egyszerre párhuzamosan akár több vendég is futhat, határt csak a hardverünk teljesítménye szab.&lt;/p&gt;&lt;p&gt;Elsőként a &lt;a href="http://www.microsoft.com/windows/virtual-pc/"&gt;Microsoft Windows Virtual PC-t&lt;/a&gt; próbáltam, mellyel semmi gondom nem volt, megbízhatóan működött. Mégis váltottam a következő okok miatt a &lt;a href="http://www.virtualbox.org/"&gt;VirtualBox-ra&lt;/a&gt;, melynek a post írása pillanatában legfrissebb verziója a 3.0.4:
&lt;/p&gt;&lt;ul&gt;&lt;li&gt; Solaris-t kellett futtatnom&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; Többen mondták, hogy gyorsabb a Virtual PC-nél&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; Sun vásárolta meg&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; GPL-es nyílt forráskódú termék&lt;/li&gt;&lt;/ul&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_czKgycLvmNo/SqbYd4Hav3I/AAAAAAAAErM/xfHbtL17-u8/s1600-h/vb.png"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 320px; height: 250px;" src="http://2.bp.blogspot.com/_czKgycLvmNo/SqbYd4Hav3I/AAAAAAAAErM/xfHbtL17-u8/s320/vb.png" alt="" id="BLOGGER_PHOTO_ID_5379224812731940722" border="0" /&gt;&lt;/a&gt;&lt;p&gt;Telepítés nagyon egyszerű, varázslóval történik. Párszor megjelenik a felirat: "A telepítés alatt álló szoftver szoftver nem ment át a Windows Logo tesztelésen, amely a Windows XP-vel való kompatibilitását vizsgálja.", de ezzel nem kell törődni. Egy új virtuális gép létrehozása is adja magát, először egy virtuális lemezt kell létrehozni, majd ehhez kapcsolódóan egy virtuális gépet. A VirtualBox képes bármilyen ISO állományt is csatolni, így gyorsan csatoltam is egy Windows XP telepítő CD ISO-ját, így sikerült arról telepítenem. Telepítés után hasznos lehet még a Guest Addition telepítése a vendég operációs rendszerbe, mely a következő funkcionalitásokat biztosítja:&lt;/p&gt;&lt;ul&gt;&lt;li&gt; Egérmutató integráció: az egeret a hordozó desktop-ról egyszerűen át lehet húzni a vendég desktop-jára.&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; Jobb videó kártya támogatás: közvetlenül a hordozó videó kártyáját használja ki, így nem csak a standard felbontások választhatóak, valamint gyorsabb is.&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; Óra szinkronizáció.&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; Megosztott könyvtárak: a hordozó és a vendég közötti állomány megosztásra.&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; Seamless windows: az egyik legérdekesebb, ilyenkor a vendég operációs rendszer nem egy külön ablakban fut, hanem annak ablakai ablakként jelennek meg a desktop-unkon. Így nem is látszik, hogy mely operációs rendszer futtatja az adott alkalmazást. Mint a Windows 7-ben a Windows XP virtualizációja. Alapértelmezetten a jobb Ctrl + L billentyűkkel aktiválható.&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; Megosztott vágólap: rendkívül hasznos.&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; Automatikus bejelentkezés.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Érdemes egy tiszta operációs rendszert tartalmazó virtuális lemezt elmenteni, és különböző környezetek kialakításakor abból kiindulni.&lt;/p&gt;&lt;p&gt;A többi funkció használata és felderítése nagyon egyszerű, egyedül a hálózatkezelés okozhat némi fejtörést. A VirtualBox 8 virtuális hálózati kártyát tud kezelni, ebből 4 felületről konfigurálható, többi parancssorból. Megadhatjuk a hálózati kártya típusát, PCNet FAST III az alapbeállítás, mert szinte minden operációs rendszer ismeri és támogatja. Majd meg kell adni a virtualizáció módját is, mely azt határozza meg, hogy hogyan csatlakozzon a jelenlegi hálózathoz. Lássuk, hogy ez a verzió milyen lehetőségeket biztosít, először is a képernyő, amin a konfigurációt lehet állítani:&lt;/p&gt;
&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_czKgycLvmNo/SqbYnCXMoKI/AAAAAAAAErU/QwZ3k3JFDUY/s1600-h/vb_config.png"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 320px; height: 286px;" src="http://1.bp.blogspot.com/_czKgycLvmNo/SqbYnCXMoKI/AAAAAAAAErU/QwZ3k3JFDUY/s320/vb_config.png" alt="" id="BLOGGER_PHOTO_ID_5379224970101301410" border="0" /&gt;&lt;/a&gt;&lt;ul&gt;&lt;li&gt; not attached (nincs csatolva): ugyan hálózati kártyát jelez a vendég operációs rendszer, de azt mutatja, hogy nincs kábel bedugva, ennél a módnál is, mint a többinél a fogaskerékre csatlakoztatva lehet a virtuális hálózati kártya MAC címét megadni.&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; NAT (Network Address Translation): ez a leggyakoribb beállítás. Használatakor a vendég operációs rendszer látja a hordozó hálózatát és az Internetet is, ha be van kötve, de a hálózatról nem lehet látni a vendég gép szolgáltatásait. Ez úgy működik, hogy egy külön hálózat kerül kialakításra a vendég és a hordozó között (a vendég a 10.0.2.x címet kapja, míg a hordozó a második ip-címet az azonos privát hálózaton belül). Ezt az ip címet a VirtualBox beépített DHCP szervere adja. A külső hálózatot a vendég úgy éri el, hogy a küldött csomagokat a VirtualBox NAT engine újracsomagolja, és elküldi, majd a választ a vendégnek továbbítja. Port forward-dal megoldható, hogy a hálózat többi tagja is elérje a vendég szolgáltatását, ilyenkor egy port-on a VirtualBox hallgat, és továbbítja a kéréseket a vendég operációs rendszerhez.&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; Bridged networking: használatakor a vendég kívülről is egy külön gépnek látszik. Pl. a  hálózaton lévő DHCP szervertől is kérhet ip címet. Ekkor a hálózat többi tagja is el tudja érni a vendég szolgáltatásait. Ezt úgy oldja meg, hogy egy device driver-t telepít, mely a hordozó hálózati kártyájáról kiszűri a neki szükséges forgalmat, ezt hívják "net filter" driver-nek is. Ez gyakorlatilag bridge-elés, azaz egy Layer 2 switch. Konfigurációkor ki kell választani a fizikai hálózati kártyát, melyre rátelepszik. Ehhez a régebbi verziókban a Windows "Hálózati kapcsolatok" ablakában kellett varázsolni, szerencsére ez ebben a verzióban már nem szükséges.&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; Internal networking (belső csatoló): hasonló a bridged networking-hez azzal a különbséggel, hogy a vendég csak az ugyanazon belső hálózathoz kapcsolódó vendégekkel tud kommunikálni, még a hordozóval sem. Ez azért fontos, mert ilyenkor a forgalom nem megy át a host halózati kártyáján, és emiatt nem lehet sniffer-elni, és gyorsabb is.&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; Host-only networking: átmenet az internal networkin és a bridged networking között. Az elsőnél annyival több, hogy a vendég tud beszélgetni a hordozó géppel is, de nem érhető el kívülről. Ezt úgy valósítja meg, hogy egy szoftveres interfészt, "loopback" hoz létre. Konfigurációjakor egy szoftveres interfészt lehet itt kiválasztani: VirtualBox Host Only Network Adapter. Ezt előzőleg telepítette a VirtualBox, ekkor az Internet egy rövid időre elmegy, mert telepítése újraindítja a hálózatot. Ezzel meg lehet oldani, hogy a pl. két virtuális gép (adatbázis és alkalmazásszerver) egy hálózatban van kötve, míg kiajánlva csak az alkalmazásszerver van egy másik (bridge-elt) hálózaton keresztül, így kinntről az adatbázis közvetlenül elérhetetlen.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Nagyon meg vagyok vele elégedve, egyetlen negatívumnak azt hoznám fel, hogy a magyar fordításban nagyon sok hiba (nem csak érdekes szóhasználat, hanem elírás is) van.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/7294342172766860875/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/09/virtualizacio-fejlesztoi-gepen.html#comment-form' title='6 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7294342172766860875'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7294342172766860875'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/09/virtualizacio-fejlesztoi-gepen.html' title='Virtualizáció fejlesztői gépen'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://2.bp.blogspot.com/_czKgycLvmNo/SqbYd4Hav3I/AAAAAAAAErM/xfHbtL17-u8/s72-c/vb.png' height='72' width='72'/><thr:total>6</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-419488517150330883</id><published>2009-08-28T00:29:00.005+02:00</published><updated>2009-08-28T00:35:52.521+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='IDE'/><category scheme='http://www.blogger.com/atom/ns#' term='Tomcat'/><category scheme='http://www.blogger.com/atom/ns#' term='NetBeans'/><title type='text'>Munka egyszerre több projekten</title><content type='html'>&lt;p&gt;Többször adódhat, hogy a munkahelyen is egyidőben több projekten dolgozunk, sőt esetleg otthon is saját hobbi projektet fejlesztünk, ugyanazon a számítógépen, pl. notebook-on. Ennek megkönnyítésére a NetBeans, és webes alkalmazások esetén a Tomcat is hatékony eszközöket biztosít.&lt;/p&gt;&lt;p&gt;A NetBeans 6.0 Milestone 5-ben &lt;a href="http://wiki.netbeans.org/NewAndNoteWorthyMilestone5"&gt;jelent meg&lt;/a&gt; a Project Group fogalma. Ezzel projekt csoportokat tudunk definiálni. A File/Project Group menüpontban tudunk új projekt csoportot hozzáadni. Egy projekt csoport tartalmazhat szabadon összeválogatott projekteket, egy projektet, és a tőle függő összes projektet, valamint egy könyvtárban lévő projekteket. A szabadon összeválogatott projektek esetén létrehozáskor megadhatjuk, hogy üres projekt csoport jöjjön létre, és ahhoz adjuk hozzá a projekteket, vagy a megnyitott projekteket tegye bele alapértelmezetten a projekt csoportba. Megadhatjuk azt is, hogy új projekt megnyitásakor vagy lezárásakor mentse-e a projekt listát. Egy projekt és a tőle függő projektek esetén a projekt könyvtárát kell megadni, míg egy könyvtárban lévő projekteket tartalmazó projekt csoport esetén a könyvtárat kell megadni. Én általában a szabadon összeválogatott projektet használom, mert így egy csoporthoz szabadon adhatom hozzá, és vehetem el a projekteket.&lt;/p&gt;&lt;p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_czKgycLvmNo/SpcJElgCHVI/AAAAAAAAEqE/bsx-32Rsj44/s1600-h/netbeans_project_group_create.png"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 320px; height: 238px;" src="http://2.bp.blogspot.com/_czKgycLvmNo/SpcJElgCHVI/AAAAAAAAEqE/bsx-32Rsj44/s320/netbeans_project_group_create.png" alt="" id="BLOGGER_PHOTO_ID_5374774654680571218" border="0" /&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;A projekt csoportok váltása között nem kell újraindítani a NetBeans-t, egyszerűen a File/Project Group menüpontban kell kiválasztani a projekt csoportot. Ekkor azonnal vált, bazárja a bezárandó projekt csoport projektjeit, és kinyitja az új projekteket. A váltáskor megjegyzi a megnyitott állományokat is, így ott folytathatjuk a munkát, ahol abbahagytuk. Ebben a menüpontban lehet a projekt csoport tulajdonságait is szerkeszteni, vagy projekt csoportot törölni.&lt;/p&gt;&lt;p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_czKgycLvmNo/SpcJymjYatI/AAAAAAAAEqU/gHbf0Eb-Edc/s1600-h/netbeans_project_group_menu.png"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 282px; height: 320px;" src="http://4.bp.blogspot.com/_czKgycLvmNo/SpcJymjYatI/AAAAAAAAEqU/gHbf0Eb-Edc/s320/netbeans_project_group_menu.png" alt="" id="BLOGGER_PHOTO_ID_5374775445237033682" border="0" /&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Ez a koncepció ismerős lehet az Eclipse felhasználóknak, ott Workspace néven fut ugyanez.&lt;/p&gt;&lt;p&gt;A projekt csoportok különösen hasznosak lehetnek pl. olyanoknak, akik prezentációkat tartanak, mert így könnyen lehet váltani a bemutatandó projektek között.&lt;/p&gt;&lt;p&gt;A projekt csoportokat a NetBeans a [user_home/].netbeans/[version/]config/Preferences/org/netbeans/modules/projectui/groups könyvtárban tárolja el, így újratelepítéskor csak ezt a könyvtárat kell átmásolni.&lt;/p&gt;&lt;p&gt;A projekt csoportokról egy remek &lt;a href="http://netbeans.dzone.com/news/how-organize-projects-netbeans"&gt;videó&lt;/a&gt; is készült.&lt;/p&gt;&lt;p&gt;Webes alkalmazások fejlesztésekor a NetBeans-ben alapesetben ugyanazt a Tomcat példányt használja, melyre az alkalmazást telepíti, és melyet futtat. A Tools/Servers fülön azonban több Tomcat példányt is fel lehet venni, ha pl. a különböző alkalmazásokat különböző verziójú Tomcat-ekben akarjuk futtatni. Azonban ha több alkalmazást fejlesztünk, gyorsabb lehet, ha mindegyik alkalmazásnak külön Tomcat-et definiálunk, akár ugyanazt a verziót is, és csak azokat a dolgokat konfiguráljuk be, melyekre a különböző alkalmazásoknak szüksége lehet (pl. csak az adott alkalmazáshoz tartozó DataSource-ot inicializálja ekkor). Ezt megoldhatjuk úgy is, hogy a Tomcat-et több példányba bemásoljuk, de lehetőséget biztosít arra is (NetBeans-től függetlenül), hogy a binárisokat megtartsuk egy közös könyvtárba (ezt nevezik Catalina Home-nak), és csak a konfigurációs állományokat másoljuk le több példányba, különböző könyvtárakba (ezt nevezik Catalina Base-nek). Ez utóbbi csak a conf, logs, webapps, work, és temp könyvtárakat tartalmazza. Amennyiben a NetBeans-ben egy új Tomcat-et veszünk fel, külön megadhatjuk mindkettőt. Szerver esetén egyedül a CATALINA_BASE környezeti változót kell beállítanunk. Ez hasznos lehet akkor, ha ugyanazon a szerveren több alkalmazást is futtatni akarunk, de nem akarjuk, hogy egymástól függjenek (pl. az egyik Tomcat-jét a másiktól függetlenül akarjuk indítani/leállítani, vagy az egyik alkalmazás a másiktól egy Tomcat-ben elenné a memóriát). Ekkor a Services fülön a Servers alatt megjelenik a két Tomcat, és jobb klikk/Edit server.xml menüpontban külön tudjuk szerkesztgetni a server.xml-jüket.&lt;/p&gt;&lt;p&gt;Manapság egy webes alkalmazáshoz több, mint 30 JAR-t használunk (3rd party library), ami akár a 20 megát is kiteheti. Amennyiben ezt a WAR-ba csomagoljuk, és újra telepítjük az alkalmazást, ezeket mindig el kell távolítani, majd be kell tölteni, miközben a Tomcat egy 20 megás WAR állományt kezel, kitömörít, stb. Ennek elkerülésére megtehetjük azt, hogy a JAR állományokat nem a WAR-ba csomagoljuk, és a web app classloader-e tölti be, hanem a Tomcat lib könyvtárába másoljuk ezeket, így a common classloader fogja betölteni ezeket. Így fejlesztés közben az alkalmazást újraindítgatva kétszeres sebességnövekedést értem el, így jelentősen rövidült a fejlesztési iteráció hossza. Persze ennél sokkal szebb megoldás, ha a JAR-okat nem a lib könyvtárába másoljuk, hanem a ${catalina.base}/conf/catalina.properties állományában a common.loader porperty értékét kiegészítjük azzal a könyvtárral, ahol a JAR állományaink elhelyezkednek. Itt használhatjuk a ${catalina.home} és ${catalina.base} környezeti változókat is. Így indításkor ezeket is betölti a Tomcat, és nem kell minden alkalmazás telepítéskor. A NetBeans-be ehhez még a Project Properties/Libraries fülön be kell állítani, hogy ne csomagolja a WAR-ba a JAR-okat, hogy a Libraries-eknél a nevük melletti pipát (Package) kikapcsoljuk. Ezt használhatjuk akkor is, ha pl. szerverre telepítünk, és nem 20 megás WAR állományokat akarunk másolni, hanem jelentősen kisebbeket.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/419488517150330883/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/08/munka-egyszerre-tobb-projekten.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/419488517150330883'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/419488517150330883'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/08/munka-egyszerre-tobb-projekten.html' title='Munka egyszerre több projekten'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://2.bp.blogspot.com/_czKgycLvmNo/SpcJElgCHVI/AAAAAAAAEqE/bsx-32Rsj44/s72-c/netbeans_project_group_create.png' height='72' width='72'/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4697469845931444657</id><published>2009-08-19T01:15:00.004+02:00</published><updated>2010-09-18T00:32:14.789+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Library'/><category scheme='http://www.blogger.com/atom/ns#' term='Tesztelés'/><category scheme='http://www.blogger.com/atom/ns#' term='Java EE'/><category scheme='http://www.blogger.com/atom/ns#' term='Spring'/><title type='text'>E-mail kezelés tesztelése</title><content type='html'>&lt;p&gt;Többször kellett már olyan alkalmazást fejleszteni, mely elektronikus levelet küld SMTP protokollon, vagy egy mailbox tartalmát figyeli POP3, esetleg IMAP protokollon. Ilyen alkalmazás tesztelése elég nehézkes, hiszen kell hozzá egy mail szerver, megfelelő e-mail címekkel és folder-ekkel. Vagy rendelkezésre áll ilyenkor az éles környezet, amin nem szerencsés tesztelni, vagy a legrosszabb esetben még egy mail szervert is telepíteni kell.&lt;/p&gt;&lt;p&gt;Erre ad megoldást a &lt;a href="https://mock-javamail.dev.java.net/"&gt;Mock JavaMail&lt;/a&gt; projekt. Ez gyakorlatilag négy osztály, mely kihasználja a &lt;a href="http://java.sun.com/products/javamail/"&gt;JavaMail API&lt;/a&gt; plugin-olhatóságát. Ezt a Session osztály teszi lehetővé, mely lehetőséget biztosít a különböző protocol provider-ekhez. A protocol provider-ek különböző osztályok, melyek a különböző protokollokat kezelik. Ezek lehetnek Transport leszármazottak pl. küldés esetén, melynek egyik leszármazottja a SMTPTransport osztály az SMTP protokoll kezelése, és lehetnek Store leszármazottak, melyek egy üzenet tárolót reprezentálnak, és az üzenetek kezelését, letöltését teszik lehetővé. A Store leszármazottja a POP3Store POP3 protokoll és az IMAPStore az IMAP protokoll kezelésére. A Session osztály a protokollokhoz tartozó provider-eket a javamail.providers vagy javamail.default.providers állományok alapján tölti be, a protokollokhoz tarozó cím típusokat a javamail.address.map vagy a javamail.default.address.map alapján tölti be. Tipikusan a cím típus SMTP esetén rfc822 (rfc-ben meghatározott), NNTP esetén news.&lt;/p&gt;&lt;p&gt;Ezen állományokat a Session vagy a java.home környezeti változóban meghatározott könyvtár lib alkönyvtárából, vagy a META-INF könyvtárból tölti be. A Mock JavaMail felüldefiniálja az SMTP, POP3 és IMAP protokollokhoz tartozó provider-eket, úgy, hogy a META-INF könyvtárában szerepel a javamail.providers állomány, mely a saját Transport és Store osztályait állítja be. Emiatt a Mock JavaMail nagyon egyszerűen használható, hiszen nem kell mást tenni, mint a JAR állományát (a bejegyzés írásának időpontjában mock-javamail-1.7.jar) el kell helyezni a CLASSPATH-ban.&lt;/p&gt;&lt;p&gt;Ezután pontosan úgy lehet levelet küldeni, mint a standard JavaMail API használatakor, azaz:&lt;/p&gt;&lt;pre class="brush: java"&gt;MimeMessage msg = new MimeMessage(session);
msg.addRecipient(RecipientType.TO, new InternetAddress("foo@bar.com"));
msg.setSubject("Foo subject");
msg.setText("Foo body");
Transport.send(msg);&lt;/pre&gt;&lt;p&gt;Valamint levelet is pontosan ugyanúgy lehet fogadni:&lt;/p&gt;&lt;pre class="brush: java"&gt;Store store = session.getStore();
store.connect("bar.com", "foo", "bar");
Folder folder = store.getDefaultFolder();
folder.open(Folder.READ_WRITE);
Message[] messages = folder.getMessages();&lt;/pre&gt;&lt;p&gt;Ez a kód semmiben nem tér el a JavaMail API normál használatától, azaz a kódunkban akár változatlanul is hagyhatjuk. A különbség annyi, hogy a JAR CLASSPATH-ban való elhelyezése után a teszt eset futtatásakor a JavaMail API a Mock JavaMail provider-eit fogja használni, azaz a mailbox-okat és az üzeneteket a memóriában tárolja, amit a org.jvnet.mock_javamail.Mailbox osztály valósít meg, mely a ArrayList&amp;lt;Message&amp;gt; osztály leszármazottja. Egy mailboxes statikus tagja tárolja az e-mail címekhez tartozó Mailbox példányokat, melyeket a get statikus metódussal lehet elérni. Azaz pl. az Assert-nél használhatjuk a következő kódrészletet a levélküldés után:&lt;/p&gt;&lt;pre class="brush: java"&gt;List&lt;message&gt; inbox = Mailbox.get("foo@bar.com");
assertEquals(1, inbox.size());
assertEquals("Foo subject", inbox.get(0).getSubject());&lt;/message&gt;&lt;/pre&gt;&lt;p&gt;Egy Mailbox példányon meghívhatjuk a setError(true) metódust is, ekkor a Mailbox példányhoz való hozzáférés hibát fog dobni. Ezzel tesztelhetjük az alkalmazásunk hibakezelését is.&lt;/p&gt;&lt;p&gt;A Session-t lehet direktben is példányosítani, de egy webes alkalmazás esetében a legszebb megoldás, ha a web konténer vagy az alkalmazásszerverben definiáljuk erőforrásként, és az alkalmazásunk JNDI-vel fér hozzá. Persze teszteléskor, ha a teszt esetet out of container futtatjuk, akkor a Session-t magunknak kell példányosítanunk. Én Spring-et használok, így a Session-t a Spring dependency injection-nel állítja be. Viszont a Session-t nem lehet közvetlenül példányosítani, hanem factory metódusai vannak, mint a getDefaultInstance. Emiatt a Spring-ben a következőképp lehet példányosítani:&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;bean id="session" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&amp;gt;
&amp;lt;property name="targetClass"&amp;gt;&amp;lt;value&amp;gt;javax.mail.Session&amp;lt;/value&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;property name="targetMethod"&amp;gt;&amp;lt;value&amp;gt;getDefaultInstance&amp;lt;/value&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;property name="arguments"&amp;gt;
&amp;lt;list&amp;gt;
  &amp;lt;props&amp;gt;
      &amp;lt;prop key="mail.store.protocol"&amp;gt;pop3&amp;lt;/prop&amp;gt;
   &amp;lt;prop key="mail.smtp.host"&amp;gt;bar.com&amp;lt;/prop&amp;gt;
      &amp;lt;prop key="mail.smtp.user"&amp;gt;foo&amp;lt;/prop&amp;gt;      
  &amp;lt;/props&amp;gt;
&amp;lt;/list&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/pre&gt;&lt;p&gt;Ahhoz, hogy az alkalmazásunk működjön, a JavaMail API JAR-ját is el kell helyeznünk a CLASSPATH-ban (jelenlegi verzió a 1.4.2, mail.jar), valamint Java 6 előtt a Java Activation Framework legutolsó verzióját (1.1.1, activation.jar). A Java 6-nál ez már nem szükséges, ugyanis már bekerült a javax.activation csomag.
&lt;/p&gt;&lt;p&gt;A projekt oldalán lévő letöltés link nekem nem működött, viszont &lt;a href="http://download.java.net/maven/2/org/jvnet/mock-javamail/mock-javamail/1.7/"&gt;innen letölthető&lt;/a&gt;, forráskóddal együtt.&lt;/p&gt;&lt;p&gt;A projekt oldala három alternatívát is megemlít: &lt;a href="http://code.google.com/p/subethasmtp/wiki/Wiser"&gt;Wiser&lt;/a&gt;, &lt;a href="http://quintanasoft.com/dumbster/"&gt;Dumbster&lt;/a&gt;, és az &lt;a href="https://aspirin.dev.java.net/"&gt;Aspirin&lt;/a&gt;, de első látásra mindegyik csak egy külön indítható, beépíthető pehelysúlyú SMTP szerver, üzenetek küldésének tesztelésére. Ezzel szemben a Mock JavaMail mock provider-eket tartalmaz, melyekkel a küldésen kívül a fogadás is tesztelhető.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/4697469845931444657/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/08/email-kezeles-tesztelese.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4697469845931444657'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4697469845931444657'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/08/email-kezeles-tesztelese.html' title='E-mail kezelés tesztelése'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7149056741139538034</id><published>2009-08-12T23:24:00.006+02:00</published><updated>2010-09-18T00:33:00.893+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='algoritmus'/><category scheme='http://www.blogger.com/atom/ns#' term='JPA'/><title type='text'>Fa ábrázolása adatbázisban</title><content type='html'>&lt;p&gt;Gyakran megesik, hogy adott egy probléma, melyet már megoldottam az általam használt eszközökkel, de egy kicsit jobban körülnézve olyan alternatív megoldásokat találok, melyekről nem is hallottam, sőt a környezetemben sem ismert, mégis egyszerű, jól használható, csak nem annyira elterjedt.&lt;/p&gt;&lt;p&gt;Ilyenbe futottam, mikor egy egyszerű fát akartam adatbázisban eltárolni. Mivel mostanában a perzisztenciát általában JPA-val oldom meg, nem is foglalkozom az adatbázis tervezéssel, engedem, hogy a JPA provider kigenerálja helyettem az adatbázis sémát. Definiáltam egy Node osztályt, melynek van Node típusú attribútuma (parent), mely egy referencia a szülő objektumra, és van egy List&lt;node&gt; típusú attribútuma (children), mely a gyermek objektumokra mutató referenciákat tartalmazza. A következő forráskód mutatja a Node osztály vázát:&lt;/node&gt;&lt;/p&gt;&lt;pre class="brush: java"&gt;@Entity
public class Node {
...

@ManyToOne
private Node parent;

@OneToMany(mappedBy="parent")
private List&lt;node&gt; children = new ArrayList&lt;node&gt;();

...
}
&lt;/node&gt;&lt;/node&gt;&lt;/pre&gt;&lt;p&gt;Az első probléma akkor adódik, ha a gyermekek sorrendje nem mindegy. Ugyanis a JPA alapban nem veszi figyelembe, hogy a List-ben számít a sorrend. Amennyiben egy új gyermeket veszek fel már létező gyermekek mellé, a következő lekérdezésnél nem garantált az, hogy ugyanazon sorrendbe kapom vissza a gyermekeket, ahogy a List-ben szerepeltek. Ez abból adódik, hogy az adatbázis rekordok között nincs sorrend definiálva, így általában olyan sorrendben kapom vissza az elemeket, ahogy az adatbázisba kerültek (de erre sem szabad építeni, mert különböző műveletek, optimalizációk miatt más sorrend is lehetséges).&lt;/p&gt;&lt;p&gt;Ennek megoldására definiálni kell egy új mezőt, legyen a neve "rank", mely alapján a rendezettséget definiálni lehet, és használjuk a @OneToMany annotációval megjelölt mezőn az @OrderBy annotációt, ami hatására a lekérdezéskor a children lista elemei a rank szerinti sorrendben lesznek. Ennek ugye az a hátránya, hogy a rank mezőt mindig karban kell tartani beszúráskor. A rank lehet egy egész szám 0-tól indexelve. Ilyenkor beszúráskor a beszúrandó gyermek utáni elemeket "jobbra kell tolni", a rank értéküket egyel növelni kell. Persze ennél hatékonyabb algoritmusok is léteznek, de ez a legegyszerűbb. Nézzük tehát a módosított Node osztályunkat:&lt;/p&gt;&lt;pre class="brush: java"&gt;@Entity
public class Node{
...

private int rank;

@ManyToOne
private Node parent;

@OneToMany(mappedBy="parent")
@OrderBy("rank ASC")
private List&lt;node&gt; children = new ArrayList&lt;node&gt;();

...
}
&lt;/node&gt;&lt;/node&gt;&lt;/pre&gt;&lt;p&gt;Ennél a megoldásnál jött elő, hogy hogyan kell törölni pl. az összes elemet a táblából. Egy DELETE FROM Node node utasítás nem volt elegendő, mert a következő hibaüzenetet kaptam: Cannot delete or update a parent row: a foreign key constraint fails. Ez azt jelenti, hogy egy elemet nem lehet letörölni, hiszen a gyermek elemek külső kulccsal hivatkoznak rá. Ezért először az összes referenciát null-ra kell állítani (UPDATE Node node SET node.parent = null), és csak aztán lehet a törlést elvégezni.&lt;/p&gt;&lt;p&gt;A következő probléma akkor adódik, mikor egy teljes részfát kell megjeleníteni. Amennyiben egy listába be akarjuk tenni a részfa teljes elemét (pl. grafikusan meg akarjuk jeleníteni és listában kívánjuk átadni a megjelenítési rétegnek), a részfát preorder módon, rekurzívan be kell járnunk. Ekkor viszont minden egyes Node esetén a gyermek-ek lekérdezésekor, amennyiben LAZY fetch type-ot alkalmaztunk (és @OneToMany kapcsolat esetén ez az alapértelmezett), minden esetben lefut egy query, mely lekérdezi a gyermek Node-okat. Akkor sem jobb a helyzet, ha EAGER fetch type-ot alkalmazunk, mert ekkor nem a bejáráskor, hanem már a betöltéskor fog lefutni az összes query, azaz pontosan annyi, amennyi Node-ból áll az adott részfánk.&lt;/p&gt;&lt;p&gt;A háttérben a Node osztály egy NODE táblára képződik le, melynek van egy PARENT_ID külső kulcsa, és a gyermekek lekérdezése esetén egy olyan SELECT-et futtat, mely lekérdezi az összes olyan NODE sort, melynek PARENT_ID mezője megegyezik a szülő azonosítójával (SELECT * FROM node WHERE parent_id = ? ORDER BY rank ASC).&lt;/p&gt;&lt;p&gt;A hierarchikus adatok kezelésére bizonyos adatbázisok beépített megoldásokat tartalmaznak, pl. Oracle esetén a START WITH és CONNECT BY parancs, vagy esetleg tárolt eljárásban is megvalósíthatjuk a hierarchia elemeinek összegyűjtését. Mindkettő használható JPA-ból is, de ekkor bukjuk a platform függetlenséget.&lt;/p&gt;&lt;p&gt;Viszont van egy ennél sokkal hatékonyabb hierarchikus adatszerkezet reprezentáció, melyet nested tree-nek hívnak. Ez ugyan lekérdezéskor gyors, de módosításkor a több művelet miatt lassabb, így csak akkor érdemes használni, ha sok a lekérdezés, és viszonylag kevés a módosítás. Azért a legtöbb CRM rendszer ebbe a kategóriába sorolható.&lt;/p&gt;&lt;p&gt;A megértéshez nézzünk is egy példa fát. A trükk, hogy minden egyes Node-hoz felveszünk egy bal és egy jobb értéket. Egy létező fa esetén ezeket a számokat úgy osztjuk ki, hogy a gyökér elem bal értéke lesz az 1, és megyünk végig gyermekeken mélységi kereséssel, és a bal értékhez mindig hozzáadunk egyet. Ha levélelemhez érünk, akkor folytatjuk a számolást visszafele, a szülő fele, és kitöltjük a jobb értékeket, míg egy testvérhez érünk, és ekkor ismét a bal értékeket osztjuk ki, és így tovább. Gyakorlatilag óramutató járásával ellentétes irányban körbejárjuk a fát.&lt;/p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_czKgycLvmNo/SoM2dQ0_jcI/AAAAAAAAEhk/jw_I8e9ko8w/s1600-h/nested_1.png"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 320px; height: 134px;" src="http://2.bp.blogspot.com/_czKgycLvmNo/SoM2dQ0_jcI/AAAAAAAAEhk/jw_I8e9ko8w/s320/nested_1.png" alt="" id="BLOGGER_PHOTO_ID_5369195057117105602" border="0" /&gt;&lt;/a&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_czKgycLvmNo/SoM0uJG6c6I/AAAAAAAAEhU/HUkNtfx81_c/s1600-h/nested_1.png"&gt;&lt;/a&gt;&lt;p&gt;&lt;/p&gt;Az így nyert számozás azért nagyon hatékony részfák lekérdezésére, mert egy elem részfáját úgy kérhetjük le, ráadásul a preorder bejárással adott sorrendnek megfelelően, hogy lekérdezzük azon elemeket, melyek bal értéke a szülő bal értékénél nagyobbak és a jobb értékénél kisebbek, a bal érték alapján rendezve. Így a teljes részfa egy lekérdezéssel előállítható, szemben a rekurzív módszerrel, ahol annyi lekérdezésre volt szükség, ahány elemből állt a fa. Ez a sorrend tökéletes a fák ábrázolására, pl. egy menü vagy egy oldaltérkép megjelenítésére.&lt;p&gt;&lt;/p&gt;&lt;p&gt;A számozás alapján látható, hogy egy elem összes leszármazottjának a számát is könnyen megkaphatjuk: (bal érték - jobb érték - 1) / 2. Ez akkor lehet különösen hasznos, ha ezt a felületen is meg szeretnénk jeleníteni.&lt;/p&gt;&lt;p&gt;Szintén könnyen észrevehető összefüggés, hogy a levélelemekre igaz az az állítás, hogy jobb érték - bal érték = 1.&lt;/p&gt;&lt;p&gt;Az egyszerűség kedvéért hagyjuk meg a szülőre mutató referenciát, valamint javasolt egy attribútum felvétele, mely megadja az adott elem mélységét a fában (level). Mindkettőt persze ki lehet számolni lekérdezésekkel is. De ezen attribútumok használatával egyszerűbbek lesznek a lekérdező műveleteink, de több helyet foglal, és módosításkor többet kell adminisztrálni. Valamint a rank attribútumra már nem lesz szükség, hiszen a bal értékek már definiálnak egyfajta sorrendet. Így néz ki tehát az osztályunk:&lt;/p&gt;&lt;pre class="brush: java"&gt;public class Node {
...

private int level;

@ManyToOne
private Node parent;

private int left;

private int right;
...
}
&lt;/pre&gt;&lt;p&gt;Egy adott elem és annak leszármazottainak lekérdezése tehát a következő JPA lekérdezéssel adható meg, ahol az első paraméter a kiválasztott elem bal értéke, a második paraméter a kiválasztott elem jobb értéke:&lt;/p&gt;&lt;pre class="brush: sql"&gt;SELECT node FROM Node node WHERE node.left BETWEEN :first AND :last ORDER BY node.left
&lt;/pre&gt;&lt;p&gt;Tehát ha pl. a java.awt.Window elemet és annak összes leszármazottját akarjuk lekérdezni, akkor az összes elemet kell lekérdezni, melynek a bal értéke nagyobb, mint 3, és a jobb értéke kisebb, mint 14, a bal érték szerint rendezve.
Igaz, hogy a lekérdezés nagyon egyszerű, de a beszúrás viszont bonyolultabb. Amennyiben ugyanis egy elemet akarunk beszúrni, először ki kell választani a beszúrás helyét. Ha a beszúrandó elem&lt;/p&gt;&lt;ul&gt;&lt;li&gt;a kiválaszott elem első gyermeke lesz, az új elem bal értéke a kiválasztott elem bal értéke + 1 lesz&lt;/li&gt;&lt;li&gt;a kiválaszott elem utolsó gyermeke lesz, az új elem bal értéke a kiválasztott elem jobb értéke lesz&lt;/li&gt;&lt;li&gt;a kiválaszott elem bal testvére lesz, az új elem bal értéke a kiválasztott elem bal értéke lesz&lt;/li&gt;&lt;li&gt;a kiválaszott elem jobb testvére lesz, az új elem bal értéke a kiválasztott elem jobb értéke + 1 lesz&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Az új elem jobb értéke, mivel az elemnek még nincs gyermeke, az új elem bal értéke + 1 lesz. Ez után egy "eltoltást" kell elvégezni, ugyanis lehetséges, hogy az így kiosztott számok már foglaltak. Ehhez két művelet szükséges, egyrészt az összes olyan elem bal értékéhez, melynek a bal értéke nagyobb, vagy egyenlő, mint a beszúrandó elem bal értéke, hozzá kell adni 2-t. Valamint az összes olyan elem jobb értékéhez, melynek a jobb értéke nagyobb, vagy egyenlő, mint a beszúrandó elem bal értéke, hozzá kell adni 2-t. Ez két egyszerű JPA bulk update művelettel is elvégezhető, ahol a paraméter a beillesztendő elem bal értéke:&lt;/p&gt;&lt;pre class="brush: sql"&gt;UPDATE Node node SET node.left = node.left + 2 WHERE node.left &gt;= :position
UPDATE Node node SET node.right = node.right + 2 WHERE node.right &gt;= :position
&lt;/pre&gt;&lt;p&gt;Vegyük példaként, hogy a java.awt.Dialog elem első gyermekeként egy java.awt.FileDialog elemet akarunk felvenni. Az új elem bal értéke 9 lesz és a jobb értéke 10. Majd az összes elem bal értékét 2-vel növelni kell, melynek bal értéke nagyobb vagy egyenlő, mint 9, és ugyanígy az összes elem jobb értékét 2-vel növelni kell, melynek jobb értéke nagyobb vagy egyenlő, mint 9.&lt;/p&gt;&lt;p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/_czKgycLvmNo/SoM2j8suFwI/AAAAAAAAEhs/w2Pq7IKZE4E/s1600-h/nested_2.png"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 320px; height: 159px;" src="http://3.bp.blogspot.com/_czKgycLvmNo/SoM2j8suFwI/AAAAAAAAEhs/w2Pq7IKZE4E/s320/nested_2.png" alt="" id="BLOGGER_PHOTO_ID_5369195171972781826" border="0" /&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Ezek alapján a további műveletek is könnyen implementálhatóak. Egy részfa törlésénél töröljük az adott elemet, majd az így keletkezett "lyukra" húzzuk vissza a mögötte elhelyezkedő elemeket. Mivel nem csak egy elemet, hanem teljes részfát is törölhetünk, az eltolás nem 2-vel történik, hanem a részfa elemszáméval, melynek kiszámolását már fentebb leírtam.&lt;/p&gt;&lt;p&gt;A gyökértől adott elemhez vezető utat is egy lekérdezéssel megkaphatjuk, ugyanis a felmenő elemek mindegyikére igaz, hogy bal értékük kisebb, mint a kiválasztott elem bal értéke, és a jobb értékük viszont nagyobb, mint a kiválaszott elem jobb értéke. Ezt tehát a következő JPA lekérdezéssel kapjuk meg, ahol az első paraméter a kiválasztott elem jobb, a második a bal értéke:&lt;/p&gt;&lt;pre class="brush: sql"&gt;SELECT node FROM Node node WHERE node.left &lt; :left AND node.right &gt; :right ORDER BY node.left&lt;/pre&gt;&lt;p&gt;Az elem közvetlen gyermekeinek, valamint egy elem testvéreinek lekérdezése a parent mutató miatt nagyon egyszerű.
A legbonyolultabb persze a részfa mozgatása, itt is először meg kell határozni a mozgatni kívánt elem új bal és jobb értékét. Ez megegyezik a beszúrással. Ezután helyet kell csinálni a részfának, azaz a kiszámolt bal értékhez el kell tolni az elemeket annyival, amennyi elem van a részfában. Mind az eltolást, mind az elemek számának kiszámolását említettem. Eztán el kell mozgatni a részfát az üres helyre, szintén a bal és jobb elemek frissítésével, majd a keletkezett üres hely mögötti elemeket kell "visszahúzni" (bal és jobb értékek csökkentésével).&lt;/p&gt;&lt;p&gt;Ebből látszik, hogy ez a megoldás sem egyértelműen jobb, mint a klasszikus mutatós megoldás, de akkor jobban használható, ha sokkal több a lekérdezés, mint a módosítás. Én úgy valósítottam meg a fa műveleteket, hogy definiáltam egy interfészt, melybe felsoroltam a metódusokat, és az interfészt két osztály implementálta, az egyik a klasszikus műveletekkel, a másik a nested tree-vel. Persze az elemnek is csináltam egy közös absztrakt osztályt, melynek egyik leszármazottja mutatókat tartalmazott, másik leszármazottja pedig a bal és jobb értékeket. Persze Spring service-ként implementáltam őket, emiatt konfigurációval azonnal választani lehet a két implementáció között. Ez gyakorlatilag a strategy tervezési minta egy megvalósítása.&lt;/p&gt;&lt;p&gt;A témáról egy &lt;a href="http://www.sitepoint.com/article/hierarchical-data-database/2/"&gt;angol nyelvű cikk ír&lt;/a&gt;, mely egy PHP-s megoldást mutat be, bár a mozgatást nem részletezi. Sőt egy &lt;a href="http://weblabor.hu/cikkek/hierarchikusadatkezeles3"&gt;magyar cikk&lt;/a&gt; is megjelent, szintén PHP megvalósítással, miközben ezt a post-ot írtam (három részes, a negyedik cikk még nem jelent meg, ami a fa módosításáról fog szólni). A post írásakor ez a &lt;a href="http://affy.blogspot.com/ntm/Ntm.java"&gt;Java kódrészlet&lt;/a&gt; is nagyon hasznos volt, mely egyszerű JDBC-t használ.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/7149056741139538034/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/08/fa-abrazolasa-adatbazisban.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7149056741139538034'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7149056741139538034'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/08/fa-abrazolasa-adatbazisban.html' title='Fa ábrázolása adatbázisban'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://2.bp.blogspot.com/_czKgycLvmNo/SoM2dQ0_jcI/AAAAAAAAEhk/jw_I8e9ko8w/s72-c/nested_1.png' height='72' width='72'/><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1438029047403381023</id><published>2009-07-07T11:20:00.005+02:00</published><updated>2010-09-18T00:33:20.408+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Módszertan'/><category scheme='http://www.blogger.com/atom/ns#' term='Community'/><title type='text'>Fizikai rendszerterv generálás Java forráskódból</title><content type='html'>&lt;p&gt;Aktuális feladatunk fizikai rendszerterv írása. Értelmezésünkben a fizikai rendszerterv abban tér el a logikai rendszertervtől, hogy itt a technológia független típusok helyett már konkrét típusokat írunk. Pl. amíg a logikai rendszertervben egy osztálydiagrammon típusként a "szöveges" szerepelt, addig a fizikai rendszertervben az osztálydiagramban "String" szerepel, a tábla leírásoknál "VARCHAR(2)".&lt;/p&gt;&lt;p&gt;A logikai rendszertervben már az osztálydiagrammokat megrajzoltuk, a kérdés az volt, hogy hogyan tovább. Bizonyos eszközök támogatják a logikai modellből fizikai modellbe továbblépést, de az általunk használt nagyon egyszerű UMLet erre nem képes. Így adott volt a kérdés, hogy először rajzoljuk meg az osztálydiagramot, és abból generáljunk forráskódot (forward engineering), vagy először írjuk meg a forráskódot és abbol állítsuk elő az osztálydiagramot (reverse engineering). A roundtrip engineering, mikor mindkét helyen módosíthatjuk, és az egyik visszaszinkronizál a másikra nem volt cél, több munka lett volna vele, mint amennyi haszna. Valamint nem csak az osztálydiagrammokban gondolkodtunk, hanem a dokumentáció kigenerálhatóságában is. Így esett a választás a reverse engineering-re, azaz hogy a kódot írjuk, és abból generálunk osztálydiagramot és dokumentációt is. Ennek két oka volt, egyrészt a logikai rendszerterv során már előállt a rendszer váza, így nem volt rizikó egyből a kóddal kezdeni, másrészt a Java programozó lévén jobban szeretek egyből kódot írni, mint egy UML eszközben klikkelgetni, és egy refaktoring is könnyebben megy a kedvenc IDE-mben. Valamint szívesebben írok dokumentációt is JavaDoc-ba, hiszen az mégis kód közelibb, mint egy Word-be.&lt;/p&gt; &lt;p&gt;Szóval a cél adott, írjuk meg a program vázát Java-ban, generáljuk ki belőle a dokumentációt, lehetőleg az osztálydiagramot, és mivel JPA-t használunk, lehetőleg az adatbázis sémát, az adatbázis séma megjegyzéseit (Oracle COMMENT ON), az adatbázis séma dokumentációját, lehetőleg ezt is osztálydiagrammal. És lehetőleg semmit ne kelljen két helyen leírni. Eredményként egy Word dokumentumnak kell előállnia, amit valamilyen sablonnal lehessen megadni, hiszen saját formátumot kell használni, ami igazodik a projekt dokumentum formátumához.&lt;/p&gt;&lt;p&gt;Mivel a szöveges dokumentáció JavaDoc-ként kerül elkészítésre, adott az ötlet, hogy valamilyen doclet-tel kell megoldani a problémát. A doclet egy olyan programrész, mely a doclet API használatával a JavaDoc megjegyzéseket képes feldolgozni, és abból valamilyen kimenetet gyártani. A Sun standard Doclet-je generálja ki a mindenki számára jól ismert HTML JavaDoc dokumentációt, de tölthetőek le 3rd party doclet-ek is, és magunk is írhatunk ilyeneket. &lt;a href="http://www.doclet.com/"&gt;Utána is néztem&lt;/a&gt;, hogy milyen lehetőségek vannak. Első körben a &lt;a href="http://www.filigris.com/products/docflex_javadoc/about.php"&gt;DocFlex/Javadoc&lt;/a&gt; lett szimpatikus, de csak úgy ingyenes a használata, hogy nem nyúlunk a template-ekhez. Van hozzá template szerkesztő is, de annak használata már fizetős. Majd próbálkoztam a &lt;a href="http://jeldoclet.sourceforge.net/"&gt;JELDoclet&lt;/a&gt; eszközzel is, mely egy saját formátumú XML generál ki, és ezt lehet tovább XSLT transzformációval alakítani. Nem tetszett, hogy egy saját formátumon kell dolgozni, és az XSLT sem tetszik. Ezután akadt meg a szemem a &lt;a href="http://fikin-ant-tasks.sourceforge.net/"&gt;Fikin Ant Tasks&lt;/a&gt; projekten, melynek része a VelocityDoclet is. A Velocity-vel nagyon jó tapasztalataim voltak, így kapott egy esélyt.&lt;/p&gt;&lt;p&gt;A kérdés már csak az volt, hogy hogyan állítsak elő Word állományt. Natívan egyik eszköz sem támogatta, gyakorlatilag a működő megoldás Java platformon kizárólag a HTML, RTF vagy PDF generálás. Az RTF hamar kiesett, mert a táblázatok kezelése nagyon macerás. A PDF-ből a copy-paste szintén nem hozott szép eredményt, és a gyakori ékezetes probléma is hamar előjött. Így maradt a HTML, és Internet Explorer-ben egy viszonylag egyszerűen formázott HTML minden gond nélkül átvihető copy-paste-tel Word-be (Firefox-ból másolva már megint problémák adódtak).&lt;/p&gt;&lt;p&gt;De hogy is állítsuk elő a HTML dokumentációt? Írhattam volna a Velocity-ben egyből HTML template-et, de hogy megbizonyosodjak az előző állításokról, valamint kicsit szabványos legyen a megoldás, és ha véletlenül később más formátumra is szükség van, adoptálni lehessen a módszert, a DocBook mellett döntöttem. A &lt;a href="http://en.wikipedia.org/wiki/DocBook"&gt;DocBook&lt;/a&gt; egy tiszta XML formátum technikai dokumentációk írására, és több formátumba is lehet transzformálni, mint pl. HTML, XHTML, EPUB, PDF, man pages és HTML Help.&lt;/p&gt;&lt;p&gt;Tehát a megálmodott és később megvalósított folyamat a következő:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Java osztályok vázának megírása, JavaDoc-kal ellátása&lt;/li&gt;&lt;li&gt;Kialakításra kerül egy DocBook Velocity template&lt;/li&gt;&lt;li&gt;A VelocityDoclet a template alapján legenerálja a kész, kitöltött DocBook dokumentációt&lt;/li&gt;&lt;li&gt;A DocBook XML-ből egy XML transzformáció előállítja a HTML dokumentációt&lt;/li&gt;&lt;li&gt;Kézzel egy Word állományba átmásolásra kerül&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;A teljes folyamat persze automatizált, Ant végzi. Ehhez a következő szoftver elemeket kellett felhasználni:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="http://fikin-ant-tasks.sourceforge.net/"&gt;Fikin Ant Tasks 1.7.3&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://www.docbook.org/schemas/4x"&gt;DocBook 4.x sémák&lt;/a&gt;, hogy az XML szerkesztő eszköz syntax highlight-olja, és automatikus kódkiegészítsen&lt;/li&gt;&lt;li&gt;&lt;a href="http://xml.apache.org/xalan-j/"&gt;Xalan-Java 2.7.1&lt;/a&gt;, az XSLT transzformációhoz&lt;/li&gt;&lt;li&gt;&lt;a href="http://wiki.docbook.org/topic/DocBookXslStylesheets"&gt;DocBook xsl 1.75.1&lt;/a&gt;, mely az XSLT transzformációt végzi DocBook-ról HTML-re&lt;/li&gt;&lt;li&gt;&lt;a href="http://wiki.docbook.org/topic/DocBookXslStylesheets"&gt;DocBook xsl Xalan 1.0&lt;/a&gt;, Xalan kiegészítés az XSLT transzformációhoz&lt;/li&gt;&lt;li&gt;&lt;a href="http://xmlgraphics.apache.org/fop/"&gt;Apache FOP 0.95&lt;/a&gt;, XSL-FO engine, amennyiben nem csak HTML-t, hanem RTF-et vagy PDF-et akarok gyártani&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Sajnos a Fikin Ant Tasks-nak van egy-két hiányossága, amiért bele kellett nyúlni. Az utolsó kiadás 2007. márciusában volt. Egyrészt még nem támogatja a Java 1.5 nyelvi elemeit, pl. a generikusokat, valamint problémája van a karakterkódolásokkal, gyakorlatilag nem lehet ezeket megadni. Javítottam, és a &lt;a href="https://sourceforge.net/tracker/index.php?func=detail&amp;amp;aid=2817845&amp;amp;group_id=168390&amp;amp;atid=846618"&gt;patch-t&lt;/a&gt; el is küldtem a projektnek.&lt;/p&gt;&lt;p&gt;Ezzel a dokumentum generálás megvan, de mi van az osztálydiagrammal? Az UMLet-nek nagyon egyszerű saját XML formátuma van, melyet szintén ki lehet generálni. Az osztályok síkbeli pozícionálásával nem is érdemes vesződni, az úgy is kézi munka, hogy logikusan kerüljenek elhelyezésre, a köztük lévő kapcsolatokkal együtt. Ugyanezen módszerrel egy másik template-tel az Oracle COMMENT ON parancsai is kigenerálhatóak.&lt;/p&gt;&lt;p&gt;Az érdekesebb probléma az adatbázis táblák dokumentációjának kigenerálása. Mivel JPA-t használunk, az adatbázis séma is generálásra kerül. Mivel Hibernate JPA provider-t használunk, az képes arra, hogy a persistence.xml, és az annotált Java osztályokat felolvassa, és a belőlük generálandó táblákat és mezőket, mint meta-adatot el lehet kérni (ezt használja a séma generálás is). Ezt mutatja a következő kód:&lt;/p&gt;&lt;pre class="brush: java"&gt;// Első paraméter a Presistence Context neve a persistence.xml-ben
Ejb3Configuration cfg = new Ejb3Configuration().configure("FooPU", new HashMap());
Configuration hbmcfg = cfg.getHibernateConfiguration();
Dialect dialect = new Oracle10gDialect();
Mapping mapping = hbmcfg.buildMapping();
for (Iterator i = hbmcfg.getTableMappings(); i.hasNext(); ) {
Table t = (Table) i.next();
System.out.println("Table: " + t.getName());
for (Iterator it = t.getColumnIterator(); it.hasNext(); ) {
Column c = (Column) it.next();
System.out.println("Column: " + c.getName() + " " + c.getSqlType(dialect, mapping));
}
}
&lt;/pre&gt;&lt;p&gt;Ebből már az adatbázis dokumentáció is kigenerálható. Ahhoz, hogy ez bekerüljön a Velocity Context-be, kiegészítettem a VelocityDoclet-et az előbb említett patch-ben azzal, hogy az Ant task-nak paraméterként osztályneveket lehet megadni, azokat példányosítja, és helyezi el a Context-ben.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/1438029047403381023/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/07/rendszerterv-generalas-java-kodbol.html#comment-form' title='3 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1438029047403381023'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1438029047403381023'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/07/rendszerterv-generalas-java-kodbol.html' title='Fizikai rendszerterv generálás Java forráskódból'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>3</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4930170574388966834</id><published>2009-07-03T01:09:00.004+02:00</published><updated>2014-01-25T22:34:46.897+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='JAXB'/><category scheme='http://www.blogger.com/atom/ns#' term='Java SE'/><title type='text'>JAXB trükkök</title><content type='html'>&lt;p&gt;Frissítve: 2014. január 25.&lt;/p&gt;

&lt;p&gt;Felhasznált technológiák: JAXB&lt;/p&gt;

&lt;p&gt;A poszthoz tartozó példaprogram elérhető a &lt;a href="https://github.com/vicziani/jtechlog-xml"&gt;GitHubon&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id="körkörös-referencia"&gt;Körkörös referencia&lt;/h3&gt;

&lt;p&gt;Amennyiben JAXB esetén azt szeretnénk, hogy két osztály között a kapcsolat kétirányú legyen, azaz pl. a &lt;code&gt;Catalog&lt;/code&gt; osztály is hivatkozzon a &lt;code&gt;Book&lt;/code&gt; osztályra, és fordítva, a következő kivételt kapjuk: &lt;code&gt;com.sun.istack.internal.SAXException2: A cycle is detected in the object graph. This will cause infinitely deep XML:&lt;/code&gt;. Ez azt jelenti, hogy először mentené a &lt;code&gt;Catalog&lt;/code&gt; példányát, majd a &lt;code&gt;Book&lt;/code&gt; példányát, majd újra a &lt;code&gt;Catalog&lt;/code&gt; példányt, és így tovább, tehát egy körkörös hivatkozás alakul ki. Ennek &lt;a href="https://jaxb.dev.java.net/guide/Mapping_cyclic_references_to_XML.html"&gt;elkerülésére&lt;/a&gt; a visszamutató getterét &lt;code&gt;@Transient&lt;/code&gt; annotációval lássuk el, és a &lt;code&gt;Book&lt;/code&gt; objektumba vegyük fel az &lt;code&gt;afterUnmarshal&lt;/code&gt; metódust.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://yuml.me/11c7cc4d" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://yuml.me/11c7cc4d" alt="UML diagram a körkörös referenciáról"/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;pre class="brush: java"&gt;public class Book {

  private Catalog catalog;
 
  @XmlTransient
  public Catalog getCatalog() {
    return catalog;
  }

  public void afterUnmarshal(Unmarshaller u, Object parent) {
    this.catalog = (Catalog) catalog;
  }

  // ... stb...
}&lt;/pre&gt;

&lt;p&gt;Az &lt;code&gt;afterUnmarshal&lt;/code&gt; használatakor kiderült még egy érdekes dolog. A JDK 1.6.0_13-asban lévő JAXB 2.1.3 a kivételt elnyeli, és a program fut tovább. A 1.6.0_14-es verziószámú JDK-ba &lt;a href="http://www.oracle.com/technetwork/java/javase/6u14-137039.html"&gt;került&lt;/a&gt; JAXB RI 2.1.10-es verziója viszont nem kezeli le, hanem kivételt okoz. Azaz a kivétel elnyelése, az üres catch ágak használata nem csak azért rossz, mert amennyiben hiba van, nehezen találjuk meg, hanem azért is, mert amikor a hibát kijavítjuk, melyre egy másik hibát építettünk, az első javításakor előjön a másik. Tanulság, hogy két update között is lehetnek kompatibilitási problémák, így érdemes minden szóbajöhető JDK verzión letesztelni az alkalmazásunkat, vagy specifikáljuk a verziószámot kínosan pontosan. Az előbbi tovább erősíti az automatikusan futtatható teszt esetek hasznosságát.&lt;/p&gt;

&lt;p&gt;A JAXB RI 2.1 EA2-ban a körkörös referencia feloldására jelent meg a &lt;code&gt;CycleRecoverable&lt;/code&gt; interfész is.&lt;/p&gt;

&lt;h3 id="ős-és-leszármazott"&gt;Ős és leszármazott&lt;/h3&gt;

&lt;p&gt;Amennyiben azt szeretnénk, hogy legyen egy &lt;code&gt;Item&lt;/code&gt; osztály, annak két leszármazottja legyen, pl. &lt;code&gt;Book&lt;/code&gt; és&lt;code&gt;Magazine&lt;/code&gt;, és azt szeretnénk, hogy az XML-ben a &lt;code&gt;&lt;catalog&gt;&lt;/code&gt; tag alatt egyszer a &lt;code&gt;&lt;book&gt;&lt;/code&gt;, egyszer a &lt;code&gt;&lt;magazine&gt;&lt;/code&gt; tag szerepeljen, mindkettő leszármazotton definiáljuk az &lt;code&gt;@XmlRootElement&lt;/code&gt; annotációt, és adjuk meg &lt;code&gt;name&lt;/code&gt; paraméterül a kívánt nevet, és a &lt;code&gt;Catalog&lt;/code&gt; osztály &lt;code&gt;items&lt;/code&gt; változójára tegyük rá a &lt;code&gt;@XmlElementRef&lt;/code&gt; annotációt. Ez megoldja, hogy ne az attribútum neve alapján nevezze el a taget, hanem dinamikusan, a konkrét példány osztályában az &lt;code&gt;@XmlRootElement&lt;/code&gt; annotáció name attribútuma alapján.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://yuml.me/7340b799" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img width="500" height="138" border="0" src="http://yuml.me/7340b799" alt="UML diagram a leszármazottakhoz"/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;h3 id="típuskonverzió"&gt;Típuskonverzió&lt;/h3&gt;

&lt;p&gt;Van, hogy nem megfelelő nekünk a JAXB által választott típus, hanem saját osztályunk példányát akarjuk példányosítani. Pl. legyen az, hogy a &lt;code&gt;Book&lt;/code&gt; osztályunk &lt;code&gt;isbn&lt;/code&gt; attribútuma ne &lt;code&gt;String&lt;/code&gt;, hanem &lt;code&gt;Isbn10&lt;/code&gt; típusú legyen (mely egy saját osztály).&lt;/p&gt;

&lt;p&gt;Ez könnyedén megtehető. Egyrészt kell írnunk egy adaptert, mely a típusok közötti konverziót elvégzi.&lt;/p&gt;

&lt;pre class="brush:java"&gt;public class Isbn10Adapter extends XmlAdapter&amp;lt;String, Isbn10&amp;gt; {

    public Isbn10 unmarshal(String value) {
        return new Isbn10(value);
    }

    public String marshal(Isbn10 value) {
        return value.getValue();
    }
}&lt;/pre&gt;

&lt;p&gt;Másrészt használjuk az &lt;code&gt;@XmlJavaTypeAdapter&lt;/code&gt; annotációt.&lt;/p&gt;

&lt;pre class="brush:java"&gt;public class Book {

    @XmlAttribute
    @XmlJavaTypeAdapter(Isbn10Adapter.class)
    public Isbn10 getIsbn10() {
        return isbn10;
    }
    
    // stb...
}&lt;/pre&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/4930170574388966834/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/07/jaxb-trukkok.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4930170574388966834'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4930170574388966834'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/07/jaxb-trukkok.html' title='JAXB trükkök'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7801878101879687317</id><published>2009-07-03T00:58:00.008+02:00</published><updated>2014-01-20T15:09:03.777+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='JAXB'/><category scheme='http://www.blogger.com/atom/ns#' term='Java SE'/><title type='text'>JAXB</title><content type='html'>&lt;p&gt;Frissítve: 2014. január 20.&lt;/p&gt;

&lt;p&gt;Mostanában, ha XML-t kell használnom Java-ból, először mindig a JAXB (JavaTM Architecture for XML Binding) jut eszembe, ami egy nagyon egyszerűen, gyorsan használatba vehető binding framework, melynek feladata a Java objektumok és az XML elemek egymáshoz rendelése, egymással való megfeleltetése. Magasabb absztrakciós szintet képvisel, mint a SAX, vagy a DOM, hiszen itt gyakorlatilag a programból csak Java objektumokkal kell dolgoznunk, az oda és vissza alakítást elvégzi a framework. Hasonló az ORM-hez, csak ott a feladat Java objektumok relációs adatbázis elemekké (sorokká) alakítása.&lt;/p&gt;

&lt;p&gt;A binding és a mapping szavakat általában keverik, nincs is kiforrott definíció, azonban érdemes megfontolnunk Mark D. Hansen SOA Using Web Services című könyében az általa kifejlesztett terminológiát. Szerinte a binding esetén az XML séma egy megvalósulása a belőle képzett Java osztály, míg mapping esetén a Java osztályt például az üzleti logikánkban használjuk, csak egy megjelenési formája, hogy XML-be is mentjük, vagy onnan betöltjük, esetleg adatbázisba perzisztáljuk. Emiatt szerinte a JAXB egy binding framework.&lt;/p&gt;

&lt;p&gt;A JAXB egy szabvány (&lt;a href="http://jcp.org/en/jsr/detail?id=222"&gt;JSR-222&lt;/a&gt;, melynek a referencia implementációja a stílusosan csak &lt;a href="https://jaxb.dev.java.net/"&gt;JAXB Reference Implementation&lt;/a&gt;-nek hívott projekt, mely már a JDK része is. A legújabb, 1.6.0_14-es verziószámú JDK-ba került a JAXB RI 2.1.10-es verziója (ez könnyen ellenőrizhető a &lt;code&gt;xjc -version&lt;/code&gt; paranccsal).&lt;/p&gt;

&lt;p&gt;Fejlesztésnél választhatjuk azt, hogy a Java kódból indulunk ki, és abból generáljuk le az XML sémát a séma generátor (schema generator) segítségével. Vagy kiindulhatunk az XML sémából, és abból generáljuk le a Java kódot a séma fordító (schema compiler) segítségével. A kettő közötti megfeleltetést Java annotációkkal lehet konfigurálni, amiket az előbbi esetben magunk írunk, az utóbbi esetben a séma fordító generálja le az osztályokba. Szerencsére az előbbi esetben viszonylag kevés annotációt kell használni, hiszen a JAXB is követi az EJB 3 azon törekvését, hogy az annotációknak alapértelmezett értékeik legyenek, amivel már működik a programunk.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://java.sun.com/javaee/5/docs/tutorial/doc/figures/jaxb-overview.gif" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://java.sun.com/javaee/5/docs/tutorial/doc/figures/jaxb-overview.gif" width="500" height="267" alt="JAXB működése"/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;A legrosszabb eset, ha XML sémánk is van, és annak megfelelő XML dokumentumot kell gyártani, valamint Java osztályaink is vannak, amik valamilyen üzleti logikát valósítanak meg. Ekkor megpróbálhatunk a JAXB-vel trükközni, hogy úgy helyezzük el az annotációkat a Java osztályokon, hogy pont az az XML jöjjön ki, amit szeretnénk (nehezebb, mert nagy JAXB ismeret kell hozzá), vagy az XML sémából kigeneráljuk a Java osztályokat, mint DTO objektumok, és programból alakítgatjuk a business domaint megvalósítandó osztályainkra (redundánsabb a kód). Tehát a sémának az annotált Java osztályok felelnek meg, míg az XML dokumentumnak a Java objektumok. XML dokumentumból Java objektumok az unmarshall művelettel keletkeznek, fordítva a marshall művelet használható.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://java.sun.com/javaee/5/docs/tutorial/doc/figures/jaxb-dataBindingProcess.gif" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://java.sun.com/javaee/5/docs/tutorial/doc/figures/jaxb-dataBindingProcess.gif" alt="Binding" /&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;Nézzünk is egy egyszerű példát, mely &lt;a href="https://github.com/vicziani/jtechlog-xml"&gt;letölthető a GitHub-ról&lt;/a&gt;. Adott egy dokumentum, és annak több oldala. UML diagramja a következő ábrán látható. A kapcsolat egyirányú, csak a dokumentum hivatkozik az oldalakra.&lt;/p&gt;

&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://yuml.me/d966b4dd" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="http://yuml.me/d966b4dd" /&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;Ahhoz, hogy XML-lé alakítható legyen, a &lt;code&gt;Catalog&lt;/code&gt; osztályra tegyük rá az &lt;code&gt;@XmlRootElement&lt;/code&gt; annotációt. A JAXB miatt mindkét osztálynak rendelkeznie kell paraméter nélküli konstruktorral is.&lt;/p&gt;

&lt;pre class="brush:java"&gt;@XmlRootElement
public class Catalog {

    private List&amp;lt;Book&amp;gt; books;

    @XmlElement(name = &amp;quot;book&amp;quot;)
    public List&amp;lt;Book&amp;gt; getBooks() {
        return books;
    }

    public void setBooks(List&amp;lt;Book&amp;gt; books) {
        this.books = books;
    }
}&lt;/pre&gt;

&lt;p&gt;Az &lt;code&gt;@XmlElement&lt;/code&gt; annotáció hatására a tag neve nem az attribútum neve lesz, hanem a &lt;code&gt;name&lt;/code&gt; paraméterként megadott.&lt;/p&gt;

&lt;p&gt;Ahhoz, hogy ezt XML-be mentsük, a marshall műveletet kell meghívni a következőképpen. Először egy &lt;code&gt;JAXBContext&lt;/code&gt;-et kell létrehoznunk, és adjuk meg neki az XML-be menteni kívánt osztályokat. Utána létrehozzuk a Marshaller objektumot, majd meghívjuk a marshal metódust.&lt;/p&gt;

&lt;pre class="brush:java"&gt;JAXBContext ctx = JAXBContext.newInstance(Catalog.class, Book.class);
Marshaller marshaller = ctx.createMarshaller();
marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,
  Boolean.TRUE);
marshaller.setProperty(Marshaller.JAXB_FRAGMENT,
  Boolean.FALSE);


StringWriter writer = new StringWriter();
marshaller.marshal(catalog, writer);
return writer.toString();&lt;/pre&gt;

&lt;p&gt;És máris megjelenik a kívánt XML.&lt;/p&gt;

&lt;pre class="brush:xml"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;

&amp;lt;catalog&amp;gt;
    &amp;lt;book&amp;gt;
        &amp;lt;isbn10&amp;gt;059610149X&amp;lt;/isbn10&amp;gt;
        &amp;lt;title&amp;gt;Java and XML&amp;lt;/title&amp;gt;
        &amp;lt;author&amp;gt;Brett McLaughlin, Justin Edelson&amp;lt;/author&amp;gt;
        &amp;lt;publisher&amp;gt;O'Reilly Media&amp;lt;/publisher&amp;gt;
        &amp;lt;year&amp;gt;2006&amp;lt;/year&amp;gt;
    &amp;lt;/book&amp;gt;
    &amp;lt;book&amp;gt;
        &amp;lt;isbn10&amp;gt;1590597060&amp;lt;/isbn10&amp;gt;
        &amp;lt;title&amp;gt;Pro XML Development with Java Technology&amp;lt;/title&amp;gt;
        &amp;lt;author&amp;gt;Ajay Vohra&amp;lt;/author&amp;gt;
        &amp;lt;publisher&amp;gt;Apress&amp;lt;/publisher&amp;gt;
        &amp;lt;year&amp;gt;2005&amp;lt;/year&amp;gt;
    &amp;lt;/book&amp;gt;
&amp;lt;/catalog&amp;gt;&lt;/pre&gt;

&lt;p&gt;Ez az alapértelmezett működés, de ezt tetszőleges módon testre szabhatjuk. Például:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ha azt akarjuk, hogy az &lt;code&gt;isbn10&lt;/code&gt; attribútum legyen, tegyük rá a &lt;code&gt;getIsbn10()&lt;/code&gt; metódusra az &lt;code&gt;@XmlAttribute&lt;/code&gt; annotációt&lt;/li&gt;
&lt;li&gt;Ha ezt a field-re akarjuk tenni, akkor használjuk osztály szinten a &lt;code&gt;@XmlAccessorType(XmlAccessType.FIELD)&lt;/code&gt; annotációt, ez jelzi, hogy nem metódusra akarjuk rakni a többi annotációt&lt;/li&gt;
&lt;li&gt;Az &lt;code&gt;@XmlType(propOrder={...})&lt;/code&gt; annotációval adhatjuk meg az elemek sorrendjét&lt;/li&gt;
&lt;li&gt;Az &lt;code&gt;@XmlTransient&lt;/code&gt; annotációval megmondhatjuk egy attribútumra, hogy ne mentődjön az XML-be&lt;/li&gt;
&lt;li&gt;Az &lt;code&gt;@XmlElementWrapper&lt;/code&gt; annotációval az ismétlődő elemek köré tehetünk egy wrapper XML tag-et&lt;/li&gt;
&lt;li&gt;Amennyiben névteret is meg akarunk adni, tegyük ezt a &lt;code&gt;package-info.java&lt;/code&gt; állományban a &lt;code&gt;@XmlSchema&lt;/code&gt; annotáció segítségével.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ilyenkor az alapértelmezett binding működik, azaz meg van adva, hogy melyik XML séma típushoz milyen Java típus tartozik, és fordítva. Persze ezt is felüldefiniálhatjuk.&lt;/p&gt;

&lt;p&gt;Az XML-bel objektumok visszanyerése hasonlóan egyszerű:&lt;/p&gt;

&lt;pre class="brush:java"&gt;JAXBContext ctx = JAXBContext.newInstance(Catalog.class, Book.class);
Unmarshaller unmarshaller = ctx.createUnmarshaller();
return (Catalog) unmarshaller.unmarshal(source);&lt;/pre&gt;

&lt;p&gt;A Java forrásból XML sémát a &lt;code&gt;schemagen&lt;/code&gt; paranccsal generálhatunk. Amennyiben az XML séma felől szeretnénk elindulni, az &lt;code&gt;xjc&lt;/code&gt; parancsot kell kiadnunk, ami legenerálja a Java osztályokat.&lt;/p&gt;

&lt;p&gt;A Java EE 5 Tutorial-ban van egy &lt;a href="http://java.sun.com/javaee/5/docs/tutorial/doc/bnazf.html"&gt;fejezet&lt;/a&gt; a JAXB-ről is.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/7801878101879687317/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/07/jaxb.html#comment-form' title='5 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7801878101879687317'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7801878101879687317'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/07/jaxb.html' title='JAXB'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>5</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7385849849313115109</id><published>2009-05-29T00:23:00.004+02:00</published><updated>2009-05-29T00:28:54.589+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='SOA'/><category scheme='http://www.blogger.com/atom/ns#' term='Community'/><title type='text'>Sun Java Café</title><content type='html'>&lt;p&gt;Ma reggel voltam a kis szünet után első &lt;a href="http://blogs.sun.com/sunhu/entry/javaone_premier_a_java_cafen"&gt;Java Café-n&lt;/a&gt;, melyet már az előző bejegyzésben is hirdettem. Röviden összefoglalva méltó újrakezdés volt, érdemes volt elmenni.&lt;/p&gt;&lt;p&gt;Mikor beléptem, azonnal meglepődtem, mert tényleg sok érdeklődő volt. Kicsit irigykedtem, hiszen a &lt;a href="http://www.jum.hu/"&gt;JUM&lt;/a&gt; rendezvényekre ehhez képest kevesen jönnek el.&lt;/p&gt;&lt;p&gt;Két előadás volt, az elsőt Molnár István és Simon Géza tartotta, mind a ketten régi motorosok, rengeteg előadási gyakorlattal és tapasztalattal rendelkeznek, ennek megfelelően hozták a rájuk jellemző magas szintet. Az előadásukban egy SOA projektekben, GlassFish ESB-vel szerzett tapasztalatokat osztották meg velünk (, melynek egy részét már a JUM-on megismerhettük). Érdekes volt az előadási koncepció, miszerint Géza képviselte a megrendelőt, míg István az architektet. Géza hamar kiesett a szerepből, és visszapártolt a fejlesztői oldalra. :) Nekem kicsit sok volt a bevezető szöveg, mivel szinte mindegyik SOA projektnél ugyanezek a problémák vetődnek fel (pl. deployment, verziókezelés, eszközválasztás, belső szabványok kidolgozásának szükségessége, különböző környezetek, migráció, lokális elosztottság, stb.), de a SOA-ban járatlanabbnak hasznos lehetett, hogy mire kell figyelni. Persze feltűnt a kötelező grafika is, mikor a résztvevő rendszerek (bőven száz felett) egymással össze vannak kötve, egy nagy spagettit alkotva. Cél ennek kibogozása nagyvállalati környezetben bizonyított, szabványokon alapuló, nyílt forráskódú, tetszőlegesen skálázható megoldással. Ennek persze első lépése egy-több proof of concept (PoC) elkészítése a felvetett problémákat megoldandó.&lt;/p&gt;&lt;p&gt;Kétféle folyamatot különböztettek meg: egyrészt a message flow-t, melyek rövid, szinkron választ adó, emberi beavatkozás nélküli folyamatok, valamint a process flow-t, amik a hosszabb, akár több hetes, emberi beavatkozást is igénylő folyamatok. Ezek állapotait persze a hosszuk és aszinkronitásuk miatt perzisztálni kell. A PoC után elsőnek egy hitelbírálati rendszert valósítottak meg, és elhangozottak olyan komoly követelmények is, hogyha változik egy üzleti szabály, akkor az ügyintézőknek kiosztott feladatokat automatikusan újraallokálja a rendszer, azaz egy megkezdett ügyet a módosult szabály alapján akár átteheti másik ügyintézőnek.&lt;/p&gt;&lt;p&gt;Azért szerencsére elhangoztak implementációs trükkök is a Glassfish ESB-vel kapcsolatban, amihez NetBeans fejlesztőeszközt használtak a SOA Pack-kel, és BPEL-t a folyamatok leírására. Pár dolog, amiket érdemes megjegyezni:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Egyrészt érdemes mérni az alkalmazást (erre a &lt;a href="https://hulp.dev.java.net/"&gt;Hulp&lt;/a&gt; eszközt alkalmazták - nem azonos a profiler-rel, ebben a naplózáshoz hasonlóan nekünk kell elhelyezni a mérőkódokat), mert ott javíthatunk jelentősen a sebességen, ahol nem is gondolunk rá.&lt;/li&gt;&lt;li&gt;Pl. érdemes a JAXB esetén a JAXBContext példányt nem minden metódushíváskor példányosítani, hanem ezt a példányt a metódushívások között megtartani (pl. EJB esetén a @PostConstruct interceptor-ban.&lt;/li&gt;&lt;li&gt;Az XSLT transzformációt is inkább a különálló XSLT service engine-ben érdemes végrehajtani, mint a BPEL engine-en belül.&lt;/li&gt;&lt;li&gt;Hosszú folyamatoknál érdemes a WS-ReliableMessaging szabványt használni. Itt egyszerű timeout kezelés nem elegendő, hiszen lehet, hogy azért nem jött válasz, mert humán interakcióra vár.&lt;/li&gt;&lt;li&gt;Érdemes alkalmazni pl. két Glassfish ESB között a &lt;a href="http://en.wikipedia.org/wiki/Fast_Infoset"&gt;Fast Infoset&lt;/a&gt; szabványt, mely az XML-ek egy bináris ábrázolási módja. Ezt a 6-os Java már alapban tartalmazza. Már 30%-os méretcsökkenést is mértek. Sőt, külső adatszótár használatával tovább lehet gyorsítani.&lt;/li&gt;&lt;li&gt;Ekkora méretnél a Composite Application Service Assembly Editor már használhatatlan. Emiatt még a fejlesztőeszközt is bővítették, egy JBI connection builder-t implementáltak, mellyel ezt manuálisan, scriptelhetően el lehet végezni, és akár különböző konfigurációk alapján is képes összeállítani a service assembly-ket.&lt;/li&gt;&lt;li&gt;Egyik legnagyobb kihívás a verziókezelés volt. Erre egy elegáns megoldást találtak. Egyrészt felosztották a folyamatokat core folyamatokra, mely mindenütt azonos, és local folyamatokra, melyek országonként különböznek. A különböző web szolgáltatások hívásainál a hívás fejlécében elhelyeztek egy ország és verzió paramétert, mely alapján egy köztes réteg (content based routing) átfordította a hívást. Ez képes nem csak a különböző implementációk, de a különböző interfészek változásait (WSDL-ben szereplő séma vagy névtér változásokat) kezelni.&lt;/li&gt;&lt;li&gt;Teszt kliensnél a SOAPUi-t használták mely mostanában egyre több előadásban szerepel, valamint hangsúlyozták, hogy érdemes az eredeti rendszereket szimuláló un. emulátorokat is építeni, melyek segítenek a tesztelésben, nem a távoli, megbízhatatlan külső rendszerrel kell kapcsolatot teremteni. Furcsa, hogy erre nem a SOAPUi-t használták, pedig tud web szolgáltatásokat emulálni, és a mock, mint fogalom sem hangzott el.&lt;/li&gt;&lt;/ul&gt;A második előadást Ekler Péter tartotta mobil fejlesztésekkel kapcsolatban, melyet a BME Automatizálási és Alkalmazott Informatikai Tanszékének mobil kutatással és alkalmazásfejlesztéssel foglalkozó &lt;a href="http://amorg.aut.bme.hu/hu/home"&gt;csoportján&lt;/a&gt; belül végez. Két szoftver került bemutatásra, egyrészt a MobSensor, mely a mobiltelefon fényképezőgépét és mikrofonját felhasználva képes mozgást vagy hangot észlelni, és riasztani (lokálisan, neten, vagy akár más telefonokon is). A mozgást pl. két kép összehasonlításával végzi, amit már közel real time-ban képes egy fejlettebb mobiltelefon processzora megtenni. Valamint bemutatásra került a MobTorrent, mely, mint a neve is mutatja, egy mobil torrent kliens. Ez a téma is érdekes volt, bár nekem kevésbé témába vágó. Ami újdonság volt számomra, hogy pl. egy Bluetooth kommunikáció akár 10x kevésbé energiaigényes, mint egy WLAN kapcsolat.
&lt;p&gt;Szóval nagyon megérte elmenni, a következőn is ott leszek. Az esemény végén ígéretet kaptunk arra is, hogy a &lt;a href="http://java.sun.com/javaone/"&gt;JavaOne&lt;/a&gt; konferencián hallottakról is lesz egy Java Café rövidesen.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/7385849849313115109/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/05/sun-java-cafe.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7385849849313115109'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7385849849313115109'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/05/sun-java-cafe.html' title='Sun Java Café'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6811375835217515356</id><published>2009-05-22T00:32:00.006+02:00</published><updated>2009-05-29T00:32:39.720+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Community'/><title type='text'>JUM 10</title><content type='html'>&lt;p&gt;Immár tizedik alkalommal került megrendezésre a &lt;a href="http://jum.hu/?q=node/16"&gt;JUM (Java User Meetings)&lt;/a&gt;, a hazai Java programozók közösségi estje. mely a kicsit kapkodó, utolsó pillanatra maradó szervezéshez képest igen színvonalasra, jó hangulatúra sikeredett. Valószínűleg a késői hirdetés miatt kevesebben voltak, mint a múltkori alkalommal.&lt;/p&gt;&lt;p&gt;Az első előadást Rév Tamás tartotta a Groovy és a Java SOA projektekben történő használatáról. A projektben, melyben a Groovy-t kipróbálták, értelmezésem szerint a feladat az volt, hogy egy legacy rendszer (hogy politikailag korrektek legyünk EIS - Enterprise Information System) http kommunikációs felülete elé kellett tenni egy SOAP interfészt (gyakorlatilag egy adapter-t). Ehhez bizonyos transzformációk már megvoltak egy egzotikus &lt;a href="http://publib.boulder.ibm.com/infocenter/wbihelp/v6rxmx/index.jsp?topic=/com.ibm.etools.mft.fp8.doc/ak00990_.htm"&gt;ESQL nyelven&lt;/a&gt; (WebSphere Business Integration Message Broker nyelve üzenetben található adatok kezelésére), ezt kellett XSLT transzformációkká átírni. Ezt nem kézzel oldották meg, hanem a Groovy-t használták (persze aztán emberi ellenőrzést is igényelt).&lt;/p&gt;&lt;p&gt;A Groovy egy Java Virtuális Gépen működő szkript nyelv, mely egyrészt rendelkezik azzal az előnnyel, hogy Java alapú, így Java fejlesztőknek viszonylag kézre áll, de rendelkezik a script nyelvek tulajdonságaival, agilis módon, gyorsan lehet működő megoldásokat összeállítani. Nem esett szó a GRails-ról, mely egy Groovy alapú keretrendszer webes alkalmazások fejlesztésére.&lt;/p&gt;&lt;p&gt;A Groovy-t nem a tulajdonságai és a tapasztalatok alapján választották a projektbe, hanem gyakorlatilag kipróbálták, hiszen alkalmasnak látszott a feladat megoldására. Viszonylag kevés hangzott el az erősségeiről, annál több a gyengéiről. Van némi probléma a kollekciók kezelésével, illetve a NetBeans IDE pluginnek is vannak még gyermekbetegségei, pl. a kódkiegészítés terén.&lt;/p&gt;&lt;p&gt;Valahogy ez a megoldás sem győzött meg arról, hogy nekem bármilyen script nyelvet kellene használnom. Sajnos, vagy szerencsére nem vettem még részt olyan projektben, ahol indokolt lett volna a használata, vagy egyáltalán felmerült volna. Úgy gondolom, hogy inkább a fejlesztési oldalon lehet hasznos, különböző eszközök (pl. automatikus teszt eszközök) megtámogatására, de éles üzemben működő üzleti rendszerben nagyon meg kell fontolni a használatukat.&lt;/p&gt;&lt;p&gt;A második előadást Corsin Decurtins tartotta, aki Svájcból jött népszerűsíteni az objektumorientált adatbázisokat, valamint a zürichi &lt;a href="http://jazoon.com/"&gt;Jazoon&lt;/a&gt; Java-s konferenciát. Az előadás eredetileg a &lt;a href="http://jazoon.com/jazoon07/en/conference/presentationdetails.html?type=sid&amp;amp;detail=874"&gt;Jazoon 2007&lt;/a&gt;-es konferencián hangzott el. Néhány szó az objektumorientált adatbázisokról. Előnyei:
&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Nincs szükség relációs adatbázisok telepítésére, hosszas konfigurálásra, azonnal használatba vehető&lt;/li&gt;&lt;li&gt;Nincs szükség egy felesleges mapping, ORM rétegre, mely az objektumorientált adatokat relációs formába képezné&lt;/li&gt;&lt;li&gt;Támogatottak az objektumorientált világ olyan fogalmai, mint az öröklődés, polimorfizmus és az egységbezárás&lt;/li&gt;&lt;li&gt;Lekérdezések összeállítása metódusok segítségével (a Hibernate Criteria API-jához hasonlóan)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Hátrányai (kiegészítve a saját véleményemmel is):
&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Nehéz a bevált és széles körben elterjedt relációs adatbázisok egyeduralmát megtörni
&lt;/li&gt;&lt;li&gt;Szabvány hiánya (az előadó véleménye szerint a szabványosításhoz kicsi a piac)
&lt;/li&gt;&lt;li&gt;Rossz híre van, a régebbi, kiforratlan technológia miatti projekt sikertelenségek miatt&lt;/li&gt;&lt;li&gt;Nagyon jó lekérdező, menedzsment és optimalizációs eszközök léteznek RDBMS-ekre&lt;/li&gt;&lt;li&gt;Nagy terhelés esetén az RDBMS-eknek jobb a teljesítményük a létező optimalizációs technikák (indexek, stb.) valamint skálázhatóságuk miatt&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Az előadás alapvetően arról szólt, hogy hogyan lehet minimális erőbefektetéssel egy beágyazott objektumorientált adatbázist prototípus készítésre felhasználni. Szóba került a &lt;a href="http://www.db4o.com/"&gt;db4o&lt;/a&gt; megvalósítás is. Az előadó elmondta, hogy az objektumorientált adatbázisok nem versenytársai az RDBMS-eknek, hanem egy kiegészítő technológia, speciális célokra. Szerintem ha nem lett volna annyi bukta ezek indulásakor, mikor még az ORM eszközök nem voltak ilyen fejlettek, és nem voltak Java-ban implementált beépített adatbázis-kezelő rendszerek, sokkal nagyobb sikereket ért volna el a technológia. Tapasztalatom szerint most egy Apache Derby-re épülő &lt;a href="http://developers.sun.com/javadb/"&gt;JavaDB&lt;/a&gt; beágyazott adatbázissal és a JPA használatával is nagyon gyorsan lehet perzisztenciát megvalósítani pl. pilot projektekben minimális konfigurációval.&lt;/p&gt;&lt;p&gt;A harmadik előadás egy nagyon kötetlen hangvételű, pörgős, élvezetes előadás volt az &lt;a href="http://aws.amazon.com/"&gt;Amazon Web Service&lt;/a&gt;-ek világából, Elek Mártontól. Az Amazon a következő szolgáltatásokat biztosítja a saját infrastruktúráján, melyek web szolgáltatás felületen (SOAP és REST) elérhetőek:
&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Amazon Elastic Compute Cloud (Amazon EC2): előregyártott vagy feltöltött virtuális gépeket tudunk futtatni az Amazon infrastruktúráján, és ezeket webes felületen, vagy web szolgáltatásokkal is vezérelhetjük&lt;/li&gt;&lt;li&gt;Amazon SimpleDB: alapvető adatbázis funkciókat nyújt&lt;/li&gt;&lt;li&gt;Amazon Simple Storage Service (Amazon S3): maximum 5 gigás állományok tárolására szolgál&lt;/li&gt;&lt;li&gt;Amazon CloudFront: megoldja az adatok terítését a világban azáltal, hogy az adatközpontok felé kiküldi az adatokat, és minden felhasználót a hozzá legközelebb eső szolgálja ki&lt;/li&gt;&lt;li&gt;Amazon Simple Queue Service (Amazon SQS): egyszerű aszinkron üzenetküldésre&lt;/li&gt;&lt;li&gt;Amazon Elastic MapReduce: a számítási kapacitás kihasználásra nagy számításigényű műveleteknél (adatbányászat, elemzések, stb.)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Az árazásról csak annyit, hogy összehasonlítva a magyar árakkal is igen versenyképes, és nagyszerű rendelkezésre állással és sebességgel rendelkezik. Kitűnő versenyző a cloud világában, jó megoldás lehet egy startup cégnek, hiszen ezzel alacsony költségeken beindítható a szolgáltatás, és a terhelés növekedésével lehet újabb erőforrásokat bevonni (persze magasabb költségen). Mivel egyszerű web szolgáltatások, a standard Java-s eszközökkel is egyszerűen használhatók, de vannak már kész Java könyvtárak is ezen szolgáltatások elérésére.
&lt;/p&gt;&lt;p&gt;A következő JUM ideje még bizonytalan, lehet, hogy egy kis nyári szünet következik. Amennyiben bármilyen Java eszközzel, technológiával kapcsolatban megosztanád másokkal a tapasztalataidat, &lt;a href="http://jum.hu/index.php?q=contact"&gt;jelentkezz&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;És ne feledjétek, hogy 2009. május 28-án a Sun által rendezett &lt;a href="http://blogs.sun.com/sunhu/entry/javaone_premier_a_java_cafen"&gt;Java Cafe&lt;/a&gt;-n lehet egy előadást hallani a GlassFish ESB-vel kapcsolatos, projekt közben szerzett tapasztalatokról, valamint egy mobiltelefonos mozgás és a zaj érzékelő alkalmazásról. Ezek az előadások fognak elhangozni a JavaOne konferencián is.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/6811375835217515356/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/05/jum-10.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6811375835217515356'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6811375835217515356'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/05/jum-10.html' title='JUM 10'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1892525895813380459</id><published>2009-05-10T17:58:00.009+02:00</published><updated>2012-09-28T10:27:52.591+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Java SE'/><category scheme='http://www.blogger.com/atom/ns#' term='JPA'/><title type='text'>Hibernate EclipseLink átállás</title><content type='html'>&lt;p&gt;Egy JPA-t használó Spring-es alkalmazásban tesztképpen ideiglenesen átálltam a JPA implementációval Hibernate-ről EclipseLink-re. Ennek lépéseit írnám le, hátha még jól fog jönni (akár magamnak, akár másnak). Akit ez nem annyira érdekel, annak is érdemes végigolvasnia, mert e kapcsán leírom, hogy mi is az a weaving, Java agent, instrumentation, stb.&lt;/p&gt;&lt;p&gt;Első lépés a JAR állományok cseréje volt. Míg a Hibernate esetén egy rakás JAR-t kellett a CLASSPATH-ba tenni (hibernate3.jar, hibernate-annotations.jar, hibernate-commons-annotations.jar, hibernate-entitymanager.jar és az összes függőségeik), addig nagyon szimpatikus az EclipseLink-ben, hogy csak a eclipselink.jar-r kellett bemásolni.&lt;/p&gt;&lt;p&gt;Következő lépésként a Spring konfigurációs állományában kellett módosításokat végezni. Az eredeti applicationContext.xml részlet:&lt;/p&gt;&lt;pre class="brush: xml"&gt;
&amp;lt;bean id="entityManagerFactory"
   class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&amp;gt;
 &amp;lt;property name="dataSource" ref="dataSource"/&amp;gt;

 &amp;lt;property name="jpaVendorAdapter"&amp;gt;
     &amp;lt;bean
         class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"&amp;gt;
         &amp;lt;property name="showSql" value="false" /&amp;gt;
         &amp;lt;property name="generateDdl" value="true" /&amp;gt;
      &amp;lt;property name="databasePlatform" value="org.hibernate.dialect.MySQL5Dialect" /&amp;gt;
     &amp;lt;/bean&amp;gt;
 &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;p&gt;A módosított applicationContext.xml részlet:&lt;/p&gt;&lt;pre class="brush: xml"&gt;
&amp;lt;bean id="entityManagerFactory"
   class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&amp;gt;
 &amp;lt;property name="dataSource" ref="dataSource"/&amp;gt;

 &amp;lt;property name="jpaVendorAdapter"&amp;gt;
     &amp;lt;bean
         class="org.springframework.orm.jpa.vendor.EclipseLinkJpaVendorAdapter"&amp;gt;
         &amp;lt;property name="showSql" value="false" /&amp;gt;
         &amp;lt;property name="generateDdl" value="true" /&amp;gt;
      &amp;lt;property name="databasePlatform" value="org.eclipse.persistence.platform.database.MySQLPlatform" /&amp;gt;
     &amp;lt;/bean&amp;gt;
 &amp;lt;/property&amp;gt;

 &amp;lt;property name="loadTimeWeaver"&amp;gt;
&amp;lt;bean class="org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver" /&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;p&gt;Ez még mindig nem volt elég, a JVM-nek paraméterként meg kellett adni a következő kapcsolót: -javaagent:lib/spring-agent.jar.&lt;/p&gt;&lt;p&gt;Az alkalmazás így tökéletesen futott, az egyetlen különbség az volt, hogy másképp kezelték az automatikus azonosító generálást. Az entitásomat a @GeneratedValue(strategy=GenerationType.AUTO) annotációval láttam el, ami azt jelenti, hogy az adatbázis platform alapján döntsön generálási mechanizmust. Az EclipseLink az azonosítónak egy sequence nevezetű táblát generált, melyből vette az azonosítót (alapesetben 50-esével cache-elve), míg a Hibernate az id mezőt a MySQL auto increment tulajdonsággal látta el.&lt;/p&gt;&lt;p&gt;De miért is kellett a -javaagent kapcsoló? A JPA implementációk a POJO példányokat különböző mechanizmusok szerint tárolhatják. Kézenfekvő megoldás lenne a reflection használata, de ennek lassúsága miatt ezt a gyakorlatban nem használják. A másik megoldás, hogy futás közben un. proxy osztályokat generálnak, melyek elvégzik az adatbázis műveleteket, majd továbbítják a hívást a POJO felé. Ehhez futás közben kell bájtkódot generálni (runtime bytecode generation), ehhez a Hibernate a CGLIB könyvtárat használja. Az EclipseLink ezzel szemben a weaving-et használja, azaz a lefordított bájtkódot (POJO bájtkódját) módosítja. Ez szükséges a lazy loading, change tracking, fetch groups és a belső optimalizálások megvalósítására. Ez történhet fordításkor (static weaving), és történhet futás közben is (dynamic weaving). Ez utóbbit Java agent-tel lehet megvalósítani.&lt;/p&gt;&lt;p&gt;A Java agent a Java 5-ben jelent meg, és bővebb leírása a &lt;a href="http://java.sun.com/javase/6/docs/api/java/lang/instrument/package-summary.html"&gt;java.lang.instrument csomag&lt;/a&gt; dokumentációjában található. Az agent egy JAR állomány, ami a manifest-ben tartalmaz egy Premain-Class bejegyzést, mely egy osztályra mutat. Ennek az osztálynak tartalmaznia kell egy public static void premain(String agentArgs, Instrumentation inst) metódust, vagy ennek második paraméter nélküli verzióját. A -javaagent JVM kapcsolóval a jar állományt kell megadni (akár több -javaagent kapcsolót is megadhatunk), és a VM inicializálásakor, az alkalmazás main metódusának hívása előtt le fognak futni a premain metódusok is.
A VM elindulása után is biztosít a Java lehetőséget az agent-ek indítására, ekkor az agentmain metódust kell implementálni. Ilyenkor a manifest.mf fájlban a Agent-Class bejegyzést kell megadni. A agentmain metódus nem kerül meghívásra a -javaagent JVM parancssori kapcsoló használatakor. A premain metódus viszont csak a parancssori kapcsoló használatakor kerül meghívásra.&lt;/p&gt;&lt;p&gt;Mindkettő metódus opcionálisan megkaphat egy Instrumentation példányt. Ennek feladata az instrumentálás, azaz a bájtkód módosítása ClassFileTransformer-ek használatával. Ez sok egyéb paraméter mellett a bájtkódot kapja bájttömbként, és ezt is adja vissza.&lt;/p&gt;&lt;p&gt;Természetesen nem csak a JPA esetén szokták használni, hanem monitorozásra, profile-olásra, lefedettség mérésre (code coverage), naplózásra, vagy az aspektus orientált programozás megvalósítására (lsd. AspectJ). Ezek általában az alkalmazás működését nem módosítják.&lt;/p&gt;&lt;p&gt;Szóval ezért nem kell a -javaagent kapcsoló a Hibernate-hez, ami a CGLIB-bel generál futásidőben proxy osztályokat, és ezért kell az EclipseLink-nek, ami a JPA entitás POJO-kat instrumentálja.&lt;/p&gt;&lt;p&gt;&lt;a href="http://today.java.net/pub/a/today/2008/04/24/add-logging-at-class-load-time-with-instrumentation.html"&gt;Nalózás megvalósítása agent-tel és javassist bájtkód manipuláló könyvtárral&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://wiki.eclipse.org/Introduction_to_EclipseLink_Application_Development_%28ELUG%29#Using_Weaving"&gt;Weaving használata az EclipseLink-ben&lt;/a&gt;&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/1892525895813380459/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/05/hibernate-eclipselink-atallas.html#comment-form' title='5 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1892525895813380459'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1892525895813380459'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/05/hibernate-eclipselink-atallas.html' title='Hibernate EclipseLink átállás'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>5</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4290553583416988902</id><published>2009-05-07T23:32:00.003+02:00</published><updated>2012-04-29T11:51:21.457+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Oktatás'/><title type='text'>Könyvespolcom</title><content type='html'>&lt;p&gt;Készítettem egy fényképet a könyvespolcomról, mintegy referenciaként, hogy a neten kívül mi alapján tájékozódom a Java világában. Nagyon sok könyvet a Számalk Továbbképzésnek köszönhetek. Jelenlegi kedvenceim ezekből:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Martin Fowler, Kendall Scott: UML Distilled: A Brief Guide to the Standard Object Modeling Language (3rd Edition) - nagyon jó, gyors, de mégis alapos áttekintés az UML leggyakrabban használt jelöléseiről. Könnyen olvasható, humoros.
&lt;/li&gt;&lt;li&gt;Nyékiné Gaizler Judit: Java 2 Útikalauz Programozóknak - egy időben sokáig naponta forgattam. Ennek most jelent meg a Java 5-tel foglalkozó kiadása, generikusokkal, annotációkkal, stb.&lt;/li&gt;&lt;li&gt;Anil Hemrajani: Agile Java Development with Spring, Hibernate and Eclipse (Developer's Library) - az elsőhöz hasonlóan szintén gyorsan olvasható könyv, mely rövid bevezetést nyújt az agilis szoftverfejlesztés és a leggyakrabban használt Java eszközök világába.&lt;/li&gt;&lt;li&gt;Pro EJB 3: Java Persistence API: A JPA miatt erre is gyakran van szükségem. Nagyon részletesen bemutatja a JPA-t, és tanácsokat is ad, hogyan kéne jól használni.
&lt;/li&gt;&lt;/ul&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_czKgycLvmNo/SgNWuJ4b_LI/AAAAAAAADmo/bcSumMeVZbo/s1600-h/konyvespolc.jpg"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 320px; height: 118px;" src="http://1.bp.blogspot.com/_czKgycLvmNo/SgNWuJ4b_LI/AAAAAAAADmo/bcSumMeVZbo/s320/konyvespolc.jpg" alt="" id="BLOGGER_PHOTO_ID_5333201734663404722" border="0" /&gt;&lt;/a&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/4290553583416988902/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/05/konyvespolcom.html#comment-form' title='1 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4290553583416988902'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4290553583416988902'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/05/konyvespolcom.html' title='Könyvespolcom'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://1.bp.blogspot.com/_czKgycLvmNo/SgNWuJ4b_LI/AAAAAAAADmo/bcSumMeVZbo/s72-c/konyvespolc.jpg' height='72' width='72'/><thr:total>1</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6830182434857140108</id><published>2009-05-07T23:10:00.007+02:00</published><updated>2010-09-18T00:35:57.817+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Tesztelés'/><category scheme='http://www.blogger.com/atom/ns#' term='Spring'/><category scheme='http://www.blogger.com/atom/ns#' term='JPA'/><title type='text'>JPA tömeges műveletek</title><content type='html'>&lt;p&gt;Történt a mai napon, hogy egy újabb felfedezést tettem a JPA tömeges műveleteivel (bulk update and delete) kapcsolatban.&lt;/p&gt;A JPA ugyanis lehetőséget biztosít egyszerre több entitás egyidejű módosítására, ahelyett, hogy az összeset be kéne tölteni, és egyesével módosítani. Ennek működése és szintaktikája hasonló az SQL UPDATE műveletéhez, azzal a különbséggel, hogy itt nem csak egy táblán, hanem a teljes entitáson lehet operálni. Formátuma a következő:
&lt;pre&gt;UPDATE &amp;lt;entity name&amp;gt; [[AS] &amp;lt;identification variable&amp;gt;]
SET &amp;lt;update statement&amp;gt; {, &amp;lt;update statement&amp;gt;}*
[WHERE &amp;lt;conditional expression&amp;gt;]
&lt;/pre&gt;Az update statement esetén az egyenlőségjel bal oldalán egy egyértékű path kifejezés áll (pl. emp.salary), a jobb oldalán egy viszonylag korlátozott kifejezés (literálra feloldható, egyszerű típusú értékre feloldható kifejezés, függvény, változónév vagy paraméter).
&lt;p&gt;Erre egy példa:
&lt;/p&gt;&lt;pre&gt;UPDATE Employee e
SET e.salary = 60000
WHERE e.salary = 55000
&lt;/pre&gt;A SET és WHERE kifejezésben látható path kifejezés mutatja, hogy nem SQL-ről van szó, hanem annál objektumorientáltabb nyelvvel állunk szemben, ahol megengedett az attribútumok láncolása.&lt;p&gt;Ehhez hasonlóan létezik a DELETE kifejezés is:
&lt;/p&gt;&lt;pre&gt;DELETE FROM &amp;lt;entity name&amp;gt; [[AS] &amp;lt;identification variable&amp;gt;]
[WHERE &amp;lt;conditional expression&amp;gt;]
&lt;/pre&gt;&lt;p&gt;Ennek külön érdekessége, hogy figyelembe veszi az öröklődést, tehát a feltételnek megfelelő osztályok is törlésre kerülnek. Viszont nem veszi figyelembe a kaszkádolást, szóval csak a kifejezésben szereplő, valamint annak alosztályához tartozó típusú entitásokat fogja törölni a kifejezés, nem töröl hozzájuk kapcsolódó objektumokat.&lt;/p&gt;Ezek használatához a Query executeUpdate() metódusát kell meghívni.&lt;p&gt;&lt;/p&gt;&lt;p&gt;Az egyik jelenlegi projektben próbálkozom egy kicsit a teszt vezérelt fejlesztés (Test Driven Development - TDD) megközelítéssel, és gondoltam olyan teszt eseteket használok, melyek függetlenek az adatbázis kezdő állapotától, azaz először mindig inicializálom a tábla tartalmát, lefut a teszt eset, majd hogy minden adat visszaálljon, végrehajtok egy rollback műveletet. A problémák akkor adódtak, mikor egy tömeges műveletet végrehajtó funkciót akartam tesztelni. A teszt a következőképp nézett ki:
&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Új tranzakció indítása&lt;/li&gt;&lt;li&gt;Összes entitás törlése&lt;/li&gt;&lt;li&gt;Teszt entitások perzisztálása&lt;/li&gt;&lt;li&gt;Tömeges update műveletek végrehajtása&lt;/li&gt;&lt;li&gt;Assert - entitások visszatöltése, update ellenőrzése&lt;/li&gt;&lt;li&gt;Tranzakció rollback&lt;/li&gt;&lt;/ul&gt;A teszt eset kódja:
&lt;pre class="brush: java"&gt;@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations={"/applicationContext.xml", "/applicationContext-persistence-tests.xml"})
@Transactional
public class EmployeeServiceTest {

@Before
public void before() {
 employeeService.deleteEmployees();
 // EntityManager.persist hívások a teszt entitások előállítására
}

@Test
@Rollback(true)
public void testBulkUpdates() {
 employeeService.doBulkUpdates();
 Assert.assertEquals(2, employeeService.listEmployees().size());
}
}
&lt;/pre&gt;A tesztelendő kód:
&lt;pre class="brush: java"&gt;@Transactional
public class EmployeeServiceJpa implements EmployeeService {

public void deleteEmployees() {
 em.createQuery("DELETE Employee e").executeUpdate();
}

public List&lt;employee&gt; listEmployees() {
 return em.createQuery("SELECT e FROM Employee e").getResultList();
}

public void doBulkUpdates() {
 em.createQuery("UPDATE Employee e SET e.salary = e.salary + 100").executeUpdate();
}

}
&lt;/employee&gt;&lt;/pre&gt;És azt vettem észre, hogy az update műveletnek semmilyen hatása nem volt, az assert elbukott.
&lt;p&gt;Ennek megértéséhez kicsit meg kell ismerni a JPA működését. Amikor ugyanis a teszt entitásokat létrehozzuk, az entitások a perzistence context által menedzselt állapotba kerülnek, és a memóriában maradnak addig, míg a tranzakció véget nem ér. A tömeges műveletek viszont kizárólag a tábla tartalmát módosítják, nem foglalkoznak a memóriában már lévő objektumokkal. A lekérdezések ismét megnézik, hogy az adott objektum a memóriában van-e, és ha igen, nem az adatbázisból töltik be azokat. Ezért először létrejöttek a teszt entitások, majd az update művelet módosította a tábla tartalmát, de az assert-nél ismét a memóriában lévő, eredeti, nem módosított objektumokat kaptuk vissza. Commit esetében még rosszabb lenne a helyzet, ugyanis ilyenkor az adatbázisban is a memóriában lévő, persist-tel elmentett eredeti objektumok kerülnének, amit nem módosított az update.
&lt;/p&gt;&lt;p&gt;Ennek elkerülésére a javasolt megoldás, hogy egy új tranzakciót kell nyitni a tömeges műveletek kezelésére, azaz a metódust el kell látni a REQUIRES_NEW tranzakciós tulajdonsággal, ami azt jelenti, hogy az eredeti tranzakciót felfüggeszti, és minden esetben új tranzakciót fog nyitni. Amennyiben ebben a metódusban hívunk a tömeges műveletek elvégzése után EntityManager.find(Class&lt;t&gt; entityClass, Object primaryKey) metódust vagy egyéb lekérdezést, és az így visszakapott entitásokat módosítjuk, nem lesz baj, hiszen a betöltés adatbázisból fog történni, hiszen a tömeges műveletek előtt nem került semmi az adatbázisba. Szóval csak arra kell figyelni, hogy ne a tömeges művelet előtt végezzünk módosítást. Ha mégis így tennénk, az entitáson hívjuk meg az EntityManager.refresh(Object entity) metódust, hogy az adatbázisból az adatokat szinkronizálja vissza a memóriába.&lt;/t&gt;
&lt;/p&gt;&lt;p&gt;No ezen felbátorodva el is helyeztem a REQUIRES_NEW tranzakciós tulajdonságot a metódusra, és azonnal deadlock lett belőle. Hiszen indítottam egy tranzakciót, mely törölte az egyedeket, illetve újakat perzisztált, majd indítottam egy másik tranzakciót, mely ugyanezen egyedeken végzett volna műveleteket. Ezáltal oda jutottam, hogy az összes entitás törlését, valamint a teszt entitások perzisztálását végző tranzakciónak le kell zárulnia, mire az tömeges műveleteket futtató metódus új tranzakciót nyitna. Ezt szerencsére egy JUnit 4 @BeforeTransaction annotációval el lehetett intézni. Ekkor azonban a művelet végén jelzett rollback az első tranzakciót nem görgette vissza, így oda az elmélet, hogy olyan teszt esetet írok, mely érintetlenül hagyja az adatbázis állapotát.
&lt;/p&gt;&lt;p&gt;De pl. a &lt;a href="http://www.dbunit.org/bestpractices.html"&gt;dbunit legjobb gyakorlatai szerint&lt;/a&gt; ez nem is olyan nagy baj. A következőket állítja:
&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Minden fejlesztőnek legyen saját adatbázisa (nem feltétlenül a saját gépén). Ez a párhuzamos tesztelés miatt fontos.&lt;/li&gt;&lt;li&gt;Nem kell a teszt adatokat eltávolítani: a jó teszt induláskor úgyis beállítja a megkívánt adatbázis tartalmat, így nem kell eltávolítani a teszt futásának eredményét. Néha különösen jól jön az adatbázis tartalmának vizsgálata, ha elbukik a teszt.&lt;/li&gt;&lt;li&gt;Érdemes kisebb adathalmazokkal dolgozni&lt;/li&gt;&lt;li&gt;Érdemes nem minden teszt előtt inicializálni az adatokat, hanem több teszt előtt egyszer. Ilyenkor persze oda kell figyelni, hogy a teszt esetek ne módosítsák az adatokat.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Ekkor persze megmaradtak a teszt adatok, melyeket a következő teszt futtatáskor ki kellett törölni. A baj ott kezdődött, hogy egy entitás saját magára mutatott (self reference), így nem lehetett a törlést végrehajtani, mert megszorítás megsértést (constraint violation) jelzett az adatbázis. Más entitással való kapcsolatnál is ugyanez a helyzet, hiszen a tömeges törlés nem kaszkádolt. Erre egy kerülő megoldást kell alkalmazni, miszerint első körben meg kell szüntetni a kapcsolatokat (kapcsoló mezők null-ra állítása update művelettel), majd második körben lehetett a törlést elvégezni.
&lt;/p&gt;&lt;p&gt;Így még mindig nem volt felhőtlen az öröm, a ugyanis az assert még mindig elbukott. Ez ezért történt, mert a teszt nyitott egy tranzakciót, ebben inicializált az adatbázist, majd lezárta a tranzakciót. Ismért nyitott egy tranzakciót, amit azonnal fel is függesztett a REQUIRES_NEW miatt, elvégezte a tömeges műveletet, lezárta a későbbi tranzakciót, de az első tranzakció még érvényben maradt, így itt még nem látszódtak a második tranzakció módosításai. Ezért az assert-nél futó lekérdezés nem látta a módosításokat. Ezt kétféleképpen lehet feloldani. Vagy nem tranzakcióban indítjuk a teszt esetet. Másik megoldás, hogy a lekérdezéseket nem tranzakcióban futtatjuk. Ez teljesítményszempontból is jó.
&lt;/p&gt;&lt;p&gt;A teszt eset javítása:&lt;/p&gt;&lt;pre class="brush: java"&gt;@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations={"/applicationContext.xml", "/applicationContext-persistence-tests.xml"})
@Transactional
public class EmployeeServiceTest {

@BeforeTransaction
public void before() {
 employeeService.deleteEmployees();
 // EntityManager.persist hívások a teszt entitások előállítására
}

@Test
public void testBulkUpdates() {
 employeeService.doBulkUpdates();
 Assert.assertEquals(2, employeeService.listEmployees().size());
}
}
&lt;/pre&gt;&lt;p&gt;A tesztelendő kód javítása:&lt;/p&gt;&lt;pre class="brush: java"&gt;
@Transactional
public class EmployeeServiceJpa implements EmployeeService {

public void deleteEmployees() {
 em.createQuery("DELETE Employee e").executeUpdate();
}

@Transactional(propagation=Propagation.NOT_SUPPORTED)
public List&lt;employee&gt; listEmployees() {
 return em.createQuery("SELECT e FROM Employee e").getResultList();
}

@Transactional(propagation=Propagation.REQUIRES_NEW)
public void doBulkUpdates() {
 em.createQuery("UPDATE Employee e SET e.salary = e.salary + 100").executeUpdate();
}

}
&lt;/employee&gt;&lt;/pre&gt;Tanulság, hogy mielőtt tömeges műveleteket kezdünk el használni, nagyon értsük meg annak működését, egyrészt a memória cache, másrészt a tranzakciók szempontjából.</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/6830182434857140108/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/05/jpa-tomeges-muveletek.html#comment-form' title='3 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6830182434857140108'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6830182434857140108'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/05/jpa-tomeges-muveletek.html' title='JPA tömeges műveletek'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>3</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7752226165485814608</id><published>2009-05-03T01:13:00.006+02:00</published><updated>2012-09-28T10:30:40.632+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='UML'/><category scheme='http://www.blogger.com/atom/ns#' term='Utils'/><category scheme='http://www.blogger.com/atom/ns#' term='Módszertan'/><title type='text'>UML tevékenységdiagram</title><content type='html'>Ahogy már említettem, az elmúlt hetekben inkább tervezéssel, mint Java programozással foglalkoztam. A logikai rendszerterv elkészítéséhez az UML-t használatuk modellező nyelvként.&lt;p&gt;Az alkalmazás statikus szerkezetének leírására leggyakrabban az osztálydiagramot (class diagram), dinamikus viselkedésének leírásához a tevékenységdiagramot (activity diagram) használtuk.&lt;/p&gt;Az első és legfontosabb kérdés az volt, hogy a folyamatokat milyen részletességgel (milyen granularitással) akarjuk modellezni.&lt;p&gt;&lt;/p&gt;&lt;p&gt;Ez a kérdés a használati eseteknél is felmerült, az ott elmondottak igazak a tevékenységdiagramokra is. Általános nézet szerint a használati eseteket két szintre lehet bontani, egyrészt az üzleti használati esetek (business level), valamint a rendszer szintű használati esetek (system level). Az előbbire példa lehet pl. egy kereskedelmi rendszer esetén egy teljes megrendelési folyamat, a második az eladó részéről a megrendelés jóváhagyása. A kettő közötti különbség, hogy míg az első egy teljes folyamatot ír le akár több aktor (akár humán, akár rendszer) szereplésével, addig a második egy konkrét aktor célját megvalósító lépéssorozatot, amelynek időtartama kb. 2 perctől fél óráig terjedhet. Alistair Cockburn &lt;a href="http://www.accelerateddeliveryplatform.com/SmartUseCaseLevels.ashx"&gt;szerint&lt;/a&gt; a használati eseteknek több szintje is lehetséges. A javasolt szint a tenger szintje (sea level), mely megfelel a rendszer szintű használati esetnek. Ez a RUP-ban is definiált szint. Egy aktor célját megvalósító felhasználói eset ez. Ennél részletesebb a halak szintje (fish level), ezekre oszthatóak fel, és újrafelhasználhatóak az előző szint felhasználói esetei által. Gyakran
nevezik alfunkciónak is. Gyakran ezt is elemi lépésekre osztják fel, ez a kagylók szintje (clamp level). Ezt már nem javasolt felhasználói esetként kezelni, mert túl részletes. Ez megegyezik Eric J. Naiburg, Robert A. Maksimchuc UML for Database Design című könyvében definiált WAVE próbának, melyet ugyanazon írók által írt, magyar nyelven is megjelent, az UML földi halandóknak című könyvben MISZHAT próbának fordítottak. E szerint egy használati esetre igaznak kell lennie:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Azt írja le, hogy &lt;b&gt;mi&lt;/b&gt;t kell csinálni, és nem azt, hogy hogyan?&lt;/li&gt;&lt;li&gt;A &lt;b&gt;sz&lt;/b&gt;ereplő (aktor) nézőpontjából lett az eset leírva?&lt;/li&gt;&lt;li&gt;Az eset &lt;b&gt;ha&lt;/b&gt;sznos-e az aktor számára?&lt;/li&gt;&lt;li&gt;&lt;b&gt;T&lt;/b&gt;eljes-e a használati eset?&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Amennyiben nem a részletekbe megyünk bele, hanem egy általános képet írunk le, használjuk a sárkány szintű (kite level) és a felhő szintű (cloud level) használati eseteket. Cockburn szerint az ideális szintek a tenger és halak szint, ami tökéletes a követelmények felmérésére, a becslésre, tervezésre, kódgenerálásra és tesztelésre.&lt;/p&gt;&lt;p&gt;Véleményem szerint amennyiben egy dokumentumot vezetők, döntéshozók számára készítjük el, javasolt használni a sárkány szintet is, mely egy teljes üzleti folyamatot ír le, melyben több humán aktor is részt vehet, és több rendszeren is átnyúlhat.&lt;/p&gt;Amennyiben pl. SOA architektúrát használunk, abban az esetben ezek a sárkány szintű használati esetek írják le egy folyamatirányító (business process management) feladatait (több rendszer vezérlése - orchestration), míg a tenger szintű használati esetek írhatják le a különböző szolgáltatást nyújtó rendszerekben a web szolgáltatások mögötti üzleti folyamatokat. Nézzük, hogy miért esett a választás a dinamikus működés leírására a tevékenységdiagramokra. Ez nem azt jelenti, hogy a többi, viselkedést leíró diagramot (pl. állapotdiagram - state diagram, sorrenddiargram - sequence diagram, stb.) nem használtuk, hanem azokat kevesebb mértékben. Az okok tehát:&lt;ul&gt;&lt;li&gt;Mivel a folyamatábrákból alakult ki, és emiatt nagyon hasonlít ahhoz, átlátható és könnyen tanulható olyanok számára is, akik nem annyira ismerik az UML nyelvet.&lt;/li&gt;&lt;li&gt;Megfelelően képesek ábrázolni az elágazást és ciklust.&lt;/li&gt;&lt;li&gt;Képesek ábrázolni a párhuzamosságot.&lt;/li&gt;&lt;li&gt;Rekeszekkel (partition) képesek ábrázolni a felelősségi összefüggéseket, azaz hogy melyik műveletet (action) melyik aktor végzi.&lt;/li&gt;&lt;li&gt;Képesek ábrázolni az érintett adatköröket is, és a paraméterek átgondolására ösztönöz, ha kötelezővé tesszük ezeknek a jelölését.&lt;/li&gt;&lt;li&gt;Képesek ábrázolni más rendszerekből érkező, vagy annak továbbítandó jelzést (signal), valamint a timeout-ot.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Viszonylag hamar bevethetőek a sorrenddiagramok is, de az már komolyabb objektumorientált ismereteket feltételez, emiatt kezdő UML-esek számára nehezebben érthetőek, valamint szerintem nem olyan látványosan ábrázolják az elágazásokat és ciklusokat.&lt;/p&gt;Nézzük is meg, egy példa üzleti folyamaton, hogy mindezt hogy is teszi. Egy előző projektben egy külön modulként kellett megvalósítaniegy SMS-es fizetést is lehető tévő fizetési modult (, hasonlóan az autópálya matrica vásárlásához). A következő tevékenységdiagram egy SMS-es fizetést ír le.&lt;p&gt;&lt;/p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_czKgycLvmNo/SfzVJoeEBJI/AAAAAAAADkI/Ur2mjyFw3SE/s1600-h/activity.png"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 299px; height: 320px;" src="http://1.bp.blogspot.com/_czKgycLvmNo/SfzVJoeEBJI/AAAAAAAADkI/Ur2mjyFw3SE/s320/activity.png" alt="SMS-es fizetés tevékenységdiagramja" id="BLOGGER_PHOTO_ID_5331370420358874258" border="0" /&gt;&lt;/a&gt;&lt;p&gt;Az ügyfél a kereskedelmi rendszer honlapján kiválaszt egy terméket, a kosárba teszi, majd fizetni próbál. A termék fő adatai átkerülnek a fizetési modulba, miközben a felhasználót a telefonszámának a megadására kéri. A telefonszám formai ellenőrzésre kerül, ha helyes, akkor az adatok átküldésre kerülnek az SMS-es fizetést biztosító szolgáltatónak, ami kiküldi az SMS-t az ügyfélnek. Amennyiben az ügyfél rossz telefonszámot adott meg, újra bekéri azt. Az ügyfél ekkor egy válasz SMS-t küld, melyről a szolgáltató értesíti a fizetési modult, amely értesíti az ügyfelet e-mailben, és a kereskedelmi rendszert. Amennyiben az ügyfél 3 percig nem ad meg  telefonszámot, vagy 5 percig nem küld válasz SMS-t, a vásárlást meg kell szakítani, és erről értesíteni kell a kereskedelmi rendszert is.&lt;/p&gt;&lt;p&gt;Látható, hogy a folyamat egy kezdőponttal (initial node) indul és egy végponttal zárul (activity final node). Ezek között lekerekített sarkú téglalapok a műveletek (action - ezek neve az UML 1.x-ben tevékenység - activity - volt). A műveletek közötti nyilak/élek a vezérlési folyamélek (control flow). A nyilak közötti téglalapok a paraméterek, adatfolyam csomópontok (dataflow node). A tevékenységdiagramon látható ezen kívül rombusszal jelölve elágazás esetválasztó csomópontokkal (conditional node), valamint vastag vízszintes vagy függőleges vonallal vezérlés elválasztó csomópont (fork node) is, párhuzamosság ábrázolására. Ezek ellentéte az összeolvasztó csomópont (fork node). A két csúcsával egymáshoz illesztett háromszög a timeout-ot jelöl, a téglalap, jobb oldalán egy háromszöggel pedig jelzés küldését (send signal). A négy nagy téglalap a rekesz (partition), mely arra való, hogy leírja, mely aktorhoz mely művelet tartozik (ezek az 1.x-ben úszósávok voltak).&lt;/p&gt;&lt;p&gt;A tevékenységdiagramok ennél jóval több mindent képesek ábrázolni, ezeket a részletes UML dokumentációk és könyvek írják le. Ilyenek pl. a egy tevékenység kifejtését biztosító altevékenységek (subactivity), expansion region, kivételek, tokenek, kapcsoló élek (connector), pin és transzformáció, stb.&lt;/p&gt;&lt;p&gt;Javasolt először az adatfolyam nélkül elkészíteni a tevékenységdiagramot, majd később kötelezően bejelölni a paramétereket is, ezzel átgondoljuk, hogy az egyik művelet a másiknak milyen paramétereket ad át, így akár új egyedekre is lelhetünk.&lt;/p&gt;&lt;p&gt;Érdekes felfedezés volt ugyanakkor, hogy az UML nem definiál semmilyen diagramot un. page flow-ra, azaz az alkalmazás képernyői közötti navigáció modellezésére. Több cikket is olvastam, ahol megpróbálják ezt állapotdiagramal, osztálydiagramal, de mind sántított. Javasolt egy egyszerű diagram használata, ahol a téglalapok a képernyők, a köztük lévő elnevezett nyilak pedig a navigációs útvonalak (pl. webes alkalmazás esetén a linkek).
&lt;/p&gt;&lt;p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://martinfowler.com/umldist.jpg"&gt;&lt;img style="margin: 0pt 0pt 10px 10px; float: right; cursor: pointer; width: 208px; height: 278px;" src="http://martinfowler.com/umldist.jpg" alt="" border="0" /&gt;&lt;/a&gt;Az UML megértéséhez javasolt a magyarul is megjelent Eric J. Naiburg, Robert A. Maksimchuc: UML földi halandóknak könyv, mely egy nagyszerű bevezető irodalom. Talán egy kicsit a végére elfogyott a lelkesedés, az UML használatáról kevésbé ír az implementáció során, valamint olyan hirtelen lett befejezve. A másik magyarul is megjelent a Harald Störrle UML 2 Unified Modeling Language című könyv, ami egy nagyon részletes, de emiatt nagyon száraz referencia jellegű könyv, ami ugyan végigvezet egy légitársaság rendszerének fejlesztésén, azonban sok UML fogalom meg van említve, de nincs példán keresztül megmagyarázva. Csak azoknak javaslom, akik már egy érthetőbb, olvasmányosabb könyv elolvasásával megismerkedtek az UML alapjaival. Magasan a legjobb könyv azonban, melyet mindenkinek ajánlok, &lt;a href="http://martinfowler.com/"&gt;Martin Fowler&lt;/a&gt; (akinek nevét a refactoring, tervezési minták, agilis módszertanok, continuous integration
témakörökkel kapcsolatban is sokat halljuk) UML Distilled: A Brief Guide to the Standard Object Modeling Language című könyve, mely már a harmadik kiadásnál tart. Előnye, hogy olvasmányos, humoros, és az UML csak azon kis részét írja le, melyet legtöbbször használunk. A könyv borítója egy rövid referenciát is tartalmaz.&lt;/p&gt;&lt;p&gt;Nagy problémánk volt azonban az eszköz kiválasztásával kapcsolatban is. Mivel UML-t főleg nagyvállalati projektekben alkalmaznak, ezért kidolgozott, jól működő, megbízható és gyors, ingyenes eszköz kevés van. Azonban rátaláltam az &lt;a href="http://www.umlet.com/"&gt;UMLet&lt;/a&gt; nevű ingyenes, nyílt forráskódú, Java-ban implementált eszközre (ami Eclipse pluginként is működik), mely teljesen levett a lábamról. Az első eszközt, amit kipróbáltunk, a NetBeans UML plugin-jét alapban übereli, hiszen a NetBeans-ben nincs undo művelet (tragédia). Én egy agilis UML eszköznek nevezném. Ne várjatok tőle csodát, kód generálást, stb., feladata kizárólag a rajzolás (a post diagramja is
ezzel készült). Előnye, hogy nem egy bonyolult popup ablakon kell a különböző elemek tulajdonságait beírni, hanem jobb oldalon van egy egyszerű szövegmező, ahova az adott elem minden tulajdonságát be lehet írni, név - érték párokkal (legerősebb tulajdonsága, hogy ide
Java kódot is be lehet írni, így gyakorlatilag a lehetőségek végtelenek). A teljes eszköz a gyors szerkesztésre van kihegyezve, jó példája, hogy egy elem másolása egy dupla-klikk, valamint minden diagramot egy külön, saját formátumú XML fájlba helyez el, nincs közös projekt, és elem repository. Egyszerű Java kóddal tetszőleges saját elemeket is definiálhatunk, amit aztán kitehetünk a többi előre definiált elem közé, és bármelyik diagramban használhatjuk. Érdemes kipróbálni.&lt;/p&gt;&lt;p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.umlet.com/screen.jpg"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 291px; height: 245px;" src="http://www.umlet.com/screen.jpg" alt="" border="0" /&gt;&lt;/a&gt;&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/7752226165485814608/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/05/uml-tevekenysegdiagram.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7752226165485814608'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7752226165485814608'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/05/uml-tevekenysegdiagram.html' title='UML tevékenységdiagram'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://1.bp.blogspot.com/_czKgycLvmNo/SfzVJoeEBJI/AAAAAAAADkI/Ur2mjyFw3SE/s72-c/activity.png' height='72' width='72'/><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6790088143720411764</id><published>2009-04-06T13:30:00.003+02:00</published><updated>2009-04-06T13:38:35.607+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Oktatás'/><title type='text'>Java technologiák és az oktatas</title><content type='html'>&lt;p&gt;A SZÁMALK Továbbképzés 2008. április 24-én tartott egy Aktuális 2008 nevű konferenciát, melynek célja a SZÁMALK oktatási tevékenységének bemutatása volt.  Ennek keretében tartottam egy előadást "Ariadné fonala a Java technológiák útvesztőjében" címmel, melyben azt mutattam be, hogy mennyire szerteágazó a Java platform, és milyen nehéz ezzel kapcsolatban egy rendszerezett tudást kezdő fejlesztőnek elsajátítania, és az oktatás hol segíthet ebben.&lt;/p&gt;&lt;p&gt;Ezen előadáson ismertettem az előző posztban írt ontológiát a Java technológiákkal kapcsolatban. Sok bűvszó előkerült, úgymint Web 2.0, AJAX, szemantikus web, Google Web Toolkit, Google Android, REST, stb. Szóval akit érdekel, az a következő helyen érheti el az előadást (diák és megjegyzések):&lt;/p&gt;&lt;a href="http://delfin.unideb.hu/%7Evicziani/pdf/2008_szamalk_eloadas_vi.pdf" onclick="pageTracker._trackPageview('pdf/2008_szamalk_eloadas_vi.pdf');"&gt;  Ariadné fonala a Java technológiák útvesztőjében&lt;/a&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/6790088143720411764/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/04/technologiak-oktatas.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6790088143720411764'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6790088143720411764'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/04/technologiak-oktatas.html' title='Java technologiák és az oktatas'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1995476347340110664</id><published>2009-04-06T00:00:00.005+02:00</published><updated>2009-04-06T00:07:26.258+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='szemantikus web'/><title type='text'>Java és a szemantikus web</title><content type='html'>&lt;p&gt;A Web 2.0 után manapság egyre divatosabb fogalom a szemantikus web, melynek célja pont az egyre növekvő, ember számára feldolgozhatatlan mennyiségű információ hasznosítása. Jelenleg, ha egy kérdésre keressük a választ, keresőket használunk, és próbálunk egy olyan keresési kifejezést megadni, melyre eredményül hozott oldalak a témához minél jobban illeszkedjenek. A találatok sorrendjénél a legelterjedtebb kereső, a Google a weben legjobban mérhető tetszésnyilvánításokat veszi figyelembe, méghozzá a linkeléseket.&lt;/p&gt;A szemantikus web célja, hogy a különböző számítógépes rendszerek az egzakt kérdéseinkre a lehető legegzaktabb választ adják, azaz ezek a rendszerek ne csak feldolgozzák, indexeljék és mintát illesszenek a weboldalakra, hanem értelmezzék is azokat, mi több, következtetéseket is tudjanak levonni. Ezt úgy gondolják megvalósítani, hogy a különböző weboldalakhoz, tágabb értelemben információforrásokhoz számítógép által is feldolgozható metaadatokat rendelnek, melyek kellően kötöttek ahhoz, hogy következtetéseket lehessen belőlük levonni.
&lt;p&gt;Erre ki is alakítottak egy RDF (Recource Description Framework – Erőforrás-Leíró Keretrendszer) nevű adatmodellt, mely a W3C által karbantartott szabvány, és ennek segítségével metaadatokat lehet szabványos módon megadni. Egy RDF egyszerű kijelentő mondatok gyűjteménye (tripletek), melyek egy alanyt (subject), egy állítmányt (predicate) és egy tárgyat (object) tartalmaznak. Mind az alany, mind a tárgy egy gráfban jelenik meg csomópontként, és az állítás pedig egy irányított kapcsolatként, így jön létre egy irányított gráf. Az alany egy erőforrás, melyet egy URI-val lehet egyértelműen azonosítani. Léteznek un. üres erőforrások is. Az állítmányok szintén erőforrások. A tárgy lehet erőforrás, vagy egy literál is (ez utóbbi önmagát magyarázza). A literál lehet típus nélküli, vagy típusos, mint pl. szöveges, szám vagy dátum. Ezen adatmodellel ábrázolt adatokat különböző formátumokban lehet tárolni, szállítani (un. szerializálás), ezek közül a leggyakoribb az XML. Az erre szolgáló XML formátumot is szokták RDF-nek nevezni, ne mi ne keverjük össze a metaadat-modellt, valamint annak tárolási módját.&lt;/p&gt;Az OWL (Web Ontology Language) ennél magasabb szinten helyezkedik el, és feladata ontológiák leírása. Az ontológiák egy tudásterület alapfogalmainak, valamint ezek összefüggéseinek géppel értelmezhető definícióit tartalmazzák. Az ontológiákat olyan emberek, adatbázisok és alkalmazások használják, akiknek/amelyeknek egy bizonyos tudásterületen együtt kell működniük (ilyen lehet egy szűkebb tudományos, gazdasági vagy kulturális terület). A nyelvnek is három változata létezik, melyek egyre nagyobb kifejezőerővel bírnak. Ebből első az OWL Lite egyszerűbb ontológiák megfogalmazásához, a második az OWL DL (Description Logics), mely már többet nyújt, viszont az automatikus számíthatóság még garantált, és a harmadik az OWL Full, mely a teljes kifejezőerőt biztosítják, de cserébe le kell mondani az automatikus számíthatóság garanciájáról. Az OWL Full az RDF kiterjesztése, míg az OWL korlátozottabb szintjei az RDF korlátozott nézetének kiterjesztései.
&lt;p&gt;Az OWL alapfogalmai az egyed (instance), a tulajdonság (property) és a class (osztály). Az egyedek alkotják a fogalmakat, a köztük lévő kapcsolatokat a tulajdonságok. Az osztály az objektumorientált szemlélethez hasonlóan egy magasabb absztrakciós szint, és egy osztályba sorolja az azonos tulajdonsággal rendelkező egyedeket.&lt;/p&gt;Az RDF és OWL bemutatására, valamint a Java fogalmak rendszerezésére kialakítottam egy egyszerű ontológiát. Középpontban áll a probléma (Problem), melyet valamilyen módszertan, technika, stb. (Method) old meg. Ezt bizonyos gyártók, szervezetek (Organisation) által készített, gyártott, fejlesztett termékei (Product) használják fel a probléma megoldására valamilyen szabványt (Specification) implementálva. Az osztályok között tartalmazási és együttműködési kapcsolat is fennállhat.&lt;p&gt;&lt;/p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_czKgycLvmNo/Sdkq8hfT42I/AAAAAAAAC_Y/hgAK1uMs5vM/s1600-h/java_technologiak_osztalyok.png"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 320px; height: 227px;" src="http://1.bp.blogspot.com/_czKgycLvmNo/Sdkq8hfT42I/AAAAAAAAC_Y/hgAK1uMs5vM/s320/java_technologiak_osztalyok.png" alt="" id="BLOGGER_PHOTO_ID_5321331653985166178" border="0" /&gt;&lt;/a&gt;&lt;p&gt;Nézzünk erre egy egyszerű példát. Probléma a perzisztencia, azaz az üzleti objektumainkat szeretnénk perzisztens tárba elmenteni. Erre egy remek módszer az objektumorientált világban az ORM (object-relational-mapping), mely az objektumokat relációs adatbázisba képzi le. Erre már egy szabványt, a JPA szabványt meg is alkották, és erre több implementációt is kiadtak, mint a RedHat JBoss által jegyzett Hibernate-et, vagy az Oracle által jegyzett Toplink-et.&lt;/p&gt;Látható, hogy így egy viszonylag nagy ontológiát lehet felépíteni, mely a Java-val kapcsolatos fogalmak nagy részét ábrázolni tudja és ezekből következtetéseket is tud levonni. Könnyen megfogalmazhatóak összetett  kérdések, melyre a gép automatikusan választ tud adni. Pl. melyek azok a termékek, melyek a perzisztenciát oldják meg, lehetőleg támogatják a JPA specifikációt, és nem Oracle termékek.&lt;p&gt;&lt;/p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_czKgycLvmNo/SdkrQbpZqMI/AAAAAAAAC_g/C26qUknm8N4/s1600-h/java_technologiak_owl.png"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 320px; height: 189px;" src="http://2.bp.blogspot.com/_czKgycLvmNo/SdkrQbpZqMI/AAAAAAAAC_g/C26qUknm8N4/s320/java_technologiak_owl.png" alt="" id="BLOGGER_PHOTO_ID_5321331996014258370" border="0" /&gt;&lt;/a&gt;&lt;p&gt;Az RDF/OWL formátumok szerkesztéséhez már rengeteg eszköz megjelent, ebből egy lehet pl. az Altova SemanticWorks, mely meglehetősen bugos, valamint a pilótavizsgás, de nagyon komoly, Java alapú Protégé nevezetű ingyenes, nyílt forráskódú eszköz. Megjelenítéshez az RDF – Gravity eszközt használtam.&lt;/p&gt;A fogalmak összegyűjtésére már elindult egy kezdeményezés Magyarországon a http://jhacks.anzix.net/space/topics címen, de ez egy egyszerű wiki, ami képes a fogalmak leírására, és a köztük lévő kapcsolatok definiálására. Azonban a számítógéppel való feldolgozáshoz szükség van arra, hogy az oldalakhoz és akár a linkekhez is metaadatokat helyezzünk el. Az egyik legelterjedtebb wiki rendszerhez, a MediaWiki-hez már van olyan kiegészítő, melyekhez ilyent meg tudunk adni Semantic MediaWiki néven (http://semantic-mediawiki.org/wiki/Semantic_MediaWiki).</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/1995476347340110664/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/04/java-szemantikus-web.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1995476347340110664'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1995476347340110664'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/04/java-szemantikus-web.html' title='Java és a szemantikus web'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://1.bp.blogspot.com/_czKgycLvmNo/Sdkq8hfT42I/AAAAAAAAC_Y/hgAK1uMs5vM/s72-c/java_technologiak_osztalyok.png' height='72' width='72'/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3270912925337717490</id><published>2009-03-30T00:26:00.006+02:00</published><updated>2010-09-18T00:37:02.161+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Utils'/><title type='text'>Szöveg generálás</title><content type='html'>&lt;p&gt;Lehet olyan eset, mikor egy weboldalnak nem kell dinamikusnak lennie, egyszerűen elegendő, ha dinamikusan generáljuk a statikus HTML oldalakat. Ez lehet egyszerű eset, mikor csak nem akarunk HTML kódot ismételni, és ezért a fejlécet, láblécet külön állományba tesszük ki, mert gyakrabban változik (persze ha a web szerverünk ismeri a server side include-ot az is jó választás lehet, de abban az esetben az összeállt oldalt csak a web szerveren tudjuk megnézni). Ezt használom például a honlapom előállításakor, valamint több felhasználói interfész prototípust is így készítettem. Gondoljuk el, elkészítjük a HTML terveket, majd a felhasználó a menüben kér egy módosítást. Persze ez is kikerülhető, ha már rögvest egy dinamikus prototípust állítunk össze (pl. kizárólag JSP alapokon), de ahhoz már környezet kell, valamint kicsit több munkabefektetés, és nem lehet az egészet egy ZIP állományban átküldeni. Ezzel megoldhatóak apróbb trükkök is, pl. lapozás, de akár bizonyos tartalmak esetén adatbázisból való kiolvasás.&lt;/p&gt;&lt;p&gt;Ennek egy továbbgondolt változata, a statikus HTML tartalom dinamikus előállításának, hogy egy CMS-be visszük fel a tartalmat, ami viszonylag ritkán változik, és az generál ki statikus tartalmat. Akár több formátumban is. Az Atlassian Confluence nagyvállalati wiki pl. képes HTML vagy PDF exportra is. Használható belső szerkesztőségi rendszernek, és a tartalmat módosítás esetén elegendő kipublikálni a web szerverre. Ekkor a szerveren egy web szerveren kívül semmilyen más szoftvert nem kell telepíteni, üzemeltetni, kevéssé terheli az erőforrásokat, stb.&lt;/p&gt;&lt;p&gt;Szóval gondoljuk meg, ha ritkán változó tartalmunk van, nem érdemes-e dinamikus forrásból időnként kigenerálni, és azt publikálni.&lt;/p&gt;&lt;p&gt;Ennek megvalósítására kitűnő eszköz lehet a &lt;a href="http://velocity.apache.org/texen/releases/texen-1.0/"&gt;Apache Texen&lt;/a&gt;, mely a Velocity projekt része. Valójában egy nagyon egyszerű Ant task, mely a Velocity-t hívja szöveg generálására. Persze nem csak HTML tartalom kigenerálására használható, hanem bármilyen, sablon alapú szövegre. Pl. ezt használja a Turbine web framework Torque ORM része SQL és a mapping file kigenerálására. De generálhatunk vele XML-t, Java forráskódot, így akár egy MDA keretrendszerbe is beilleszthető lenne, stb.&lt;/p&gt;&lt;p&gt;A Texen-t egy control template irányítja, amiben a Velocity nyelvén kell leírnunk, hogy hogyan is történjen a generálás. Ez tipikusan végigmegy a szintén Velocity nyelvén írt sablon állományokon (egyen akár többször is), és kigenerálja a szöveges állományokat. A Velocity context-be több segédobjektumot is elhelyez a Texen, pl. a generálást végző &lt;a href="http://velocity.apache.org/texen/releases/texen-1.0/apidocs/org/apache/texen/Generator.html"&gt;generátor&lt;/a&gt; objektumot, az output könyvtár nevét, egy szövegműveletekre használható &lt;a href="http://jakarta.apache.org/commons/lang/apidocs/org/apache/commons/lang/StringUtils.html"&gt;StringUtils&lt;/a&gt; példányt, fájlműveletekre használható &lt;a href="http://velocity.apache.org/texen/releases/texen-1.0/apidocs/org/apache/texen/util/FileUtil.html"&gt;FileUtil&lt;/a&gt; példányt, vagy property-k kezelésére való &lt;a href="http://velocity.apache.org/texen/releases/texen-1.0/apidocs/org/apache/texen/util/PropertiesUtil.html"&gt;PropertiesUtil&lt;/a&gt; példányt. A Velocity nyelve azért alkalmas különösen erre, mert a context-be rakott objektumokat nem csak olvasni tudjuk, hanem tetszőleges metódusukat is meg tudjuk hívni (szemben pl. a JSP-vel).&lt;/p&gt;&lt;p&gt;Egy példa Velocity vezérlő állomány lehet a következő:
&lt;/p&gt;&lt;pre&gt;Generating mockups for templates in $generator.getTemplatePath() directory.

#foreach ($file in $files.file($generator.getTemplatePath()).list()) 
 #if ($file.endsWith(".htm") || $file.endsWith(".html"))
Generating file to $file template.
   $generator.parse($file, "UTF-8", $file, "UTF-8", null, null)
 #end
#end
&lt;/pre&gt;&lt;p&gt;Az állomány végigmegy a sablonokat tartalmazó könyvtár összes állományán, és ha htm-re vagy html-re végződik, akkor végrehajtja azokat (látszik, hogy itt kell a kódolást is megadni). A generálás kimenete egy riport lesz, mely ezen vezérlő állomány alapján keletkezik.&lt;/p&gt;&lt;p&gt;A Texen-t futtatni Ant-tal lehetséges, melynek egy példa build.xml állománya:
&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;project name="generator" default="gen" basedir="."&amp;gt;

 &amp;lt;path id="classpath"&amp;gt;
   &amp;lt;fileset dir="lib" includes="*.jar"/&amp;gt;
 &amp;lt;/path&amp;gt;

 &amp;lt;taskdef name="texen" 
   classname="org.apache.texen.ant.TexenTask" 
   classpathref="classpath"/&amp;gt;

 &amp;lt;target name="gen"&amp;gt;
   &amp;lt;texen controlTemplate="control.vm"
          outputDirectory="build"
          templatePath="templates"    
          outputFile="generation.report"
          outputEncoding="UTF-8" inputEncoding="UTF-8"/&amp;gt; 
 &amp;lt;/target&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/pre&gt;&lt;p&gt;Ekkor a Texen-hez szükséges JAR-okat a lib könyvtárban helyezzük el (commons-collections, commons-lang, texen, velocity). A templates könyvtárban kell elhelyezni a control.vm állományt és a HTML sablonokat is. Az állományokat, és a riportot tartalmazó (generation.report) állományt a build könyvtárban fogja elhelyezni. Figyeljük meg, hogy itt adható meg a kódolás is. A következő példa egy egyszerű sablon állományt mutat, mely beemeli a fejlécet és láblécet, valamint kiírja a generálás dátumát, mert a Texen Ant task alapértelmezetten még date névvel elhelyez egy Date objektumot is:
&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;html&amp;gt;
 &amp;lt;body&amp;gt;
   #parse('header.vm')
   Content. $date
   #parse('footer.vm')
 &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;p&gt;Amennyiben személyre akarjuk szabni a Texen-t, a org.apache.texen.ant.TexenTask Ant task-ot kell leszármaztatnunk, és a populateInitialContext metódusát implementálnunk. Ennek a metódusnak a feladata a Velocity context feltöltése. Ide akár egyszerű szöveg konstruálásától kezdve adatbázisból való lekérdezéséig bármit implementálhatunk. Példánkban írjuk ki magyar formátumban a generálás dátumát. A szükséges Java osztályt a következő kódrészlet mutatja:
&lt;/p&gt;&lt;pre class="brush: xml"&gt;package jtechlog.mytexentask;

import java.util.Date;
import java.util.Locale;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import org.apache.texen.ant.TexenTask;
import org.apache.velocity.context.Context;

public class MyTexenTask extends TexenTask {

private static final String FORMAT = "yyyy MMMM dd. hh:mm";

private static final Locale HU = new Locale("hu", "HU");

   protected void populateInitialContext(Context context)
                                  throws Exception {
       DateFormat df = new SimpleDateFormat(FORMAT, HU);
    context.put("dateOfGeneration", df.format(new Date()));
   }

}
&lt;/pre&gt;&lt;p&gt;Ez a dateOfGeneration névvel fog betenni egy String objektumot a context-be. Ahhoz, hogy ebből egy Ant task legyen, használjuk az Ant 1.7-től rendelkezésre álló antlib lehetőséget, a jtechlog.mytexentask package-ben hozzunk létre egy antlib.xml állományt, majd csomagoljuk a lefordított class, valamint az xml állományt egy mytexentask.jar állományba.  Az antlib.xml tartalma:
&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;?xml version="1.0" ?&amp;gt;
&amp;lt;antlib&amp;gt;
 &amp;lt;typedef name="MyTexenTask" 
  classname="jtechlog.mytexentask.MyTexenTask" /&amp;gt;
&amp;lt;/antlib&amp;gt;
&lt;/pre&gt;&lt;p&gt;Hogy ezt felhasználhassuk, az mytexentask.jar állományt tegyük az eredeti projektünk lib könyvtárába, és a build.xml állományba módosítsuk a project, taskdef és a texen tag-et.
&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;project name="name="generator" " default="gen" basedir="." 
  xmlns:mytexentask="antlib:jtechlog.mytexentask"&amp;gt;
...
&amp;lt;taskdef uri="antlib:jtechlog.mytexentask"
  resource="jtechlog/mytexentask/antlib.xml"
  classpathref="classpath"/&amp;gt;

&amp;lt;mytexentask:MyTexenTask
 controlTemplate="control.vm"
 outputDirectory="build"
 templatePath="templates"
 outputFile="generation.report"
 outputEncoding="UTF-8" inputEncoding="UTF-8"/&amp;gt;
&lt;/pre&gt;&lt;p&gt;Eztán máris használhatjuk a dateOfGeneration változót a sablonunkban:
&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;html&amp;gt;
 &amp;lt;body&amp;gt;
   #parse('header.vm')
   Content. $dateOfGeneration
   #parse('footer.vm')
 &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/3270912925337717490/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/03/szoveg-generalas.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3270912925337717490'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3270912925337717490'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/03/szoveg-generalas.html' title='Szöveg generálás'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6768451653104605209</id><published>2009-03-23T03:38:00.009+01:00</published><updated>2009-09-20T12:08:40.497+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='BI'/><category scheme='http://www.blogger.com/atom/ns#' term='Community'/><title type='text'>OLAP Java eszközökkel</title><content type='html'>&lt;p&gt;2009. március 18-án tartottuk a 9. &lt;a href="http://jum.hu/?q=node/15"&gt;JUM&lt;/a&gt; rendezvényt a SZÁMALK egyik termében. A JUM célja lehetőséget teremteni arra, hogy a magyarországi Java-val foglalkozó szakembereknek, hogy technológiai tudásukat karbantartsák, tapasztalataikat megosszák egymással. Ezért alkalmi session-okat szervezzünk, ahol különböző témakörökben előadásokat tartunk egymásnak.&lt;/p&gt;&lt;p&gt;Első előadást Verhás István tartotta a "Maven2 a gyakorlatban" címmel. Az előadás tartalmazott elméleti és gyakorlati részeket is. Alapvetően én Maven ellenes vagyok, mert nem dolgoztam olyan környezetben, ahol többet használt volna, mint ártott. Viszont két dologban mindenképp egyetértek. Először is a convention over configuration jó dolog. Nagyon sajnálom, hogy még nincs szabvány arra, hogyan kell egy Java, akár Enterprise Java projekt felépítésének kinéznie. Másodsorban a Maven használata vállalati belső repository nélkül elég körülményes.&lt;/p&gt;&lt;p&gt;A második előadást Verhás Péter tartotta a "Web Szervizek tesztelése SOAPui-val" címmel. Az ötlet nagyon tetszett: remekül ismerték fel, hogyha a tesztelést, mint szolgáltatást el akarják adni, érdemes kicsit több munkát befektetni egyrészt az automatizálásba, másrészt a felület fejlesztésébe. Ők ezt úgy oldották meg, hogy integrálták a SOAPUi web szolgáltatások tesztelésére való eszközt (ingyenes, csak a professzionális változatáért kell fizetni), a GreenPepper automatikus funkcionális tesztelésre kifejlesztett eszközt (kereskedelmi), valamint az Atlassian Confluence nagyvállalati wiki megoldást. Így a SOAPUi-ban implementálják a teszteseteket, a Wiki felületén felviszik az input és output adatokat, és onnan is indítják a tesztelést, aminek eredménye megjelenik a felületen.&lt;/p&gt;&lt;p&gt;A harmadik előadást én tartottam "Adattárház és jelentéskészítés OLAP-pal a Pentaho Mondrian és JPivot nyílt forráskódú eszközök használatával" címmel. Ahogy ígértem, az előadásról &lt;a href="http://delfin.unideb.hu/%7Evicziani/pdf/Java_OLAP.pdf" onclick="pageTracker._trackPageview('link/Java_OLAP.pdf');"&gt;cikket írok és itt közlöm.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;object id="prezi_5hqg4hd6jahb" name="prezi_5hqg4hd6jahb" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" width="550" height="400"&gt; &lt;param name="movie" value="http://prezi.com/bin/preziloader.swf"/&gt;  &lt;param name="allowfullscreen" value="true"/&gt;  &lt;param name="allowscriptaccess" value="always"/&gt;  &lt;param name="bgcolor" value="#ffffff"/&gt;  &lt;param name="flashvars" value="prezi_id=5hqg4hd6jahb&amp;amp;lock_to_path=1&amp;amp;color=ffffff&amp;amp;autoplay=no"/&gt;  &lt;embed id="preziEmbed_5hqg4hd6jahb" name="preziEmbed_5hqg4hd6jahb" src="http://prezi.com/bin/preziloader.swf" type="application/x-shockwave-flash" allowfullscreen="true" allowscriptaccess="always" width="550" height="400" bgcolor="#ffffff" flashvars="prezi_id=5hqg4hd6jahb&amp;amp;lock_to_path=1&amp;amp;color=ffffff&amp;amp;autoplay=no"&gt;&lt;/embed&gt;&lt;/object&gt;&lt;/p&gt;&lt;p&gt;A &lt;a href="http://prezi.com/"&gt;Prezi&lt;/a&gt; online prezentációkészítő szolgáltatást mindenkinek javaslom kipróbálásra, hiszen nagyon látványos bemutatókat lehet vele készíteni. Szakít a "slide" fogalmával, és az egész prezentációt egy kicsinyíthető, nagyítható térben kell elhelyezni.&lt;/p&gt;&lt;p&gt;A JUM-mal kapcsolatban annyit, hogy többen voltunk, mint amennyire számítottunk, a létszám 20 felett volt (, bár több, mint 40-en regisztráltak). A legnagyobb hiba az idővel való elcsúszás volt, így az előadásomat is abba kellet hagyni, kérdésekre sem volt idő. Amennyiben az ember viszonylag ismeretlen dolgokról akar beszélni, csak az alapozással eltelik az a húsz perc, ami a prezentációra van szánva. Emiatt vagy populárisabb témát kell választani, vagy az előadók számát egy alkalommal háromról kettőre kell csökkenteni. Most elsőként kérdőívek is ki lettek osztva. Az értékelések egész jók lettek, 4-es skálán 3,5 körül. Tapasztalat velük annyi, hogy önmagában az osztályozás nem sokat ér, a szöveges megjegyzések, értékelések sokkal többet segítettek volna, hiszen az alapján tudnánk, hogy mit kéne esetleg másképp csinálni. Sajnos mindenki üresen hagyta.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/6768451653104605209/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/03/olap-java-eszkozokkel.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6768451653104605209'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6768451653104605209'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/03/olap-java-eszkozokkel.html' title='OLAP Java eszközökkel'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6365931995110998978</id><published>2009-03-14T22:04:00.007+01:00</published><updated>2014-02-02T16:37:41.173+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Módszertan'/><title type='text'>Hogyan írjunk dokumentációt csoportmunkában?</title><content type='html'>&lt;p&gt;A Java fanatikusokat el kell most keserítsem, ugyanis nem technikai témájú hozzászólás, hanem csoportmunkával kapcsolatos bejegyzés következik. Az utóbbi időkben főleg nem fejlesztenem kellett, hanem követelményspecifikációt írni csoportban, és ennek tapasztalatait szeretném veletek megosztani, de legalábbis magamnak felírni, hogy ne felejtsem el a következő projekt elején. Nem módszertanról szeretnék írni, hanem a gyakorlati munkaszervezésről. Utólag átolvasva meglepően sok dologban hasonlít a programozáshoz. Ígérem, a következő bejegyzésem technikai lesz, mivel szerdán (2009. március 18-án) a &lt;a href="http://jum.hu/?q=node/15"&gt;JUM&lt;/a&gt;-on tartok előadást, melynek anyagát kirakom ide is.&lt;/p&gt;Nézzük a manapság oly divatos felsorolást.
&lt;h3&gt;Az elején fektessétek le az alapszabályokat&lt;/h3&gt;Ezt egy nagyon jó "train the trainer" képzésen hallottam. A szabályokat már a munka elején le kell fektetni. Mivel minden résztvevő meghallgatja, és beleegyezik, ezért ehhez is próbálja tartani magát, ezekre lehet később hivatkozni. Nem önkényuralmi eszközökkel kell ezen szabályokat meghozni, hanem közösen, mindenki számára biztosítva a hozzászólást, hogy mindenki egy kicsit magának érezze az ügyet. Ha megvannak a keretek, akkor könnyebb lesz azokon belül maradni. Ezen keretek lehetőség szerint legyenek dokumentálva. Nem kőbe vésettek, ha később valamire rájövünk, hogy másképp jobban működik, akkor módosítani kell, de erről mindenkit tájékoztassunk, és mindenki egyezzen bele. Ne felejtsük el ezeket, folyamatosan ezekhez igazodjunk, és tartsuk karban. Ez a dokumentum lesz az én alapszabályaim alapja.
&lt;h3&gt;Válasszatok eszközt az információ tárolására&lt;/h3&gt;A követelményspecifikáció esetén különösen jellemző, hogy az információk különböző helyekről esnek be, ilyenek például:
&lt;ul&gt;&lt;li&gt;Interjúk&lt;/li&gt;
&lt;li&gt;Telefonos és személyes megbeszélések&lt;/li&gt;
&lt;li&gt;Elektronikus kommunikációs csatornák, mint e-mail, hangalapú és szöveges chat, stb.&lt;/li&gt;
&lt;li&gt;Elolvasott dokumentumok, emlékeztetők, jogszabályok, stb.&lt;/li&gt;
&lt;li&gt;Saját ötletek, az olvasottakkal kapcsolatban megfogalmazott kérések&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Ezek nyilvántartására, rendszerezésére nem elegendőek az egyszerű megoldások, valamilyen szofisztikáltabb eszközt, vagy módszert kell választani. Szerintem az egyik legjobb megoldás tudástár építésére a wiki alapú eszközök, személy szerint az &lt;a href="http://www.atlassian.com/software/confluence/"&gt;Atlassian Confluence&lt;/a&gt; Java alapú, Enterprise Wiki-re esküszöm. Lehet az oldalakhoz csatolmányokat fűzni, amiben keresni is képes, valamint e-mail postafiókokból is a leveleket képes letölteni, ezzel egy teljes információ konglomerátummá válni. Persze lehetnek mondjuk Word dokumentumok is egy megosztott, de inkább egy Subversion
szerveren, melyet &lt;a href="http://jtechlog.blogspot.com/2009/02/webdav-tapasztalatok.html"&gt;WebDAV&lt;/a&gt;-on keresztül lehet elérni. Elvárás az eszközzel kapcsolatban, hogy verziókezelést, valamint nem csak számítógép guruk által legyen használható. Mit ér a szofisztikált eszköz, ha nehéz kezelni, megtanulni. Ráadásul ilyen dokumentumokat nem csak informatikailag magasan képzett felhasználók írnak.&lt;/p&gt;Fontos, hogy az összes beáramló információt tereljünk ebbe a mederbe. Ha pl. egy e-mail jön be, akkor "feldolgozom", az összes lényeges információt átvezetem a rendszerbe, az attachment-et is átcsatolom, ha más számára is érdekes lehet. Vigyázz, ahol lehet egyszerűsíts. Csak a lényeget vezesd át.
&lt;h3&gt;Készíts dokumentum sablonokat&lt;/h3&gt;&lt;p&gt;Jó, ha készítetek sablonokat, amiket aztán csak ki kell tölteni. Legyen előlapjuk (címmel, dátummal, szerzővel, dokumentumtörténettel, jóváhagyókkal, elosztási listával, stb.), tartalomjegyzékük, figyelj a fejlécre, láblécre. Alkalmazkodj a céges, projekt és minőségbiztosítási előírásokhoz. Használd a dokumentum meta-leírását, Word-ben az adatlapot, és a dokumentumban hivatkozz ezekre.&lt;/p&gt;
&lt;h3&gt;Tervezz és oszd szét a feladatokat&lt;/h3&gt;Egy jó dokumentáció megírásához is alapos tervezés szükséges. Én általában úgy kezdem, hogy egy szövegszerkesztőben, vagy egy papíron összeírom a kulcsszavakat, amikről írni szeretnék. Utána megpróbálom rendezgetni, csoportosítani őket. Valamiket
könyörtelenül ki kell húznom, mert nem témája a dokumentumnak (vagy áttenni egy másikhoz), vagy újakkal kiegészítenem. A legfontosabbakat kiemelem, és hierarchiát alkotok. Ezzel meg is van a dokumentum tartalomjegyzéke, melyek alá a nem olyan fontos kulcsszavak bekerülnek témaként, hogy ebben a fejezetben erről kell írni. Majd a tartalomjegyzékbe lehet neveket írni, hogy melyik fejezet megírása kinek a feladata.
&lt;h3&gt;Ne találd fel a kereket!&lt;/h3&gt;&lt;p&gt;Feltehetőleg te is, valamint kollégáid is rengeteg követelményspecifikációt, rendszertervet, programozói és üzemeltetési dokumentációt írtak. Használd fel a hasznos részeket újra. Meríts a felépítésükből, a tartalmukból. Valamint te is úgy írd meg a dokumentációt, hogy később meríteni lehessen belőle, újra fel lehessen használni.&lt;/p&gt;&lt;h3&gt;Adj mintát&lt;/h3&gt;&lt;p&gt;Lehetőleg válaszd a legbonyolultabb fejezetet, írd meg, add körbe véleményezésre, és ezt használjátok alapul. De ne másoljátok! Ezzel egy mintát nyújtasz, amin tisztázható a stílus, a formátum, a szóhasználat. Jobb, mint a végén egységesíteni a stílust.&lt;/p&gt;&lt;h3&gt;Készíts szójegyzéket&lt;/h3&gt;&lt;p&gt;Készítse egy szójegyzéket, fogalommagyarázatot, ami tartalmazza a fontos fogalmakat, gyakran használt szavakat, rövidítéseket. Írd meg a szó rokonértelmű szavait is, de a dokumentumban az egységesség kedvéért mindig csak az eredeti szót használjátok. Ezzel definiálhatod, hogy mit kell egybe írni, mit kell külön írni, mit kell nagybetűvel írni, mit takar a rövidítés, stb.&lt;/p&gt;&lt;h3&gt;Ne ismételj&lt;/h3&gt;&lt;p&gt;Sok dokumentációban látom, hogy tele van ismétléssel, copy-paste-tel. Ez két ok miatt sem jó. Egyrészt általában akinek a dokumentum készül (pl. fejlesztő, ügyfél) nem szeret olvasni, feleslegesen nem szabad untatni. Másrészt karbantartani is nehezebb, mert ha változik egy rész, az összes helyen, ahova másolva lett, módosítani kell. Ez egyrészt erőforrásigényes művelet, másrészt nem biztos, hogy minden előfordulást javítottunk. Ezen eszközökben nagyon jól lehet referenciákat kezeni, wiki esetén egyszerű linkekkel, Word esetén kereszthivatkozásokkal.&lt;/p&gt;&lt;h3&gt;Tartsd egyszerűen&lt;/h3&gt;&lt;p&gt;Senki nem szeret unalmas, hosszú, száraz anyagot olvasni. Nagyon sokan azt hiszik, a hosszú dokumentum a jó dokumentum. Egy rövid, lényegre törő, kompakt dokumentum sokkal célravezetőbb lehet. Aki meg nem így gondolja, azzal akarunk mi együtt dolgozni?&lt;/p&gt;&lt;p&gt;Gyakori hiba az is, hogy a dogokat túlkategorizálják. Ezerféle hierarchiát dolgoznak ki, nagyon mély tartalomjegyzésket, stb. Majd a végén derül ki, hogy a feléről keveset tudnak csak írni, ezért egybeolvasszák egy másikkal. Talán a fordított elképzelés jobb, mikor egy viszonylag egyszerű hierarchiát alakítunk kis, és mikor egy fejezet túlnő egy méreten, akkor bontjuk kisebbekre.&lt;/p&gt;&lt;h3&gt;Ne tarts meg magadnak információt&lt;/h3&gt;&lt;p&gt;Ha bárhonnan információt kapsz, azonnal oszd meg a többiekkel. A többiek segíthetnek feldolgozni, rendszerezni, olyan kérdéseket tehetnek fel, olyan aspektusokat fedezhetnek fel, amik neked épp nem jutnak az eszedbe. Valamint ha bármi történik veled, jobb esetben csak másik projektre kerülsz, azonnal át tudják venni a feladataidat.&lt;/p&gt;&lt;h3&gt;Ne dolgozz saját gépre&lt;/h3&gt;&lt;p&gt;Csak a tudástárba, vagy a megosztott Word dokumentumba írj, ne a saját gépeden egy eldugott állományba. Hidd el, kevés embert zavar egy félkész anyag, mindenki a saját munkájával van elfoglalva, sokkal nagyobb probléma, ha az anyag elvész, vagy nem kerül időben a többiekhez. Pl. hazamész este, és elfelejted a közös helyre felmásolni. Különösen igaz ez mostanában, mikor általában nem kötött munkaidőben dolgozunk ezeken az anyagokon.&lt;/p&gt;&lt;h3&gt;Több szem többet lát&lt;/h3&gt;&lt;p&gt;Olvasd el más fejezeteit, és mások is olvassák el a te fejezeteidet. Lehetőleg ne színessel firkálj bele, hanem szabványos eszközöket használj, mint a Word korrektúrája, vagy megjegyzés hozzáadása. Amennyiben valamire konkrét javaslatod van, akkor ne megjegyzésként fűzd hozzá, hogy valahogy így kéne módosítani, hanem korrektúrával módosítsd. A másiknak könnyebb ezt elfogadnia, mint a te iránymutatásod alapján az ő szavaival megfogalmaznia. Ha valamiben nem vagy biztos, vagy kérdésed van hozzá, akkor alkalmazd a megjegyzést.&lt;/p&gt;&lt;h3&gt;Ne küldj levélben információt&lt;/h3&gt;&lt;p&gt;Mások dolgát megkönnyítve dolgozd fel azt, tedd be a közös rendszerbe, és csak egy linket küldj tovább. A levelezés nem annyira integrált, kereshető, archiválható, verziókezelhető.&lt;/p&gt;&lt;h3&gt;Gyűjtsd a kérdéseid&lt;/h3&gt;&lt;p&gt;Egységes helyen gyűjtsétek a kérdéseket, és a rá kapott válaszokat is, megfelelően kategorizálva. Fontos, hogy a válaszokat is, gyakran van olyan, hogy egy kérdésre egyszer így válaszoltak, egyszer úgy, és nem tudjuk észben tartani, hogy melyik is volt az utolsó álláspont. Ebben segít, hogy gyűjtitek ezeket. Ezek sem maradjanak sosem csak levélben.&lt;/p&gt;&lt;h3&gt;Refactor&lt;/h3&gt;&lt;p&gt;Amennyiben úgy érzed, hogy nem megfelelő az adott szerkezet, felépítés, ne félj hozzányúlni. Vonj össze fejezeteket, bontsd szét őket, vezess be újabbakat, módosítsd a hierarchiát.&lt;/p&gt;&lt;h3&gt;A tartalomra koncentrálj, ne a formátumra&lt;/h3&gt;&lt;p&gt;Az egyik legfontosabb. Akkor tudok megőrülni, mikor a dokumentum alkotója félkész állapotban "tördeli", formázza a dokumentumot. Én, hogy magam erről leszoktassam, először minden dokumentumot egy darabig Notepadben írtam, és a címeknél helyeztem el sortörést. Ha a dokumentum így is megállta a helyét, akkor elégedett voltam. Most már egyből Word-be írom, és csak a Címsor 1, 2, 3 stílusokat használom, valamint kód esetén készítek egy kód stílust, meg néha szükségem van táblázatra is. Ezen kívül semmilyen más formázási funkciót nem vagyok hajlandó használni. Azt csak a munkafolyamat végén szabad, template-ek használatával, vagy a stílusok felüldefiniálásával. Ebben segített a HTML is, ahol ugyanígy kell a tartalmat és a stílust elválasztani, egyiket az (X)HTML-ben, másikat a CSS-ben kell definiálni. Megőrülök, ha valaki üres hely képzésére a sortörést használja. Borzasztó, hogy sokan nem ismerik a Shift+Enter fogalmát. Üres hely definiálására a térközt kell használni. Ne mi sorszámozzunk, bízzuk rá az eszközre. Használjuk a képaláírásokat, táblázatok leírásait. Ha így használnánk a Word-öt, akkor nem lenne annyi bajunk az oldaltörésekkel, valamint egyéb misztikus hibajelenségekkel. Valamint rengeteg időt takarítanánk meg, ha a dokumentum írása közben nem foglalkoznánk a formátummal, és hogy hova jönnek ki az oldaltörések. Ültetek már valaki mellett azt nézve, hogy az ecsettel formátumot másol percekig?&lt;/p&gt;&lt;h3&gt;Használj helyesírás ellenőrzőt&lt;/h3&gt;&lt;p&gt;Igen elterjedt eszköz, de mégis sok helyről kapok olyan dokumentumokat, melyben nyüzsögnek a helyesírási hibák. Több platformon, és eszközbe beépítve is megtaláljuk, ne sajnáljuk rá az időt. Hiába professzionális a tartalom, a hibák ennek fényét homályosítják. Még jobb, ha van egy korrektor a cégnél, vagy egy magyar szakos, azok átolvasva is rengeteg stilisztikai hibát tudnak javítani. A fejlesztők általában szeretik a szenvedő szerkezeteket, és nem szeretnek egyeztetni, az igeidőket, alany használatát, feltételes módot nem következetesen ugyanúgy használják a dokumentumban.&lt;/p&gt;&lt;h3&gt;Hagyj időt a végére&lt;/h3&gt;&lt;p&gt;Sokan még az utolsó percig írják a dokumentumot. Próbáld meg úgy ütemezni, hogy a végén legyen egy kis idő pihenni rá egyet, majd újból elolvasni. A végső összeszerkesztés is több időbe szokott telni, mint azt az ember elgondolja.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/6365931995110998978/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/03/dokumentumok-irasa-csoportosan.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6365931995110998978'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6365931995110998978'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/03/dokumentumok-irasa-csoportosan.html' title='Hogyan írjunk dokumentációt csoportmunkában?'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6807279072739304839</id><published>2009-02-23T21:51:00.003+01:00</published><updated>2010-09-18T00:37:29.779+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Tesztelés'/><title type='text'>Code coverage</title><content type='html'>&lt;p&gt;A code coverage (lefedettség mérés) egy olyan technika, mellyel az mérhető, hogy a kód mely részei futottak le. Tesztelésnél alkalmazzák, ahol összehasonlítják a forráskódot, valamint azt, hogy egy konkrét teszt készlet (test suite) végrehajtása során ténylegesen a kód mely sorai futottak le. Emiatt a white box tesztelés egy formája.&lt;/p&gt;A code coverage célja olyan kódrészletek megtalálása, melyekre a teszt során nem került a vezérlés, valamint pl. olyan feltételek kiválasztásra, melyeknek csak egyik ága futott le.
&lt;p&gt;Általában százalékban szokták megadni, ami kifejezi a tesztelt és az összes kódsor viszonyát.&lt;/p&gt;Elvileg ideális az lenne, hogy újrafuttatható teszt eseteket implementálunk (netalán már a funkcionalitás implementálása előtt - lsd. test driven development), közben beállítunk egy code coverage eszközt, és a teszt esetekkel megpróbáljuk az összes kódsort tesztelni, így 100%-os lefedettséget teljesíteni. Én személy szerint valódi projektben nehezen tudok elképzelni ilyent, és ettől óva is intenék mindenkit, a következő okok miatt:
&lt;ul&gt;&lt;li&gt;Nagyon időigényes, így projekt költségét nagymértékben megnövelheti&lt;/li&gt;&lt;li&gt;Rettentő fárasztó, unalmas, abszolút nem kreatív munka ilyen teszt eseteket írni, ilyen mennyiségben, amit a fejlesztők nagyon nem szeretnek&lt;/li&gt;&lt;li&gt;A code coverage nem mutatja ki a hiányzó funkciókat&lt;/li&gt;&lt;li&gt;Teljes lefedettség esetén sem biztosítható a hibamentes működés&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Javaslom ezt is egy eszközként használni a többi között, mely segíthet a tesztelésben, rámutathat a hibákra, de meg kell találni az arany középutat. Ne próbáljunk meg teljes lefedettséget elérni, sőt egy viszonylag jó lefedettséget is csak fokozatosan érjünk el. Nagyon fontos, hogy amennyiben találtunk egy nagyobb kódrészletet, amit nem teszteltünk, akkor ne egy olyan teszt metódust írjunk, ami leteszteli az adott kódrészletet, hanem lépjünk háta egyet, és próbáljuk meg azt az üzleti igényt megfogalmazni, melyet az adott kódrészlet valósítana meg, és azt teszteljük. Ezáltal elkerülhetjük, hogy fogalom nélkül, csak az adott metódust teszteljük le attól függetlenül, hogy vajon hol is helyezkedik el a rendszerben, milyen nagyobb funkciónak a része.&lt;/p&gt;Azon projektekben, ahol nem alkalmazunk automatikus unit teszteket, ott is jól tud jönni. Ha a tesztelést manuálisan végzik, külön erre delegált szakemberek, akkor is hasznos lehet. A teszt eseteket ekkor is írjuk le (Word dokumentumban, Excel táblázatban strukturáltan, de vannak erre külön eszközök). Javasolt, hogy az első pár teszt esetet a fejlesztő írja le, egy gyors kódpásztázás alapján a főbb elágazásokat, képernyőket figyelembe véve (white box). Utána a manuális tesztelők hajtsák végre a teszt eseteket, majd a fejlesztő nézze meg, hogy mely kódsorok maradtak ki. Ezután a kód alapján vissza kell fejteni azon funkcionalitásokat (nem metódusokat, kódrészleteket!), melyek tesztelése részleges, netalántán teljesen kimaradt. Ez alapján lehet továbbfejleszteni a teszt eseteket. A ciklust megismételve (mondjuk új release-enként) így előbb utóbb egy jó lefedettséget produkáló teszt forgatókönyv jön létre. Természetesen a teszt forgatókönyvet a manuális tesztelést végzők is módosíthatják, pontosíthatják, kiegészíthetik a felhasználói követelmények alapján.
&lt;p&gt;Hasznos lehet még, hogy nem csak az aktuális lefedettséget vesszük figyelembe, hanem a trendeket is nyomon követjük. Ha nagymértékben csökken a lefedettség, az arra utalhat, hogy a rendszerbe újabb funkciók kerültek be, de új teszt esetek nem készültek, esetleg néhány teszt eset futtatása kimaradt.&lt;/p&gt;Több mérőszámot is definiáltak, bizonyos mérőszámok csak Java környezetben értelmezettek:
&lt;ul&gt;&lt;li&gt;Class coverage: mely osztályok vettek részt a futásban&lt;/li&gt;&lt;li&gt;Method coverage: mely metódusok lettek meghívva&lt;/li&gt;&lt;li&gt;Statement coverage: mely kódsorok futottak le, akár metódus, osztály és package szinten aggergálva
&lt;/li&gt;&lt;li&gt;Block coverage: itt nem kódsorok, hanem blokkok az alapegységek&lt;/li&gt;&lt;li&gt;Decision coverage (vagy ismert Branch coverage néven is): elágazás esetén minden ág lefutott-e&lt;/li&gt;&lt;li&gt;Path coverage: minden lehetséges lefutási útvonal lefutott-e&lt;/li&gt;&lt;li&gt;stb.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;A különböző eszközök kiválasztásánál a következő szempontokat vehetjük figyelembe:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Mennyire integrált egy fejlesztőeszközzel&lt;/li&gt;&lt;li&gt;Mennyire integrált egy build tool-lal (pl. Ant, Maven)&lt;/li&gt;&lt;li&gt;Milyen kimeneti formátumokat támogat (XML, HTML elvárt), és azok milyen minőségűek, könnyen navigálhatóak
&lt;/li&gt;&lt;li&gt;Mennyire támogatja a trendek figyelését&lt;/li&gt;&lt;li&gt;Ki lehet-e zárni bizonyos kódrészleteket (pl. 3rd party library-k)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Az eszközök megvalósítása is eltérő lehet. Egyrészt módosíthatják a forráskódot, amit a fordító lefordít, vagy a már lefordított bájtkódot matatják (instumentation). Az utóbbi történhet build time-ban, vagy akár futás közben speciális classloader segítségével.&lt;/p&gt;&lt;p&gt;Vigyázzunk, hogy a code coverage megnövelheti mind a processzorterhelést, mind a memóriaigényt. Emiatt javasolt csak teszt környezetben használni, és ott sem terheléses teszt közben. Az előbbi miatt lehet az is, hogy bizonyos párhuzamossági, vagy real time rendszerben jelentkező hibák elő sem jönnek tesztelés közben. Az &lt;a href="http://www.atlassian.com/software/clover/default.jsp"&gt;Atlassian Clover&lt;/a&gt; egy remek, ám kereskedelmi termék. Nagyon jó felülettel, rengeteg funkcióval rendelkezik, integrálható a JUnit-tal, és Eclipse és IntelliJ IDEA plugin is van hozzá. A &lt;a href="http://codecoverage.netbeans.org/"&gt;NetBeans Unit Tests Code Coverage Plugin&lt;/a&gt; egy ígéretes eszköz, mely a NetBeans-be épül be, de sajnos egyelőre csak a unit tesztek és az egyszerű alkalmazásokat tudja követni, webes alkalmazásokat még nem. A két leggyakrabban említett nyílt forráskódú, ingyenes egyköz a &lt;a href="http://cobertura.sourceforge.net/"&gt;Cobertura&lt;/a&gt; és az &lt;a href="http://emma.sourceforge.net/index.html"&gt;Emma&lt;/a&gt;. Az előbbi talán könnyebben emészthető riportot generál, míg az utóbbi több funkcióval rendelkezik (pl. class, method, block coverage, runtime instrumentation, adatok JVM leállítása nélküli mentése vagy törlése, stb.)&lt;/p&gt;&lt;p&gt;Nézzük, hogy hogyan is kell a Cobertura-t beállítani egy egyszerű webes alkalmazáshoz, NetBeans esetében. Az alapvető elvárás az volt, hogy minden fejlesztő számára minimális konfigurációval beüzemelhető lehessen.&lt;/p&gt;Ehhez egyrészt a projekt lib könyvtárába másoltam a Cobertura számára nélkülözhetetlen jar állományokat (asm-3.0.jar, asm-tree-3.0.jar, jakarta-oro-2.0.8.jar, log4j-1.2.9.jar), valamint a következőket adtam hozzá a NetBeans által generált build.xml-hez.
&lt;pre class="brush: xml"&gt;&amp;lt;loadproperties srcFile="build.properties"/&amp;gt;

&amp;lt;path id="cobertura.classpath"&amp;gt;
   &amp;lt;fileset dir="lib/cobertura/"&amp;gt;
       &amp;lt;include name="*.jar" /&amp;gt;
   &amp;lt;/fileset&amp;gt;
&amp;lt;/path&amp;gt;

&amp;lt;taskdef classpathref="cobertura.classpath"
 resource="tasks.properties" /&amp;gt;

&amp;lt;target name="cobertura-instrument" if="cobertura.instrument"&amp;gt;
   &amp;lt;cobertura-instrument todir="build/web/WEB-INF/classes"&amp;gt;
       &amp;lt;fileset dir="build/web/WEB-INF/classes"&amp;gt;
           &amp;lt;include name="**/*.class" /&amp;gt;
       &amp;lt;/fileset&amp;gt;
   &amp;lt;/cobertura-instrument&amp;gt;
&amp;lt;/target&amp;gt;

&amp;lt;target name="-pre-dist" depends="cobertura-instrument" /&amp;gt;

&amp;lt;target name="report"&amp;gt;
   &amp;lt;cobertura-report format="html" destdir="dist/coverage"
    srcdir="src/java"/&amp;gt;
&amp;lt;/target&amp;gt;
&lt;/pre&gt;Ez a részlet betölti a build.properties állományt, és ha abban szerepel a cobertura.instrument property, akkor instrumentálni (statikust, azaz build idejűt támogat) fogja a class állományokat. Így ezen property megjegyzésbe helyezésével egyszerűen kikapcsolható. Mivel a -pre-dist előfeltétele a cobertura-instrument task futtatása, a war állomány becsomagolása előtt fogja a class állományokat módosítani. A futtatáshoz a Coberturá-hoz szükséges JAR állományokat a konténer, NetBeans esetén pl. a Tomcat classpath-jában kell elhelyezni (lib könyvtár), és nem a war állományban. A projektet fordítva a projekt gyökerében azonnal létre fog jönni egy cobertura.ser állomány, melyet az instrumentálás hoz létre. Fontos, hogy a futás közben is ezt a ser állományt kell használni, ehhez a Tomcat-nek adjuk meg a következő kapcsolót -Dnet.sourceforge.cobertura.datafile=${basedir}/cobertura.ser a Tools/Servers ablak Platform fülén a VM Options mezőbe. A ${basedir} a projektünk könyvtárát jelenti, ahol az előbb létrejött a ser állomány. Amennyiben nem így teszünk, a riportban 0%, 100% vagy na értékek fognak szerepelni. Fontos, hogy ahhoz, hogy a code coverage információk ki legyenek írva lemezre, le kell állítani a konténert. Ez után már futtathatjuk is a report task-ot, mely a dist könyvtárban létrehoz egy html jelentést, a &lt;a href="http://cobertura.sourceforge.net/sample/"&gt;Cobertura honlapján található példához&lt;/a&gt; hasonlót.
&lt;p&gt;A Cobertura-nak ezen kívül több funkciója is van: használható parancssorból, képes XML kimenet generálására, képes WAR, JAR instrumentálására, osztályok minta szerinti kihagyására, különböző ser fájlok összefésülésére, valamint threshold értékek megadására (melyek túllépése leállítja a build folyamatot).&lt;/p&gt;A riportban megjelenik a cyclomatic complexity is. Ez egy mérőszám, melyet statikus kódelemzéssel meg lehet állapítani, és gyakorlatilag a program bonyolultságát méri. Szokás McCabe számnak is nevezni a feltalálójáról, aki 1976-ban publikálta. Ez a szám meghatározza egy programon belül a lineárisan független futási ágak számát. Gyakorlatilag egy gráfon dolgozik, ahol a csomópontok a programutasítások, és két csomópont akkor van irányítottan összekötve, ha az egyik utasítás futás közben követheti a másikat. Ennek a formális definíciója: M = E − N + 2P, ahol M a cyclomatic complexity, az E az élek száma, az N a csomópontok száma, és a P a maximális kapcsolódó algráfok száma. Ez egyszerűbben is meghatározható, méghozzá úgy, hogy meg kell számolni a zárt körök számát, és hozzáadni a kilépési pontok számát.
&lt;p&gt;Egy Java metódusban össze kell számolni a program lefutását módosító elemeket, és hozzáadni egyet. Ilyenek: return, if, else, case, default, for, while, do-while, break, continue, &amp;amp;&amp;amp;, ||, ?:, catch, finally, throw vagy throws, thread start().&lt;/p&gt;A cyclomatic complexity gyakorlatban egy metódus komplexitását adja meg. Minél bonyolultabb, annál nehezebb megérteni és karbantartani. Kb. 10-es komplexitás a max, amit még érdemes használni.
&lt;p&gt;Azért szerepel gyakran a code coverage eszközökben, mert ez a szám adja meg azon teszt esetek számát is, melyekkel az összes lehetséges lefutási módot tesztelni lehet. Más statikus elemző eszközök is tudnak ilyent számolni, mint pl. a PMD.&lt;/p&gt;Abban az esetben, ha elértük a cyclomatic complexity határát, és csökkenteni akarjuk, akkor forduljunk a refactoring-hoz, melynek első lépése egy teszt eset gyártása. Utána vagy csökkentsük a bonyolultságát, vagy vezessünk be új, beszédes nevű metódusokat. A funkcionalitást ne módosítsuk. A refactoring után ezt az előbb megírt teszt esettel ellenőrizhetjük.</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/6807279072739304839/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/02/code-coverage.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6807279072739304839'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6807279072739304839'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/02/code-coverage.html' title='Code coverage'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2326763854835297631</id><published>2009-02-11T22:19:00.005+01:00</published><updated>2009-03-08T14:43:23.578+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Subversion'/><title type='text'>WebDAV tapasztalatok</title><content type='html'>&lt;p&gt;Nem kifejezetten Java téma, de szerintem minden fejlesztőnek hasznos lehet, ha egy kicsit megismerkedik a WebDAV protokollal.&lt;/p&gt;Az utóbbi napokban az volt a feladatom, hogy kialakítsak egy közös helyet dokumentumok (általában Word állományok) megosztására. Az elvárások a következők voltak:
&lt;ul&gt;&lt;li&gt;Maximális biztonság, hiszen komoly projektről van szó&lt;/li&gt;&lt;li&gt;Elérés a net bármely pontjáról, hiszen nem egy lokális hálózaton belül ülünk&lt;/li&gt;&lt;li&gt;Egyszerűen, nem programozók számára is egyszerűen telepíthető és használható&lt;/li&gt;&lt;li&gt;Jogosultságkezelés
&lt;/li&gt;&lt;li&gt;Amennyiben lehetséges, legyen automatikus verziókezelés&lt;/li&gt;&lt;li&gt;Lehetőleg támogassa a zárolást (lock): ha egy felhasználó elkezd szerkeszteni egy dokumentumot, lehetőleg más addig ne szerkessze (szemben a merge modellel, ahol lehet szerkeszteni, de ha ütközés van, automatikusan vagy kézzel kel feloldanunk)
&lt;/li&gt;&lt;li&gt;Minél jobban illeszkedjen a jelenlegi eszközökhöz
&lt;/li&gt;&lt;/ul&gt;A következő megoldások jöttek szóba:
&lt;ul&gt;&lt;li&gt;WebDAV&lt;/li&gt;&lt;li&gt;Valamilyen webes document management rendszer, akár egy wiki&lt;/li&gt;&lt;li&gt;VPN-nel becsatlakozás a cég hálózatába, majd megosztott könyvtár használata&lt;/li&gt;&lt;li&gt;Microsoft  Windows SharePoint Services vagy Office SharePoint Server&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Az első a macerásabb konfiguráció miatt kiesett, a Microsoft termékek az áruk, valamint Microsoft-os szerverek hiánya miatt nem jöhetett szóba. A maradék két megoldás közül a WebDAV-ot választottam, hiszen az gyorsan beüzemelhető és kipróbálható volt, valamint illeszkedett a jelenlegi architektúrába.&lt;/p&gt;A Web-based Distributed Authoring and Versioning (WebDAV) a HTTP protokoll kiterjesztése, mely lehetővé teszi azt is, hogy egy web szerverről ne csak lekérjük az állományokat, hanem feltölthessük, módosíthassuk és törölhessük őket. A WebDAV főbb jellemzői, melyeket nem minden kliens támogat: lockolás, tulajdonságok (property-k, metaadatok, pl. író, módosítás dátuma, stb.), használata, névtér kezelés (namespace - másolás, mozgatás) és fájlok csoportosítása (collections - könyvtárral). Az ígéret szerint kellően gyors hálózatnál, és jó klienssel szinte megkülönböztethetetlen egy lokális meghajtótól. A http sokak által ismert GET, POST, stb. metódusai mellett megjelentek a PROPFIND, PROPPATCH metódusok tulajdonságok kezelésére, MKCOL kollekciók kezelésére, COPY, MOVE az erőforrások kezelésére és a LOCK és UNLOCK a zárolásra.
&lt;p&gt;Ugye ismerősek? Igen, az egyik legelterjedtebb nyílt forráskódú ingyenes Subversion verziókezelő is képes WebDAV-on keresztül működni. Ehhez egy Apache HTTP Server-t kell telepítenünk, és abba a bekapcsolni a mod_dav modult, és az Subversion mod_dav_svn modult. Ha a Subversion repository-t HTTP-n keresztül érjük el, akkor valószínűleg így van beállítva. Ez a konfiguráció többek között a következőket biztosítja:&lt;/p&gt;Apache által támogatott authorizációs mechanizmusok használata&lt;ul&gt;&lt;li&gt;Teljes körű jogosultságkezelés&lt;/li&gt;&lt;li&gt;Naplózás&lt;/li&gt;&lt;li&gt;SSL-lel titkosítható&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Ezen megoldásnak nagyon sok előnye van. Egyrészt általában mindenütt működik egy Subversion szerver, amit ezek után dokumentum tárolásra is használhatunk. A HTTP(S) átmegy a tűzfalakon, és a repository, ezáltal a dokumentumaink is böngészőből elérhetőek olvasásra.&lt;/p&gt;A WebDAV-hoz kifejlesztették a DeltaV kiegészítést, ami az eredeti szabványt megtoldja verziókezeléssel. A Subversion nem egy teljes DeltaV megoldás, és megvalósítja az un. autoversioning opcionális lehetőséget. Ez azt jelenti, ha verziókezelést nem megvalósító kliens támad, akkor is képes a verziók automatikus kezelésére, méghozzá a műveletek után automatikusan kiad egy commit műveletet, és ekkor egy log üzenet automatikusan generálódik hozzá.
&lt;p&gt;De nézzük meg, hogy mi kell ahhoz, hogy módosítsunk is. Vagy egy Subversion kliens, vagy egy kezdő felhasználók számára transzparens WebDAV kliens. No, itt kezdődtek a problémák. A legtöbb operációs rendszer, mint a Windows is tartalmaz beépített klienst, sőt ez kettőt is, korábban Web folders néven, később a Windows XP-ben jelent meg az újabb verziója WebDAV mini-redirector néven. Az előbbi Windows Explorer (és nem az Internet Explorer) bővítménye. A WebDAV mini-redirector fájlrendszer szinten épülne be, de nagyon hibás szoftver, használata nem javasolt (nem kezeli a https protokollt, és az alapértelmezett, 80-as porttól eltérő portokat).&lt;/p&gt;No gondoltam, akkor válasszunk egy 3rd party megoldást a következők közül:
&lt;ul&gt;&lt;li&gt;&lt;a href="http://www.webdrive.com/"&gt;WebDrive&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://www.netdrive.net/"&gt;NetDrive&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Novell NetDrive 4.0, mely megtalálható a NetWare 6 Client CD-n, valamint a &lt;a href="http://www.theblog.ca/novell-netdrive"&gt;neten&lt;/a&gt; is nem teljesen legálisan.
&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Mindegyik előnye, hogy egy WebDAV elérést drive-ként tudna bemappelni. Három géppel próbálkoztunk, és mindegyik kliens képes volt ezek közül legalább egyet lefagyasztani. Azért sem jó megoldás a használatuk, mert nem működik a zárolás, a Word speciális nevű fájlokat helyez el. Valamint a mentésnél nem egy létezőt módosít, hanem letörli az előzőt, és újra létrehozza.&lt;/p&gt;Ezért maradtam a Windows beépített megoldásánál, de nem a hibás mini-redirector-nál, hanem a Windows Explorer-ből elérhető Web folders-nél, amit a következőképpen kell beüzemelni:
&lt;ul&gt;&lt;li&gt;Hálózati helyek (Asztalról a legegyszerűbben elérhető)&lt;/li&gt;&lt;li&gt;Hálózati hely hozzáadása&lt;/li&gt;&lt;li&gt;A varázslóban a „Válasszon másik hálózati helyet” kiválasztása&lt;/li&gt;&lt;li&gt;Internet- vagy hálózati cím beviteli mezőben az URL megadása&lt;/li&gt;&lt;li&gt;A tovább gombra, ha HTTPS kapcsolat van, nem böngésző által elfogadott hitelesítésszolgáltató által kiadott tanúsítvánnyal, el kell fogadni (amennyiben nem akarjuk mindig elfogadni, telepíthetjük is), majd ha autentikáció van beállítva, meg kell adni a felhasználónevet és jelszót. Végül adjunk meg egy nevet.&lt;/li&gt;&lt;li&gt;Fejezzük be a varázslót, és nyissuk meg a hálózati helyet.&lt;/li&gt;&lt;li&gt;Ekkor megjelenik a megosztott könyvtár.&lt;/li&gt;&lt;li&gt;Később, ha Windows Explorer-t használunk, akkor megjelenik a Hálózati helyek között a megosztás a bal oldali fában. A megosztás megjelenik a Word Fájl/Megnyitás menüre előugró ablakában is, a Hálózati helyek gombra klikkelve bal alul. Az Office is alapban használja a WebDAV klienst, azaz megnyitáskor megadhatunk WebDAV URL-t is.
&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Sajnos ez sem tökéletes megoldás, a Word néha elveszíti a kapcsolatot, ekkor lokálisan kell elmenteni, majd újra a megosztásra menteni, és kiválasztani, hogy csak új verziót akarunk feltölteni, nem akarjuk törölni a régit.
Linux alatt WebDAV mount-olható a davfs2 vagy fusedav alkalmazásokkal, a Konqueror és a Nautilus beépített támogatást tartalmaz, valamint elérhető egy parancssoros Cadaver kliens is.&lt;/p&gt;Nagyon sokat küzdöttem azzal is, hogy Internet Explorer-ből (vagy Firefox-ból) egy dokumentumra kattintva úgy nyissa meg a Word, hogy azonnal menteni is lehessen. Találtam registry buherálós megoldást, HTTP header módosítással operáló megoldást (MS-Author-Via: "DAV"), Firefox plugin-okat, de sajnos nekem egyik sem hajlandó működni.
&lt;p&gt;Szóval az elképzelés nem rossz, de a silány Windows-os WebDAV kliensek miatt még mindig nincs kényelmes megoldás.&lt;/p&gt;Lehet, hogy mégis inkább egy Wiki alapú megoldást kell keresni. Sőt, ennek keveréke is elképzelhető, hiszen pl. az Atlassian Confluence (ami ugyan kereskedelmi termék) képes a tartalmat WebDAV-on keresztül kiajánlani (ez is verziókövetett), valamint egy WebDAV kliens plugin is van hozzá, más szerverek elérésére.
&lt;p&gt;Hogy kicsit a Java-hoz is köze legyen, vannak Java-s kliensek, mint az &lt;a href="http://www.davexplorer.org/"&gt;DAV Explorer&lt;/a&gt;. Volt egy Apache Slide is, tartalomkezelésre, de ennek fejlesztése leállt, javasolt az Apache Jackrabbit használata. Ezen kívül egyszerűen tesztelhetünk WebDAV-ot, hiszen az Apache Tomcat is tartalmaz egy &lt;a href="http://tomcat.apache.org/tomcat-6.0-doc/api/org/apache/catalina/servlets/WebdavServlet.html"&gt;org.apache.catalina.servlets.WebdavServlet&lt;/a&gt; nevű servlet-et, mely megvalósítja a WebDAV protokollt.&lt;/p&gt;&lt;p&gt;&lt;span style="font-weight: bold;"&gt;Frissítés:&lt;/span&gt; Sajnos a Word gyakran veszti el a kapcsolatot a WebDAV szerverrel, és ilyenkor csak akkor sikerül neki lementeni a fájlt, ha az eredetit törli. Ezzel viszont ugrik a verziókezelés, hiszen egy törlés, majd egy hozzáadás művelet zajlik a háttérben.&lt;/p&gt;&lt;p&gt;Találtam egy kereskedelmi terméket is &lt;a href="http://www.webdavsystem.com/mapdrive/home"&gt;IT Hit Map WebDAV Drive&lt;/a&gt; néven, lehet, hogy érdemes lenne ezt is megvizsgálni.
&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/2326763854835297631/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/02/webdav-tapasztalatok.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2326763854835297631'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2326763854835297631'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/02/webdav-tapasztalatok.html' title='WebDAV tapasztalatok'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5780082598515212534</id><published>2009-01-25T12:25:00.006+01:00</published><updated>2010-09-18T00:38:03.070+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Library'/><title type='text'>Apache Lucene keresőmotor</title><content type='html'>&lt;p&gt;Oktatás során szoktam hangsúlyozni, hogy a Java nem csak egy programozási nyelv, hanem sokkal több annál, divatos szóval nevezhetnénk akár platformnak, egy blogger nézőpontjából életformának.&lt;/p&gt;A Sun-nak ezzel kapcsolatban van egy nagyon jól eltalált &lt;a href="http://java.sun.com/new2java/javamap/intro.html"&gt;Java Technology Concept Map&lt;/a&gt;nevezetű kiadványa, mely egy lapon próbálja a Java részeit, és a Java világához tartozó dolgokat megemlíteni.
&lt;p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://java.sun.com/images/java_map.gif"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 450px; height: 319px;" src="http://java.sun.com/images/java_map.gif" alt="" border="0" /&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Nézzük melyek is azok a nevek, technológiák, szabványok nagy vonalakban, melyeket mindenképp érdemes megemlíteni:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Java mint objektum-orientált programozási nyelv, mely egy &lt;a href="http://java.sun.com/docs/books/jls/"&gt;specifikáció&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;A Java virtuális gépet (Java Virtual Machine - JVM), mely szintén egy &lt;a href="http://java.sun.com/docs/books/jvms/"&gt;specifikáció&lt;/a&gt;.
&lt;/li&gt;&lt;li&gt;&lt;a href="http://java.sun.com/javase/6/docs/"&gt;Java SE (Standard Edition)&lt;/a&gt;, mely egy fejlesztési platform asztali, egyszerűbb szerver  alkalmazások fejlesztésére, mely már tartalmaz egy kiterjedt &lt;a href="http://java.sun.com/javase/6/docs/api/index.html"&gt;osztálykönyvtárat, API-t&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;Ezen specifikációk legelterjedtebb megvalósítása a Sun Java SE Runtime Environment (JRE), mely egy futtató környezet, benne a Sun HotSpot virtuális géppel, valamint a Java SE Development Kit (JDK), mely parancssori fejlesztő eszközöket is tartalmaz. Ne feledjük, léteznek alternatív megvalósítások is, pl. virtuális gépre a Bea, ma már Oracle JRockit.&lt;/li&gt;&lt;li&gt;A SE nem elegendő minden igény kiszolgálására, ezért kialakítottak két új, bár az SE-re épülő változatot, a mobil fejlesztésre koncentráló Micro Edition-t, ME (ide tartoznak nem csak a mobiltelefonok, de az összes un. limited device, mint pda, set-top box, stb.), valamint a nagyvállalati fejlesztésre szolgáló Enterprise Edition-t, EE. Intelligens kártyákra a Java Card technológiával lehet fejleszteni.
&lt;/li&gt;&lt;li&gt;A Java elvei közé tartozik, hogy specifikációkat hoznak ki, és arra több gyártó, sőt akár nyílt forráskódú közösség is adhasson ki implementációt. A szabványok kidolgázásáért felelős szervezet az &lt;a href="http://jcp.org/en/home/index"&gt;Java Community Process (JCP)&lt;/a&gt;, melynek keretében szabvány kérelmeket (Java Specification Request - JSR) állítanak elő. Van JSR olyan alap dologhoz is, mint a programozási nyelv maga (&lt;a href="http://jcp.org/en/jsr/detail?id=901"&gt;JSR 901&lt;/a&gt;), de olyan nagyvállalati specifikációk is, mint a Java EE, EJB3, JPA, portlet, stb.&lt;/li&gt;&lt;li&gt;Természetesen egy nyelv keveset ér a fejlesztők nélkül. A Sun a Java fejlesztők számát 10 millió fölé tippeli.
&lt;/li&gt;&lt;li&gt;Ide tartoznak azok az eszközök, melyek képesek Java-t futtatni. Ezek nem csak személyi számítógépek, de szerver szintű számítógépek, a másik oldalon mobiltelefonok, PDA-k, de beágyazott rendszerek is, pl. kenyérpirító szoftvere. :)&lt;/li&gt;&lt;li&gt;Szerencsére, bár ezt sokan elfelejtik, a Java-nak a célja SEM a fejlesztők érdeklődésének, tanulási, fejlődési vágyának kiszolgálásra, hanem a felhasználók kiszolgálása. Számítógépet használók szinte mindegyike találkozott már tudva, tudatlanul, akarva akaratlanul Java-ban implementált szoftverekkel, pl. Java applet-tel, vagy pl. a telefonhívásából számlát gyártó, vagy banki hitelét elbíráló nagyvállalati alkalmazással.&lt;/li&gt;&lt;li&gt;A Java elterjedését nagyban segítette az Internet. Egyrészt a Java nyelv és osztálykönyvtár elemei a kezdetektől támogatják elosztott rendszerek fejlesztését, Internet-et használó alkalmazások elkészítését. Másrészt az Internet remek közeg arra, hogy a fejlesztők kommunikáljanak, a gondolataikat megosszák egymással levelező listákon, fórumokon, blogokon, verziókövető és hibabejelentő rendszereken, stb. keresztül.&lt;/li&gt;&lt;li&gt;Ezen fejlesztők hatalmas mennyiségű nyílt forráskódú, valamint kereskedelmi terméket állítanak elő. Érdemes megnézni a Sourceforge, Java-Source.net, Codehaus, Apache oldalakat, hogy csak a nagyokat említsem, valamint a Sun, IBM, Oracle is több százas nagyságrendben kínál Java alapú szoftvereket, nem beszélve a kisebb cégekről. Ide tartoznak a fejlesztéshez használt eszközök, tool-ok (pl. modellező eszköz, IDE, projekt menedzsment, build és continouus integration eszköz, tudásmenedzsment eszköz, verziókezelő, issue tracker, teszt eszközök), library-k, middleware-ek, keretrendszerek, de a végfelhasználói programok is.&lt;/li&gt;&lt;li&gt;A legtöbb termékhez (legyen akár nyílt forráskódú, akár kereskedelmi), rengeteg információ áll rendelkezésre, melyeket különböző csatornákon lehet megszerezni, mint portálok, wiki-k, blogok, RSS feed-ek, fórumok, levelezési listák, podcast-ok. Információkat szerezhetünk nyomtatott és elektronikus könyvekből, cikkekből, tutorial-okból, FAQ-kból, példaprogramokból és ha adott, akár a forráskód is segíthet. A Java-hoz különböző események, konferenciák, közösségek (pl. a magyar Java Users Group - JUG, a &lt;a href="http://www.jum.hu/"&gt;Java User Meeting - JUM&lt;/a&gt; is ilyen).
&lt;/li&gt;&lt;li&gt;A Java alapú szoftverfejlesztéshez (de a szoftverfejlesztéshez általában) rengeteg elméleti tudás, metodológia, módszertan is kapcsolódik, melynek széles körű áttekintse, megismerése is lehetetlen feladat. Ilyenek a fejlesztési módszertanok (unified process, agilis szoftverfejlesztés) és a hozzájuk tartozó modellező eszközök, objektum-orientált paradigmák, tervezési minták, refactoring, AJAX, Web 2.0, RIA, EAI, SOA, stb.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Ezt a szerteágazó világot megismerni, követni, a részeit JÓL alkalmazni nem egyszerű feladat, hatalmas kihívás egy fejlesztő számára.&lt;/p&gt;Ebben a blogban próbálok ebben segíteni, különböző hasznos eszközöket, library-ket bemutatni.
&lt;p&gt;Ezek közül egyik a Lucene könyvtár, mely egy nagy teljesítményű, minden alkalmazási területet lefedő, Java nyelven implementált ingyenes, nyílt forráskódú keresőmotor (az Apache Software Licence alatt).&lt;/p&gt;A Lucene-ről már 2003 májusában már megjelent egy cikkem, de azóta a könyvtár több változáson ment keresztül, így a cikket is frissítettem, az &lt;a href="http://delfin.unideb.hu/%7Evicziani/pdf/lucene.pdf"&gt;új verzió&lt;/a&gt; letölthető a honlapomon.A következő forráskód megmutatja, hogyan kell egy JavaMail API részét képző üzenetet indexelni (nem teljes részletességgel).
&lt;pre class="brush: java"&gt;public void indexMessages(Message[] messages) {
...
Directory directory = new RAMDirectory();
// Directory directory = FSDirectory.getDirectory("/tmp/testindex");
Analyzer analyzer = new StandardAnalyzer();
IndexWriter writer = new IndexWriter(directory, analyzer, MaxFieldLength.UNLIMITED);
for (Message message : messages) {
 Document document = new Document();
     document.add(new Field("fromAddress", ((InternetAddress) message.getFrom()[0]).getAddress(), Field.Store.YES, Field.Index.NOT_ANALYZED));
     document.add(new Field("fromPersonal", ((InternetAddress) message.getFrom()[0]).getPersonal(), Field.Store.YES, Field.Index.NOT_ANALYZED));
     document.add(new Field("sentDate", DateTools.dateToString(message.getSentDate(), DateTools.Resolution.MINUTE), Field.Store.YES, Field.Index.NOT_ANALYZED));
     document.add(new Field("subject", message.getSubject(), Field.Store.YES, Field.Index.ANALYZED));
     document.add(new Field("size", Integer.toString(message.getSize()), Field.Store.YES, Field.Index.NO));
     if (message.getContent()instanceof String) {
         document.add(new Field("content", (String) message.getContent(), Field.Store.NO, Field.Index.ANALYZED));
     }
     writer.addDocument(document);
}
writer.close();
...
}
&lt;/pre&gt;&lt;p&gt;A kódrészlet először létrehoz egy RAMDirectory, ami az indexet a memóriában tárolja. Majd példányosítja a beépített szabványos feldolgozót (Analyzer), létrehoz egy IndexWriter objektumot. Majd végigiterál az üzeneteken, és mindegyik üzenethez létrehoz egy üres dokumentumot (Document). A dokumentumhoz hozzáadja a különböző mezőket. A tárolt mezőt kereséskor le lehet kérni az eredeti formában a találati listából. Az indexelt mezőre lehet keresni.&lt;/p&gt;&lt;p&gt;A következő kódrészlet megmutatja, hogyan kell keresni.
&lt;/p&gt;&lt;pre class="brush: java"&gt;public void searchMessages(Directory dir, String query) {
 ...
 IndexSearcher s = new IndexSearcher(dir);
 Query q = new QueryParser("content", new StandardAnalyzer()).parse(query);
 TopFieldDocs docs = s.search(q, null, 100, new Sort("sentDate", true));
 for (ScoreDoc scoreDoc : docs.scoreDocs) {
     Document doc = s.doc(scoreDoc.doc);
     System.out.println("Subject: " + doc.get("subject"));
 }
 ... 
}
&lt;/pre&gt;&lt;p&gt;Először egy IndexSearcher objektumot kell példányosítani, melyek konstruktorban egy Directory-t kell átadni. Majd egy Query-t kell létrehozni a szöveges keresési feltétel elemzésével (ez dobhat ParseException kivételt), a QueryParser osztállyal lehetséges. Ennek meg kell adni a keresési feltétel szöveges ábrázolását, az alapértelmezett mezőt és egy feldolgozót. A keresést futtatva egy TopFieldDocs objektumot kapunk vissza, amitől le lehet kérdezni a találatokat reprezentáló ScoreDoc objektumokat a dokumentum azonosítójával és pontszámával.
A dokumentumot az IndexSearcher-től lehet elkérni annak azonosítója alapján, és a dokumentum egy mezőjét pedig a Document.get(String fieldName) metódussal.
&lt;/p&gt;&lt;p&gt;A forráskód magyarázata, és a Lucene-el kapcsolatos rengeteg információ elolvasható a cikkben.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/5780082598515212534/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/01/apache-lucene-keresomotor.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/5780082598515212534'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/5780082598515212534'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/01/apache-lucene-keresomotor.html' title='Apache Lucene keresőmotor'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-906175397810708721</id><published>2009-01-22T00:22:00.003+01:00</published><updated>2010-09-18T00:38:30.410+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Tesztelés'/><title type='text'>Ejb3unit</title><content type='html'>&lt;p&gt;Egyre inkább fenntartásokkal kezelem azokat a rendszereket, ahol az alkalmazás és az operációs rendszer között több köztes réteg (middleware) is elhelyezkedik.&lt;/p&gt;Már egyszerű Java programok írásánál is előjön a JVM, amivel könnyen meg lehet barátkozni, de azért az első időkben nem indult be olyan könnyedén, az appletek elterjedését nagyban gátolta a mérete, telepítésével kapcsolatos nehézségek és inkompatibilitási problémák. De a mai gépeken, valamint a JVM fejlesztésével már elfogadható sebességgel fut, de azért emlékezzünk az időkre, mikor egy több (akár száz) ablakból indítható Delphi vagy Visual Basic alkalmazásunk milyen gyorsan elindult. De az ember megbarátkozik vele az általa nyújtott előnyök miatt, mint a platformfüggetlenség és magas biztonság.
&lt;p&gt;Ha webes alkalmazásokat kell fejlesztenünk, akkor már web konténert kell alkalmaznunk, amikkel szintén viszonylag kevés probléma van, leszámítva a az alkalmazások többszöri újratelepítésekor előforduló java.lang.OutOfMemoryError: PermGen space hibákat, mely azt jelzi, hogy a régi web alkalmazást valami ok miatt nem tudta kitakarítani a memóriából. Igaz ugyan, hogy ez az alkalmazás miatt van, de klasszikus programozási mintákat követve is találkozzunk vele. Érdemes ekkor valamilyen profiler eszközt elővenni.&lt;/p&gt;A következő szint, mikor már a alkalmazásszervert vetünk be, hogy nagyvállalati igényeinket kielégítsük, vagy ágyúval lőjünk verébre. Na ez az a szint, aminek bevezetésén már alaposan el kell gondolkozni, mert nem feltétlenül használjuk ki az alkalmazásszerver előnyeit, de rengeteg hibába ütközhetünk, lásd egy korábbi &lt;a href="http://jtechlog.blogspot.com/2008/12/netbeans-65-s-glassfish-v2-ur2.html"&gt;bejegyzésemben&lt;/a&gt;. Sajnos az alkalmazásszerver gyártók, ahelyett, hogy kijavítanák a hibákat, és egy stabil verzió irányába mennének, vagy nagyon lassan moccannak, vagy annyira az új funkciókra koncentrálnak a nagy versenyben, hogy nincs egy stabil verzió.
&lt;p&gt;A következő szint az integrációs (EAI, SOA) szint, mely újabb szoftver rétegeket vezet be, mint az ESB, service registry, workflow motor az orchestration megvalósítására, valamint a rules engine-ek. Ezt is lehetne jól csinálni, de sajnos mivel ekkora infrastruktúra bevezetésére csak nagy cégek, telekom szolgáltatók, bankok, stb. képesek, az egész a szoftver licensz eladás lobbiba
torkollik, és általában nem egy pilot projektre támaszkodva, a megfelelőség és tudás alapján döntenek. Másik probléma vele, hogy mind a grafikusan megrajzolható üzleti folyamatok, mind a szabály motorok bevezetése egy (nem mindig) leplezett célt szolgál, tudjuk az üzleti folyamatainkat fejlesztői tudás nélkül is módosítani, továbbfejleszteni. Ez egy olyan infrastruktúrával jár, mely fenntartása, üzemeltetése sokkal költségesebb, és a fejlesztésnél még magasabb szintű technológiai tudás kell, ami ritkább és drágább. Azaz költség megtakarításból költség növelés lesz.&lt;/p&gt;És ezt még bonyolítja az alkalmazáson belüli rétegek és keretrendszerek (nem egy esetben felesleges) használata.
&lt;p&gt;Tapasztalva ezen magas szintű eszközök által biztosított fejlesztési folyamat (compile, package, deploy) lassúságát fordult a figyelmem a konténeren kívüli tesztelés felé, hiszen így a fejlesztett funkciók gyorsabban futtathatóak és tesztelhetőek.
Alapvetően nem hiszek a Test Driven Development (TDD) fejlesztésben egyszerű, pl. CRUD alkalmazások fejlesztésekor, viszonylag egyszerű webes rendszereknél. Nagyobb létjogosultsága lehet pl. bonyolult üzleti folyamatok, valamint szélesebb körben terjesztett 3rd party eszközök fejlesztésekor. Nem tartom szükségesnek a 100%-os lefedettségi teszt elérését sem, az accessor metódusok tesztelését, stb.&lt;/p&gt;Viszont a különböző funkciók konténer nélküli indítására, tesztelésére, amire a JUnit-os idők előtt esetleg gyorsan összetákoltam egy main függvényt, arra most javasolt egy újrafelhasználható JUnit teszt esetet írni.
&lt;p&gt;Az EJB3 komponensek tesztelésére különböző eszközök állnak a rendelkezésünkre. Egyik lehetőség natív JUnit kóddal, esetleg Mock objektumokkal való tesztelés, amikor a dependency injection-t mi oldjuk fel. De használhatunk valamilyen segítséget is erre, ilyen pl. a külön is, alkalmazásszerveren kívül futtatható, beágyazható EJB konténer, mint az &lt;a href="http://openejb.apache.org/"&gt;OpenEJB&lt;/a&gt;, vagy a &lt;a href="http://docs.jboss.org/ejb3/embedded/embedded.html"&gt;JBoss Embeddable EJB 3.0&lt;/a&gt;. Másik megoldás a cikkem főszereplője, az &lt;a href="http://ejb3unit.sourceforge.net/index.html"&gt;Ejb3unit&lt;/a&gt;, mely egy
JUnit-ra épülő EJB-k és entitások (entity bean-eknek nevezi, szerintem tévesen) tesztelését támogató keretrendszer.&lt;/p&gt;Nézzünk is egy példát erre. Képzeljük el, hogy van egy banki alkalmazásunk két session bean-nel. Az egyikkel (BankEJB) lehet számlát ügyfelet felvenni, számlát nyitni, számlát lekérdezni, stb., a másik session bean (TransferEJB) végzi az átutalásokat az előbbi bean meghívásával. Az alkalmazásban szerepel két entitás is 1:n kapcsolatban (az egyszerűség kedvéért), az ügyfél (Client) és a számla (Account). A példa bemutatja a két távoli üzleti interfészt, de a bean osztályok (TransferEJBBean és ebből a @EJB annotációval hivatkozott BankEJBBean) és a JPA entitások megvalósítását az olvasó képzeletére bízom. A BankEJB távoli üzleti interfész:
&lt;pre class="brush: java"&gt;@Remote
public interface BankEJB {

 public Client createClient(String name);
  
 public Account openAccount(Client client, long balance);

 public void credit(long accountId, long balance);

 public Account findAccountById(long accountId);

  ...
}
&lt;/pre&gt;A TransferEJB távoli üzleti interfész:
&lt;pre class="brush: java"&gt;@Remote
public interface TransferEJB {

 public void doTransfer(long srcAccountId, long destAccountId, long amount);
  
 ...
}
&lt;/pre&gt;A bean-ek teszteléséhez a következő teszt esetet készíthetjük el:
&lt;pre class="brush: java"&gt;public class TransferEJBBeanTest extends BaseSessionBeanFixture {

   private static final Class[] usedBeans = {Account.class, Client.class};

   public TransferEJBBeanTest() {
       super(TransferEJBBean.class, usedBeans);
   }

   public void testTransfer() throws NamingException {
       TransferEJB transferEJB = (TransferEJB) getBeanToTest();

       Context c = new InitialContext();
       BankEJB bankEJB = (BankEJB) c.lookup("ejb/BankEJBBean");

       getEntityManager().getTransaction().begin();
       Client client = bankEJB.createClient("Client");

       Account srcAccount = bankEJB.openAccount(client.getId(), 1000);
       Account destAccount = bankEJB.openAccount(client.getId(), 2000);

       transferEJB.doTransfer(src.getId(), dst.getId(), 500);

       srcAccount = bankEJB.findAccountById(src.getId());
       destAccount = bankEJB.findAccountById(dst.getId());

       assertEquals(srcAccount.getBalance(), 500);
       assertEquals(destAccount.getBalance(), 2500);

       getEntityManager().getTransaction().rollback();
   }
}
&lt;/pre&gt;A példában látható, hogy a BaseSessionBeanFixture osztályt kell kiterjeszteni, és az abban definiált konstruktort kell meghívni a tesztelendő bean osztályával és a tesztelendő entitásokkal. Nagyon fontos, hogy a többi bean-t JNDI-ből lehet lekérni. Fontos, hogy a tranzakciót manuálisan kell indítani. A rollback a végén azért szerepel, mert így a teszt esetnek semmi mellékhatása nem lesz, így nem marad semmi az adatbázisban. Az Ejb3unit automatikusan elvégzi a bean-ek példányosítását, a dependency injection-t és a perzisztenciát. Ezt konfigurálni a classpath-ban lévő ejb3unit.properties állománnyal lehet, melynek tartalma:
&lt;pre&gt;ejb3unit.inMemoryTest=true
ejb3unit.show_sql=true

ejb3unit_jndi.1.isSessionBean=true
ejb3unit_jndi.1.jndiName=ejb/BankEJBBean
ejb3unit_jndi.1.className=bankejb.beans.BankEJBBean

ejb3unit_jndi.2.isSessionBean=true
ejb3unit_jndi.2.jndiName=ejb/TransferEJBBean
ejb3unit_jndi.2.className=bankejb.beans.TransferEJBBean

ejb3unit.loadPersistenceXML=true
ejb3unit.persistenceUnit.name=BankEJB
&lt;/pre&gt;&lt;p&gt;Ennek pontosságára figyeljünk, mert a hibaüzenet sajnos nem mindig nyomravezető. Ebben az esetben egy memóriában futó relációs adatbázis (Derby) indul be, és az SQL parancsokat is képes naplózni. Utána a session bean-ek konfigurációja történik (osztály neve, session bean-e, JNDI neve), majd meg lehet adni, hogy töltse be a persistence.xml állományt is, megadva az abban definiált persistence unit nevét.&lt;/p&gt;&lt;p&gt;A jndi a classpath-ban lévő jndi.properties állománnyal konfigurálható:
&lt;/p&gt;&lt;pre&gt;java.naming.factory.initial=com.bm.jndi.MemoryContextFactory
&lt;/pre&gt;&lt;p&gt;Ekkor a JNDI fa a memóriában fog elhelyezkedni.&lt;/p&gt;&lt;p&gt;A példát ha NetBeans-ben akarjuk kipróbálni, akkor figyelni kell arra, hogy a test környvtárban elhelyezett két (ejb3unit.properties, jndi.properties) állományt egyszerű futtatás esetén nem másolja a build/test/classes könyvtárba, így nem fogja azokat megtalálni. Érdekes, hogy a nbproject/build-impl.xml fájlban a -do-compile-test target-ben benne van, de a -do-compile-test-single target-ben viszont nincs, ezt pótolva futtatható a teszt esetünk.&lt;/p&gt;Ennél az Ejb3unit többet is tud, pl. entitások automatikus példányosítását, véletlen adatokkal való feltöltését, perzisztálását és visszaolvasását, vagy az adatbázis feltöltését CSV fájl alapján az entitásokon keresztül.
&lt;p&gt;Az Ejb3unit egyik általam felfedezett hiányossága pl., hogy a teszt eseteinkben nem használhatunk DI annotációkat. Erre a JTechnics blogban láttam &lt;a href="http://jtechnics.anzix.net/tag/ejb3-test/"&gt;példát&lt;/a&gt;, de sajnos csak a &lt;a href="http://unitils.org/"&gt;Unitils&lt;/a&gt; keretrendszerhez.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/906175397810708721/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/01/ejb3unit.html#comment-form' title='4 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/906175397810708721'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/906175397810708721'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/01/ejb3unit.html' title='Ejb3unit'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>4</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4256004315988976427</id><published>2009-01-19T01:43:00.008+01:00</published><updated>2010-09-18T00:40:19.661+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Java SE'/><title type='text'>A Hashtable már nem menő</title><content type='html'>&lt;p&gt;Kedves kollégáim ihletésére született ez a bejegyzés, nem az első, akiket jól belinkelek ide, amint hajlandóak végre blogot indítani.&lt;/p&gt;
&lt;p&gt;Az blog bejegyzés tartalma, hogy mi a különbség a Hashtable és a HashMap között.
&lt;p&gt;Az eredeti ötlet onnan jött, hogy a Masterfield Oktatóközpont indított egy új blogot, melyen egy &lt;a href="http://masterfield.blog.hu/2008/12/05/hogyan_hasznaljuk_hatekonyan_a_java_hashtable_osztalyat"&gt;bejegyzés&lt;/a&gt; arról szól, hogyan használjuk hatékonyan a Hashtable-t.&lt;/p&gt;
&lt;p&gt;Ezen kicsit meglepődtem, hiszen a Java 1.2-es verziója óta, amikor is bevezették a &lt;a href="http://java.sun.com/docs/books/tutorial/collections/index.html"&gt;collections framework-öt&lt;/a&gt;, én csak HashMap-et használok. De miért, milyen technológiai megfontolások állhatnak ennek a hátterében.&lt;/p&gt;
&lt;p&gt;Mindkét osztály implementálja a Map interfészt, de nézzük meg a különbségeket:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;A legfőbb különbség, hogy amíg a Hashtable osztály szinkronizált, addig a HashMap osztály nem
&lt;/li&gt;&lt;li&gt;A HashMap engedélyezi null értékek használatát is
&lt;/li&gt;&lt;li&gt;A Hashtable nem követi a camelcase elnevezési konvenciót :)
&lt;/li&gt;&lt;li&gt;A Hashtable metódusai nincsenek ellátva a final módosítószóval, ahogy Bruce Eckel a &lt;a href="http://www.mindview.net/Books/TIJ/"&gt;Thinking in Java&lt;/a&gt; könyvében rámutat&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Funkcionalitás szempontjából foglalkozzunk csak az első különbséggel. A collections framework azt mondja, hogyha a collections framework osztály példányait szinkronizálni akarjuk, akkor használjuk a Collections osztály metódusait, az adott példában a Collections.synchronizedMap statikus metódust.&lt;/p&gt;Van-e különbség a Hashtable példányunk és a szinkronizált HashMap között? A válasz, hogy nincs, hiszen a két osztály működése nagyon hasonló, ez az osztálykönyvtár forráskódjából hamar kiderül. Sokan tesztelték, de az előző állításból is levezethető, hogy szignifikáns performancia különbség sincs a kettő között.
&lt;p&gt;Akkor mi alapján válasszunk, döntsünk? Semmiképp ne a funkcionalitás alapján, mert ott nincs különbség. De mivel minden dokumentáció és könyv (a collections framework tutorial-ja, a Sun-os SCJP vizsgára felkészítő, és Bruce Eckel könyve is) a Hashtable-t legacy osztálynak minősíti, ezért kerüljük a használatát, hátha előbb-utóbb módosítás következik be kettőjük viszonyában. Persze feltehetőleg egyhamar nem fogják eltávolítani, depracated-dé tenni, hiszen annyi program használja. A különös, hogy erről a JavaDoc semmit nem ír.&lt;/p&gt;Itt érdemes még megemlíteni, hogy a collections framework vezette be az Enumeration helyett az Iterator osztályt is. A Hashtable osztály elemein mindkét osztály példányával végigmehetünk, lásd a kódot. A values().iterator() un. fail-fast iterator-t ad vissza, ami azt jelenti, hogy amennyiben nem az iterator módosító metódusain keresztül módosítjuk a Hashtable-t, kivétel fog keletkezni. Az Enumeration amúgy szintén egy ilyen maradványosztály a Java 1.0, 1.1 időkből, mely annyiban különbözik az Iterator-tól, hogy hosszabbak a metódusnevei, valamint nem rendelkezik egy remove() metódussal. Ezt viszont már megemlíti a JavaDoc, hogy az Iterator-t használjuk.&lt;/p&gt;
&lt;pre class="brush: java"&gt;import java.util.ConcurrentModificationException;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import junit.framework.Assert;
import org.junit.Test;

public class HashTest {

  @Test
  public void hashtableEnumeration() {
      Hashtable&lt;string, string=""&gt; hashtable = new Hashtable&lt;string, string=""&gt;(){{
          put("key0", "value");
      }};
      Enumeration enumeration = hashtable.elements();
      hashtable.put("key1", "value1");
      Assert.assertEquals("value1", enumeration.nextElement());
  }

  @Test(expected=ConcurrentModificationException.class)
  public void hashtableIterator() {
      Hashtable&lt;string, string=""&gt; hashtable = new Hashtable&lt;string, string=""&gt;(){{
          put("key0", "value");
      }};
      Iterator iterator = hashtable.values().iterator();
      hashtable.put("key1", "value1");
      // ConcurrentModificationException kivetelt valt ki
      iterator.next();
  }
}
&lt;/pre&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/4256004315988976427/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/01/hashtable-mr-nem-men.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4256004315988976427'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4256004315988976427'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/01/hashtable-mr-nem-men.html' title='A Hashtable már nem menő'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3999068897644214024</id><published>2009-01-13T12:36:00.005+01:00</published><updated>2010-09-18T00:41:07.871+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Naplózás'/><category scheme='http://www.blogger.com/atom/ns#' term='Java EE'/><category scheme='http://www.blogger.com/atom/ns#' term='Spring'/><title type='text'>Naplózás webes környezetben, Log4J-vel, Spring-gel</title><content type='html'>&lt;p&gt;Az előző bejegyzésemhez kapcsolódnak a következő elvárásaim egy Log4J alapú naplózással kapcsolatban:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Az alkalmazást a verziókezelővel checkout-olva, és futtatva azonnal legyen egy viszonylag részletes naplózás, mindenféle konfiguráció nélkül. Ahhoz, hogy a fejlesztőkörnyezet konzolján is megjelenjen, ennek a konzolra kell mennie.
&lt;/li&gt;&lt;li&gt;A naplózást az alkalmazáson kívül is lehessen konfigurálni, így minden környezetre feltelepíthető ugyanaz az EAR, WAR állomány, nem az alkalmazást kell a naplózáshoz módosítani.&lt;/li&gt;&lt;li&gt;Egy default naplózás legyen az alkalmazásban is, ha nincs az alkalmazáson kívül konfigurációs állomány, akkor is legyen valamilyen szintű naplózás.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Ezen követelmények megvalósításához először tegyünk egy default konzolra naplózó log4j.properties konfig állományt az alkalmazásunkba, lehetőleg ne a CLASSPATH-ra, hogy ne zavarjon be. A WEB-INF könyvtár megfelelő lehet. Az állomány tartalma pl. a következő lehet:&lt;/p&gt;&lt;pre&gt;
log4j.rootLogger=WARN, A1

log4j.appender.A1=org.apache.log4j.ConsoleAppender

log4j.appender.A1.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%4d{dd MMM yyyy HH:mm:ss,SSS} %-5p - %c: %m\n

log4j.category.jtechlog=DEBUG
&lt;/pre&gt;&lt;p&gt;Ezután ServletContextListener-t definiáljunk, mely a naplózást inicializálni fogja. Valamint implementáljunk egy ListLog4jWebConfigurer osztályt, mely a paraméterként átadott URL listát végignézi, és amelyik URL-en először talál egy konfigurációs állományt, azt tölti be.&lt;/p&gt;&lt;p&gt;A ListLog4jConfigListener osztály:&lt;/p&gt;&lt;pre class="brush: java"&gt;
public class ListLog4jConfigListener implements ServletContextListener {

    public void contextInitialized(ServletContextEvent event) {
        ListLog4jWebConfigurer.initLogging(event.getServletContext());
    }

    public void contextDestroyed(ServletContextEvent event) {
        ListLog4jWebConfigurer.shutdownLogging(event.getServletContext());
    }
}
&lt;/pre&gt;&lt;p&gt;A ListLog4jWebConfigurer osztály:&lt;/p&gt;&lt;pre class="brush: java"&gt;
public class ListLog4jWebConfigurer {

    public static final String CONFIG_LOCATION_PARAM = "log4jConfigLocation";

    public static void initLogging(ServletContext servletContext) {
        String locationParams = servletContext.getInitParameter(CONFIG_LOCATION_PARAM);

        if (locationParams != null) {
            String[] locations = locationParams.split("\\s+");
            for (String location : locations) {
                try {
                    if (!ResourceUtils.isUrl(location)) {
                        // Resolve system property placeholders before resolving real path.
                        location = SystemPropertyUtils.resolvePlaceholders(location);
                        location = WebUtils.getRealPath(servletContext, location);
                    }

                    File file = ResourceUtils.getFile(location);
                    if (!file.exists()) {
                        throw new FileNotFoundException(location);
                    }

                    servletContext.log("Initializing log4j from [" + location + "]");
                    Log4jConfigurer.initLogging(location);
                    
                    break;

                } catch (FileNotFoundException ex) {
                    servletContext.log("Cannot initializing log4j from [" + location + "]");
                }
            }
        }

    }

    public static void shutdownLogging(ServletContext servletContext) {
        Log4jConfigurer.shutdownLogging();
    }
}
&lt;/pre&gt;&lt;p&gt;A kódban látható, hogy végigiterál az URL-eken, kiírja a ServletContext log metódusával, hogy hol nem, és hol talált konfigurációs állományt. Az is látható, hogy a system property placeholder-ek cseréjét is elvégzi, így a web.xml-ben a következőképp konfigurálható:&lt;/p&gt;&lt;pre class="brush: xml"&gt;
&amp;lt;context-param&amp;gt;
    &amp;lt;param-name&amp;gt;log4jConfigLocation&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;
        file:${catalina.home}/conf/jtechlog.log4j.properties
        /WEB-INF/log4j.properties
    &amp;lt;/param-value&amp;gt;
&amp;lt;/context-param&amp;gt;
&amp;lt;listener&amp;gt;
    &amp;lt;listener-class&amp;gt;hu.kdiv.common.web.logging.ListLog4jConfigListener&amp;lt;/listener-class&amp;gt;
&amp;lt;/listener&amp;gt;
&lt;/pre&gt;&lt;p&gt;Így először feloldja a ${catalina.home} placeholder-t a Tomcat telepítési könyvtárára (pl. /opt/Tomcat6), majd megvizsgálja, hogy ott létezik-e a megadott fájl. Ha létezik, betölti, ha nem létezik, akkor betölti az alkalmazásból a WEB-INF könyvtárból&lt;/p&gt;&lt;p&gt;Ezzel megoldottuk, hogy mind az IDE-ből való futtatáskor, mind a szerveren legyen egy alapértelmezett naplózás, ami a konzolra ír, de amennyiben környezetenként (pl. teszt, éles) más és más naplózást akarunk beállítani, csak el kell helyeznünk a Tomcat conf könyvtárába egy jtechlog.log4j.properties állományt. És ehhez az alkalmazást nem kell módosítanunk.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/3999068897644214024/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/01/naplzs-webes-krnyezetben-log4j-vel.html#comment-form' title='3 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3999068897644214024'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3999068897644214024'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/01/naplzs-webes-krnyezetben-log4j-vel.html' title='Naplózás webes környezetben, Log4J-vel, Spring-gel'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>3</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3326979225522262721</id><published>2009-01-13T00:15:00.007+01:00</published><updated>2010-12-24T12:20:06.657+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Servlet'/><category scheme='http://www.blogger.com/atom/ns#' term='IDE'/><category scheme='http://www.blogger.com/atom/ns#' term='Java EE'/><category scheme='http://www.blogger.com/atom/ns#' term='Tomcat'/><title type='text'>JNDI nevek Tomcat alatt</title><content type='html'>&lt;p&gt;Egy új projekt létrehozásakor a következő irányelveket próbálom megvalósítani:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Az alkalmazás az verziókezelőből (már kizárólag Subversion) checkout-olva azonnal fordítható legyen, lehetőleg platformfüggetlen módon, parancssorból. Erre gyakran lehet szükség, ha csak aprót akarunk változtatni, és nem akarjuk elindítani az IDE-t, vagy egy szerver áll rendelkezésünkre grafikus felület nélkül. Jól jöhet continous integration esetén is.
&lt;/li&gt;&lt;li&gt;Az alkalmazás fejlesztéséhez a lehető leggyorsabban hozzá lehessen kezdeni, azaz a checkout-olt projekt azonnal megnyitható, és futtatható legyen legalább egy fejlesztőeszközben. Ez jól jön, ha új fejlesztő áll csatasorba, vagy gép újrainstallálása után.
&lt;/li&gt;&lt;li&gt;A projektet úgy elkészíteni, hogy fejlesztőeszköz független legyen sokkal kisebb rossz, mint egy fejlesztőt egy általa nem preferált IDE-re kényszeríteni.
&lt;/li&gt;&lt;li&gt;Lehetőleg ugyanazon állományt lehessen telepíteni a különböző környezetekre, pl. fejlesztői, teszt és éles. A környezetfüggő beállítások az alkalmazáson kívül helyezkedjenek el. Ezzel kivédhető az, hogy különböző build folyamataink legyenek a különböző környezetekre, vagy a build után kelljen az alkalmazást még módosítanunk.&lt;/li&gt;&lt;/ul&gt;Egyszerű követelményeknek tűnnek, mégis gyakran látok ellenpéldát:
&lt;ul&gt;&lt;li&gt;Sajnos több helyen még nem ismerik a verziókezelő fogalmát, a kódbázis még mindig megosztott könyvtárban tárolt.
&lt;/li&gt;&lt;li&gt;Az alkalmazásnak rengeteg külső függősége van. Volt, ahol egy fejlesztő munkába állása, fejlesztői környezetének kialakítása több napot (!) vett igénybe, a gép beszerzésétől kezdve a különböző környezetek hozzáférésének megszerzéséig. A különböző "middleware" szoftverek felinstallálásával is rengeteg idő mehet el.&lt;/li&gt;&lt;li&gt;A fejlesztés fejlesztőeszközhöz van kötve.&lt;/li&gt;&lt;li&gt;A build folyamat vagy elágazik, vagy a build előtt figyelni kell arra, hogy a beállítások megfelelőek legyenek az adott környezetre, és úgy fusson le a build folyamat.&lt;/li&gt;&lt;li&gt;Az alkalmazáson a build folyamat után a fejlesztőnek, rosszabb esetben az adminisztrátornak még módosítania kell, pl. a WAR, EAR állományban lévő properties állományt (!) kell szerkesztgetni.&lt;/li&gt;&lt;/ul&gt;Szerencsére a célkitűzések megvalósítására a NetBeans fejlesztőeszköz, az Ant build tool és a Tomcat konténer elegendő megoldást biztosít.
&lt;ul&gt;&lt;li&gt;A NetBeans build folyamata Ant alapú, így ugyanaz a folyamat fut le fejlesztéskor az alkalmazás IDE-n belüli futtatásakor és build kiadáskor is.&lt;/li&gt;&lt;li&gt;A build kiadása fejlesztőeszközből és parancssorból is történhet.&lt;/li&gt;&lt;li&gt;A NetBeans a 6.1-től kezdve lehet könyvtárakat és JAR állományokat abszolút és relatív útvonallal is megadni. Az előző verziókban ugyan abszolút névvel tárolta, de ha a verziókezelőbe nincs betéve a nbproject\private könyvtára (ez frissebbnél is javasolt), akkor relatív nevekkel próbálkozik, és a build folyamat menni fog parancssorból is.
&lt;/li&gt;&lt;li&gt;A NetBeans projekt szerkezete nem elvarázsolt, az Eclipse meg kellően konfigurálható ahhoz, hogy ezt betöltse.&lt;/li&gt;&lt;li&gt;A Tomcat is tartalmaz egy csak olvasható JNDI InitialContext implementációt, melynek segítségével a web alkalmazásonként definiált JNDI fához tudunk hozzáférni. Erről fog szólni ez a bejegyzés.
&lt;/li&gt;&lt;/ul&gt;Sajnos sok projektben, de az Interneten található példa alkalmazásokban is gyakran látom, hogy az alkalmazások, a környezeti beállításokat, és a erőforrásokat az alkalmazáson belüli properties, vagy XML konfigurációs állományokban tárolják. Így minden telepítés előtt gondoskodni kell arról, hogy azok megfelelően át legyenek írva. Ilyenek pl. adatbázis hozzáférések (pl. jdbc.properties), vagy elérési útvonalak, beégetett e-mail címek, stb.
Ennek kivédésére támogatja a Java EE szabvány annyira a névszolgáltatásokat, a JNDI használatát. De nem csak alkalmazásszerverekben, hanem a közkedvelt Tomcat web konténerben is elérhető ez a szolgáltatás.
Tegyük fel, hogy szükségünk van egy adatbázis kapcsolatra, egy kapcsolatra a mail server felé, és egy elérési útvonalra.
Ezeket ne az alkalmazásunkba konfiguráljuk, hanem az alkalmazáson kívül, a web konténerben. Ezt a $CATALINA_BASE/conf/server.xml állományban a &amp;lt;GlobalNamingResources&amp;gt; XML elem alatt tudjuk megtenni, a következőképpen. A példában nézzük, hogy kell egy MySQL adatbázishoz kapcsolódni.&lt;pre class="brush: xml"&gt;&amp;lt;Resource name="JTechLogDS" auth="Container" type="javax.sql.DataSource"
        maxActive="100" maxIdle="30" maxWait="10000"
        username="jtechlog" password="jtechlog12" driverClassName="com.mysql.jdbc.Driver"
        url="jdbc:mysql://localhost:3306/jtechlog?autoReconnect=true"/&amp;gt;

&amp;lt;Resource name="JTechLogMailSession" auth="Container" type="javax.mail.Session" mail.smtp.host="mail.jtechlog.hu" /&amp;gt;

&amp;lt;Environment name="JTechLogPath" type="java.lang.String" value="/opt/jtechlog" /&amp;gt;
&lt;/pre&gt;&lt;p&gt;Ekkor ezek a nevek még csak globálisan vannak definiálva, ahhoz, hogy ezek a webes komponensekből (pl. Servlet, JSP) is lokális névvel elérhetőek legyenek, vagy az alkalmazás META-INF könyvtárában lévő Tomcat specifikus context.xml konfigurációs állományban kell ezeket definiálni, vagy a web.xml-ben kell ezeket megadni. Nézzük először az első megoldást:&lt;/p&gt;&lt;pre class="brush: xml"&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;Context path="/jtechlog" &amp;gt;
&amp;lt;ResourceLink global="JTechLogDS" name="jdbc/JTechLogLocalDS" type="javax.sql.DataSource"/&amp;gt;
&amp;lt;ResourceLink global="JTechLogMailSession" name="mail/JTechLogLocalMailSession" type="javax.mail.Session"/&amp;gt;
&amp;lt;ResourceLink global="JTechLogPath" name="JTechLogLocalPath" type="java.lang.String"/&amp;gt;
&amp;lt;/Context&amp;gt;
&lt;/pre&gt;&lt;p&gt;Ezzel ekvivalens megoldás, ha a logikai neveket a WEB-INF/web.xml állományunkban definiáljuk a resource-ref XML elem alatt.&lt;/p&gt;Az így, a JNDI-be regisztrált objektumokhoz Java-ból a következő módon tudunk hozzáférni:&lt;pre class="brush: xml"&gt;Context ctx = new InitialContext();

DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/JTechLogLocalDS");

Connection conn = ds.getConnection();

Session mailSession = (Session) ctx.lookup("java:comp/env/mail/JTechLogLocalMailSession");

String path = (String) ctx.lookup("java:comp/env/JTechLogLocalPath");
&lt;/pre&gt;&lt;p&gt;Látható, hogy a forráskódban a logikai neveket definiáljuk, a web konténer server.xml fájljába a konkrét értékeket, és az alkalmazásban szereplő context.xml konfigurációs állományban kötjük össze ezeket. A lokális nevek elé mindig elé kell írni az ENC előtagot, a java:comp/env szöveget. A resource-ref használatakor a res-ref-name elemben ezt nem kell kiírni, a konténer automatikusan elé teszi.
&lt;/p&gt;&lt;p&gt;Ezáltal megoldottuk azt, hogy mivel különböző környezetekben a Tomcat server.xml állománya más konfigurációkat tartalmaz, az alkalmazásunkat nem kell módosítani, és az összes környezetre telepíthető lesz.&lt;/p&gt;&lt;p&gt;A DataSource objektum egy factory, mely az adatbázishoz való kapcsolódás paramétereit tartalmazza, és Connection objektumokat gyárt a getConnection metódusának meghívásakor. Ez meg lehet valósítani úgy is, hogy a kapcsolatokat egy példányfarmon (connection pool) tárolja, valamint úgy is, hogy a visszaadott kapcsolat részt vehessen elosztott tranzakcióban. Az adatbázis hozzáférésnek ez a preferált módja szemben a DriverManager használatával. A példában láttuk, hogy mail session-t, String-et lehetett tárolni, de lehetőség van egyéb egyszerű osztály példányainak ilyen módon való konfigurálására, JMS erőforrások definiálására, sőt saját objektum példányokat gyártó factory-kat is implementálhatunk.&lt;/p&gt;&lt;p&gt;Link: &lt;a href="http://tomcat.apache.org/tomcat-6.0-doc/jndi-resources-howto.html"&gt;Tomcat 6.0 JNDI Resources HOW-TO&lt;/a&gt;.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/3326979225522262721/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/01/jndi-nevek-tomcat-alatt.html#comment-form' title='5 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3326979225522262721'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/3326979225522262721'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/01/jndi-nevek-tomcat-alatt.html' title='JNDI nevek Tomcat alatt'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>5</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6392476049818230384</id><published>2009-01-10T00:06:00.007+01:00</published><updated>2010-09-18T00:42:13.080+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Java EE'/><category scheme='http://www.blogger.com/atom/ns#' term='Tomcat'/><title type='text'>JNDI nevek EJB környezetben</title><content type='html'>&lt;p&gt;Nagyvállalati környezetben gyakran lehet hallani a név- és címtárszolgáltatásokról (naming and directory services), de egy átlagos felhasználó is nap mint nap találkozik velük. A név egy egyszerű címtárszolgáltatás, mely név és érték párokat tartalmaz (általában hierarchikus formában). Egy bonyolultabb címtárszolgáltatás egy névhez több, akár különböző típusú információt is képes eltárolni. Ilyen szolgáltatások pl. az ip-címek és domain-nevek összerendelését végző DNS, a Windows Active Directory, OpenLDAP (ne felejtsük el, hogy az LDAP nem egy konkrét termék, hanem címtárszolgáltatás elérésére szolgáló protokoll), a CORBA névszolgáltatása, Java környezetben az RMI registry, stb.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;A címtárszolgáltatás lehetővé teszi egy névhez érték hozzárendelését (un. bind művelet), név törlését, értékek módosítását, valamint név alapján az érték lekérését (lookup művelet), és keresési, szűrési lehetőséget. A címtárszolgáltatásban olyan értékeket érdemes eltárolni, melyet egy rendszer vagy adminisztrátor definiál, és több rendszer is használ (kliens). Ezeket az értékeket így nem kell minden rendszernél külön-külön eltárolni, hanem mindig a szolgáltatástól lehet elkérni. Ezért az érték módosításkor nem kell az összes klienst átírni, konfigurálni, a szolgáltatásban tárolt érték átírásától kezdve az összes kliens az új értéket fogja használni. Ezért ilyen szolgáltatások és az adatbázisok közötti legnagyobb különbség, hogy az előbbiekben ritka a módosítás művelet, és nagyon gyakori a lekérdezés.&lt;/p&gt;&lt;p&gt;A Java világban a JNDI API (Java Naming and Directory Interface API) használható név- és címtárszolgáltatások elérésére. A JDBC-hez nagyon hasonló, hiszen ez is egy API-t deklarál, alatta a megvalósítás cserélhető a JNDI SPI-t (Service Provider Interface) megvalósító provider-ek használatával, a JDBC driver-rel analóg módon. A JNDI is már a Java SE-ben megtalálható.&lt;/p&gt;&lt;p&gt;A Java EE az első verzióktól kezdve jelentősen támaszkodik a névszolgáltatásra. Minden egyes EJB komponens kap egy egyedi nevet, mellyel az alkalmazásszerver beregisztrálja a névszolgáltatásba. Ezen kívül a külső erőforrásokat is egy JNDI névvel kell definiálni az alkalmazásszerver adminisztrációjakor, és a különböző komponensek ezen a néven tudják ezeket elérni. Ilyen erőforrások pl. a relációs adatbázisok eléréséhez használt DataSource, az e-mail küldésére használható Session, URL, az EJB komponensek környezeti bejegyzései (environment entries), az aszinkron üzenetkezelésre szolgáló Connection Factory és Destination leszármazottak (Queue, Topic), valamint bizonyos JPA fogalmak (EntityManagerFactory - persistence unit, EntityManager - persistence context), JCA fogalmak. Így ha változik pl. az adatbázis címe, akkor csak az adminisztrációs felületen kell módosítanunk, a programot nem kell változtatni (sem a forráskódot, sem programon belüli konfigurációs állományt), hiszen ott csak JNDI név szerepel, a kapcsolódási paraméterek az alkalmazásszerverben vannak konfigurálva. Ezek a névszolgáltatásokban név (String), és az előbb említett Java osztályok példány párokként jelennek meg.&lt;/p&gt;&lt;p&gt;Ezen példányokhoz a komponensek a JNDI környezetükön keresztül tudnak hozzáférni, mely a javax.naming.Context interfész egy példánya. A JNDI névszolgáltatással a kapcsolatot az InitialContext objektum példányosításával tudjuk felvenni. A névszolgáltató elérési paramétereit a következők szerint állapítja meg:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Az InitialContext konstruktorában paraméterként átadott Properties objektum alapján&lt;/li&gt;&lt;li&gt;Amennyiben paraméter nélküli konstruktort alkalmazunk, úgy a rendszer változók (system properties), vagy applet esetén az applet paraméterek alapján&lt;/li&gt;&lt;li&gt;A classpath-ban található jndi.properties állomány alapján&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Ezen beállítások név érték párokban tartalmazzák a névszolgáltatás hozzáférésének paramétereit, pl. a névszolgáltató url-jét, a Context objektumot létrehozó Factory osztály FQCN (fully qualified class name - osztály minősített) nevét, biztonsági beállításokat, stb. Ezek közül a leggyakoribbaknak (, mivel nem standardak) a nevük megtalálhatóak a Context interfészben konstansként.&lt;/p&gt;&lt;p&gt;Amennyiben egy komponens tehát egy erőforrásra, vagy egy másik komponensre referenciát akar szerezni, létrehoz egy Context objektumot az InitialContext példányosításával, és a lookup művelettel lekéri név alapján az érték, az objektum referenciát. Sokak számára ismerős lehet a kód:&lt;/p&gt;&lt;pre class="brush: java"&gt;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
...
try {
 Context ctx = new InitialContext();
 DataSource ds = (DataSource) ctx.lookup("jdbc/JTechLogDS");
} catch (NamingException e) {
   LOGGER.error("Cannot lookup database connection.", e);
}

&lt;/pre&gt;&lt;p&gt;Itt nem adtunk meg az InitialContext-nek paramétereket, ugyanis az alkalmazásszerverek jar-jában általában van egy jndi.properties, mely a lokálisan futó alkalmazásszerverhez való kapcsolódást biztosítják.&lt;/p&gt;&lt;p&gt;A JNDI nevek amint a példában is láthatóak könyvtár struktúrába szervezhetőek. Erre nincs szabvány, csak ajánlás, méghozzá a DataSource-okat a jdbc könyvtárba, az EJB-ket a beans könyvtárba, a mail session-öket a mail könyvtárba, és a JMS connection factory-t és destination-öket a jms könyvtárba.&lt;/p&gt;&lt;p&gt;A problémák az EJB komponensen körül kezdődnek, ugyanis az enterprise alkalmazás telepítésekor ugyan az EJB konténer bejegyzi a névszolgáltatásba az EJB-ket, de ezek a nevek (un. globális nevek) nem standardak, a Java EE specifikációban nincsenek deklarálva, alkalmazásszerverenként eltérhetnek. Ezért amennyiben egy alkalmazás kliens, vagy egy másik EJB referenciát akar rá szerezni a lookup művelet segítségével, az alkalmazásunk alkalmazásszerver függő lesz, és elvesztjük a portabilitást. Hogy mik legyenek a globális nevek, azt általában egy alkalmazásszerver függő telepítés leíróban is meg tudjuk adni.&lt;/p&gt;&lt;p&gt;Másik hátránya, hogy a szép üzleti logikánk keveredik az infrastruktúrát kezelő kóddal, hiszen amennyiben szükségünk van egy EJB komponensre vagy egy erőforrásra, ilyen kódot kell alkalmaznunk. Ennek feloldására találták ki a service locator J2EE design pattern-t, mely minden komponens vagy erőforrás JNDI-ből való lekérdezésére egy külön metódust biztosít, mely már cast-olva adja vissza a megfelelő példányt.&lt;/p&gt;&lt;p&gt;Az első problémát felismerve vezették be a ENC-t (environment naming context), mely komponensenként (EJB komponens, web alkalmazás, application client, és applet) biztosít egy JNDI fát, melyet a java:comp/env/ név alatt lehet elérni (ahol a java a séma, a másik két szó a component és environment szavak rövidítése). Ezzel együtt bevezettek egy indirekciót is. Ugyanis innentől kezdve a komponens fejlesztőjének kell definiálni azt, hogy milyen erőforrásokra, és más komponensekre lesz szüksége az általa fejlesztett komponensnek, ezek a komponens készítője által definiált lokális, logikai nevek, melyeket felhasznál a JNDI lookup-jaiban, de a logikai nevekhez az alkalmazás telepítőjének (deployer) kell konkrét globális JNDI neveket megfeleltetnie. Szerencsére ez nem kötelező, ugyanis az alkalmazásszerverek képesek arra, hogyha nincsen ilyen megfeleltetés, akkor a globális JNDI nevek közül a vele megegyezőre fognak mutatni. Amennyiben mégis módosítani akarja a telepítő, azt alkalmazás szerver specifikus telepítési leírókkal (xml formátumú deployment descriptor) tudja megtenni. Pl. ezzel valósítható meg az a típusú terhelés elosztás is, hogy az EJB-ink egy részét az egyik alkalmazásszerverre, a másik részét egy másik alkalmazásszerverre telepítjük, és a telepítésleíróban a logikai névhez a távoli EJB elérését adjuk meg (lokális transzparencia). Tehát a lekérés csak annyiban változik, hogy módosul a JNDI név.&lt;/p&gt;&lt;pre class="brush: java"&gt;try {
 Context ctx = new InitialContext();
 DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/JTechLogDS");
}
} catch (NamingException e) {
   LOGGER.error("Cannot lookup database connection.", e);
}&lt;/pre&gt;&lt;p&gt;Ezen módszert alkalmazza az EJB 2.1 szabvány, ahol az EJB komponenseknek a következő típusú logikai neveket definiálhatjuk az ejb.xml állományban:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;ejb-local-ref: lokális EJB-k&lt;/li&gt;&lt;li&gt;ejb-ref: távoli EJB-k&lt;/li&gt;&lt;li&gt;resource-ref: resource manager connection factory (javax.sql.DataSource, javax.jms.QueueConnectionFactory/javax.jms.TopicConnectionFactory, javax.mail.Session, java.net.URL)&lt;/li&gt;&lt;li&gt;resource-env-ref: resource (javax.jms.Queue, javax.jms.Topic)&lt;/li&gt;&lt;li&gt;env-entry: EJB környezeti bejegyzések&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;A resource manager connection factory egy olyan objektumot ad vissza, melyekkel az erőforráshoz csatlakozó kapcsolatokat ad vissza. Ilyen pl. a DataSource, mely Connection-öket ad vissza. Az env-entry közvetlenül erőforrásokat ad vissza, és kizárólag JMS sorok (Queue) vagy témák (Topic) definiálására szolgál. Az env-entry-vel egyszerű típusú értékeket tudunk definiálni a deployment descriptor-ban, EJB-nként. Globális értékek felvételére nincs lehetőség.&lt;/p&gt;&lt;p&gt;Szerencsére az EJB 3.0-ban erőteljesen használják az Inversion Of Control és a Dependency Injection technikákat. Ezeket gyakran keverik, ezért érdemes tisztázni, mit jelentenek. Az Inversion of Control jelenti azt, hogy az egyik komponens nem közvetlenül hívja a másik komponenst, hanem átmegy a hívás valamilyen köztes rétegen, EJB estében a konténeren, mely képes egyéb műveleteket is elvégezni. A hívást egy request interceptor kapja el, és továbbítja a komponensnek. A Dependency Injection azt jelenti, hogy nem én kérek egy referenciát egy másik komponensre, ha meg akarom hívni, hanem definiálom, hogy nekem szükségem van egy másik komponensre, és azt a köztes réteg biztosítja a számomra. Az EJB 2.1-ben még nekem kellett JNDI lookup-pal lekérni a referenciát (ezt hívják explicit middleware-nek is, ahol egy API-t használok a middleware szolgáltatásainak eléréséhez), az EJB 3.0-ban viszont annotációkkal tudom jelezni, hogy szükségem van egy referenciára (transparent middleware-nek is nevezik).&lt;/p&gt;&lt;p&gt;Az EJB 3.0-ban a @EJB annotáció felel meg az ejb-ref, és ejb-local-ref telepítés leíróbeli elemnek (más EJB-re való hivatkozás definiálása), míg a @Resource annotáció a többi elemnek (erőforrásra való hivatkozás). Mindkettőnek van egy name attribútuma, mellyel megadhatjuk az erőforrás JNDI nevét. Itt csak ENC, lokális neveket lehet használni, és a konténer automatikusan elé teszi a java:comp/env/ szöveget. Szerencsére nem kell mindig hozzá mappelnünk a globális nevet is, az alkalmazásszerverek automatikusan hozzá tudják kötni az ugyanazon nevű globális névhez. Lehetőségünk van persze globális JNDI nevek használatára is, ekkor használjuk a mappedName attribútumot. Ekkor persze ne felejtsük el, hogy ezek már alkalmazásszerver függő nevek. Pl. JBoss esetén teljes EAR deploy-kor [EAR név]/[osztály neve]/[interfész típusa], pl. JTechLogEarName/JTechLogBean/remote, Glassfish esetén csak az osztály minősített neve, azaz com.blogspot.jtechlog.JTechLogBean.&lt;/p&gt;&lt;p&gt;Ezek alapján használjunk mindenütt ENC nevet, és nem globális nevet a hordozhatóság miatt. De hogyan tudunk egy kliens alkalmazásban ilyeneket használni, hogyan kerülhetjük el a lookup-ot a globális névre? Szerencsére az alkalmazásszerverek gyártói általában készítenek egy pehelysúlyú kliens konténert is, ami nagyon alapvető funkciókkal rendelkezik, de lehetővé teszi a kliens beillesztését a Java EE architektúrába. Ez az ACC - application client container, mely felelőssége a kliensben is a Dependency Injection megvalósítása (azaz használhatunk @EJB annotációt), valamint a security context propagálása. Futtatásához a kliens konténer JAR fájljait el kell helyezni a classpath-ban, és az tartalmaz egy jndi.properties állományt is. Ahhoz, hogy ne csak lokális, hanem távoli szerverhez is tudjunk kapcsolódni, csak saját jndi.properties fájlt kell definiálnunk. Az kliens konténer használata sem szabványos, de a kliens felépítése, amit futtat, az igen.&lt;/p&gt;&lt;p&gt;És végére a jó hír, hogy az EJB 3.1-ben a globális JNDI nevek is standardizálva lesznek, méghozzá a következő formátumban: java:global[/&amp;lt;application-name&amp;gt;]/&amp;lt;module-name&amp;gt;/&amp;lt;bean-name&amp;gt;#&amp;lt;interface-name&amp;gt;, azaz az előző példa esetén JTechLogAppName/JTechLogEjbName/JTechLogBean#JTechLog&lt;/p&gt;&lt;p&gt;Linkek: &lt;a href="http://www.theserverside.com/tt/articles/article.tss?l=NewFeaturesinEJB31-Part5"&gt;Újdonságok az EJB 3.1-ben&lt;/a&gt;, &lt;a href="https://glassfish.dev.java.net/javaee5/ejb/EJB_FAQ.html"&gt;Glassfish EJB FAQ&lt;/a&gt;, &lt;a href="http://www.adam-bien.com/roller/abien/entry/ejb_3_portability_issue_why"&gt;EJB 3 portabilitási problémák&lt;/a&gt;&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/6392476049818230384/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2009/01/jndi-nevek-ejb-krnyezetben.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6392476049818230384'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6392476049818230384'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/01/jndi-nevek-ejb-krnyezetben.html' title='JNDI nevek EJB környezetben'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4058600501547773890</id><published>2008-12-27T18:47:00.005+01:00</published><updated>2014-01-10T23:33:33.024+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Servlet'/><category scheme='http://www.blogger.com/atom/ns#' term='Java EE'/><title type='text'>Kérés tárgyának meghatározása és kódolások/ékezetek használata webes alkalmazásoknál</title><content type='html'>&lt;p&gt;A cikk alapvetően a Servlet API-val kapcsolatos, de hasznos információkat tartalmazhat bármilyen webes keretrendszert használóknak. Az itt leírt dolgokat érdemes kipróbálni, esetleg a kérések, válaszok tartalmát egy HTTP proxy-val megvizsgálni.&lt;/p&gt;
&lt;p&gt;Webes alkalmazások készítésekor ritkán van olyan eset, mikor minden URL-t különböző servlet szolgálna ki, és nem kapna az URL-ben különböző járulékos információkat. Emiatt érdemes az URL felépítését kicsit megvizsgálni, és megnézni, hogyan lehet a Servlet API felhasználásával az URL különböző részeit lekérdezni.&lt;/p&gt;
&lt;p&gt;A leggyakoribb félreértés az URI, URL és URN közötti különbségekkel kapcsolatban szokott felmerülni. Az URI (Unified Resource Identifier), mely egy egyedi erőforrás azonosító. Az erőforrást lehet azonosítani névvel, elérési helyével vagy mindkettővel. Az URL (Unified Resource Locator) egy olyan URI, ami az erőforrást annak helyével azonosítja, azaz megadja, hogy kell ahhoz hozzáférni. Az URN (Unified Resource Name) szintén egy URI, mely a teljesen egyedi névvel azonosítja az erőforrást, és nem adja meg, hogy hogyan lehet ahhoz hozzáférni. Az URI szintaksztisát az &lt;a href="http://www.ietf.org/rfc/rfc3986.txt"&gt;RFC 3986 - Uniform Resource Identifiers Generic Syntax&lt;/a&gt; szabvány írja le, de hivatkozik több más szabványra is. Az URI, URL és URN közötti különbségeket a 1.1.3-as fejezet tartalmazza.&lt;/p&gt;
&lt;p&gt;A webes alkalmazásokkal a böngészők a HTTP protokollon keresztül kommunikálnak, melyet a &lt;a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html"&gt;RFC 2616 - Hypertext Transfer Protocol - HTTP/1.1&lt;/a&gt; szabvány tartalmaz. A lekérdendő erőforrást meg lehet adni abszolút URI-val, mely egy http sémájú URL.&lt;/p&gt;
&lt;pre&gt;GET http://jtechlog.blogspot.com/2008/13/servlet.html HTTP/1.1&lt;/pre&gt;
&lt;p&gt;Ennél gyakoribb megoldás, mikor a böngésző a HTTP kérés első sorában csak a host-hoz tartozó abszolút path-t adja meg, és Host nevű HTTP fejlécben adja meg a host-ot, pl.:&lt;/p&gt;
&lt;pre&gt;GET /2008/13/servlet.html HTTP/1.1
Host: jtechlog.blogspot.com
&lt;/pre&gt;&lt;p&gt;Ezen definíciókat átfordítva a Servlet API működésére az URL tartalmazza a teljes címet, sémával (protokollal), szervernévvel és porttal, míg az URI csak a szerveren belüli erőforrást azonosítja egyedileg. Mint azt láttuk, a teljes URL ugyan megjelenik a böngésző címsorában, de azt a böngésző általában nem küldi el egyben a webes alkalmazásnak, így nincs olyan metódus, mellyel ezt le lehet kérdezni. A HTTP kérés első sorában lévő értéket a HttpServletRequest interfész getRequestURI() metódusával lehet lekérni, mely a legtöbb esetben nem adja vissza a sémát, a szervernevet és a portot. Ezen értékeket rendben a ServletRequest interfész getScheme(), getServerName() és getServerPort() metódusaival lehet lekérdeni. A teljes URL előállítására a HttpServletRequest interfész getRequestURL() metódusa való, mely a háttérben az előbb említett metódusokat hívja meg, és így állítja össze a végeredményt. Összegezve:&lt;/p&gt;
&lt;pre&gt;requestURL = scheme + serverName + serverPort + requestURI&lt;/pre&gt;
&lt;p&gt;Dokumentáció szerint a tényleges, böngészőben megjelenő, és az összeállított URL-ek között minimális különbségek lehetnek, nevezetese, hogy a szóköz %20 helyett +
(pluszjel) karakterként jelenik meg. Ezt Tomcat-nél nem tapasztaltam.&lt;/p&gt;
&lt;p&gt;Ahogy a requestURI sem, így a requestURL sem tartalmazza a HTTP kérés paramétereit. A kliens oldalról paraméterek két féleképpen jöhetnek. Egyrészt a HTTP kérés törzsében név = érték formátumban, egymástól &amp;amp; karakterrel elválasztva. Másrészt jöhetnek az URL-hez hozzáfűzve is ugyanezen formátumban, ? karakter után. Ha űrlapot használunk POST metódussal, akkor a HTTP kérés törzsében jönnek a paraméterek, GET metódus esetén az URL-ben.&lt;/p&gt;
&lt;p&gt;Megjegyzendő, hogy bár így szoktuk használni, és így érkezik be a HTML form-okról, nem kötelező a paramétereknek ezt a formátumot használniuk.&lt;/p&gt;
&lt;p&gt;A requestURI is három részből áll. Egyrészt áll a web alkalmazást a szerveren belül egyedileg azonosító contextPath-ból. Ebből kiemelt a root contextPath, mely a szerver gyökerére vonatkozó kéréseket szolgálja ki. Áll a servletPath-ból, mely az adott web alkalmazáson belül a servlet-et jelöli (egy servlet több path-t is kiszolgálhat). Valamint az un. extra útinformációból (pathInfo), mely még a CGI-s időkből maradt ránk. A Servlet API-ból úgy kezelhetjük ezt, ha a servlet-ünket nem egy konkrét URL-re map-peljük rá, hanem wildcard karaktert alkalmazunk. Pl., nézzük a következő web.xml részletet.&lt;/p&gt;
&lt;pre class="brush: xml"&gt;&amp;lt;servlet&amp;gt;
  &amp;lt;servlet-name&amp;gt;MyServlet&amp;lt;/servlet-name&amp;gt;
  &amp;lt;servlet-class&amp;gt;jtechlog.MyServlet&amp;lt;/servlet-class&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
  &amp;lt;servlet-name&amp;gt;MyServlet&amp;lt;/servlet-name&amp;gt;
  &amp;lt;url-pattern&amp;gt;/MyServlet/*&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&lt;/pre&gt;
&lt;p&gt;Ekkor a MyServlet nem csak a /MyServlet kérést fogja megkapni, hanem pl. a /MyServlet/jtechlog/servlet.html-re vonatkozó kérést is, és ebben az esetben a servletPath a /MyServlet lesz, míg a pathInfo a /jtechlog/servlet.html. A három érték lekérdezhető a HttpServletRequest interfész getContextPath, getServletPath és getPathInfo metódusaival. A pathInfo eredetileg arra volt használatos, hogy a fájlrendszerben lévő állományokat egy servlet szolgálja ki, így meghívva a getPathTranslated metódust visszaad egy abszolút fájl elérést, a pathInfo-t, mint relatív útvonalat véve a web alkalmazásunk főkönyvtárához képest. Amennyiben ez utóbbi nem érhető el, pl. az alkalmazás WAR-ból fut, null-t ad vissza.&lt;/p&gt;
&lt;p&gt;Milyen kódolásokat kell használnunk ilyen környezetben?&lt;/p&gt;
&lt;p&gt;Az első, és legegyszerűbb kódolás a HttpServletResponse encodeRedirectURL és encodeURL metódusa. Ezen metódusok valók arra, hogy a paraméterként megadott URL-hez abban az esetben, ha a kliens böngésző nem támogatja a sütik használatát (nem képes, vagy ki van kapcsolva), hozzáfűzze a session azonosítót. Így ilyen böngésző esetén a session követés csak abban az esetben fog működni, ha az URL-t így kódoljuk. Az encodeRedirectURL metódust csak akkor használjuk, ha a response.sendRedirect metódust akarjuk alkalmazni, ugyanis ebben az esetben a kódolás lehet, hogy másképp történik. Ha JSP-ben használunk URL-eket, akkor a JSTL core taglib-jének url tag-jét használjuk erre a célra.&lt;/p&gt;
&lt;p&gt;Ennél bonyolultabb annak biztosítása, hogy a speciális és az ékezetes karakterek jól jelenjenek meg, illetve jól kerüljenek bevitelre. A kezelésüket is megjelenítés és bevitel szerint csoportosítjuk.&lt;/p&gt;&lt;p&gt;Amennyiben ékezetes karaktereket szeretnénk használni, javasolt az UTF-8 character set használata, hiszen ez egy unicode alapú kódolás, változó hosszon, maximum 6 byte-on. A 7 bites ASCII karakterek kódja ugyanaz, azaz egy byte, míg az európai ékezetes karaktereket 2 byte-on kódolja.&lt;/p&gt;
&lt;p&gt;Amennyiben előállt az ékezetes szöveg, és a böngészőnek küldjük, ennek kódolását a Content-Type HTTP fejlécben kell megadni. Ennek beállítása történhet servlet-ből, vagy JSP direktívával, mint ahogy a következő sorok mutatják.&lt;/p&gt;
&lt;pre class="brush: java"&gt;response.setContentType(&amp;quot;text/html;charset=UTF-8&amp;quot;);

&amp;lt;%@page contentType=&amp;quot;text/html&amp;quot; pageEncoding=&amp;quot;UTF-8&amp;quot;%&amp;gt;
&lt;/pre&gt;
&lt;p&gt;Régebbi böngészők közül sok úgy értelmezte, ha nem volt küldve character set, hogy akkor azt a böngészőnek kell kitalálnia. Ez kivédhető, hogy ISO-8859-1 character set esetén is küldjük azt a Content-Type fejlécben.&lt;/p&gt;
&lt;p&gt;Ékezetes karaktereket lehetőleg adatbázisból, properties állományból, vagy külső erőforrásból vegyünk csak.&lt;/p&gt;
&lt;p&gt;Itt jegyzem meg, hogy egy Properties objektumot az 1.4-es Java-ig bezárólag csak egyszerű properties állományból lehetett betölteni, ami csak ISO 8859-1 kódolású lehet. Más kódolású állományból ilyent készíteni a native2ascii programmal lehetséges, ahol a speciális karakterek unicode escape szekvenciával lesznek kódolva. Az 5.0-ás Java-ban megjelent, hogy a Properties objektumot már XML állományból is be lehet tölteni, itt bármilyen kódolás használható. A 6-os Java-ban a Properties osztálynak megjelent a load(Reader) metódusa is, melyel bármilyen kódolású properties állományt be lehet tölteni.&lt;/p&gt;
&lt;p&gt;Nagyon távol tartanék mindenkit attól, hogy a forráskódban ékezetes karaktereket használjon. Amennyiben mégis, itt is javasolt az UTF-8 használata, de ekkor a fordítónak meg kell mondani, hogy a forrás állományok kódolása milyen. Ezt a -encoding utf8 parancssori paraméterrel kell megadni. Fontos, hogy ilyenkor figyeljünk oda, hogy a szövegszerkesztőnk nehogy odaírja a BOM (byte order mark) karaktereket a szöveges állományunk elejére, mert a fordító hibát fog jelezni (a Windows Notepad pl. odaírja).&lt;/p&gt;
&lt;p&gt;Ennél bonyolultabb a speciális és ékezetes karakterek fogadása. Amennyiben ilyeneket akarunk átvinni, URL kódolást kell alkalmaznunk. Ennek neve &lt;a href="http://en.wikipedia.org/wiki/Percent-encoding"&gt;Percent-encoding&lt;/a&gt;, azaz százalékjellel történő kódolás, vagy ismert URL encoding, azaz URL kódolás néven is (ez utóbbit fogom használni). Ezt is az említett RFC 3986 írja le. Lényege, hogy bizonyos karaktereket változatlanul hagy, bizonyos speciális karaktereket pedig egy százalékjellel és egy kétjegyű hexadecimális számmal ír le. Később alkalmassá tették bináris adatok átvitelére is, ahol egy bájtot a % jel utánis hexadecimális értékével reprezentálnak.&lt;/p&gt;
&lt;p&gt;Amennyiben mi állítunk elő olyan linket, mely ilyen karaktereket tartalmaz, nekünk kell az URL-t kódolnunk. Amennyiben viszont egy form-on használunk ékezetes karaktereket, a böngésző automatikusan kódolja azokat. A szerver oldalon ennek megfelelően dekódolásnak kell következnie.&lt;/p&gt;
&lt;p&gt;Ebből következik, ha speciális karaktereket akarunk átküldeni, egyszer URL-ben, egyszer pl. form hidden field-ben, akkor nekünk kell arra figyelnünk, hogy URL esetén manuálisan kódoljuk, form esetén ne kódoljuk az átküldendő karaktereket. (A legjobb persze, ha nem akarunk speciális karaktereket átvinni.)&lt;/p&gt;
&lt;p&gt;A manuális kódolást az URLEncoder.encode és a manuális dekódolást az URLDecoder.decode metódusokkal tudunk végezni. Ez elvégzi a kódolást application/x-www-form-urlencoded MIME formátumra, és vissza, melyet a &lt;a href="http://www.w3.org/TR/html4/"&gt;HTML szabvány&lt;/a&gt; tartalmaz. Ennek külön érdekessége, hogy ez különbözik az URL kódolás szabványától, ami azt írja, hogy a szóköz karaktert %20 karaktersorra kell leképezni, nem pedig + (plusz) jelre (ezt az magyarázza, hogy az application/x-www-form-urlencoded az URL kódolás egy korai verziójából származott le). Amennyiben szabályos kódolást akarunk, használjuk az URI osztályt, és annak toURL() metódusát.&lt;/p&gt;
&lt;p&gt;Az ékezetes karaktereknek a bájt kódja kerül átküldésre, viszont a nehézség az, hogy a böngésző nem küldi át, hogy az adott bájt sorozat milyen character set-en (pl. UTF-8-on) értelmezett. Ezért az ékezetes karakterek kezelésére a Servlet API automatizmust sem tartalmaz, nekünk kell azt biztosítani.&lt;/p&gt;
&lt;p&gt;A beérkező adatok kódolását és dekódolását is két csoportra kell osztani. Egyrészt az URL-ben érkező szövegek, másrészt a HTTP kérés törzsében érkező paraméterek.&lt;/p&gt;
&lt;p&gt;A böngésző általában az ékezetes karaktereket abban a character set-ben küldi el,
ahogyan a választ is kapta. Így érdemes úgy írni az alkalmazásainkat, hogy a böngésző felé küldött szövegek, és a böngésző felől érkező szövegek is UTF-8 character set-ben legyenek.&lt;/p&gt;
&lt;p&gt;Az URL-ben érkező szöveget a konténer dekódolja. Tomcat esetén ez a server.xml-ben
konfigurálható a connector-nál kell beírni a URIEncoding="utf-8" paramétert. Amennyiben ilyent nem adunk meg, a dekódolás a ISO-8859-1 karakter set-tel történik.&lt;/p&gt;
&lt;p&gt;Bizonyos metódusok elvégzik a dekódolást, de bizonyos metódusok nem. Lássuk:&lt;/p&gt;
&lt;table&gt;
 &lt;tbody&gt;
  &lt;tr&gt;
   &lt;td&gt;getRequestURI&lt;/td&gt;
   &lt;td&gt;nincs dekódolás&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;getContextPath&lt;/td&gt;
   &lt;td&gt;nincs dekódolás&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;getServletPath&lt;/td&gt;
   &lt;td&gt;van dekódolás&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;getPathInfo&lt;/td&gt;
   &lt;td&gt;van dekódolás&lt;/td&gt;
  &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Emiatt a következő képlet írható fel:&lt;/p&gt;
&lt;pre&gt;dekódolt(getRequestURI) = dekódolt(getContextPath) + getServletPath + getPathInfo
&lt;/pre&gt;&lt;p&gt;A paramétereket két csoportra oszthatjuk: az URL-ben és a HTTP törzsben érkező paraméterekre.&lt;/p&gt;
&lt;p&gt;Az URL-ben érkező paramétereket lekérdezni a HttpServletRequest interfész getQueryString metódusával lehet, mely nem végez dekódolást, gyakorlatilag a kérdőjel utáni szöveget kapjuk vissza. A getParameter és hasonló metódusok meghívásakor ezt dekódolja a konténer a connector beállításai alapján.&lt;/p&gt;
&lt;p&gt;A HTTP törzsben érkező paramétereket is alapértelmezetten a ISO-8859-1 karakter set-tel dekódolja, és ha ezt módosítani akarjuk, akkor be kell állítanunk a HTTP kérés karakter set-jét a HttpServletRequest setCharacterEncoding metódusával. Megjegyzendő, hogy ez csak Servlet 2.4+ konténereknél használható. Valamint az első paraméter kiolvasás, vagy a getReader által visszaadott Reader-ből való olvasás előtt kell meghívni, különben nem lesz hatása.&lt;/p&gt;
&lt;p&gt;Hogy ezt ne kelljen minden egyes servlet elejére beírni, gyakran alkalmazott módszer egy servlet filter alkalmazása, mely minden kérésre meghívja az előbb említett metódust. A Spring alapban tartalmazza ezt az osztályt org.springframework.web.filter.CharacterEncodingFilter néven, melynek encoding init paraméterben kell megadni a kódolást. Ez az osztály az org.springframework.web.filter.OncePerRequestFilter leszármazottja, mely a request scope-ban egy változó elhelyezésével biztosítja, hogy kérésenként csak egyszer legyen meghívva.&lt;/p&gt;
&lt;p&gt;A HttpServletRequest setCharacterEncoding metódusával biztosítjuk tehát azt, hogy
a dekódolás a getParameter és társai metódusok segítségével milyen character set-tel
történjen.&lt;/p&gt;
&lt;p&gt;A org.apache.catalina.util.RequestUtil osztályt érdemes olvasgatni az URL dekódolással,
valamint a paraméterek feldolgozásával kapcsolatban.&lt;/p&gt;
&lt;p&gt;Összefoglalásképp:&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;Ha mi magunk állítunk össze link-et használjuk az encodeRedirectURL és
encodeURL metódusokat a session követés érdekében.&lt;/li&gt;
 &lt;li&gt;Ha mi magunk állítunk össze paramétert, akkor URL-ben mi gondoskodjunk annak
kódolásáról, form esetén a böngésző elvégzi helyettünk.&lt;/li&gt;
 &lt;li&gt;Állítsuk be, hogy a konténer milyen kódolás alapján dekódolja az URL-eket. Tomcat esetén
URIEncoding paramétere a Connector konfigurációnak.&lt;/li&gt;
 &lt;li&gt;Használjunk CharacterEncodingFilter-t a form-ról érkező ékezetes szövegek helyes
dekódolásához.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Amennyiben bináris adatot szeretnénk URL-ben, vagy form-ban átvinni, figyelni kell arra, hogy URL-ben kell kódolást végeznünk, form-ban nem. Ezt kikerülhetjük úgy is, hogy &lt;a href="http://mindprod.com/jgloss/armouring.html"&gt;más kódolást&lt;/a&gt; alkalmazunk, melynek kimenete nem tartalmaz speciális karaktereket. Sajnos a Base64 nem alkalmas erre, mivel a kódolt szöveg tartalmaz olyan karaktert, melynek URL-ben speciális jelentése lehet. Alkalmazhatjuk ehelyett egy speciális típusát, a Base64u-t, mely kimenetében nem szerepelhet + / és = jel.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/4058600501547773890/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2008/12/krs-trgynak-meghatrozsa-s.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4058600501547773890'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4058600501547773890'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/12/krs-trgynak-meghatrozsa-s.html' title='Kérés tárgyának meghatározása és kódolások/ékezetek használata webes alkalmazásoknál'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6313820679959495698</id><published>2008-12-27T18:44:00.002+01:00</published><updated>2014-01-12T23:03:14.667+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Utils'/><title type='text'>Gyakran használt alkalmazások</title><content type='html'>A leghasznosabb alkalmazásokat általában nem a neten találom, hanem valamelyik ismerősöm mutatja, vagy valamilyen blogban olvasok róluk. Emiatt én is közzéteszem gyakran használt alkalmazásaim listáját (általános, FAR plugin-ek, Firefox plugin-ek, fejlesztéshez használt), hátha más merít belőle ötleteket.

A lista megtalálható a &lt;a href="http://vicziani.github.io/alkalmazasok.htm"&gt;http://vicziani.github.io/alkalmazasok.htm&lt;/a&gt; címen.</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/6313820679959495698/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2008/12/gyakran-hasznlt-alkalmazsok.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6313820679959495698'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6313820679959495698'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/12/gyakran-hasznlt-alkalmazsok.html' title='Gyakran használt alkalmazások'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-373733089556805930</id><published>2008-12-17T21:17:00.006+01:00</published><updated>2012-04-29T11:52:51.107+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='IDE'/><category scheme='http://www.blogger.com/atom/ns#' term='Java EE'/><title type='text'>NetBeans 6.5 és GlassFish v2 ur2</title><content type='html'>&lt;p class="paragraph"&gt;A Számalk Továbbképzés keretein belül JP-05 - Alkalmazásfejlesztés Java EE környezetben tanfolyamot tartva több fejlesztőeszközzel és alkalmazásszerverrel megpróbálkoztunk már. Ezek a következők voltak:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Eclipse IDE for Java EE Developers Europa (3.3) + JBoss 4.2.2 GA
&lt;/li&gt;&lt;li&gt;Oracle JDeveloper 10.1.3.4 + OC4J&lt;/li&gt;&lt;li&gt;NetBeans 6.5 + GlassFish v2 ur2
&lt;/li&gt;&lt;/ul&gt;Ebben a bejegyzésben megpróbálom ezeket összehasonlítani.&lt;p class="paragraph"&gt;Az Eclipse + JBoss kombinációt először a JBoss Tools 2.0.0GA Eclipse plugin-nel kezdtük, de annyira bugos volt, hogy hamar átálltunk arra, hogy csak az alkalmazásszerver elindítására és leállítására használtuk.&lt;/p&gt;&lt;p class="paragraph"&gt;Sajnos ez a párosítás nem felel meg az oktatásra, ugyanis a JBoss-nak olyan hibaüzenetei vannak, melyek egyrészt több oldalas, több egymásba ágyazott exception-t tartalmazó stacktrace-ek, másrészt kezdő, avatatlan szem számára teljesen semmitmondóak. Az oktatás gyakorlatilag abból telt, hogy a hallgatók által generált hibákat nekem kellett visszafejtenem, hiszen a hibaüzenet számukra nem sugallta a megoldást.&lt;/p&gt;&lt;p class="paragraph"&gt;Egyik hallgatónál a teszt eset futtatása során, amit pontosan ugyanúgy írt meg, mint a többiek, a következő hibaüzenet jött elő:&lt;/p&gt;&lt;pre&gt;Could not connect to:  : 3393
java.net.ConnectException: Connection refused: connect
at java.net.PlainSocketImpl.socketConnect(Native Method)
at java.net.PlainSocketImpl.doConnect(PlainSocketImpl.java:333)
...
&lt;/pre&gt;&lt;p class="paragraph"&gt;Ezzel kapcsolatban találtam is egy &lt;a href="http://mcqueeney.com/roller/page/tom/20070626"&gt;blog bejegyzést&lt;/a&gt;, a megoldás itt is ugyanaz volt, Eclipse újraindítás.
A következő probléma az volt, hogy a JBoss esetén, ha egy EJB 3.0 Named Query szintaktikailag hibás volt, onnantól kezdve hiába deploy-oltam újra az alkalmazást, nem segített, a teljes alkalmazásszervert újra kellett indítani. Ez sem ritka kezdőknél.&lt;/p&gt;&lt;p class="paragraph"&gt;Sajnos a hallgatók rossz szájízzel távoztak, a Java EE technológia még kiforratlan. Azóta kijött az Eclipse 3.4, Ganymede, azzal még nem próbálkoztunk.&lt;/p&gt;&lt;p class="paragraph"&gt;A következő oktatás a JDeveloper + beépített pehelysúlyú konténerrel, az OC4J-vel történt. Talán összehasonlítva az oktatásokat, a legkevesebb probléma ezzel a kombinációval volt. Összeértek az eszközök, a sebességre sem volt panasz. Azóta kijött a 11g, mely már nem az OC4J-t, hanem a BEA WebLogic Application Server-t tartalmazza alkalmazásszerverként, hát vannak fenntartásaim.&lt;/p&gt;&lt;p class="paragraph"&gt;A harmadik, legfrissebb tanfolyam a NetBeans + Glassfish párosítással történik. Egy ilyen oktatás már lement, és nagyon kedvezőek voltak a tapasztalatok, bár régebbi verziókkal történt. A jelenlegi összkép leírhatatlan, csupán az első példa alkalmazásnál (ami egy szál Session Bean, valamint ehhez tartozó Application Container-ben futó kliens) a következő hibákba botlottunk.&lt;/p&gt;&lt;p class="paragraph"&gt;Minden egyes indításnál, telepítésnél a következő hibaüzenetet írja a konzolra:&lt;/p&gt;&lt;pre&gt;Error attempting to process extensions from the manifest of JAR file C:\jtechlog\EnterpriseApplication1\dist\gfdeploy\EnterpriseApplication1-ejb.jar; ignoring it and continuing
java.io.FileNotFoundException: C:\jtechlog\EnterpriseApplication1\dist\gfdeploy\EnterpriseApplication1-ejb.jar (A rendszer nem találja a megadott fájlt)
     at java.util.zip.ZipFile.open(Native Method)
at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:114)
&lt;/init&gt;&lt;/pre&gt;&lt;p class="paragraph"&gt;Ezzel egy &lt;a href="http://blogs.sun.com/quinn/entry/why_the_warnings_about_glassfish"&gt;másik bejegyzés&lt;/a&gt; is foglalkozik, mely azt írja, hogy ez amiatt van, hogy a telepítésnél a NetBeans nem EAR-t, és abba csomagolt JAR-t deploy-ol, hanem rögtön kicsomagolva. Ez eddig szép is, de én tökéletesen egyetértek az egyik hozzászólóval, hogy próbáljuk követni a Linux szemléletet. Ha minden simán működik, akkor ne írjunk ki semmit, ha valami baj van, akkor viszont a lehető leginformatívabb szöveget. A hallgatókat sokszor megzavarja a hibaüzenet.&lt;/p&gt;&lt;p class="paragraph"&gt;A következő probléma az volt, hogy bizonyos (!) hallgatóknál egy, az alkalmazásszerverben futó Session Bean-hez kapcsolódni kívánó távoli klienst nem lehetett lefuttatni, ugyanis a következő hibaüzenetet dobta.&lt;/p&gt;&lt;pre&gt;Warning: Could not find file C:\jtechlog\ApplicationClient1\${wa.copy.client.jar.from}\ to copy.
&lt;/pre&gt;&lt;p class="paragraph"&gt;A tanári gépen a hiba nem volt reprodukálható, de itthon új telepítéssel újra előjött. Megoldás nem lett, pár próbálkozás után "megjavult". Ezzel kapcsolatosan &lt;a href="http://www.netbeans.org/issues/show_bug.cgi?id=91211"&gt;egy&lt;/a&gt; és &lt;a href="http://www.netbeans.org/issues/show_bug.cgi?id=85129"&gt;két&lt;/a&gt; hiba is regisztrálva van a NetBeans Issue Tracker-ében, valamint egy &lt;a href="http://wiki.netbeans.org/RemoteApplicationClientInNetBeans"&gt;konfig buherálás&lt;/a&gt; is ismeretes.&lt;/p&gt;&lt;p class="paragraph"&gt;No, ha már elindult az alkalmazásunk, mutassuk be, hogy a Glassfish képes arra, hogy az EAR-ba csomagolt alkalmazás klienst kliens konténerben (Application Client Container - ACC) képes futtatni, méghozzá az adminisztrátori felületről is indítva, Java Web Start-tal. Ez sem sikerült, a Glassfish-ben ez egy ismert &lt;a href="https://glassfish.dev.java.net/issues/show_bug.cgi?id=5374"&gt;hiba&lt;/a&gt;, ha Java SE 6 update 6 utáni verzióval futtatod az alkalmazásszervert.&lt;/p&gt;&lt;p class="paragraph"&gt;A következő hibát a Message Driven Bean-nél találtuk, hiszen üzenet fogadásakor a Glassfish logban mindig a következő üzenet jelent meg:&lt;/p&gt;&lt;pre&gt;DirectConsumer:Caught Exception delivering messagecom.sun.messaging.jmq.io.Packet cannot be cast to com.sun.messaging.jms.ra.DirectPacket&lt;/pre&gt;&lt;p class="paragraph"&gt;A &lt;a href="http://bugs.sun.com/view_bug.do?bug_id=6650996"&gt;hiba&lt;/a&gt; szintén ismeretes a Glassfish-nél, &lt;a href="http://www.adam-bien.com/roller/abien/entry/how_to_get_rid_of"&gt;megoldása&lt;/a&gt;, hogy az adminisztrációs konzolon, a Configuration -&gt; Java Message Service menü alatt a típust "Embedded"-ről "Local"-ra kell váltani.&lt;/p&gt;&lt;p class="paragraph"&gt;A hab a tortán az volt, hogy ugyan nagyon kényelmes eszköz van arra, hogy JPA esetén a persistence unit létrehozása közben a NetBeans-ből tudunk DataSource-ot létrehozni az alkalmazásszerveren, de ez csak a hallgatói gépek felén működött, a másik felén nem jelent meg az alkalmazásszerveren, csak a NetBeans Server Resources/sun-recources.xml állományban, így azoknak kézzel kellett felvenniük az adminisztrációs felületen.&lt;/p&gt;&lt;p class="paragraph"&gt;Az oktatás alatt első körben csak pár soros példa kódokat használunk. Amennyiben ezen egyszerű példák esetén is ennyit hibáznak ezek az eszközök, mennyit hibázhatnak éles fejlesztés során? Mire való, hol van az a rengeteg automatikus teszt eset, ami pont az ilyen egyszerű eseteket tesztelné? Egyáltalán bevállalhatóak-e ilyen silány minőségű eszközökkel projektek?&lt;/p&gt;&lt;p class="paragraph"&gt;Tovább keresem az oktatásra megfelelő párosítást.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/373733089556805930/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2008/12/netbeans-65-s-glassfish-v2-ur2.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/373733089556805930'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/373733089556805930'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/12/netbeans-65-s-glassfish-v2-ur2.html' title='NetBeans 6.5 és GlassFish v2 ur2'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5790868397106235133</id><published>2008-12-10T22:38:00.005+01:00</published><updated>2009-02-23T23:33:45.103+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Naplózás'/><title type='text'>Tomcat 6 osztálybetöltők és naplózás</title><content type='html'>Az &lt;a href="http://tomcat.apache.org/"&gt;Apache Tomcat&lt;/a&gt; 6.0 implementálja a Servlet 2.5 and JavaServer Pages 2.1 specifikációkat. További újítások: &lt;ul class="minus"&gt;&lt;li&gt;Javított memóriafelhasználás&lt;/li&gt;&lt;li&gt;Haladó IO képességek&lt;/li&gt;&lt;li&gt;Átalakított fürtözés&lt;/li&gt;&lt;/ul&gt;Ezen kívül a naplózásban is történtek változások. Az 5.5-ös Tomcat-ben jelent meg a juli csomag, melynek két Java osztálya két Logging API osztályt származtatott le, az egyik a org.apache.juli.ClassLoaderLogManager extends java.util.logging.LogManager, valamint a org.apache.juli.FileHandler extends java.util.logging.Handler. Az első főbb előnye, hogy osztálybetöltőnként lehet konfigurálni a Java Logging API-t, azaz logging.propperties állományt megadni, tehát web-alkalmazásonként külön állományban szabályozható a naplózás. A FileHandler főbb újdonsága, hogy {prefix}.{date}.{suffix} nevű állományhoz adja hozzá a napló bejegyzéseket.Az 5.5-ös osztálybetöltő-hierarchiája a következőképp néz ki:&lt;p class="paragraph"&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_czKgycLvmNo/SUA4EDX6hnI/AAAAAAAACVU/I_nKVr3ST_g/s1600-h/classloader_5_5.png"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 400px; height: 107px;" src="http://1.bp.blogspot.com/_czKgycLvmNo/SUA4EDX6hnI/AAAAAAAACVU/I_nKVr3ST_g/s400/classloader_5_5.png" alt="" id="BLOGGER_PHOTO_ID_5278280405554464370" border="0" /&gt;&lt;/a&gt;&lt;/p&gt;Ahol minden alant lévő osztálybetöltő által betöltött osztály hozzáfér a felette lévő osztálybetöltő által betöltött osztályokhoz. A Catalina osztálybetöltő által betöltött osztályokhoz a web-alkalmazások nem férnek hozzá.&lt;p class="paragraph"&gt;A 6-os Tomcat módosított a naplózáson, és az osztálybetöltők hierarchiáján is. Egyrészt a juli csomagban megjelent egy logging csomag is, mely a következő négy osztályt tartalmazza: &lt;/p&gt;&lt;ul class="minus"&gt;&lt;li&gt;DirectJDKLog&lt;/li&gt;&lt;li&gt;Log&lt;/li&gt;&lt;li&gt;LogConfigurationException&lt;/li&gt;&lt;li&gt;LogFactory&lt;/li&gt;&lt;/ul&gt;Ezek valójában a&lt;span class="nobr"&gt; &lt;a href="http://jakarta.apache.org/commons/logging/"&gt;Commons Logging&lt;/a&gt;&lt;/span&gt; csomag megfelelő osztályai, azzal a különbséggel, hogy egyrészt más a csomag nevük, valamint a Commons Logging-gal ellentétben nem dinamikusan választja ki a konkrét naplózó implementációt, hanem automatikusan a JDK 4-ben bevezetett Java Logging implementációt használja. Az Apache Tomcat minden osztálya így a org.apache.juli.logging.LogFactory osztályt (mely DirectJDKLog osztályt gyárt), és Log interfészt használja. Ezáltal gyorsabb, egyszerűbb, átláthatóbb.&lt;p class="paragraph"&gt;Ahhoz, hogy cseréljük a naplózó implementációt (pl. Java Logging API helyett Log4J-t használjunk), le kell cserélnünk a bin könyvtár tomcat-juli.jar állományát, méghozzá azzal, melyet forrásból, az extras.xml Ant build fájl felhasználásával készíthetünk. Ez letölti a Commons Logging implementációt, mindenhol kicseréli a csomagnevet org.apache.commons-ról org.apache.juli-ra, és így egy olyan könyvtárhoz jutunk, ami már dinamikusan tölti be a megfelelő naplózó implementációt.&lt;/p&gt;&lt;p class="paragraph"&gt;Ezzel egyetemben a az osztálybetöltő-hierarchia is változott, egyszerűsödött:&lt;/p&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_czKgycLvmNo/SUA4w6k3wFI/AAAAAAAACVc/VGF8DxRtNf4/s1600-h/classloader_6.png"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 400px; height: 118px;" src="http://1.bp.blogspot.com/_czKgycLvmNo/SUA4w6k3wFI/AAAAAAAACVc/VGF8DxRtNf4/s400/classloader_6.png" alt="" id="BLOGGER_PHOTO_ID_5278281176287002706" border="0" /&gt;&lt;/a&gt;&lt;p class="paragraph"&gt;Azon kívül hogy a ClassLoaderLogManager osztálybetöltőnként tárolja a logger példányokat, kiegészítette a konfigurálási lehetőségét is a Java Logging API-nak a következőkkel: &lt;/p&gt;&lt;ul class="minus"&gt;&lt;li&gt;képes különböző napló bejegyzéseket külön fájlba is kiírni, ezt úgy oldja meg, hogy egy osztályhoz több prefixet is lehet írni&lt;/li&gt;&lt;li&gt;logger-hez handler-t lehet megadni a loggerName.handler property beállításával&lt;/li&gt;&lt;li&gt;alapértelmezésben a logger nem delegál a szülőjének handler-e felé, ezt állítani a loggerName.useParentHandlers property-vel lehet&lt;/li&gt;&lt;li&gt;a root loggernek is lehet megadni handler-t a .handlers property használatával&lt;/li&gt;&lt;li&gt;kicseréli a property állományban betöltéskor a ${sytstemPropertyName} mintákat, a kapcsos zárójelek között megnevezett rendszerváltozók értékeivel&lt;/li&gt;&lt;/ul&gt;A konfigurációs állományában (/conf/logging.properties) a handler-eket a következőképp lehet megadni:
&lt;pre&gt;handlers = 1catalina.org.apache.juli.FileHandler,
2localhost.org.apache.juli.FileHandler,
3manager.org.apache.juli.FileHandler,
4admin.org.apache.juli.FileHandler,
5host-manager.org.apache.juli.FileHandler,
java.util.logging.ConsoleHandler
&lt;/pre&gt;A ClassLoaderLogManager readConfiguration metódusa ezt úgy oldja fel, hogy az első pontig lévő részt (prefix) levágja (ez csak az egyediséget biztosítja), és a maradék osztályt példányosítja. Persze a további konfigurációt még a prefixszel együtt olvassa be (level, handlers).&lt;p class="paragraph"&gt;A logging.properties-ban root handler-nek a 1catalina.org.apache.juli.FileHandler és a java.util.logging.ConsoleHandler van beállítva. Minden előtte el nem fogott naplózás ide kerül.&lt;/p&gt;&lt;p class="paragraph"&gt;A különböző, előre telepített webes alkalmazások (manager, host-manager), valamint később telepíthető alkalmazás (admin) a ServletContext log metódusát hívja, ami a Tomcat alapértelmezett implementációját használja, ami a org.apache.catalina.core.ContainerBase.[engine].[host].[/context] (pl. org.apache.catalina.core.ContainerBase.[Catalina].[localhost].[/manager]) log-gal naplóz. Azon alkalmazások, melyek ugyanezen metódusokat használják naplózásra, ha naplóznak, annak a napló bejegyzéseit a 2localhost.org.apache.juli.FileHandler handler kapja el, ilyen lehet pl. a balancer.&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/5790868397106235133/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2008/12/tomcat-6-osztlybetltk-s-naplzs.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/5790868397106235133'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/5790868397106235133'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/12/tomcat-6-osztlybetltk-s-naplzs.html' title='Tomcat 6 osztálybetöltők és naplózás'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://1.bp.blogspot.com/_czKgycLvmNo/SUA4EDX6hnI/AAAAAAAACVU/I_nKVr3ST_g/s72-c/classloader_5_5.png' height='72' width='72'/><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7696813335873518588</id><published>2008-12-09T11:02:00.003+01:00</published><updated>2009-01-19T03:09:23.395+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Java SE'/><title type='text'>Erőforrások betöltése</title><content type='html'>&lt;p class="paragraph"&gt;Az alkalmazás által használt erőforrások olyan adatok, melyek a kódban nem helyezhetőek (nem ajánlott elhelyezni), mint pl. kép, hang, videó, szöveg (a szövegek pl. sablonok, felhasználói felület feliratok, stb.).&lt;/p&gt;&lt;p class="paragraph"&gt;Az erőforrások elérésének két módja van. Egyrészt lehet direkt elérés, amikor a programban abszolút módon meg kell adni az erőforrás helyét (pl. konkrét fájl path vagy URL), és lehet indirekt, un. helyfüggetlen (location-independent) elérés is, mikor az alkalmazásban egy szimbólikus nevet adunk meg, és a környezet oldja fel ezt egy abszolút helyre. Ez a feloldás pont emiatt környezetfüggő.&lt;/p&gt;&lt;p class="paragraph"&gt;Lehetőleg kerüljük a direkt elérést, az alkalmazásunkban mindig logikai neveket használjunk. A logikai nevekhez rendelhetünk magunk konkrét értékeket, pl. JNDI-ből oldjuk fel (pl. web konténerben, alkalmazásszerverben konfiguráljuk), vagy használhatjuk a Java beépített mechanizmusát, ha az erőforrást classpath-ból tudjuk betölteni (amikor az erőforrást pl. az alkalmazásunkhoz csomagolva, a JAR, WAR, EAR, RAR állományokban tudjuk elhelyezni).
&lt;/p&gt;&lt;p class="paragraph"&gt;Az erőforrások nevei különböző részekből állnak, melyek / karakterrel vannak elválasztva. Mindegyik rész egy Java azonosító. Ezzel a konvencióval egy hierarchiát lehet kialakítani az erőforrások elhelyezkedésében. Az utolsó rész az erőforrás egyszerű neve, ami tartalmazhat egy kiterjesztést is (ez csak egy konvenció), ponttal elválasztva, és szintén Java típusú azonosító.&lt;/p&gt;&lt;p class="paragraph"&gt;Az elválasztójel mindig / jel, ennek feloldásáról pl. fájlrendszerre, URL-re, stb. a környezet gondoskodik.&lt;/p&gt;&lt;p class="paragraph"&gt;A környezetet Java nyelvben a ClassLoader osztály leszármazottai biztosítják. Ezek megfelelő metódusai oldják fel az erőforrás neveket abszolút hivatkozásokra, és ezek is töltik be azokat.&lt;/p&gt;&lt;p class="paragraph"&gt;Az erőforrások lehetnek rendszer-erőforrások, aminek betöltéséről a statikus ClassLoader.getSystemResource és ClassLoader.getSystemResourceAsStream metódusok gondoskodnak. Ez a CLASSPATH bejegyzéseket végigjárva próbálja az adott erőforrást megtalálni.&lt;/p&gt;&lt;p class="paragraph"&gt;A nem rendszer-erőforrások betöltéséért a ClassLoader.getResource és ClassLoader.getResourceAsStream példány metódusok gondoskodnak. Ezek implementációja leszármazottanként más és más lehet, emiatt eltérhet az erőforrás-betöltés mikéntje. Minden osztálybetöltő azonban először rendszer-erőforrásként próbálja betölteni az erőforrást.&lt;/p&gt;&lt;p class="paragraph"&gt;Az erőforrásokat ajánlott az osztályok mellé elhelyezni, ugyanazon csomag struktúrába. Ekkor a nevének megadásakor a csomag minősített nevét is meg kell adni, de elválasztáshoz . helyett a már említett / jelet kell használni.&lt;/p&gt;&lt;p class="paragraph"&gt;A könnyebb használhatóság érdekében a bevezették a Class.getResource és Class.getResourceAsStream metódusokat is, melyek több könnyebbséget adnak: &lt;/p&gt;&lt;ul class="minus"&gt;&lt;li&gt;Bizonyos osztályok betöltését az un. elsődleges osztálybetöltő végzi. Ekkor a Class.getClassLoader metódus null-t ad vissza. Ezt a Class.getResource és Class.getResourceAsStream metódus ellenőrzi, és ebben az esetben rendszer-erőforrásként próbálja betölteni az erőforrást.&lt;/li&gt;&lt;li&gt;Ha nem adjunk meg a / jelet az erőforrás első karaktereként, akkor relatív hivatkozásnak veszi, és automatikusan elérakja az osztály csomagjának minősített nevét, a pontokat / jelre cserélve. Erőforrás megadása azért lehet követendő példa, mert ilyenkor csomag átnevezésekor nem kell a forráskódban is változtatni az erőforrás nevét, aminek elmaradása ráadásul futásidejű hibát eredményez.&lt;/li&gt;&lt;li&gt;Ennek használatakor nem kell a getClassLoader security permission.&lt;/li&gt;&lt;/ul&gt;Az osztályra való hivatkozást meg lehet szerezni FooClass.class.getResource és egy példányon keresztül a foo.getClass().getResource módokon is. Az előbbi használata javasolt, mert: &lt;ul class="minus"&gt;&lt;li&gt;Nem kell hozzá példány.&lt;/li&gt;&lt;li&gt;Ha örököltetünk, és egy másik csomagba kerül a gyermek osztály, akkor a foo.getClass() a leszármazott osztályt fogja visszaadni, így a relatív névmegadással nem lehet az erőforrást megtalálni.&lt;/li&gt;&lt;/ul&gt;&lt;span style="font-weight: bold;"&gt;&lt;/span&gt;&lt;p class="paragraph"&gt;Ehhez érdemes kicsit megérteni az osztálybetöltőket. Ha egy osztályt az elsődleges osztálybetöltő tölt be, tipikusan a java.* csomag bizonyos osztályait, akkor az null-t ad vissza. Ez azért van, hiszen az elsődleges osztálybetöltő C-ben van írva. Hiszen ha ez is egy normál osztály lenne, akkor ezt mi töltené be (tyúk-tojás probléma)? Osztálybetöltők: &lt;/p&gt;&lt;ul class="minus"&gt;&lt;li&gt;Bootstrap class loader: boot classpath-on lévő osztályok, nem kell őket ellenőrizni&lt;/li&gt;&lt;li&gt;Extension class loader&lt;/li&gt;&lt;li&gt;System class loader&lt;/li&gt;&lt;/ul&gt;Osztálybetöltők között egy futásidejű fa hierarchia alakul ki. Osztálybetöltéskor un. delegation model van alkalmazva, azaz az osztálybetöltő először a szülő osztálybetöltővel próbálja betöltetni az osztályt, csak utána próbálja meg önmaga. Ha ő sem tudja, ClassNotFoundException kivétel váltódik ki.&lt;p class="paragraph"&gt;&lt;span class="nobr"&gt;&lt;a href="http://java.sun.com/javase/6/docs/technotes/guides/lang/resources.html"&gt;http://java.sun.com/javase/6/docs/technotes/guides/lang/resources.html&lt;/a&gt;&lt;/span&gt;&lt;br /&gt; &lt;span class="nobr"&gt;&lt;a href="http://www.javaworld.com/javaworld/javaqa/2002-11/02-qa-1122-resources.html"&gt;http://www.javaworld.com/javaworld/javaqa/2002-11/02-qa-1122-resources.html&lt;/a&gt;&lt;/span&gt;&lt;br /&gt; &lt;span class="nobr"&gt;&lt;a href="http://java.sun.com/developer/technicalArticles/Networking/classloaders/index.html"&gt;http://java.sun.com/developer/technicalArticles/Networking/classloaders/index.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/7696813335873518588/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2008/12/erforrsok-betltse.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7696813335873518588'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/7696813335873518588'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/12/erforrsok-betltse.html' title='Erőforrások betöltése'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-225935663707090254</id><published>2008-12-03T22:11:00.003+01:00</published><updated>2008-12-04T00:01:46.334+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='SOA'/><category scheme='http://www.blogger.com/atom/ns#' term='Oracle'/><title type='text'>Oracle Fusion Middleware - SOA</title><content type='html'>Egy előző bejegyzésben áttekintettem a BEA felvásárlással kapcsolatos Oracle Fusion Middleware infrastrukturális elemeket, most következzen az Oracle termékskáláján közvetlenül e felett lévő szint, a SOA Suite, BPM és SOA Governance Suite. A SOA eszközök felelősek a szolgáltatásorientált architektúra megvalósításáért. A BPM az üzleti folyamatok tervezéséért, fejlesztéséért, szimulációjáért és monitorozásáért. A SOA Governance felelős azért, hogy irányítás alatt tartsuk, felügyeljük a SOA architektúrában definiált szolgáltatásokat (pl. szabványok használatával, változás követésével).
Minden terméknél leírom hogy az Oracle vagy a BEA terméke-e, valamint az Oracle stratégiáját.
&lt;h2&gt;SOA&lt;/h2&gt;Az ide tartozó termékeit az Oracle csomagban, Oracle SOA Suite néven is forgalmazza.
&lt;ul&gt;&lt;li&gt;Oracle Data Integrator: heterogén adatmigráció, batch ETL (Extract, Transform, and Load - eszköz adatok kinyerésére külső adatforrásokból, ezek transzformálása az üzleti igényeknek megfelelően, majd ezek betöltése, pl. adattárházba): stratégiai termék. Heterogén, szemben az Oracle Warehouse Builderrel, mely csak Oracle adatbázisok között teszi ez meg.&lt;/li&gt;&lt;li&gt;Oracle Service Bus (AquaLogic ServiceBus &amp;amp; Oracle ESB)‏: itt egyik terméket sem tudják a másik fölé helyezni, integrálják a két terméket, stratégiai termék.&lt;/li&gt;&lt;li&gt;Oracle BPEL Process Manager: BPEL motor, folyamatok irányítására, stratégiai termék.&lt;/li&gt;&lt;li&gt;Oracle Complex Event Processor (Oracle CEP): Oracle Event-Driven Architecture-ba illeszkedő, eseményeket feldolgozó alkalmazások fejlesztésére szolgáló környezet. Stratégiai termék.&lt;/li&gt;&lt;li&gt;Oracle Business Activity Monitoring (BAM): üzleti tevékenységek, KPI (key performance indicator - mérőszámok arra, hogy mennyire teljesülnek az üzleti célok) monitorozására szolgáló eszköz. Stratégiai termék.&lt;/li&gt;&lt;li&gt;BEA WebLogic Integration: konvergáló termék. A BEA ezen a fronton elvesztette a csatát, valószínűleg azért, mert nem a szabvány BPEL-re épít ezen folyamatirányító alkalmazásuk.&lt;/li&gt;&lt;li&gt;BEA Cyclone &amp;amp;� RFID Server: nem támogatott BEA termék, karbantartott termékek kategóriába került.
&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;SOA BPM&lt;/h2&gt;Cél rendszer-központú, ember-központú, dokumentum-központú, és döntés-központú üzleti folyamatok elemzésére, tervezésére (modellezésére), implementálására, futtatására, szimulálására, követésére (monitorozására) szolgáló környezet felállítása, ami képes követni a gyorsan változó igényeket (szemben az IT álmával, az állandósággal). Ebből a csoportból minden termék stratégiai termék. Egyben, Oracle BPM Suite csomagban is kapható.
&lt;ul&gt;&lt;li&gt;Oracle BPA Designer: tervező eszköz modellezéshez és folyamat tervezéshez.&lt;/li&gt;&lt;li&gt;Oracle BPM Studio (BEA AquaLogic BPM Designer)‏ - Oracle eszközhöz képest agilisebb tervező eszköz.&lt;/li&gt;&lt;li&gt;Oracle BPM Server (BEA AquaLogic BPM): folyamat irányításra, XPDL nyelven adható meg.&lt;/li&gt;&lt;li&gt;Oracle Document Capture &amp;amp; Imaging: papír alapú dokumentum és képek feldolgozására való folyamatirányító.&lt;/li&gt;&lt;li&gt;Oracle Business Rules - sűrűn változó üzleti szabályok deklaratív megadására, lehetőleg fejlesztés nélkül. Tárolhatók benne döntési táblák, amik ugyan relációs adatbázisban is tárolhatóak lennének, de ott dimenziók növekedésével ez egyre körülményesebb lenne. Lehetőség van feltételek megadására is.&lt;/li&gt;&lt;li&gt;Oracle User Interaction: humán workflow.&lt;/li&gt;&lt;li&gt;Oracle WebCenter
&lt;/li&gt;&lt;/ul&gt;Valamint az előzőekben már említett Oracle BPEL Process Manager és Oracle BAM.
A jelenlegi helyzet szerint a BEA-tól átvett, és átnevezett Oracle BPM Studio és Oracle BPM Server működik együtt (XPDL alapú), valamint az eredeti Oracle JDeveloper alapú Oracle BPA Designer (11g-ben még nem elérhető) és a Oracle BPEL Process Manager működik együtt (BPEL alapú). A kettő ugyan együttműködik, de a jövőképben egy tervező és futtató rendszer jelenik meg.
&lt;h2&gt;SOA Governance&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;BEA AquaLogic Enterprise Repository: termékek összegyűjtése, megosztása, változás és életciklus kezelése, stratégiai termék.&lt;/li&gt;&lt;li&gt;Oracle Service Registry: UDDI registry, stratégiai termék.&lt;/li&gt;&lt;li&gt;Oracle Web Services Manager: biztonsági szabályok, stratégiai termék.&lt;/li&gt;&lt;li&gt;EM Service Level Management Pack: válaszidő és elérhetőség mérésére, stratégiai termék.&lt;/li&gt;&lt;li&gt;EM SOA Management Pack: teljes SOA architektúra menedzseléséhez, stratégiai termék.&lt;/li&gt;&lt;li&gt;BEA AquaLogic Services Manager: konvergáló termék.
&lt;/li&gt;&lt;/ul&gt;A SOA Governance keretén belül érdemes tárolni a következőket: XSD, WSDL állományok, üzleti követelmények, modellek, szabályok és szabványok, autit adatok és metrikák, verziók, kapcsolatok és függőségek, SLA, felelősök, biztonsági előírások.</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/225935663707090254/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2008/12/oracle-fusion-middleware-soa.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/225935663707090254'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/225935663707090254'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/12/oracle-fusion-middleware-soa.html' title='Oracle Fusion Middleware - SOA'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6190185992411799485</id><published>2008-12-02T14:26:00.008+01:00</published><updated>2014-01-06T23:38:03.870+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='PKI'/><title type='text'>Minősített elektronikus aláírás</title><content type='html'>&lt;p&gt;
    &lt;b&gt;A post-ot 2013. december 23-án frissítettem.&lt;/b&gt;
&lt;/p&gt;
&lt;p&gt;Több projekt kapcsán is előjött az elektronikus aláírás témakör, hogyan kell minősített aláírást készíteni. Több
    dokumentum szól arról, hogy mi az az elektronikus aláírás, tanúsítványok, hitelesítésszolgáltatások, de kevés
    helyen van összefoglalva, hogy Magyarországon milyen lehetőségeink vannak, és ezek milyen szabványokra épülnek.
&lt;/p&gt;
&lt;p&gt;Mi köze ennek a Java-hoz? Egyrészt feladat lehet elektronikus aláírást készíteni, illetve ellenőrizni Java
    alkalmazásból, másrészt van olyan elektronikus aláírást létrehozó termék is, melyet Java-ban fejlesztettek.
&lt;/p&gt;
&lt;p&gt;Ezzel a témakörrel kapcsolatban magyar nyelven rengeteget lehet megtudni &lt;a href="http://www.sansserif.hu/ealairas/konyv.htm "&gt;Almási János "Elektronikus aláírás és társai" című könyvéből&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;Én most csak arra térnék ki, hogy mi kell az elektronikus aláírás készítéséhez? Egyrészt kell egy tanúsítvány,
    mely tartalmazza a tulajdonos személyes adatait, a tulajdonos nyilvános kulcsát, valamint hitelesítve van egy
    harmadik fél, a hitelesítésszolgáltató által (ez a tanúsítvány hitelesítésszolgáltató általi elektronikus
    aláírásával történik). Szükség van egy aláíró eszközre, mely általában egy token, mágneskártya, USB eszköz stb.
    Ez az eszköz végezheti az aláírást oly módon, hogy beküldésre kerül az aláírandó adat, és az aláírást adja
    vissza (megakadályozva ezzel a magánkulcs másolásának lehetőségét) - ennek neve a BALE, biztonságos
    aláírás-létrehozó hardver eszköz. Valamint szükség van egy környezetre, melyben az aláírás történik, mondjuk egy
    személyi számítógépre, és különböző szoftver eszközökre, melyek az aláíró eszközzel kommunikálnak.
&lt;/p&gt;
&lt;p&gt;A könyv megírása óta a magyar hitelesítésszolgáltatókkal (certificate authority or certification authority - CA)
    kapcsolatban több változás is történt, melyeket nyomon lehet követni a&lt;a
            href="http://webold.nhh.hu/esign/index.jsp"&gt;Nemzeti Hírközlési Hatóság Elektronikus aláírásokkal
        kapcsolatos nyilvántartásokat tartalmazó honlapján&lt;/a&gt;.
&lt;/p&gt;
&lt;p&gt;Itt fel vannak sorolva a nem-minősített és minősített szolgáltatók is, a minősítettek a következők:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="http://hiteles.mavinformatika.hu/"&gt;MÁV Szolgáltató Központ Zrt.&lt;/a&gt;, mely várhatóan 2014 első félévében
        véglegesen megszünteti az elektronikus aláírással kapcsolatos szolgáltatásait
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href="http://www.e-szigno.hu/"&gt;MICROSEC zrt. e-Szignó&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href="http://www.netlock.hu/"&gt;NetLock Kft.&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href="http://hiteles.gov.hu/"&gt;NISZ Zrt.&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A
    &lt;a href="http://www.netlock.hu/giro/"&gt;GIRO HIT@LES szolgáltatás&lt;/a&gt;
    és a
    &lt;a href="http://www.t-systems.hu/nagyvallalatok/hitelesites_szolgaltatasok"&gt;Magyar Telekom (volt Matáv)
        e-Szignó
    &lt;/a&gt;
    is megszűnt, a megszűnő szolgáltatásokat átvevő szervezet a NetLock.&lt;/p&gt;
&lt;p&gt;Valamint létrehoztak egy Közigazgatási Gyökér Hitelesítés-szolgáltatót (KGYHSZ) is, melynek jellegtelen
    &lt;a href="http://www.kgyhsz.gov.hu/"&gt;honlapján&lt;/a&gt;
    megtudható, hogy az előbb felsorolt hitelesítésszolgáltatók mindegyikét felülminősítette, azaz egyaránt
    jogosultak közigazgatási felhasználásra szolgáló, hivatali aláíráshoz és ügyfél által használt aláíráshoz
    kapcsolódó tanúsítványok kibocsátására. Jelenleg tanúsítványt nem bocsát ki.
&lt;/p&gt;
&lt;p&gt;Ahhoz, hogy minősített aláírást hozzunk létre, a minősített tanúsítványunkon kívül szükség van egy biztonságos
    tanúsított minősített aláírást létrehozó termékre is, melyet jelenleg két szervezet tanúsít, hogy az adott
    hardver (ide tartozik a BALE is) és szoftver megfelel-e aláírás létrehozására:
&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;
        &lt;a href="http://www.hunguard.hu/"&gt;Hunguard&lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href="http://www.matrix-tanusito.hu/"&gt;Matrix&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Az elektronikus aláírás és annak rokon, kapcsolódó és származékos technológiák népszerűsítésére létrejött a&lt;a
        href="http://www.melasz.hu/"&gt;Magyar Elektronikus Aláírás Szövetség&lt;/a&gt;, mely kiadott egy MELASZ-Ready
    Ajánlást, melynek célja, hogy a magyar közigazgatás számára kidolgozzon egy olyan feltételrendszert az
    elektronikus aláírás formátumára, és egy olyan tanúsítási eljárást, mellyel biztosítható a különböző eszközök
    által készített aláírások kompatibilitása. A szabvány a W3C XML Advanced Electronic Signatures (XAdES)
    szabványon alapul. A XAdES XML formátumú, és hátránya, hogy az aláírt dokumentum megtekintéséhez először ki kell
    csomagolni azt. Mivel a PDF a PKCS szabványok közül válogatott, az a XAdES-szel nem kompatibilis, előnye
    viszont, hogy az aláírt dokumentum azonnal megnyitható, kicsomagolás nélkül.
&lt;/p&gt;
&lt;p&gt;A következő aláírási termékek tanúsítottak, melyek képesek minősített aláírás létrehozására. A Melasz a
    &lt;a href="http://melasz.hu/lang-hu/tanusitott-termekek"&gt;tanúsított termékek között&lt;/a&gt; az összeset felsorolja az
    InfoCA-n kívül.
&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;a href="http://www.polysys.eu/hu/CryptoSignoInterop/"&gt;Polysys CryptoSigno Interop&lt;/a&gt;, a Magyarországon első platform
        független, Java-ban implementált fejlesztő készlet.
    &lt;/li&gt;

    &lt;li&gt;&lt;a href="http://noreg.hu/esign-termekcsalad"&gt;Noreg eSign Toolkit&lt;/a&gt;&lt;/li&gt;

    &lt;li&gt;&lt;a href="http://srv.e-szigno.hu/menu/index.php?lap=eszigno"&gt;Microsec e-Szignó&lt;/a&gt;
    &lt;/li&gt;

    &lt;li&gt;&lt;a href="http://www.infoscope.hu/infoca.html"&gt;InfoScope Kft. InfoCA&lt;/a&gt;
    &lt;/li&gt;

    &lt;li&gt;
        &lt;a href="http://www.argeon.hu/infosigno.html"&gt;Argeon Infosigno&lt;/a&gt;, a cég felszámolás alatt.
    &lt;/li&gt;

    &lt;li&gt;
        &lt;a href="http://www.netlock.net/"&gt;NetLock NCA TWS és NLCAPI3&lt;/a&gt;, mely feltehetően a NetLock különböző alkalmazásainak,
        mint pl. a &lt;a href="http://www.netlock.hu/mokka/"&gt;MOKKA&lt;/a&gt; magját képezi.
    &lt;/li&gt;

    &lt;li&gt;
        &lt;a href="http://www.egroup.hu/main/hu/sdx"&gt;E-Group SDX&lt;/a&gt;
        egy termékcsalád, mely tartalmaz szerver oldali és kliens oldali (van böngészőbe épülő változata is) aláíró
        modulokat.
    &lt;/li&gt;
&lt;/ul&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/6190185992411799485/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2008/12/minstett-elektronikus-alrs.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6190185992411799485'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/6190185992411799485'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/12/minstett-elektronikus-alrs.html' title='Minősített elektronikus aláírás'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-9136625273765151611</id><published>2008-11-30T23:41:00.009+01:00</published><updated>2010-09-18T00:43:57.354+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='JSP'/><title type='text'>Több táblázat egy oldalon Display tag-gel</title><content type='html'>A &lt;a href="http://displaytag.sourceforge.net"&gt;Display tag library&lt;/a&gt; az egyik leggyakrabban használt nyílt forráskódú JSP tag library táblázatok megjelenítésére. Az MVC architektúrális mintára épül. Annak ellenére, hogy a jelenleg legfrissebb 1.1.1-es verziót 2007 augusztus 15-én adták ki, elég jól tartja magát.
Képes a táblázatokkal kapcsolatos, legmacerásabban megvalósítható elvárásoknak eleget tenni, mint a rendezhetőség, lapozás, szűrés, csoportosítás, exportálás CSV, Excel és XML formátumokba. Szép XHTML kódot állít elő, fel van készítve a többnyelvűségre, és CSS-sel remekül formázható. A decorator tervezési mintát megvalósítva lehetőség van mind a táblázat, mind a cella XHTML kód generálásának befolyásolására.
Az egyik leggyakoribb kérdés vele kapcsolatban, hogy megvalósították-e, hogy az adatokat adatbázisból vegye. Erre a válasz konkrétan, hogy nem, hiszen a Display tag library alapvető feladata a megjelenítés, hogy a mögötte lévő modell hogy áll elő, az már a programozó dolga. Emiatt a lapozást is úgy szeretnénk megoldani, hogy az adatbázisból csak a megfelelő rekordokat kérdezzük le, magunknak kell megoldani.
Alapból nem támogatja az AJAX-ot, de lehet találni fejlesztéseket ezzel kapcsolatban, többek között az &lt;a href="http://ajaxtags.sourceforge.net/"&gt;AjaxTags&lt;/a&gt;, vagy egy &lt;a href="http://blog.xebia.com/2007/12/10/how-to-make-displaytag-ajax-enabled-using-dwr/"&gt;DWR alapú megoldás&lt;/a&gt;, vagy &lt;a href="http://raibledesigns.com/rd/entry/the_future_of_the_displaytag"&gt;AjaxAnywhere-rel&lt;/a&gt;.
Már az 1.0-ás verzió is képes volt arra, hogy egy oldalon több táblázatot jelenítsen meg, és a lapozást, rendezést és exportálást külön kezelni mindkét táblázat esetén. Ehhez semmi mást nem kell tenni, mint hogy a táblázatnak különböző id-t adunk. Az id attribútum szolgál arra, hogy a táblázatnak azonosítót adjunk, valamint ez jelöli annak a változónak a nevét, mellyel a táblázat soraira hivatkozunk.
Képzeljük el azonban, hogy mi egy tag állományban szeretnénk a táblázat generálását elhelyezni, és egy oldalon többször is meghívni. A táblázat oszlopán belül mivel valami műveletet szeretnénk végezni még az oszlop értékkel (pl. linkben használni), a column tag törzsén belül használjuk, és nem attribútumként adjuk meg. A megoldás lehet a következő:
&lt;pre class="brush: xml"&gt;
&amp;lt;%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&amp;gt;
&amp;lt;%@taglib uri="http://displaytag.sf.net" prefix="display" %&amp;gt;
...
&amp;lt;%@attribute name="element" required="true" type="java.util.List"%&amp;gt;
...
&amp;lt;display:table name="${elements}" id="element"&amp;gt;
  &amp;lt;display:column&amp;gt;
    &amp;lt;c:url var="url" value="/element"&amp;gt;
      &amp;lt;c:param name="id" value="${element.id}" /&amp;gt;
    &amp;lt;/c:url&amp;gt;
    &amp;lt;a href="${url}"&amp;gt;${element.name}&amp;lt;/a&amp;gt;
  &amp;lt;/display:column&amp;gt;
&amp;lt;/display:table&amp;gt;
&lt;/pre&gt;
Ez azonban nem jó megoldás akkor, ha egy oldalon több táblázatot akarunk megjeleníteni, hiszen a táblázat id-ja minden esetben az element lesz. Erre való azonban az uid paraméter, amit az id helyett használunk, ugyanis ezzel adhatunk meg id-ként EL kifejezést. Adjuk meg ez a nevet is tableId paraméterként a tag-nek (opcionális, csak akkor használjuk, ha tényleg több táblázatot akarunk használni egy oldalon). Ekkor azonban a sort tartalmazó változó értéke nem element lesz, hanem a ${tableId} EL kifejezés értéke. Így erre a következő módon kell hivatkoznunk: pageScope[tableId].
A helyes kód tehát ez lehet:
&lt;pre class="brush: xml"&gt;
&amp;lt;%@taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&amp;gt;
&amp;lt;%@taglib uri="http://displaytag.sf.net" prefix="display" %&amp;gt;
...
&amp;lt;%@attribute name="element" required="true" type="java.util.List"%&amp;gt;
&amp;lt;%@attribute name="tableId" required="false" type="java.lang.String"%&amp;gt;
...
&amp;lt;c:if test="${tableId == null}"&amp;gt;
  &amp;lt;c:set var="tableId" value="element" /&amp;gt;
&amp;lt;/c:if&amp;gt;
&amp;lt;display:table name="${elements}" uid="${tableId}"&amp;gt;
  &amp;lt;display:column&amp;gt;
    &amp;lt;c:url var="url" value="/element"&amp;gt;
      &amp;lt;c:param name="id" value="${pageContext[tableId].id}" /&amp;gt;
    &amp;lt;/c:url&amp;gt;
    &amp;lt;a href="${url}"&amp;gt;${pageContext[tableId].name}&amp;lt;/a&amp;gt;
  &amp;lt;/display:column&amp;gt;
&amp;lt;/display:table&amp;gt;
&lt;/pre&gt;</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/9136625273765151611/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2008/11/tbb-tblzat-egy-oldalon-display-tag-gel.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/9136625273765151611'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/9136625273765151611'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/11/tbb-tblzat-egy-oldalon-display-tag-gel.html' title='Több táblázat egy oldalon Display tag-gel'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5490890653937846270</id><published>2008-11-29T15:15:00.005+01:00</published><updated>2012-04-29T11:53:41.067+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Community'/><title type='text'>JavaOne 2007 - 2008 témák</title><content type='html'>Még a Számalk konferenciára készítettem egy programot, mely letölti a 2007-es és 2008-as JavaOne előadásainak bevezetőit, és a Java technológiával kapcsolatos kulcsszavakat kigyűjti, és címke felhőként megjeleníti (a méret a zárójelen belüli számtól függ, amely azt jelzi, hogy az adott szó hány előadás anyagában fordult elő). Persze ez nem lehet pontos, de trendeket megmutathat. Mindenki vonja le magának a következtetéseket. 
&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_czKgycLvmNo/STFQqHP8nqI/AAAAAAAACVE/xOt0KshmykQ/s1600-h/javaone_osszehasonlitas.png"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 400px; height: 395px;" src="http://4.bp.blogspot.com/_czKgycLvmNo/STFQqHP8nqI/AAAAAAAACVE/xOt0KshmykQ/s400/javaone_osszehasonlitas.png" alt="" id="BLOGGER_PHOTO_ID_5274085323058224802" border="0" /&gt;&lt;/a&gt;A képre kattintva megjelenik nagyobban.</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/5490890653937846270/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2008/11/javaone-2007-2008-tmk.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/5490890653937846270'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/5490890653937846270'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/11/javaone-2007-2008-tmk.html' title='JavaOne 2007 - 2008 témák'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><media:thumbnail xmlns:media='http://search.yahoo.com/mrss/' url='http://4.bp.blogspot.com/_czKgycLvmNo/STFQqHP8nqI/AAAAAAAACVE/xOt0KshmykQ/s72-c/javaone_osszehasonlitas.png' height='72' width='72'/><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2397947430693517402</id><published>2008-11-28T20:06:00.004+01:00</published><updated>2008-11-28T23:13:21.532+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='Oracle'/><title type='text'>Oracle Fusion Middleware</title><content type='html'>A felvásárlások miatt lassan a legtöbb Java termék mögött (akár ingyenes is!) néhány multi áll, érdemes nyomon követni ezek termékstruktúráját.
Mivel úgy is át kell néznem az Oracle termékeit, írok egy rövid összefoglalót a 2008. október 9-én tartott &lt;a href="http://www.oracle.com/global/hu/events/20081009.html"&gt;Oracle Fusion Middleware Forum&lt;/a&gt; rendezvényről, melynek apropója az volt, hogy az Oracle felvásárolta a BEA Systems-t, és előadások hangoztak el a címben szereplő fogalomról, valamint a felvásárlás következményeiről.
Az Oracle Fusion Middleware nem egy termék, hanem bizonyos Oracle termékek összefoglaló neve, melyek magukban foglalnak Java EE-re épülő termékeket és fejlesztőeszközöket, integrációs, folyamatvezérlő, üzleti intelligencia, csoportmunka és tartalomkezelő megoldásokat. A cél szabványokon alapuló, egymással integrálható, un. hot-pluggable eszközök gyártása, melyek biztosítják, vagy könnyen beilleszthetőek a SOA architektúrába. Az egységesítés következményeképp csökkenhetnek az üzemeltetési költségek, javulhat a terméktámogatás.
A felvásárlás miatt azonban lehetnek konkurens termékek, és emiatt a következő szempontok szerint kategóriákra osztották ezeket: mennyire illik bele a jelenlegi architektúrába, mennyire támaszkodik szabványokra, mekkora a piaci részesedése, és mennyire szolgálja ki az Oracle Applications elemeit. Ezek alapján a különböző termékeket három kategóriára bontották: stratégia termékek, konvergáló termékek és karbantartott termékek. A BEA termékek közül stratégiai termékeket azonnal, 12 - 18 hónapon belül integrálják, ezek főleg azok, melyek nagyon befutottak, vagy nincs Oracle-ös megfelelője, a konvergáló termékeket nem fejlesztik akkora ütemben, de folyamatosan integrálják, és 9 évig biztosítják a fejlesztést és követést, valamint a karbantartott termékek azon termékek lettek, melyeket már a BEA a felvásárlás előtt leállított, ezeknek a fejlesztése még 5 évig tart.
Az Oracle a következő csoportokra bontotta a Middleware termékpalettáját, egymásra épülve alulról felfelé:
&lt;ul&gt;&lt;li&gt;Grid kiszolgáló elemek&lt;/li&gt;&lt;li&gt;Alkalmazás szerver&lt;/li&gt;&lt;li&gt;SOA és folyamatirányítás&lt;/li&gt;&lt;li&gt;Tartalomkezelés&lt;/li&gt;&lt;li&gt;Üzleti intelligencia&lt;/li&gt;&lt;li&gt;Enterprise Performance Management&lt;/li&gt;&lt;li&gt;Felhasználói felület&lt;/li&gt;&lt;/ul&gt;Valamint mindezek mellett találhatóak a fejlesztőeszközök, menedzsment és felhasználó- és jogosultságkezelő rendszerek.
Ebben a bejegyzésben csak az infrastrukturális elemekkel foglalkozom, úgymint grid, alkalmazás szerver és fejlesztő eszközök, a SOA termékekről szóljon a következő bejegyzés.
Az infrastruktúra alapját a BEA JRockit JVM (mely a Sun JVM-nél gyorsabb működést, priorizált GC-t, és instrumentáció nélküli profile-t ígér), vagy valós rendszerekben a BEA JRockit Real Time adja. Megemlítésre került a BEA JRockit Liquid VM, mely virtualizációs környezetben megkerüli a virtuális operációs rendszert, így nagyobb hardver kihasználást biztosít. Az Oracle Coherence egy tranzakcionális, in-memory, több szerveren elosztott (akár 2000 szerverig is skálázható), transzparens adatréteg/grid (ezzel kapcsolatban egy meggyőző demó is volt). Jól alkalmazható second level cache-ként, webes alkalmazásoknál session szinkronizálásra, lekérdezések párhuzamosítására, vagy valós idejű eseményfigyelésre (Java-n kívül létezik .NET és C++ kliens is).
Az Oracle TopLink (11g verziója szeptember 22-én jött ki) nem csak egy JPA implementáció, hanem egyrészt támogat object-XML binding-ot is, valamint bizonyos entitások megjelölhetők úgy, hogy a Coherence tárolja őket, egyszerűen beillesztve így a grid architektúrába. Az Oracle átadta a TopLink forráskód egy részét a nyílt forráskódú közösségnek, ebből lett az EclipseLink projekt, melyet a JPA 2.0 referencia implementációjának válaszottak. A BEA Kodo-ról nem esett szó, de gondolom az Oracle TopLink mellett labdába sem rúghat.
A BEA WebLogic Server alkalmazás szerver lett a stratégiai termék, míg az Oracle OC4J pehelysúlyú konténer, valamint az erre épülő Oracle Application Server már csak konvergáló termék, számos komponensét már át is emeltek a BEA WebLogic Server-be.  A BEA WebLogic Server a RASP (Reliability, availability, scalability, performance) infrastruktúrára épít, Java EE 5 tanúsított, jellemzői a FastSwap (hot-deployment), a WS/SOA, RIA (Rich Internet Application) és OSS (open source software) támogatása. Menedzsment szempontból fontos, hogy a menedzsment teendőket tranzakciókba lehet foglalni, melyeket a végén érvényesíteni vagy visszavonni is lehet. A webes Administration Console-t ki is lehet bővíteni saját fejlesztéssel, valamint parancssorból is menedzselhető, Jython alapú script-ekkel. Kiegészíthető a WebLogic Operation Control-lal, mely biztosítja az adaptív, dinamikus erőforrás optimalizációt, ezzel az elvárt szolgáltatási szintet (SLA).
Fejlesztő eszközök és keretrendszerek közül az Oracle JDeveloper, Oracle ADF és az Oracle Enterprise Pack for Eclipse a stratégiai termék, az Oracle Forms &amp; Reports, BEA Workshop konvergáló termék, és a BEA Beehive-ról pedig már a BEA is letett, ezért karbantartott termék marad. Nem szerencsés, de az Oracle kijött egy szintén Beehive nevű csoportmunkát támogató keretrendszerrel, ami viszont stratégiai termék, nem szabad keverni a kettőt. A konferencián elhangzott, hogy a Java EE eszközöket a Oracle Enterprise Pack for Eclipse és Oracle JDeveloper J2EE Edition-be fogják pakolni, míg a SOA eszközöket a JDeveloper Studio Edition-be, mint régen. Azonban most letölthető Studio Edition-ben nincsenek SOA eszközök, J2EE Edition meg nem letölthető. Az Oracle ADF egy MVC architektúrán alapuló keretrendszer, Java EE fejlesztéshez, mely deklaratív megközelítése miatt lehetővé teszi a RAD-ot (demóval - de ezzel a kódolás nélküli klikkelgetős alkalmazás fejlesztéssel mindig fenntartásaim vannak - a RAD Delphi-ig működött).
Menedzsmentre természetesen marad a bevált Oracle Enterprise Manager. A model, controller és view réteg is tetszőlegesen választható a &lt;a href="http://en.wikipedia.org/wiki/Oracle_ADF"&gt;különböző technológiákból&lt;/a&gt;. Segíti a RIA fejlesztést, pl. az Apache MyFaces Trinidad projekten alapuló komponensekkel.
Java programozók számára kevésbé érdekes, de fontos termék a C, C++ és Cobol programok elosztott tranzakciókezeléséért felelős BEA Tuxedo Transaction Processing Platform.
A konferencia előtt két nappal jelent meg az Oracle JDeveloper és Oracle ADF 11g végleges verziója, mely már az Oracle WebLogic Server 10g (10.3)-t tartalmazza.</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/2397947430693517402/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2008/11/oracle-fusion-middleware.html#comment-form' title='2 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2397947430693517402'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/2397947430693517402'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/11/oracle-fusion-middleware.html' title='Oracle Fusion Middleware'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>2</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4401397981590625894</id><published>2008-11-27T00:20:00.003+01:00</published><updated>2008-11-27T01:31:11.962+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='SOA'/><title type='text'>Web szolgáltatásokkal kapcsolatos szabványok</title><content type='html'>Az előző bejegyzésben is említett integrációs projekt során definiálni kell a partner rendszerek felé, hogy milyen protokollon és milyen formában szeretnénk velük kommunikálni. Az ember hajlamos lenne könnyedén elintézni, hogy web szolgáltatásokkal, de ennél azonban egy kicsit többre van szükség.
Biztos mindenki számára ismert, hogy a web szolgáltatások környékén előfordulő bűvszavak, és azok jelentése: XML, SOAP, WSDL és UDDI. Nem is ismertetném ezeket, csak néhány szót róluk. Leggyakrabban a web szolgáltatások XML formátumú dokumentumokat várnak, és ilyent adnak vissza. A SOAP egy XML alapú kiterjeszthető boríték formátumot definiál, a WSDL egy szintén XML alapú interfész leíró nyelv, és nagyobb rendszereknél alkalmazott szolgáltatás tárak egy része XML alapú UDDI használatával is megszólítható. Ezen leírások mindegyikét a W3C tartja karban.
A SOAP &lt;a href="http://www.w3.org/TR/2000/NOTE-SOAP-20000508/"&gt;1.1&lt;/a&gt;-es verziója specifikációként használható, míg az &lt;a href="http://www.w3.org/TR/2007/REC-soap12-part0-20070427/"&gt;1.2&lt;/a&gt;-es 2003. június 24-én vált ajánlássá, majd kijött azóta a 2. kiadása is. A két verzió között akkora lényegi &lt;a href="http://www.idealliance.org/papers/xmle02/dx_xmle02/papers/02-02-02/02-02-02.html"&gt;különbség&lt;/a&gt; nincs, pl. a Simple Object Access Protokol elnevezést váltották le, ugyanis félrevezető, a rövidítést azonban megtartották.
A WSDL-ből is az 1.1-es verzió a széles körben támogatott hivatalos szabvány, míg a &lt;a href="http://www.w3.org/TR/wsdl20/"&gt;2.0&lt;/a&gt;-ás csupán ajánlás.
Azonban ezek a szabványok alapban nem biztosítják azt, hogy a szabvány alapján implementált web szolgáltatás keretrendszerek egymással együttműködjenek. Így neves gyártók részvételével létrejött a &lt;a href="http://www.ws-i.org"&gt;WS-Interoperability&lt;/a&gt; szervezet, melynek feladata olyan metodológiák, specifikációk, tesztesetek kialakítása, melyek használatával tényleg együttműködő web szolgáltatásokat lehet implementálni.
A WS-I un. &lt;a href="http://www.ws-i.org/deliverables/matrix.aspx"&gt;profilokkal&lt;/a&gt; dolgozik, melyek egy specifikáció halmazt írnak le, valamint a specifikációkhoz kapcsolódó megszorításokat, pontosításokat és a félreértések elkerülését biztosító tisztázó magyarázatokat. Ebből a legelterjedtebb a Basic Profile 1.1 (BP), mely a SOAP 1.1, WSDL 1.1 és UDDI 2 specifikációkat pontosítja. A BP 1.0 és 1.1 közötti egyetlen lényeges különbség, hogy a SOAP perzisztálásával és kötésével (binding) kapcsolatos pontosításokat átemelték egy új, Simple SOAP Binding Profile 1.0 profilba. A csatolmányokkal külön, az Attachments Profile 1.0 foglalkozik, mely a SOAP Messages with Attachments W3C szabványt pontosítja, mely a SOAP 1.1 átvitelét definiálja MIME multipart mechanizmussal. A BP 2.0 már a SOAP 1.2-őt veszi alapul.
Ezek alapján biztosított, hogy amelyik web szolgáltatás implementáció rendelkezik az említett profilokkal, az együtt fog működni az ugyanazon profilokat biztosító más implementációkkal. A Glassfish Metro keretében fejlesztett, a JDK-hoz is csatolt JAX-WS referencia implementáció (mely a JSR 224 RI-ja) megvalósítja a Basic Profile 1.1, Simple SOAP Binding Profile 1.0 és az Attachments Profile 1.0 profilokat. Ugyanígy több Java-s keretrendszer, valamint az ASP .NET 2.0 is.
Itt érdemes még megemlíteni azt is, hogy a SOAP több lehetőséget biztosít a SOAP törzs leírására. Az első lehetőség az RPC stílusú leírás, mely a távoli metódushíváshoz hasonló, ahol definiálni kell a hívott metódust, a paramétereket, visszatérési értéket, hibákat. Második lehetőség a dokumentum típusú (Document), ahol tetszőleges XML adat szerepelhet.
Az üzenet kódolása is fontos szempont, ami megmondja az adattípusokat, melyeket a SOAP törzsben használhatunk. Egyik kódolás a literál kódolás (Literal), ahol az adattípusokat egy XML sémával adjuk meg, másrészt a SOAP kódolás (SOAP encoded/encoded), amikor nem kell XML sémának megfelelni, és a SOAP-ban definiált típusokat használhatjuk. 
A két stílus és két kódolás tetszőlegesen keverhető, de amennyiben SOA-t szeretnénk felépíteni, javasolt a document/literal párosítás használata. Interfész egyeztetésnél ezt is definiálni kell.
Javasolt még megállapodni az átviteli protokollban. A SOAP esetében a leggyakoribb átviteli protokoll a HTTP(S), a SOAP szabvány ugyan megemlíti, hogy más is használható, de csak a HTTP(S)-t részletezi. A SOAP bírálói között sokan kritizálják, hogy túl absztraktra sikerült, és felesleges volt ennyire elválasztani a borítékot a protokolltól, és a RESTful web szoltáltatások esetén a kettő kicsit közelebb esik egymáshoz, így csökken a komlexitás. De ez már egy másik történet...</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/4401397981590625894/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2008/11/web-szolgltatsokkal-kapcsolatos.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4401397981590625894'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/4401397981590625894'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/11/web-szolgltatsokkal-kapcsolatos.html' title='Web szolgáltatásokkal kapcsolatos szabványok'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5100550635715090597</id><published>2008-11-26T23:58:00.004+01:00</published><updated>2008-11-28T12:07:15.587+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='SOA'/><title type='text'>Kapcsolat Lotus Domino szerverrel</title><content type='html'>Egy integrációs projekt során kell egy Lotus Domino 7.0.1 környezetben implementált alkalmazáshoz kapcsolódni, gyakorlatilag dokumentumot kell neki beküldeni, valamint adatot fogadni. Ennek kapcsán utánanéztem, hogy hogyan is épül fel.
A Lotus Notes egy kliens-szerver alkalmazás, csoportmunkára. Támogatja levelezést, van benne naptár, névjegyalbum, todo lista, valamint dokumentum kezelés, és integrálták a legújabb web 2.0-ás felfedezésekkel is, mint wiki, RSS, valamint rendelkezik CRM és HelpDesk alkalmazásokkal is. Ezen kívül egy alkalmazás platform is, melyeken ilyen típusú alkalmazásokat lehet fejleszteni. Szervere a Lotus Notes Server volt, melyet később átneveztek IBM Lotus Domino-ra.
Segítségével keresztplatformos, elosztott, dokumentum orientált adatbázison és üzenetkezelő keretrendszeren alapuló alkalmazásokat lehet fejleszteni RAD eszközzel (Domino Designer), és rendelkezik API-val is, melyet több nyelven is el lehet érni. A Lotus Domino-t C, C++ és Java nyelveken implementálták, és támogatja a Formula, LotusScript, Java, JavaScript, C és C++ nyelveket, valamint egy XML alapú Domino XML Language-t.
A Java-t már a 4.5-ös verzió, majd később az 5-ös verzió is támogatta, de a 7-es verzióban vezették be a Java 1.4.2 támogatását, és került bele egy Java debugger is. Szintén a 7-es újítása (2005 aug.), hogy web service design element-eket lehet fejleszteni, amivel web szolgáltatásokat lehet fejleszteni, Java és LotusScript nyelveken. A &lt;a href="http://www.ibm.com/developerworks/lotus/library/nd7-webservices/"&gt;web szolgáltatás fejlesztés folyamata&lt;/a&gt; indulhat WSDL-ből és Java/LotusScript nyelvből is, a kettőt szinkronban tudja tartani. A SOAP 1.1 és WSDL 1.1 szabványt támogatja. A 8-as Lotus Notes (2007. aug. - jelenleg legfrissebb) kliens legnagyobb újdonsága, hogy megváltoztatták a felhasználói interfészt, és a Lotus Notes Expeditor-ra építették, ami Eclipse alapú.
A Lotus Domino alatti adatbázis egy dokumentum alapú adatbázis un. Notes Storage Facility (NSF), mely note-okat tartalmaz, és azokhoz item-eket. Ez nem relációs, és nem is normalizált adatbázis, így ebből a szempontból jobban hasonlít az XML, vagy oo alapú adatbázisokhoz. A mezőknél még típust sem kell definiálni, szabadon lehet felvenni. A 7-es verziótól kezdve azonban perzisztens tárolónak lehet az IBM DB2-őt is választani, ez view-kat biztosít az SQL lekérdezésekhez.
Ezek alapján első körben megpróbálkozunk a web szolgáltatással történő integrációval, a további tapasztalatokról hírt adok.</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/5100550635715090597/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2008/11/kapcsolat-lotus-domino-szerverrel.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/5100550635715090597'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/5100550635715090597'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/11/kapcsolat-lotus-domino-szerverrel.html' title='Kapcsolat Lotus Domino szerverrel'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8524503525872181202</id><published>2008-11-24T21:29:00.009+01:00</published><updated>2010-09-18T00:44:52.836+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><category scheme='http://www.blogger.com/atom/ns#' term='JSP'/><title type='text'>Szöveges állomány generálása JSP-vel</title><content type='html'>A közelmúltban azt a feladatot kaptam, hogy szöveges állományt generáljak ki egy webes alkalmazással, mely formátuma plain text, azaz nem a leggyakrabban használt XML vagy (X)HTML formátum. Ráadásul formázott plain text, azaz pontosan meghatározott, hogy mit és hova, hány karakterre kell írni.
A web alkalmazás a megjelenítési rétegben a JSP view technológiát használja. A következő megoldások jöttek szóba:
&lt;ul&gt;&lt;li&gt;Servlet&lt;/li&gt;&lt;li&gt;JSP&lt;/li&gt;&lt;li&gt;Velocity&lt;/li&gt;&lt;li&gt;Utófeldolgozás servlet filter segítségével
&lt;/li&gt;&lt;/ul&gt;Ami a fejtörést okozta, hogy sem a JSP, sem a Velocity használatával nem lehet egzakt módon megadni a whitespace-ek kezelését. Persze ez oda vezet vissza, hogy ezek a nyelvek elsősorban az XML és (X)HTML formátumokra lettek kitalálva, ahol a whitespace-eket kellő hanyagsággal lehet kezelni, hiszen a böngésző feldolgozáskor a közvetlen egymás mögött álló whitespace sorozatot egy whitespace karakterre cseréli. A JSP specifikáció is úgy definiálja, hogy az XML-ben meghatározott whitespace kezelést kell követni. Mindig zavart, hogy szöveg generálására kitalált template engine-ekben mért nem lehet trükközés nélkül a whitespace karaktereket kezelni, gondoltam, utánajárok.
A felsorolt technológiák közül az alkalmazásban már szerepelt a servlet-ben megvalósított implementáció, de a több oldalon keresztül húzódó, különböző metódusokba szétszórt out.println(); és out.printf(); utasítások tömege visszatetszést keltett. Használjunk hát template engine-t, de minek válasszunk egy újat (Velocity - melyekkel szintén kétes élményeim voltak whitespace ügyben), ha már az alkalmazásunkban úgy is szerepel a JSP technológia.
Első ötletet hamar elvetettem, amit már a Velocity esetében is használtam, hogy úgy kell elhelyezni a megjegyzéseket, hogy közvetlenül két tag közé, és akkor, mivel ezeket a JSP fordító úgyis figyelmen kívül hagyja, megvan az általam kívánt működés. A megoldás működik is, de a szépérzékemet bántotta.
A következő felfedezés a JSP 2.1-ben bevezetett trimDirectiveWhitespaces nevű direktívája volt, mely hatására a kimenetben nem szerepelnek a felesleges whitespace karakterek. (A fejlesztői közösség kérte, hogy a felesleges whitespace-ek eltávolításával a sávszélesség felhasználás csökkenjen - erre eddig formázó filtereket használtak, ami azért erőforrás igényesebb művelet, vagy közvetlen a JSP-re engedték rá telepítés/fordítás előtt. Erre remek eszköz a &lt;a href="http://jtidy.sourceforge.net/"&gt;JTidy&lt;/a&gt;, melyet Java-ból hívhatunk.) Természetesen a direktíva hatására nem az összes whitespace kerül eltávolításra, hanem a a tag végétől a következő hasznos karakterig szereplő whitespace-ek. Azaz ha egy szó közé több whitespace karaktert teszünk, azok megmaradnak.
Mivel az alkalmazás lokalizált, ezért szöveg nem is szerepelt a JSP-ben, minden csak a c:out és fmt:message standard tag-ekkel került kiírásra, a legenerált szöveg gyakorlatilag egy sorba került.
A következő meglepetés ott ért, hogy a JSP specifikáció egyértelműen leírja, hogy nem lehet speciális karaktereket, pl. \n escape szekvenciát használni a JSP oldalakban. Egyedül a \', \" és \\ escape szekvenciák megengedettek, de nekem sem a NetBeans, sem a Tomcat nem fogadta el ezeket sem. A specifikáció javasolja, hogy ilyenkor Java kódot alkalmazzunk. A &amp;lt;% out.println("\n"); %&amp;gt; scriptlet nem nyerte el a tetszésem, hiszen sosem alkalmazok JSP-ben scriptlet-et, így egy egyszerű JSP függvényt definiáltam, mellyel egy sortörést lehet kiírni. Ezen kívül definiáltam egy függvényt, mely a háttérben a printf metódust hívja. Ilyen JSP-ben nincs, és mivel a printf függvénnyel lehet pl. megadott mezőhosszra szöveget kiíratni, és azon belül is jobbra, valamint balra helyezni azt, szintén tökéletes a whitespace-ek explicit kezelésére, lsd. a &lt;a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Formatter.html"&gt;Formatter&lt;/a&gt; osztályt.
A függvény kódja:
&lt;pre class="brush: java"&gt;
package jtechlog;

import java.io.PrintWriter;
import java.io.StringWriter;

public class Functions {
 public static String br() {
     return "\r\n";
 }

 public static String printf(String format, String param) {
     StringWriter sw = new StringWriter();
     PrintWriter pw = new PrintWriter(sw);
     pw.printf(format,  param);
     return sw.toString();
 }
}
&lt;/pre&gt;
Eztán már csak a következő részt kellett elhelyezni a TLD állományban:
&lt;pre class="brush: xml"&gt;
&amp;lt;function&amp;gt;
&amp;lt;description&amp;gt;Line break.&amp;lt;/description&amp;gt;
&amp;lt;name&amp;gt;br&amp;lt;/name&amp;gt;
&amp;lt;function-class&amp;gt;jtechlog.Functions&amp;lt;/function-class&amp;gt;
&amp;lt;function-signature&amp;gt;java.lang.String br()&amp;lt;/function-signature&amp;gt; 
&amp;lt;/function&amp;gt;

&amp;lt;function&amp;gt;
&amp;lt;description&amp;gt;Printf.&amp;lt;/description&amp;gt;
&amp;lt;name&amp;gt;printf&amp;lt;/name&amp;gt;
&amp;lt;function-class&amp;gt;jtechlog.Functions&amp;lt;/function-class&amp;gt;
&amp;lt;function-signature&amp;gt;java.lang.String printf(java.lang.String, java.lang.String) &amp;lt;/function-signature&amp;gt; 
&amp;lt;/function&amp;gt;
&lt;/pre&gt;
Így két függvényt is kaptam, mellyel egzakt módon tudom a whitespace karaktereket befolyásolni. Egyrészt a &amp;lt;c:out "${jtechlog:br()}" /&amp;gt; sorral tudok sortörést elhelyezni, valamint a &amp;lt;c:out value="${jtechlog:printf('%1$-14s', '')}" /&amp;gt; sorral tudok egy szöveget 14 karakteren kiírni, balra igazítva, ahol ha a szöveg kisebb, mint 14 karakter, kiegészíti még szóközökkel (padding). Ezen kívül a JSP-t is tetszőlegesen formázhatom.</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/8524503525872181202/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2008/11/szveges-llomny-generlsa-jsp-vel.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/8524503525872181202'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/8524503525872181202'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/11/szveges-llomny-generlsa-jsp-vel.html' title='Szöveges állomány generálása JSP-vel'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1611871855906973383</id><published>2008-11-24T21:12:00.004+01:00</published><updated>2008-11-24T23:01:57.198+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#post'/><title type='text'>Újraindulás</title><content type='html'>Ezennel újra elindítom a kb. öt éve szunnyadó blogomat, JTechLog névvel, melyet 2002. november 19-én indítottam, és 2003. november 21-én hagytam abba. A téma marad ugyanaz, a Java programozási nyelv, és hozzá kapcsolódó elméleti ismeretek és gyakorlati tapasztalatok, szabványok, technológiák, ingyenes és kereskedelmi termékekkel kapcsolatos impulzusok.
Blogom hőskorában még statikus HTML oldalba írtam a bejegyzéseket, most már haladva a korral, mindenféle válogatás nélkül a Blogger szolgáltatást választottam.
A blog stílusán nem szeretnék változtatni, hosszabb, egy témát alaposan körüljáró bejegyzéseket szeretnék írni. Ez több munkával jár, emiatt lehet, hogy ritkábban is jelentkezem. A blogot saját használatra is írom, így lehet, hogy több téma számotokra érdektelen lesz, de én fontosnak látom megírni, hogy később, ha újra belefutok a problémába, visszakereshessem a megoldást.
A blogot nem kezdem el még reklámozni, egyelőre saját okulásomra és szórakoztatásomra írom, teljesen puritán megjelenéssel, de amennyiben kitartó leszek, mind a megjelenítésére, mind a terjesztésére több hangsúlyt fogok fektetni.</content><link rel='replies' type='application/atom+xml' href='http://www.jtechlog.hu/feeds/1611871855906973383/comments/default' title='Megjegyzések küldése'/><link rel='replies' type='text/html' href='http://www.jtechlog.hu/2008/11/j-induls.html#comment-form' title='0 megjegyzés'/><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1611871855906973383'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/posts/default/1611871855906973383'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/11/j-induls.html' title='Újraindulás'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:total>0</thr:total></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.page-7042809002956016193</id><published>2014-03-28T23:21:00.000+01:00</published><updated>2014-03-28T23:21:31.277+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#page'/><title type='text'>Online jelenlét</title><content type='html'>&lt;p&gt;Végre sikeresen rendbe tettem a munkafolyamataimat, és az általam megosztott információkat. Követelmény volt, hogy alapvetően engem szolgáljon, azaz bármilyen információt könnyen vissza tudjak keresni, de mással is meg tudjam osztani, és közben el tudjam különíteni a Java-s (erre a blogra is publikált) és a személyes tartalmakat. Nézzük, milyen szolgáltatásokat is használok, és mire. Remélem másnak is ad egy-két ötletet, hiszen ezeket használva mindennek megvan a maga helye.&lt;/p&gt;

&lt;p&gt;Amennyiben RSS-en akarsz követni, két lehetőséged van:&lt;/p&gt;

&lt;p&gt;&lt;a href="http://feeds2.feedburner.com/JTechLog"&gt;JTechLog blog RSS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://feeds.feedburner.com/viczianijava"&gt;Java tartalmak, összes szolgáltatás - RSS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Használt webes szolgáltatásokról részletesen:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JTechLog a Blogger-en: itt jelennek meg a hosszabb, kidolgozott cikkek. (&lt;a href="http://jtechlog.blogspot.com/"&gt;web&lt;/a&gt;, &lt;a href="http://feeds2.feedburner.com/JTechLog"&gt;RSS&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;JTechLog szösszentek a Blogger-en: ide írom a munka közben talált megoldásokat, melyek később is jól jöhetnek. Olyan rövid cikkek, írások kerülnek ide, amiket nem akarok bővebben kifejteni a JTechLog-on, csak leírni, hogy legközelebb ne kelljen keresgetni. A "java" tag alatt vannak a Java-val kapcsolatos dolgok. Régebben Tumblr-t használtam, de nagyon sok problémám volt vele. (&lt;a href="http://jtechlogext.blogspot.com/"&gt;web&lt;/a&gt;, &lt;a href="http://www.jtechlogext.blogspot.com/feeds/posts/default?alt=rss"&gt;RSS&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Twitter: rövid, SMS hosszúságú rövid üzenetek, melyek épp az aktuális tevékenységemet, bosszúságomat vagy felfedezett dolgot tartalmazza. Vagy olyan cikkek, melyet elég egyszer elolvasni, de másnak hasznos lehet. Általában Java-val kapcsolatos, vagy ahhoz közeli dolgokról írok. A webes és mobilos felületét is használom. (&lt;a href="http://twitter.com/vicziani"&gt;web&lt;/a&gt;, &lt;a href="http://twitter.com/statuses/user_timeline/28844467.rss"&gt;RSS&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Delicious: könyvjelzők, olyan cikkek, melyek később még jól jöhetnek. A "java" tag alatt vannak a Java-val kapcsolatos dolgok. A Delicious Extension Firefox Add-on-t használom. (&lt;a href="http://delicious.com/vicziani"&gt;web&lt;/a&gt;, &lt;a href="http://feeds.delicious.com/v2/rss/vicziani?count=15"&gt;RSS&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;GitHub: forráskódok tárolására és megosztására. (&lt;a href="https://github.com/vicziani"&gt;web&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;LinkedIn: szakmai önéletrajz. (&lt;a href="http://www.linkedin.com/profile/view?id=67382971&amp;trk=tab_pro"&gt;web&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A FeedBurner a feed-eket proxy-zza, és statisztikát készít, hogy mennyien olvasnak.&lt;/p&gt;</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/pages/default/7042809002956016193'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/pages/default/7042809002956016193'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/p/online-jelenlet.html' title='Online jelenlét'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.page-4999407689300825792</id><published>2014-01-06T23:31:00.000+01:00</published><updated>2014-01-06T23:31:55.957+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#page'/><title type='text'>Források</title><content type='html'>&lt;p&gt;Magyar nyelvű tartalmak&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://dpc.hu/blog/hu/java.xml"&gt;DPC Consulting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://epam-debrecen.blogspot.com/"&gt;EPAM Systems Kft. - Debreceni iroda&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.anzix.net"&gt;Home :: blog.anzix.net&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://hup.hu/taxonomy/term/155/0"&gt;HUP - Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://iwillworkforfood.blogspot.com/"&gt;I will work for food&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://infokukac.com/"&gt;info@&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://infnav.blogspot.com/"&gt;Informatikai Navigátor Magazin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://wiki.javaforum.hu"&gt;Java Forum RSS Feed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jpattern.blogspot.com/"&gt;java’nother blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://juex.blog.hu"&gt;JUzer EXpiriensz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://juzraai.blogspot.com/"&gt;juzraai blogja&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://kodzaj.blog.hu"&gt;Kódzaj&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://lorands.com"&gt;Lóránd Somogyi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://seamplex.blogspot.com/"&gt;Seamplex&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://szimijava.blogspot.com/"&gt;Szimeonov György Java blogja&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://tifyty.wordpress.com"&gt;tifyty&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.webstar.hu"&gt;Webstar Blog | Webstar Csoport Kft. blogja&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Angol nyelvű tartalmak&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.adam-bien.com/roller"&gt;Adam Bien&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.artima.com/spotlight/"&gt;Artima Developer Spotlight&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.artima.com/weblogs/"&gt;Artima Weblogs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.arungupta.me"&gt;Arun Gupta, Miles to go …&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://bigjavablog.blogspot.com/"&gt;Big Java Blog by szpetip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://previous.delicious.com/OracleTechnologyNetwork/otnheadlines"&gt;Delicious/OracleTechnologyNetwork/otnheadlines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.developer.com"&gt;Developer.com Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.devwebpro.com"&gt;DevWebPro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.dzone.com/links/tag/java.html"&gt;dzone.com: java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.eisele.net/"&gt;Enterprise Software Development with Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blogs.oracle.com/hinkmond/"&gt;Hinkmond Wong’s Weblog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.ibm.com/developerworks/"&gt;IBM developerWorks : Java technology&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.infoq.com"&gt;InfoQ Personalized Feed for Unregistered User - Register to upgrade!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.javacodegeeks.com"&gt;Java Code Geeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://java.dzone.com/"&gt;Javalobby - The heart of the Java developer community&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://javarevisited.blogspot.com/"&gt;Javarevisited&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.javaworld.com"&gt;JavaWorld - Featured Articles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jaxenter.com/feed//rss"&gt;JAXenter - All-Inclusive Feed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://planet.jboss.org/view/all"&gt;JBoss&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.jetbrains.com/idea"&gt;JetBrains IntelliJ IDEA Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://kohsuke.org"&gt;Kohsuke Kawaguchi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://martinfowler.com"&gt;Martin Fowler’s Bliki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mechanical-sympathy.blogspot.com/"&gt;Mechanical Sympathy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://netbeans.org/index.html"&gt;NetBeans Highlights&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://nighthacks.com/roller/jag/"&gt;On a New Road&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blogs.oracle.com/otn/"&gt;Oracle Technology Network Blog (aka TechBlog)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://oreilly.com/java/"&gt;O’Reilly News: Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://patrikvarga.blogspot.com/"&gt;Patrik Varga’s Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://patrikvarga.blogspot.com/"&gt;Patrik Varga’s Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.programcreek.com"&gt;ProgramCreek.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://raibledesigns.com/rd/"&gt;Raible Designs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://server.dzone.com/"&gt;Server Zone - Everything for the server-side developer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.sonatype.com"&gt;Sonatype Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.springsource.org"&gt;Spring&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://spring.io/blog"&gt;SpringSource Team Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blogs.oracle.com/java/"&gt;The Java Source&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.javaspecialists.eu"&gt;The Java(tm) Specialists’ Newsletter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mreinhold.org/blog/"&gt;There’s not a moment to lose!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.theserverside.com"&gt;TheServerSide : Thread List - News&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/pages/default/4999407689300825792'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/pages/default/4999407689300825792'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/p/forrasok.html' title='Források'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.page-7745062515757888006</id><published>2011-04-29T22:19:00.000+02:00</published><updated>2012-01-14T23:00:01.603+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#page'/><title type='text'>A blogról</title><content type='html'>&lt;p&gt;Viczián István vagyok, Java fanatikusként fejlesztek, oktatok, blogot írok és rendezvényeket szervezek. 1998 óta foglalkozom objektumorientált programozással és szoftverfejlesztéssel
foglalkozom, kiemelt szakterületem a Java és Java EE alkalmazásfejlesztés, valamint a EAI és SOA technológiákat követem figyelemmel. Már az egyetemen Java összejövetelek szervezésében 
vettem részt, oktattam, és a diplomamunkámat is ezzel kapcsolatban írtam.
Vezető fejlesztőként, architektként dolgoztam/dolgozom kormányzati, banki és telekommunikációs fejlesztési projektekben. Korábban a Számalknál, most a &lt;a href="http://www.training360.com"&gt;Training360-nál&lt;/a&gt; Java-val
kapcsolatos oktatásokat tartok. Írom ezt a szakmai blogot JTechLog néven,  
valamint Java fejlesztői találkozók (&lt;a href="http://jum.javaforum.hu/"&gt;Java Users Meeting&lt;/a&gt;) megrendezésében segédkezem. Viszonylag
aktív tag vagyok a &lt;a href="http://www.javagrund.hu/mailman/listinfo/javalist"&gt;Java listán&lt;/a&gt; és a &lt;a href="http://www.javaforum.hu/javaforum"&gt;JavaForum&lt;/a&gt;-on.
Szabadidőmben sokat túrázok, próbálom felfedezni Magyarország rejtett kincseit. Rólam többet a &lt;a href="http://delfin.unideb.hu/%7Evicziani/"&gt;személyes honlapomon&lt;/a&gt; találsz.&lt;/p&gt;

&lt;p&gt;Minősítések:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sun Certified Java Programmer (SCJP)&lt;/li&gt;
&lt;li&gt;Java Platform, Enterprise Edition 6 Enterprise JavaBeans Developer&lt;/li&gt;
&lt;li&gt;Java Platform, Enterprise Edition 6 Java Persistence API Developer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2002 november 22-én indítottam el a JTechLog-ot, mellyel nem titkolt célom, hogy egy magyar nyelvű Java hírforrás legyen. Kötetlen stílusú napló, témája a Java platform, és hozzá kapcsolódó elméleti ismeretek és gyakorlati tapasztalatok, szabványok, technológiák, ingyenes és kereskedelmi termékekkel kapcsolatos impulzusok. Egy témát alaposan körüljáró bejegyzéseket szeretnék írni. Ez több munkával jár, emiatt lehet, hogy ritkábban is jelentkezem. A blogot saját használatra is írom, így lehet, hogy több téma számotokra érdektelen lesz, de én fontosnak látom megírni, hogy később, ha újra belefutok a problémába, visszakereshessem a megoldást.&lt;/p&gt;
&lt;p&gt;Amennyiben bármilyen ötleted, javaslatod van, vedd fel velem a kapcsolatot, hiszen nektek írom ezt a blogot, minden visszajelzés fontos a számomra.&lt;/p&gt;</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/pages/default/7745062515757888006'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/pages/default/7745062515757888006'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/p/blogrol.html' title='A blogról'/><author><name>István Viczián</name><uri>https://plus.google.com/115891152269405230539</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6645324556252105236</id><published>2008-12-17T23:21:00.000+01:00</published><updated>2008-12-17T23:21:54.678+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Hú, ez szerintem egy nagyon hasznos cikk, tényleg ...</title><content type='html'>Hú, ez szerintem egy nagyon hasznos cikk, tényleg nagyon megdöbbentőek és lehangolóak ezek az eredmények! Tök jó, hogy azonnal ilyen gyakorlati képpel tud találkozni ott egy csoport, ez értékes tudás, ha egy projekt előtt áll az ember, és eszközöket kell választania.&lt;BR/&gt;&lt;BR/&gt;Sohasem voltam J2EE párti, mindig inkább a Spring-es irányt éreztem jobbnak, magaménak, és mindamellett, hogy tudom, hogy szükség van rá (mármint a J2EE-re), most mégjobban megerősödött bennem a sima tomcat+spring iránti vonzalom. De nem mondom azt, hogy ez mindenre megoldás, korántsem.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/373733089556805930/comments/default/6645324556252105236'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/373733089556805930/comments/default/6645324556252105236'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/12/netbeans-65-s-glassfish-v2-ur2.html?showComment=1229552460000#c6645324556252105236' title=''/><author><name>Steve</name><uri>http://www.blogger.com/profile/13407946410017714787</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2008/12/netbeans-65-s-glassfish-v2-ur2.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-373733089556805930' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/373733089556805930' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1169922675'/><gd:extendedProperty name='blogger.displayTime' value='2008. december 17. 23:21'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1938491852225538</id><published>2008-12-18T00:10:00.000+01:00</published><updated>2008-12-18T00:10:40.904+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Az a baj, hogy a Java EE alapötlete, és a Java EE ...</title><content type='html'>Az a baj, hogy a Java EE alapötlete, és a Java EE 5 bevezetésével az egyszerűségre törekvés jegyében a szintaktikája is nagyon jó. Mivel támogatják a fejlesztőeszközök, emiatt sokkal egyszerűbb ezen elmagyarázni az AOP-t (interceptor-ok), IoC-t (wrapper osztályok), DI-t (@EJB annotáció JNDI lookup helyett), mint a Spring-en, ugyanis a lényegre koncentrálhatsz, az összes egyebet elvégzik a varázslók. Persze nincs benne annyi eszköz, mint a Spring-ben, emiatt nem is veszik el benne annyira a hallgató, gyártófüggetlen szabvány, és még a clusterezés is teljesen megoldott.&lt;BR/&gt;&lt;BR/&gt;De ezzel, hogy integrálva van az eszköz és az alkalmazásszerver, annyi hibalehetőség van, amit nem is tudnak a gyártók kifogástalanul megoldani, ezért a jó koncepciót elrontják hibás megvalósításokkal. Egy-két ilyen hiba után az ember tényleg eldobja az eszközt, és keres olyant, ahol a mintapéldák legalább jól működnek.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/373733089556805930/comments/default/1938491852225538'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/373733089556805930/comments/default/1938491852225538'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/12/netbeans-65-s-glassfish-v2-ur2.html?showComment=1229555400000#c1938491852225538' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2008/12/netbeans-65-s-glassfish-v2-ur2.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-373733089556805930' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/373733089556805930' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2008. december 18. 0:10'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6625498082266389607</id><published>2009-01-13T15:39:00.000+01:00</published><updated>2009-01-13T15:39:12.163+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A cikk elejével 120% egyetértek (bár netbéna nem k...</title><content type='html'>A cikk elejével 120% egyetértek (bár netbéna nem kenyerem), automatikus tesztelésnél viszont azért visszaüt ez a JNDI varázs csúnyán.. vagy rögtön JUnit-ból indítod a JNDI-emulációt minden setup-nál? :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3326979225522262721/comments/default/6625498082266389607'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3326979225522262721/comments/default/6625498082266389607'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/01/jndi-nevek-tomcat-alatt.html?showComment=1231857540000#c6625498082266389607' title=''/><author><name>Kristof Jozsa</name><uri>http://www.blogger.com/profile/06607669172500255805</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/01/jndi-nevek-tomcat-alatt.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3326979225522262721' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3326979225522262721' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-686590949'/><gd:extendedProperty name='blogger.displayTime' value='2009. január 13. 15:39'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1963375200427456515</id><published>2009-01-13T16:14:00.000+01:00</published><updated>2009-01-13T16:14:34.207+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A JNDI-t kétféleképp kezelheted, de javasolt a JND...</title><content type='html'>A JNDI-t kétféleképp kezelheted, de javasolt a JNDI lekérdezéseket nem szétszórni a kódban. Vagy használod a service locator tervezési mintát, ekkor a lekérdezések egy helyre vannak kigyűjtve, vagy használod a dependency injection-t. Az előbbi esetben csak a service locator implementációt kell kicserélned úgy, hogy megfeleljen a teszt infrastruktúrádnak, második esetben pedig egyszerű konfigurációval megoldható. Mi általában Spring-et használunk, és újabban az ilyen hivatkozásokat külön Spring xml állományba pakoljuk. JNDI lekérdezésre Spring-ben használhatjuk a JndiObjectFactoryBean-t, vagy a jee:jndi-lookup tag-et. Ha a teszt folyamán az erőforrásokat nem JNDI-ből akarod elérni, csak a Spring ezen konfig állományát kell a teszt előtt kicserélni (persze automatikusan). Amúgy én a Mock JNDI implementációtól sem fázom, hiszen tesztelésnél ez egy sima Map. :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3326979225522262721/comments/default/1963375200427456515'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3326979225522262721/comments/default/1963375200427456515'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/01/jndi-nevek-tomcat-alatt.html?showComment=1231859640000#c1963375200427456515' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/01/jndi-nevek-tomcat-alatt.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3326979225522262721' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3326979225522262721' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2009. január 13. 16:14'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5760978786422525846</id><published>2009-01-22T10:26:00.000+01:00</published><updated>2009-01-22T10:26:53.549+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Na végre már egy érdekes bejegyzés. :)&lt;br&gt;Az első,...</title><content type='html'>Na végre már egy érdekes bejegyzés. :)&lt;BR/&gt;Az első, elméleti felével teljesen egyetértek, a gyakorlati fele meg hasznos. Több ilyet légyszi. :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/906175397810708721/comments/default/5760978786422525846'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/906175397810708721/comments/default/5760978786422525846'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/01/ejb3unit.html?showComment=1232616360000#c5760978786422525846' title=''/><author><name>G</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/01/ejb3unit.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-906175397810708721' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/906175397810708721' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-191744188'/><gd:extendedProperty name='blogger.displayTime' value='2009. január 22. 10:26'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8395090779663356767</id><published>2009-01-22T10:41:00.000+01:00</published><updated>2009-01-22T10:41:14.105+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A unitils-es megoldásban mi nem tetszik? &lt;br&gt;&lt;br&gt;M...</title><content type='html'>A unitils-es megoldásban mi nem tetszik? &lt;BR/&gt;&lt;BR/&gt;Mi egy viszonylag nagy projekten használtuk, és nekünk bevált. JUnit vagy TestNG alatt fut, és DI-t is kezel (bár csak annyit, amennyit implemenáltunk, korántsem fedi le a teljes EJB speckót a környezet.)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/906175397810708721/comments/default/8395090779663356767'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/906175397810708721/comments/default/8395090779663356767'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/01/ejb3unit.html?showComment=1232617260000#c8395090779663356767' title=''/><author><name>karenin</name><uri>http://www.blogger.com/profile/02683406828110839343</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/01/ejb3unit.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-906175397810708721' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/906175397810708721' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1182670978'/><gd:extendedProperty name='blogger.displayTime' value='2009. január 22. 10:41'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5861251396246351454</id><published>2009-01-22T11:34:00.000+01:00</published><updated>2009-01-22T11:34:23.818+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszönöm G a biztatást! Miről szeretnél hallani? B...</title><content type='html'>Köszönöm G a biztatást! Miről szeretnél hallani? Bármiről szívesen szakértek neked. :)&lt;BR/&gt;&lt;BR/&gt;Karenin, lehet, hogy félreérthető voltam, a unitils-es megoldás is tetszik, sőt jobban tetszik a DI miatt. Sőt, az utolsó frissítése is jobb, jan. 4., szemben az Ejb3unit 2008. májusával, pedig mióta ígérgetik a 2.0-ás verziót. Csak amíg az Ejb3unit-ot használtam, és arról írtam a bejegyzésben, addig a unitils-ről csak most olvastam a weben, még nem próbáltam. De ami késik...</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/906175397810708721/comments/default/5861251396246351454'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/906175397810708721/comments/default/5861251396246351454'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/01/ejb3unit.html?showComment=1232620440000#c5861251396246351454' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://1.bp.blogspot.com/_czKgycLvmNo/SXJSYEagteI/AAAAAAAACZQ/W58fSCi3IKI/S220/korzika_400.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/01/ejb3unit.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-906175397810708721' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/906175397810708721' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2009. január 22. 11:34'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6543111696483599411</id><published>2009-01-22T14:44:00.000+01:00</published><updated>2009-01-22T14:44:14.510+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Azért túl sokat ne várj tőle, sose volt időnk impl...</title><content type='html'>Azért túl sokat ne várj tőle, sose volt időnk implementálni az olyan dolgokat, amire nem volt igényünk. Bár ha igény mutatkozna rá, lehet hogy raknék bele még dolgokat.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/906175397810708721/comments/default/6543111696483599411'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/906175397810708721/comments/default/6543111696483599411'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/01/ejb3unit.html?showComment=1232631840000#c6543111696483599411' title=''/><author><name>karenin</name><uri>http://www.blogger.com/profile/02683406828110839343</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/01/ejb3unit.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-906175397810708721' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/906175397810708721' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1182670978'/><gd:extendedProperty name='blogger.displayTime' value='2009. január 22. 14:44'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2738455021027387574</id><published>2009-02-24T13:25:00.000+01:00</published><updated>2009-02-24T13:25:28.069+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Free Eclipse coverage plugin: EclEmma&lt;br&gt;http://em...</title><content type='html'>Free Eclipse coverage plugin: EclEmma&lt;BR/&gt;http://emma.sourceforge.net/&lt;BR/&gt;Egészen használható.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6807279072739304839/comments/default/2738455021027387574'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6807279072739304839/comments/default/2738455021027387574'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/02/code-coverage.html?showComment=1235478300000#c2738455021027387574' title=''/><author><name>pcjuzer</name><uri>http://www.blogger.com/profile/02215826552900660449</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/02/code-coverage.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6807279072739304839' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6807279072739304839' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1989835059'/><gd:extendedProperty name='blogger.displayTime' value='2009. február 24. 13:25'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5748752921895430799</id><published>2009-02-24T16:58:00.000+01:00</published><updated>2009-02-24T16:58:23.569+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi! A link a http://www.eclemma.org/, gondolom....</title><content type='html'>Köszi! A link a http://www.eclemma.org/, gondolom. Érdekes, hogy a NetBeans Unit Tests Code Coverage Plugin is az EMMA-ra építkezik.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6807279072739304839/comments/default/5748752921895430799'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6807279072739304839/comments/default/5748752921895430799'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/02/code-coverage.html?showComment=1235491080000#c5748752921895430799' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://1.bp.blogspot.com/_czKgycLvmNo/SXJSYEagteI/AAAAAAAACZQ/W58fSCi3IKI/S220/korzika_400.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/02/code-coverage.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6807279072739304839' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6807279072739304839' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2009. február 24. 16:58'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7567982548816978560</id><published>2009-03-09T15:57:00.000+01:00</published><updated>2009-03-09T15:57:45.408+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Gratulálok!&lt;br&gt;&lt;br&gt;Pontosan ez az amit keves tudna...</title><content type='html'>Gratulálok!&lt;BR/&gt;&lt;BR/&gt;Pontosan ez az amit keves tudnak:&lt;BR/&gt;Egy eszköz  használatának megkezdéséhez szükséges és elégséges információt átadni.&lt;BR/&gt;&lt;BR/&gt;U.B.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3999068897644214024/comments/default/7567982548816978560'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3999068897644214024/comments/default/7567982548816978560'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/01/naplzs-webes-krnyezetben-log4j-vel.html?showComment=1236610620000#c7567982548816978560' title=''/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/01/naplzs-webes-krnyezetben-log4j-vel.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3999068897644214024' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3999068897644214024' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1150942882'/><gd:extendedProperty name='blogger.displayTime' value='2009. március 9. 15:57'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4718286749786623500</id><published>2009-03-23T09:21:00.000+01:00</published><updated>2009-03-23T09:21:31.909+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Helló,  megjegyzéseket talán azért nem töltötte ki...</title><content type='html'>Helló,  megjegyzéseket talán azért nem töltötte ki senki, mert nem volt már rá idő. Én is 5mp alatt töltöttem ki az ívet, aztán csomagoltam.&lt;BR/&gt;&lt;BR/&gt;Ha ennyire fix a rendelkezésre álló idő, tényleg elég lenne a 2 előadás.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6768451653104605209/comments/default/4718286749786623500'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6768451653104605209/comments/default/4718286749786623500'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/03/olap-java-eszkozokkel.html?showComment=1237796460000#c4718286749786623500' title=''/><author><name>pcjuzer</name><uri>http://www.blogger.com/profile/02215826552900660449</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/03/olap-java-eszkozokkel.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6768451653104605209' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6768451653104605209' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1989835059'/><gd:extendedProperty name='blogger.displayTime' value='2009. március 23. 9:21'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2682914770963493667</id><published>2009-04-10T16:58:00.000+02:00</published><updated>2009-04-10T16:58:39.766+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Megnéztem az előadás anyagot. Nagyon izgalmas a té...</title><content type='html'>Megnéztem az előadás anyagot. Nagyon izgalmas a téma felvetés, érdekes megoldás lehet a szemantikus web és annak grafikus megjelenítése. Ugyanakkor nem értem, hogy az utolsó három slide miképpen kapcsolódik a témához.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6790088143720411764/comments/default/2682914770963493667'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6790088143720411764/comments/default/2682914770963493667'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/04/technologiak-oktatas.html?showComment=1239375480000#c2682914770963493667' title=''/><author><name>verhasi</name><uri>http://www.blogger.com/profile/04422179881036855160</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/04/technologiak-oktatas.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6790088143720411764' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6790088143720411764' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2010359704'/><gd:extendedProperty name='blogger.displayTime' value='2009. április 10. 16:58'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1010909615504726558</id><published>2009-04-10T17:08:00.000+02:00</published><updated>2009-04-10T17:08:13.731+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Az előadás a Számalk konferencián hangzott el, aho...</title><content type='html'>Az előadás a Számalk konferencián hangzott el, ahol a célom volt bemutatni a Java világ sokszínűségét. Ennek része annak felvillantása, hogy a mobil eszközöktől (lsd. Android) a szerver cluster-ekig (lsd. Java EE) bármire lehet Java platformon fejleszteni. Inkább a szemantikus web lógott ki, azzal azt szerettem volna hangsúlyozni, hogy a Számalk oktatás keretein belül rendszerezzük a tudást, párhuzamokat vonunk, és nem egy fix tematika alapján haladunk, ami nem nyújt kellő kitekintést.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6790088143720411764/comments/default/1010909615504726558'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6790088143720411764/comments/default/1010909615504726558'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/04/technologiak-oktatas.html?showComment=1239376080000#c1010909615504726558' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://1.bp.blogspot.com/_czKgycLvmNo/SXJSYEagteI/AAAAAAAACZQ/W58fSCi3IKI/S220/korzika_400.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/04/technologiak-oktatas.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6790088143720411764' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6790088143720411764' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2009. április 10. 17:08'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8496189897353948606</id><published>2009-05-06T20:39:00.000+02:00</published><updated>2009-05-06T20:39:17.209+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Írtad hogy az UMLet saját XML formátumot használ. ...</title><content type='html'>Írtad hogy az UMLet saját XML formátumot használ. Nincs benne lehetőség szabványos UML (XMI) exportra/importra?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7752226165485814608/comments/default/8496189897353948606'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7752226165485814608/comments/default/8496189897353948606'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/05/uml-tevekenysegdiagram.html?showComment=1241635140000#c8496189897353948606' title=''/><author><name>pcjuzer</name><uri>http://www.blogger.com/profile/02215826552900660449</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/05/uml-tevekenysegdiagram.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7752226165485814608' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7752226165485814608' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1989835059'/><gd:extendedProperty name='blogger.displayTime' value='2009. május 6. 20:39'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5877990916949867504</id><published>2009-05-06T20:55:00.000+02:00</published><updated>2009-05-06T20:55:23.095+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Az UMLet túl egyszerű ahhoz. Ha kipróbálod, látod,...</title><content type='html'>Az UMLet túl egyszerű ahhoz. Ha kipróbálod, látod, hogy szinte mindent szövegként tárol, nem azonosítja, hogy ez egy metódus név, egy paraméter név, vagy típus, esetleg egy láthatósági módosító. Nincs is property szerkesztője, hanem mindent egy darab szövegmezőbe kell beírni. Emiatt nem képes az exportra sem, és nem is lehet képes arra. Ezért a forward engineering, és mindenféle MDA ki van lőve, tényleg csak egy gyors skiccelésre való, de arra nem találtam nála jobbat.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7752226165485814608/comments/default/5877990916949867504'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7752226165485814608/comments/default/5877990916949867504'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/05/uml-tevekenysegdiagram.html?showComment=1241636100000#c5877990916949867504' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/05/uml-tevekenysegdiagram.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7752226165485814608' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7752226165485814608' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2009. május 6. 20:55'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6243059469245578573</id><published>2009-05-08T08:38:00.000+02:00</published><updated>2009-05-08T08:38:31.481+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>a rollbackelt tesztekkel egyébként is érdemes vigy...</title><content type='html'>a rollbackelt tesztekkel egyébként is érdemes vigyázni, gyakran a hibás működés csak commit közben bukik ki. &lt;br /&gt;&lt;br /&gt;a tesztek végén az adatok benthagyása pedig rendben, de a tesztek tetszőleges sorrendben ill akár egyesével is futtathatóak kell legyenek a korrekt teszteléshez, tehát nem szabad feltételezéseket tenniük más tesztek által készitett/benthagyott adatokra.&lt;br /&gt;&lt;br /&gt;milyen jpa implementációt használsz?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6830182434857140108/comments/default/6243059469245578573'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6830182434857140108/comments/default/6243059469245578573'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/05/jpa-tomeges-muveletek.html?showComment=1241764680000#c6243059469245578573' title=''/><author><name>Kristof Jozsa</name><uri>http://www.blogger.com/profile/06607669172500255805</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/05/jpa-tomeges-muveletek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6830182434857140108' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6830182434857140108' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-686590949'/><gd:extendedProperty name='blogger.displayTime' value='2009. május 8. 8:38'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2288726221308633307</id><published>2009-05-08T08:54:00.000+02:00</published><updated>2009-05-08T08:54:43.575+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A projektjeink mindegyikében eddig Hibernate-t has...</title><content type='html'>A projektjeink mindegyikében eddig Hibernate-t használtunk. Java EE oktatás során pedig egyszer a JBoss-ban lévő Hibernate-et, leggyakrabban azonban a GlassFish-ben lévő TopLink-et. Igazából egyikkel sem volt problémánk.&lt;br /&gt;&lt;br /&gt;A bejegyzés teszt programját amúgy kipróbáltam mindkettővel, teljesen ugyanazt a működést produkálták.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6830182434857140108/comments/default/2288726221308633307'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6830182434857140108/comments/default/2288726221308633307'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/05/jpa-tomeges-muveletek.html?showComment=1241765640000#c2288726221308633307' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/05/jpa-tomeges-muveletek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6830182434857140108' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6830182434857140108' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2009. május 8. 8:54'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5369073606869852115</id><published>2009-05-08T09:37:00.000+02:00</published><updated>2009-05-08T09:37:29.757+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A tranzakciók témájába vág:
http://www.ibm.com/dev...</title><content type='html'>A tranzakciók témájába vág:&lt;br /&gt;http://www.ibm.com/developerworks/java/library/j-ts1.html&lt;br /&gt;&lt;br /&gt;Könyv ugyanattól a szerzőtől:&lt;br /&gt;http://www.infoq.com/minibooks/JTDS</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6830182434857140108/comments/default/5369073606869852115'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6830182434857140108/comments/default/5369073606869852115'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/05/jpa-tomeges-muveletek.html?showComment=1241768220000#c5369073606869852115' title=''/><author><name>Kofa</name><uri>http://www.blogger.com/profile/09608502634061041209</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/05/jpa-tomeges-muveletek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6830182434857140108' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6830182434857140108' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-111703032'/><gd:extendedProperty name='blogger.displayTime' value='2009. május 8. 9:37'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1083589271730497485</id><published>2009-05-29T19:34:51.435+02:00</published><updated>2009-05-29T19:34:51.435+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>"Kicsit irigykedtem, hiszen a JUM rendezvényekre e...</title><content type='html'>"Kicsit irigykedtem, hiszen a JUM rendezvényekre ehhez képest kevesen jönnek el."&lt;br /&gt;&lt;br /&gt;Viszont a Java Cafe kb egyszer van egy évben, a JUM pedig ötször és szerintem már az előadások is simán partiban vannak ahogy a legutóbbi alkalmakat nézem.&lt;br /&gt;&lt;br /&gt;Ráadásul néha a JUM-ra csak két nappal az esemény előtt lehet regisztrálni. Ahhoz képest igencsak jó a részvételi arány. :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7385849849313115109/comments/default/1083589271730497485'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7385849849313115109/comments/default/1083589271730497485'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/05/sun-java-cafe.html?showComment=1243618491435#c1083589271730497485' title=''/><author><name>pcjuzer</name><uri>http://www.blogger.com/profile/02215826552900660449</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/05/sun-java-cafe.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7385849849313115109' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7385849849313115109' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1989835059'/><gd:extendedProperty name='blogger.displayTime' value='2009. május 29. 19:34'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8259985195745978063</id><published>2009-05-29T19:52:53.886+02:00</published><updated>2009-05-29T19:52:53.886+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Igazad van. Az előadások tényleg jók, és a szervez...</title><content type='html'>Igazad van. Az előadások tényleg jók, és a szervezésben meg tudjuk, mit kell másképp csinálni. :) És szeptemberben meg is valósítjuk! :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7385849849313115109/comments/default/8259985195745978063'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7385849849313115109/comments/default/8259985195745978063'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/05/sun-java-cafe.html?showComment=1243619573886#c8259985195745978063' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/05/sun-java-cafe.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7385849849313115109' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7385849849313115109' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2009. május 29. 19:52'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5593099595035650039</id><published>2009-07-05T16:27:50.890+02:00</published><updated>2009-07-05T16:27:50.890+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szia!

Marha jó a blogod! Kár, hogy csak most akad...</title><content type='html'>Szia!&lt;br /&gt;&lt;br /&gt;Marha jó a blogod! Kár, hogy csak most akadtam rá...&lt;br /&gt;&lt;br /&gt;Ez a JAXB dolog pár hete nagyon jól jött volna:)&lt;br /&gt;&lt;br /&gt;JPA kapcsán: Oracle TopLink-ről mi a véleményed, használtad már? Én még csak ezt próbáltam (Glassfish-ben ez van), de néha kicsit furcsa. (a cégnél általunk használt MSSQL után kissé bugyutának tűnik, de ezt csak suttogva mondtam:)&lt;br /&gt;&lt;br /&gt;Sok kitartást kívánok a folytatáshoz!&lt;br /&gt;Balázs</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1892525895813380459/comments/default/5593099595035650039'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1892525895813380459/comments/default/5593099595035650039'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/05/hibernate-eclipselink-atallas.html?showComment=1246804070890#c5593099595035650039' title=''/><author><name>mbazs</name><uri>http://www.blogger.com/profile/14757449206130736047</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/05/hibernate-eclipselink-atallas.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-1892525895813380459' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/1892525895813380459' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1984031293'/><gd:extendedProperty name='blogger.displayTime' value='2009. július 5. 16:27'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3323943605036910449</id><published>2009-07-06T13:14:53.551+02:00</published><updated>2009-07-06T13:14:53.551+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szia!

Köszönöm szépen.

Az Oracle TopLink-et (ill...</title><content type='html'>Szia!&lt;br /&gt;&lt;br /&gt;Köszönöm szépen.&lt;br /&gt;&lt;br /&gt;Az Oracle TopLink-et (illetve annak egy részének forráskódját az Oracle odaadta az Eclipse-nek, így lett EclipseLink) éles projektben nem használtuk, csak oktatáson, ott semmi probléma nem volt vele. Mi a Hibernate-et használjuk, mint JPA provider-t, és jól működik. Az EclipseLink-ben nekem az szimpatikus, hogy kevesebb JAR. :)&lt;br /&gt;&lt;br /&gt;Az MSSQL és TopLink közötti párhuzamodat nem értem. Az MSSQL egy relációs adatbázis-kezelő, a TopLink egy object relational mapping (ORM) eszköz, mely az objektumorientált világot köti össze relációs adatbázisokkal. Azaz pl. az TopLink-et MSSQL-lel is használhatod, így tudod összekötni az üzleti objektumaidat az MSSQL rekordokkal.&lt;br /&gt;&lt;br /&gt;Tény, hogy az adatbázisok képességének csak egy kis részét tudod JPA-n keresztül megszólítani.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1892525895813380459/comments/default/3323943605036910449'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1892525895813380459/comments/default/3323943605036910449'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/05/hibernate-eclipselink-atallas.html?showComment=1246878893551#c3323943605036910449' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/05/hibernate-eclipselink-atallas.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-1892525895813380459' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/1892525895813380459' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2009. július 6. 13:14'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1075499174950583639</id><published>2009-07-09T15:14:12.273+02:00</published><updated>2009-07-09T15:14:12.273+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A DocBook tud RTF kimenetet, nem lett volna az has...</title><content type='html'>A DocBook tud RTF kimenetet, nem lett volna az hasznosabb, mint a HTML?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1438029047403381023/comments/default/1075499174950583639'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1438029047403381023/comments/default/1075499174950583639'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/07/rendszerterv-generalas-java-kodbol.html?showComment=1247145252273#c1075499174950583639' title=''/><author><name>Kofa</name><uri>http://www.blogger.com/profile/09608502634061041209</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/07/rendszerterv-generalas-java-kodbol.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-1438029047403381023' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/1438029047403381023' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-111703032'/><gd:extendedProperty name='blogger.displayTime' value='2009. július 9. 15:14'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2413599857935334754</id><published>2009-07-09T15:18:45.930+02:00</published><updated>2009-07-09T15:18:45.930+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A cikkben mindenütt RDF-et írtam, persze RTF-re go...</title><content type='html'>A cikkben mindenütt RDF-et írtam, persze RTF-re gondoltam, javítottam is.&lt;br /&gt;Természetesen az első ötlet az RTF volt, amit ki is próbáltam, a változó soros táblázatok teljesen szétcsúsztak. A Java listán, a neten talált hozzászólások és saját tapasztalatok alapján is nem tűnt triviálisnak, ezért gyorsan el is felejtettem. Úgy nézett ki, hogy minden táblázat minden oszlopa 1-2 pixel széles volt, nem töltötte ki a rendelkezésre álló helyet, viszont egy cella magassága fél lapnyi volt.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1438029047403381023/comments/default/2413599857935334754'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1438029047403381023/comments/default/2413599857935334754'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/07/rendszerterv-generalas-java-kodbol.html?showComment=1247145525930#c2413599857935334754' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/07/rendszerterv-generalas-java-kodbol.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-1438029047403381023' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/1438029047403381023' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2009. július 9. 15:18'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-381236279321229313</id><published>2009-07-10T13:11:47.005+02:00</published><updated>2009-07-10T13:11:47.005+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>&amp;quot;Tény, hogy az adatbázisok képességének csak ...</title><content type='html'>&amp;quot;Tény, hogy az adatbázisok képességének csak egy kis részét tudod JPA-n keresztül megszólítani.&amp;quot;&lt;br /&gt;&lt;br /&gt;Én pont erre gondoltam, csak rosszul fogalmaztam: a JPQL mintha olyan egyszerűcske lenne a natív SQL-hez képest. A mi cégünknél hatalmas tárolt eljárások vannak; hogy ezeket hogyan lehetne JPA-val megvalósítani, egyszerűen fogalmam sincs.&lt;br /&gt;Bár ez az egész ORM, az entitáskapcsolatok közti átjárhatóság stb. nagyon tetszik.&lt;br /&gt;&lt;br /&gt;Csak mindig falakba ütközöm, pl. milyen jó lenne, ha lehetne ilyet csinálni:&lt;br /&gt;&lt;br /&gt;&amp;quot;SELECT address FROM Address address WHERE address.city.id IN ?1&amp;quot;&lt;br /&gt;&lt;br /&gt;(itt az 1. paraméter egy java.util.List lenne, amely település ID-ket tartalmaz, remélem elég szemléletes). De ilyen IN-t nem tud, pedig szerintem ez nem is olyan nagy dolog.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1892525895813380459/comments/default/381236279321229313'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1892525895813380459/comments/default/381236279321229313'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/05/hibernate-eclipselink-atallas.html?showComment=1247224307005#c381236279321229313' title=''/><author><name>mbazs</name><uri>http://www.blogger.com/profile/14757449206130736047</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/05/hibernate-eclipselink-atallas.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-1892525895813380459' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/1892525895813380459' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1984031293'/><gd:extendedProperty name='blogger.displayTime' value='2009. július 10. 13:11'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3828160570537088682</id><published>2009-07-10T15:20:11.118+02:00</published><updated>2009-07-10T15:20:11.118+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szia,

Igen, tény, hogy egyszerűbb, mint egy SQL. ...</title><content type='html'>Szia,&lt;br /&gt;&lt;br /&gt;Igen, tény, hogy egyszerűbb, mint egy SQL. De a legtöbb esetben megfelelő, és ha mégis SQL-re vágysz, ott a Native Query, amivel persze bukhatod a platformfüggetlenséget.&lt;br /&gt;&lt;br /&gt;A tárolt eljárásokat nem kell JPA-ban megvalósítani, jól vannak ott az adatbázisban, annak ez a feladata, JPA-n keresztül csak meghívnod kell. Ha mégis át akarod vinni, akkor ott a teljes Java eszköztár, csak az adatokért nyúlsz le JPA-val.&lt;br /&gt;&lt;br /&gt;Másrészt az IN működik, nézd meg ezt a linket:&lt;br /&gt;&lt;br /&gt;http://www.coderanch.com/t/415118/Object-Relational-Mapping/java/JPA-Query-using-where-setParameter#1969760</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1892525895813380459/comments/default/3828160570537088682'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1892525895813380459/comments/default/3828160570537088682'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/05/hibernate-eclipselink-atallas.html?showComment=1247232011118#c3828160570537088682' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/05/hibernate-eclipselink-atallas.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-1892525895813380459' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/1892525895813380459' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2009. július 10. 15:20'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1540580127059444723</id><published>2009-07-10T16:07:37.869+02:00</published><updated>2009-07-10T16:07:37.869+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Hát nekem a Collection-ös IN TopLink alatt nem men...</title><content type='html'>Hát nekem a Collection-ös IN TopLink alatt nem ment sajnos.&lt;br /&gt;&lt;br /&gt;Asszem ezt nemrég tették bele az EclipseLink-be, ha jól látom:&lt;br /&gt;&lt;br /&gt;https://bugs.eclipse.org/bugs/show_bug.cgi?id=249224&lt;br /&gt;&lt;br /&gt;2009-06-10 &amp;quot;Updates to allow TYPE() and IN with paramters of List type&amp;quot;&lt;br /&gt;&lt;br /&gt;Köszi, minden jót!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1892525895813380459/comments/default/1540580127059444723'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1892525895813380459/comments/default/1540580127059444723'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/05/hibernate-eclipselink-atallas.html?showComment=1247234857869#c1540580127059444723' title=''/><author><name>mbazs</name><uri>http://www.blogger.com/profile/14757449206130736047</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/05/hibernate-eclipselink-atallas.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-1892525895813380459' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/1892525895813380459' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1984031293'/><gd:extendedProperty name='blogger.displayTime' value='2009. július 10. 16:07'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5345863397613164107</id><published>2009-08-06T21:54:19.914+02:00</published><updated>2009-08-06T21:54:19.914+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>István kösz az angol nyelvű könyv tippket, a polco...</title><content type='html'>István kösz az angol nyelvű könyv tippket, a polcodon van valamennyi a jávával foglalkozó magyarul megjenet könyv, amely megéri a reá költött pénzt. Üdv. Csaba</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4290553583416988902/comments/default/5345863397613164107'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4290553583416988902/comments/default/5345863397613164107'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/05/konyvespolcom.html?showComment=1249588459914#c5345863397613164107' title=''/><author><name>Csaba</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/05/konyvespolcom.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4290553583416988902' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4290553583416988902' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-860074120'/><gd:extendedProperty name='blogger.displayTime' value='2009. augusztus 6. 21:54'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3028183479276259989</id><published>2009-09-09T09:32:52.169+02:00</published><updated>2009-09-09T09:32:52.169+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Én jelenleg VM-ben fejlesztek (VMWare ESX vagy GSX...</title><content type='html'>Én jelenleg VM-ben fejlesztek (VMWare ESX vagy GSX, nem is tudom). Az ügyfél maga is technológiai cég, csak munkaerőt kölcsönöz tőlünk. Ők adják a VM-et, amelyre telepítik az általuk standardizált környezetet (oprendszertől fejlesztőeszközig; az általuk liszenszelt fizetős cuccok és a forráskód felett is jobb kontrollal rendelkeznek így). Minden VM egyforma fájlrendszerrel rendelkezik.&lt;br /&gt;A dolog meglepő módon működik, bár időnként nagyon lelassul (nem azért, mert az ügyfél az óceán túlpartján van, hanem az erőforrások viszonylagos szűkössége miatt).&lt;br /&gt;&lt;br /&gt;A VMWare szervert nem próbáltad? Az is ingyenes.&lt;br /&gt;&lt;br /&gt;Azt nem írtad a VirtualBox-ról, hogy a &amp;quot;teljes&amp;quot; (nem nyílt forrású!) verzió RDP (Remote Desktop) kapcsolatot nyújt távirányításhoz, bármilyen legyen is a benne futó oprendszer. Valamint ők az egyetlenek, akik Direct3D-t is támogatnak (igaz, csak a 9-est, és a legtöbb fejlesztőnek ez nem is túl fontos; akinek meg fontos, annak a VM kevés lesz).</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7294342172766860875/comments/default/3028183479276259989'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7294342172766860875/comments/default/3028183479276259989'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/09/virtualizacio-fejlesztoi-gepen.html?showComment=1252481572169#c3028183479276259989' title=''/><author><name>Kofa</name><uri>http://www.blogger.com/profile/09608502634061041209</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/09/virtualizacio-fejlesztoi-gepen.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7294342172766860875' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7294342172766860875' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-111703032'/><gd:extendedProperty name='blogger.displayTime' value='2009. szeptember 9. 9:32'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2560784586959354392</id><published>2009-09-09T10:22:31.571+02:00</published><updated>2009-09-09T10:22:31.571+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Akkor te első kézből rendelkezel tapasztalatokkal ...</title><content type='html'>Akkor te első kézből rendelkezel tapasztalatokkal arról, hogy hogyan lehet virtuális környezetben fejleszteni. Én kicsit ódzkodtam tőle, de akkor úgy tűnik működik.&lt;br /&gt;Én élesben még csak olyant láttam, hogy távoli terminállal egy központi szerverre jelentkezel be, és azon fejlesztesz, no arról viszont elég rosszakat hallottam.&lt;br /&gt;Erről már az az ötletünk ugrott be, ha Office helyett már a Google nyomja a webes megoldását, akkor lassan az Eclipse-t is át kéne ültetni webes, AJAX-os alkalmazássá, és a weben fejleszteni, bárhonnan elérhető. :)))&lt;br /&gt;&lt;br /&gt;A VMWare-t nem próbáltam még. Nem az összehasonlítás volt a cél, és ami működik, azt nem szoktam leváltani. Írtam, a Virtual PC-vel sem volt bajom, csak aki a Solaris-t telepítette, az mondta, hogy ezt inkább VirtualBox-ra tenné.&lt;br /&gt;&lt;br /&gt;Közben nézem a http://www.sun.com/software/products/virtualbox/ oldalt, és én nem látom, hogy van külön open source és &amp;quot;teljes&amp;quot; megoldás. Azt látom, hogy van &amp;quot;Sun VirtualBox Enterprise Subscriptions&amp;quot;, de olyan, mintha csak support-ot adnának hozzá.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7294342172766860875/comments/default/2560784586959354392'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7294342172766860875/comments/default/2560784586959354392'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/09/virtualizacio-fejlesztoi-gepen.html?showComment=1252484551571#c2560784586959354392' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/09/virtualizacio-fejlesztoi-gepen.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7294342172766860875' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7294342172766860875' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2009. szeptember 9. 10:22'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-463617074303468980</id><published>2009-09-09T10:43:39.535+02:00</published><updated>2009-09-09T10:43:39.535+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Gyakorlatilag mi is terminálból (RDP) támadjuk a k...</title><content type='html'>Gyakorlatilag mi is terminálból (RDP) támadjuk a kanadai VM-eket. Kb. 30-an dolgozunk távolról. A VM 3 GB RAM-ot mutat, de hogy ténylegesen mennyi van mögötte fizikailag, nem tudom. Vannak napok, amikor brutál lassú, máskor alig észrevehető.&lt;br /&gt;&lt;br /&gt;A különböző VirtualBox változatokról itt olvastam:&lt;br /&gt;http://www.virtualbox.org/wiki/Editions&lt;br /&gt;Az oldal alján ott a Sun copyright, de ettől még lehet elavult.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7294342172766860875/comments/default/463617074303468980'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7294342172766860875/comments/default/463617074303468980'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/09/virtualizacio-fejlesztoi-gepen.html?showComment=1252485819535#c463617074303468980' title=''/><author><name>Kofa</name><uri>http://www.blogger.com/profile/09608502634061041209</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/09/virtualizacio-fejlesztoi-gepen.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7294342172766860875' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7294342172766860875' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-111703032'/><gd:extendedProperty name='blogger.displayTime' value='2009. szeptember 9. 10:43'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5821038202699866320</id><published>2009-09-09T10:51:09.111+02:00</published><updated>2009-09-09T10:51:09.111+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Ahá, azt hittem kaptatok egy image-et, és a saját ...</title><content type='html'>Ahá, azt hittem kaptatok egy image-et, és a saját gépen futtatjátok.&lt;br /&gt;&lt;br /&gt;A menük és a súgó szerint nekem is van távoli terminál (most így nevezik: VirtualBox Remote Desktop Protocol (VRDP)), USB támogatás és DirectX 8/9, tehát szerintem már nincs ilyen megkülönböztetés.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7294342172766860875/comments/default/5821038202699866320'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7294342172766860875/comments/default/5821038202699866320'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/09/virtualizacio-fejlesztoi-gepen.html?showComment=1252486269111#c5821038202699866320' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/09/virtualizacio-fejlesztoi-gepen.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7294342172766860875' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7294342172766860875' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2009. szeptember 9. 10:51'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7463116242768989965</id><published>2009-09-28T16:05:27.246+02:00</published><updated>2009-09-28T16:05:27.246+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>&amp;quot;Persze több kereskedelmi termék is van, mint...</title><content type='html'>&amp;quot;Persze több kereskedelmi termék is van, mint a Sun Java System Message Queue, Oracle Advanced Queuing.&amp;quot;&lt;br /&gt;&lt;br /&gt;A Sun Java System Message Queue ingyenesen letölthető és használható (fejlesztésre és termelésben egyaránt); liszensz &amp;quot;csak&amp;quot; a terméktámogatáshoz kell.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4180001514533033810/comments/default/7463116242768989965'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4180001514533033810/comments/default/7463116242768989965'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/09/ibm-websphere-mq.html?showComment=1254146727246#c7463116242768989965' title=''/><author><name>Kofa</name><uri>http://www.blogger.com/profile/09608502634061041209</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/09/ibm-websphere-mq.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4180001514533033810' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4180001514533033810' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-111703032'/><gd:extendedProperty name='blogger.displayTime' value='2009. szeptember 28. 16:05'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4505806545718047280</id><published>2009-10-01T00:53:31.849+02:00</published><updated>2009-10-01T00:53:31.849+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nagyon szépen köszönöm, teljesen igazad van, javít...</title><content type='html'>Nagyon szépen köszönöm, teljesen igazad van, javítottam.&lt;br /&gt;A http://en.wikipedia.org/wiki/Java_Message_Service oldalon már frissítve van, de a magyarban még hibás (http://hu.wikipedia.org/wiki/Java_Message_Service).&lt;br /&gt;Amúgy az ingyenes verziója az Open Message Queue (https://mq.dev.java.net/), ami a Glassfish-ben is van, és ennek kereskedelmi változata a Sun Java System Message Queue.&lt;br /&gt;Amennyiben további post-okban is találsz hibát, kérlek jelezd, szívesen veszem!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4180001514533033810/comments/default/4505806545718047280'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4180001514533033810/comments/default/4505806545718047280'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/09/ibm-websphere-mq.html?showComment=1254351211849#c4505806545718047280' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/09/ibm-websphere-mq.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4180001514533033810' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4180001514533033810' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2009. október 1. 0:53'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7744788050314954849</id><published>2009-10-01T15:19:55.689+02:00</published><updated>2009-10-01T15:19:55.689+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szia! Jo a bejegyzes! Nekem nagyon-nagyon tetszik ...</title><content type='html'>Szia! Jo a bejegyzes! Nekem nagyon-nagyon tetszik Antal Margit (szabadon) letoltheto konyve is. A szerzo az Erdelyi Magyar Tudomanyegyetem tanara es a konyv az alapoktol mutatja be a Java nyelvet es rajta keresztul az OOP programozast is.&lt;br /&gt;http://www.ms.sapientia.ro/~manyi/teaching/oop/oop.pdf</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1485120607241271708/comments/default/7744788050314954849'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1485120607241271708/comments/default/7744788050314954849'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/10/java-forrasok-tanulashoz.html?showComment=1254403195689#c7744788050314954849' title=''/><author><name>zsooolt75</name><uri>http://www.blogger.com/profile/09087457984622414088</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/10/java-forrasok-tanulashoz.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-1485120607241271708' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/1485120607241271708' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-263036344'/><gd:extendedProperty name='blogger.displayTime' value='2009. október 1. 15:19'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1929083246290269725</id><published>2009-10-01T15:29:12.129+02:00</published><updated>2009-10-01T15:29:12.129+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szia! Köszönöm! Az említett munkát már megtaláltam...</title><content type='html'>Szia! Köszönöm! Az említett munkát már megtaláltam Nagy Gusztáv honlapján is a hozzászólások között. Belenéztem mindkettőbe, és megnéztem, melyik említi pl. a generikusokat. Mivel csak Gusztáv munkájában találtam, azt gondoltam, hogy az részletesebb, és jobban követi a nyelv módosításait (a generikus ugye az 1.5-ben jelent meg, és már az 1.6-nál tartunk). Ettől függetlenül jó, hogy ideírtad, mert így bárki összehasonlíthatja a kettőt, és abból tanulhat, amelyik szimpatikusabb.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1485120607241271708/comments/default/1929083246290269725'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1485120607241271708/comments/default/1929083246290269725'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/10/java-forrasok-tanulashoz.html?showComment=1254403752129#c1929083246290269725' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/10/java-forrasok-tanulashoz.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-1485120607241271708' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/1485120607241271708' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2009. október 1. 15:29'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3671971197822793437</id><published>2009-10-03T22:30:32.208+02:00</published><updated>2009-10-03T22:30:32.208+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Azóta már két alkalom is volt, és egyrészt sikerül...</title><content type='html'>Azóta már két alkalom is volt, és egyrészt sikerült az időbe is beleférni. &lt;br /&gt;Ezt még odáig kéne fejleszteni, hogy egy számlálót is mutasson az ott lévő gép, hogy mennyi ideje van még hátra az előadónak.&lt;br /&gt;Másrészt online lett a kérdőív is.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6768451653104605209/comments/default/3671971197822793437'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6768451653104605209/comments/default/3671971197822793437'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/03/olap-java-eszkozokkel.html?showComment=1254601832208#c3671971197822793437' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/03/olap-java-eszkozokkel.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6768451653104605209' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6768451653104605209' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2009. október 3. 22:30'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8894732903331425247</id><published>2009-10-07T10:34:37.632+02:00</published><updated>2009-10-07T10:34:37.632+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Jó kis konf lehetett, sajnos most nincs időm ilyen...</title><content type='html'>Jó kis konf lehetett, sajnos most nincs időm ilyenekre.&lt;br /&gt;&lt;br /&gt;Verziókezelők kapcsán: &amp;quot;a merge a lényeg&amp;quot; Azt gondolnám, hogy a merge-elő eszköz független a verziókezelőtől.&lt;br /&gt;&lt;br /&gt;Abban sem hiszek, hogy a feature-öket branch-ekben kéne tartani. Inkább a kódot szervezem úgy, hogy a feature-ök kapcsolhatóak legyenek konfigurációval.&lt;br /&gt;&lt;br /&gt;A branch-ek közötti különbségek növelésével a merge művelet bonyolultsága és a hibalehetőségek száma exponenciálisan növekszik szerintem.&lt;br /&gt;&lt;br /&gt;Branch-ellenes vagyok.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4084766187948911501/comments/default/8894732903331425247'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4084766187948911501/comments/default/8894732903331425247'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/10/web-konferencia-2009.html?showComment=1254904477632#c8894732903331425247' title=''/><author><name>pcjuzer</name><uri>http://www.blogger.com/profile/02215826552900660449</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/10/web-konferencia-2009.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4084766187948911501' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4084766187948911501' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1989835059'/><gd:extendedProperty name='blogger.displayTime' value='2009. október 7. 10:34'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7403087814207326995</id><published>2009-10-07T11:13:01.682+02:00</published><updated>2009-10-07T11:13:01.682+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Én nem tudom, miben hiszek. :)
Szerencsére viszony...</title><content type='html'>Én nem tudom, miben hiszek. :)&lt;br /&gt;Szerencsére viszonylag lineáris projektjeink vannak, ezért ilyenbe nem futottam bele. Azért egy Linux kernel fejlesztés teljesen más tészta, mint egy ügyfél által megrendelt egyedi szoftver. &lt;br /&gt;Az előadó elmondta, hogy igen, a szoftverbe épített megoldás is nagyon jó, csak sok munka van vele. Ha jól tudom, nem Java-s világból való, inkább PHP, így nem tud olyan szép dolgokról, mint pl. az OSGi.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4084766187948911501/comments/default/7403087814207326995'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4084766187948911501/comments/default/7403087814207326995'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/10/web-konferencia-2009.html?showComment=1254906781682#c7403087814207326995' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/10/web-konferencia-2009.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4084766187948911501' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4084766187948911501' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2009. október 7. 11:13'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7028464185855856704</id><published>2009-10-19T11:20:03.185+02:00</published><updated>2009-10-19T11:20:03.185+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>&amp;quot;Generikus esetében a deklarációban és az ért...</title><content type='html'>&amp;quot;Generikus esetében a deklarációban és az értékadásban a generikus típusának pontosan meg kell egyeznie&amp;quot;&lt;br /&gt;&lt;br /&gt;Vagy félreértettelek, vagy tévedsz :-)&lt;br /&gt;Ez pl. legális:&lt;br /&gt;List&amp;lt;? extends Number&amp;gt; numbers = new ArrayList&amp;lt;Integer&amp;gt;();&lt;br /&gt;&lt;br /&gt;Ez persze nem fordul le:&lt;br /&gt;List&amp;lt;Integer&amp;gt; ints = new ArrayList&amp;lt;Integer&amp;gt;();&lt;br /&gt;List&amp;lt;Number&amp;gt; numbers = ints;&lt;br /&gt;Oka, hogy ha legális lenne, akkor lehetséges lenne az &amp;quot;ints&amp;quot; listába pl. Double számokat írni a numbers referencián keresztül:&lt;br /&gt;numbers.add(2.3);&lt;br /&gt;&lt;br /&gt;Ha viszont numbers List&amp;lt;? extends Number&amp;gt;, akkor a fenti sor (add hívása) nem fordul le.&lt;br /&gt;&lt;br /&gt;Mondjuk a generics a Javaban nem épp triviális, lásd mondjuk a következő, kissé ijesztő deklarációt: http://java.sun.com/javase/6/docs/api/java/util/Collections.html#max(java.util.Collection)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6053182487627786968/comments/default/7028464185855856704'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6053182487627786968/comments/default/7028464185855856704'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/10/scjp.html?showComment=1255944003185#c7028464185855856704' title=''/><author><name>Kofa</name><uri>http://www.blogger.com/profile/09608502634061041209</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/10/scjp.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6053182487627786968' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6053182487627786968' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-111703032'/><gd:extendedProperty name='blogger.displayTime' value='2009. október 19. 11:20'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-78976703019635549</id><published>2009-10-19T23:48:40.763+02:00</published><updated>2009-10-19T23:48:40.763+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi, javítottam, ott látszik, mire gondoltam.
Té...</title><content type='html'>Köszi, javítottam, ott látszik, mire gondoltam.&lt;br /&gt;Tény, hogy a szálakon kívül ezt utáltam a legjobban.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6053182487627786968/comments/default/78976703019635549'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6053182487627786968/comments/default/78976703019635549'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/10/scjp.html?showComment=1255988920763#c78976703019635549' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/10/scjp.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6053182487627786968' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6053182487627786968' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2009. október 19. 23:48'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3091343693216645293</id><published>2009-10-20T09:34:54.190+02:00</published><updated>2009-10-20T09:34:54.190+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>gratulálok! én is készülök régóta, de még gyűjtene...</title><content type='html'>gratulálok! én is készülök régóta, de még gyűjtenem kell rá.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6053182487627786968/comments/default/3091343693216645293'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6053182487627786968/comments/default/3091343693216645293'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/10/scjp.html?showComment=1256024094190#c3091343693216645293' title=''/><author><name>akos.tajti</name><uri>http://cesjava.freeblog.hu</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/10/scjp.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6053182487627786968' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6053182487627786968' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1451470054'/><gd:extendedProperty name='blogger.displayTime' value='2009. október 20. 9:34'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4645163962538769366</id><published>2009-10-20T09:40:07.125+02:00</published><updated>2009-10-20T09:40:07.125+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi!
Szerencsére nekem hivatalból kellett. :)
ht...</title><content type='html'>Köszi!&lt;br /&gt;Szerencsére nekem hivatalból kellett. :)&lt;br /&gt;http://www.szamalk.hu/Szolgaltatasok/oktatoink.aspx</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6053182487627786968/comments/default/4645163962538769366'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6053182487627786968/comments/default/4645163962538769366'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/10/scjp.html?showComment=1256024407125#c4645163962538769366' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/10/scjp.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6053182487627786968' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6053182487627786968' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2009. október 20. 9:40'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5449439275263365387</id><published>2009-10-20T09:47:51.822+02:00</published><updated>2009-10-20T09:47:51.822+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Generics ill. szálak témakörében ajánlott:
Java Co...</title><content type='html'>Generics ill. szálak témakörében ajánlott:&lt;br /&gt;Java Concurrency in Practice (http://www.javaconcurrencyinpractice.com/)&lt;br /&gt;&lt;br /&gt;Java Generics and Collections (http://www.oreilly.com/catalog/javagenerics/)&lt;br /&gt;&lt;br /&gt;Mindkét könyv nagyon jó. A Concurrency in Practice az alacsony szintű alapoktól (volatile, synchronized, Java Memory Model) a Java 5-ben bevezetett java.util.concurrent-ig mindent tárgyal, és azon túl is bemutat hasznos technikákat (pl. hogyan állítsunk le szálakat).&lt;br /&gt;&lt;br /&gt;A Generics and Collections első fele a generics bemutatásával foglalkozik, szintén az egyszerű esetektől a buktatókon át mindennel (pár apró hiba van benne, de ezeket könnyű kiszúrni). A második fele a collection osztályokat tárgyalja, bemutatva a belső működést is (pl. ConcurrentSkipListMap). A legjobb szakmai könyvek közé tartoznak, amelyeket olvastam (tény, hogy közel sem olvastam annyit, mint Te :-) ).</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6053182487627786968/comments/default/5449439275263365387'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6053182487627786968/comments/default/5449439275263365387'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/10/scjp.html?showComment=1256024871822#c5449439275263365387' title=''/><author><name>Kofa</name><uri>http://www.blogger.com/profile/09608502634061041209</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/10/scjp.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6053182487627786968' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6053182487627786968' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-111703032'/><gd:extendedProperty name='blogger.displayTime' value='2009. október 20. 9:47'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-882092584382039811</id><published>2009-10-20T10:05:50.737+02:00</published><updated>2009-10-20T10:05:50.737+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A Java Concurrency in Practice alapmű, már nagyon ...</title><content type='html'>A Java Concurrency in Practice alapmű, már nagyon régóta a listámon van, rengetegen ajánlják. &lt;br /&gt;De szerencsére mostanában a szálas dolgaimat megoldják az alkalmazásszerverek, nem is tudom, mikor írtam le utoljára, hogy Thread.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6053182487627786968/comments/default/882092584382039811'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6053182487627786968/comments/default/882092584382039811'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/10/scjp.html?showComment=1256025950737#c882092584382039811' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/10/scjp.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6053182487627786968' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6053182487627786968' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2009. október 20. 10:05'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1380119205107392708</id><published>2009-10-20T12:32:52.109+02:00</published><updated>2009-10-20T12:32:52.109+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Hát igen, az alkalmazásszervereknek megvannak az e...</title><content type='html'>Hát igen, az alkalmazásszervereknek megvannak az előnyeik. Viszont ha servlet API-val foglalkozol valamiért, és van állapot a servletben/filterben, máris bejön a többszálúság.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6053182487627786968/comments/default/1380119205107392708'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6053182487627786968/comments/default/1380119205107392708'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/10/scjp.html?showComment=1256034772109#c1380119205107392708' title=''/><author><name>Kofa</name><uri>http://www.blogger.com/profile/09608502634061041209</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/10/scjp.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6053182487627786968' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6053182487627786968' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-111703032'/><gd:extendedProperty name='blogger.displayTime' value='2009. október 20. 12:32'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7174398472061936190</id><published>2009-10-30T15:27:15.275+01:00</published><updated>2009-10-30T15:27:15.275+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nem egyszerűbb, ha használok a kódban egy
if( prop...</title><content type='html'>Nem egyszerűbb, ha használok a kódban egy&lt;br /&gt;if( propertyFile != null )&lt;br /&gt; PropertyConfigurator.configure(propertyFile);&lt;br /&gt;&lt;br /&gt;hívást akkor ha a propertyFile stringet meg tudom szerezni naming exception nélkül JNDI-ből, egy rögzített név alapján? A JNDI konfigurálható minden szervlet konténerben, ha meg nem konfiguráltam, akkor fallback defaultra.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3999068897644214024/comments/default/7174398472061936190'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3999068897644214024/comments/default/7174398472061936190'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/01/naplzs-webes-krnyezetben-log4j-vel.html?showComment=1256912835275#c7174398472061936190' title=''/><author><name>Verhás Péter</name><uri>http://www.blogger.com/profile/06377161363854132582</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/01/naplzs-webes-krnyezetben-log4j-vel.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3999068897644214024' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3999068897644214024' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-377703703'/><gd:extendedProperty name='blogger.displayTime' value='2009. október 30. 15:27'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3240975402578611804</id><published>2009-10-30T17:05:30.916+01:00</published><updated>2009-10-30T17:05:30.916+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Ha jól értem, annyi a különbség, hogy az állomány ...</title><content type='html'>Ha jól értem, annyi a különbség, hogy az állomány helyét nem a servletContext-ből veszed (azaz a web.xml-ből), hanem a JNDI-ből.&lt;br /&gt;Tökéletes megoldásnak tűnik az is.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3999068897644214024/comments/default/3240975402578611804'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3999068897644214024/comments/default/3240975402578611804'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/01/naplzs-webes-krnyezetben-log4j-vel.html?showComment=1256918730916#c3240975402578611804' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/01/naplzs-webes-krnyezetben-log4j-vel.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3999068897644214024' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3999068897644214024' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2009. október 30. 17:05'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5005151112558123490</id><published>2009-11-23T02:34:15.430+01:00</published><updated>2009-11-23T02:34:15.430+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>you might also want to look at vtd-xml, the latest...</title><content type='html'>you might also want to look at vtd-xml, the latest and most advanced XML processing API available today&lt;br /&gt;&lt;br /&gt;&lt;a href="http://vtd-xml.sf.net" rel="nofollow"&gt;http://vtd-xml.sf.net&lt;/a&gt;</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6117870073201976470/comments/default/5005151112558123490'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6117870073201976470/comments/default/5005151112558123490'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/11/jax-ws-melyviz.html?showComment=1258940055430#c5005151112558123490' title=''/><author><name>dontcare</name><uri>http://www.blogger.com/profile/14424619310452413715</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/11/jax-ws-melyviz.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6117870073201976470' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6117870073201976470' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1911439462'/><gd:extendedProperty name='blogger.displayTime' value='2009. november 23. 2:34'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5081650206227838383</id><published>2009-11-30T02:51:02.759+01:00</published><updated>2009-11-30T02:51:02.759+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Hi,

It would be great if you translated your arti...</title><content type='html'>Hi,&lt;br /&gt;&lt;br /&gt;It would be great if you translated your article also into English so we could read it too.&lt;br /&gt;&lt;br /&gt;Thanks,&lt;br /&gt;Leonid Rudy &lt;br /&gt;--&lt;br /&gt;The architect of &lt;a href="http://www.filigris.com/products/docflex_javadoc/" rel="nofollow"&gt;DocFlex/Javadoc&lt;/a&gt; tool mentioned here.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1438029047403381023/comments/default/5081650206227838383'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1438029047403381023/comments/default/5081650206227838383'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/07/rendszerterv-generalas-java-kodbol.html?showComment=1259545862759#c5081650206227838383' title=''/><author><name>Leonid</name><uri>http://www.blogger.com/profile/01198612226079554893</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/07/rendszerterv-generalas-java-kodbol.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-1438029047403381023' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/1438029047403381023' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1923682366'/><gd:extendedProperty name='blogger.displayTime' value='2009. november 30. 2:51'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1654390634916147970</id><published>2010-01-01T14:51:43.845+01:00</published><updated>2010-01-01T14:51:43.845+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszönöm az ajánlást.

Jó lenne a jegyzetem frissí...</title><content type='html'>Köszönöm az ajánlást.&lt;br /&gt;&lt;br /&gt;Jó lenne a jegyzetem frissíteni a Java 6-hoz is, de a tárgyam menet közben megszűnt.&lt;br /&gt;&lt;br /&gt;:-(</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1485120607241271708/comments/default/1654390634916147970'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1485120607241271708/comments/default/1654390634916147970'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/10/java-forrasok-tanulashoz.html?showComment=1262353903845#c1654390634916147970' title=''/><author><name>Gusztáv</name><uri>http://www.blogger.com/profile/16062855949139248371</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/10/java-forrasok-tanulashoz.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-1485120607241271708' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/1485120607241271708' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-972116689'/><gd:extendedProperty name='blogger.displayTime' value='2010. január 1. 14:51'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6605498231609577029</id><published>2010-01-02T15:09:58.512+01:00</published><updated>2010-01-02T15:09:58.512+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Kedves Gusztáv, azóta egy tanítványomat elkezdtem ...</title><content type='html'>Kedves Gusztáv, azóta egy tanítványomat elkezdtem ebből a jegyzetből oktatni, és nagyon tetszik. Amennyiben idén is folytatjuk, küldöm az árát.&lt;br /&gt;Sajnálom, hogy megszűnt a tantárgyad, érdemes lenne folytatni, esetleg kiadatni?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1485120607241271708/comments/default/6605498231609577029'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1485120607241271708/comments/default/6605498231609577029'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/10/java-forrasok-tanulashoz.html?showComment=1262441398512#c6605498231609577029' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/10/java-forrasok-tanulashoz.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-1485120607241271708' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/1485120607241271708' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. január 2. 15:09'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4228159506971676744</id><published>2010-01-08T22:26:11.071+01:00</published><updated>2010-01-08T22:26:11.071+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Hát, azt hiszem nyugodt szívvel kijelenthetem, hog...</title><content type='html'>Hát, azt hiszem nyugodt szívvel kijelenthetem, hogy ez az SCJP igazi szarrágás. &lt;br /&gt;&lt;br /&gt;Végignéztem az általad és a palacsint által gyűjtött (igazán kimerítőnek nevezhető) listákat, és úgy gondolom, hogy a megjegyzések nagyrészt arra utalnak, hogy a vizsga kb. a &amp;quot;szívatós egyetemi írásbeli vizsga&amp;quot; színvonalán megy.&lt;br /&gt;&lt;br /&gt;Találtam egy-két teljesen triviális dolgot (pl. &amp;quot;array toString() eredménye: [Ljava.lang.String;@a90653, nem az elemek toString-je&amp;quot;, &amp;quot;Polimorfizmus csak a példánymetódusokra vonatkozik, se a statikus metódusokra, se bármilyen típusú változókra&amp;quot;), amik minimális gyakorlás után szinte kiszúrják az ember szemét.&lt;br /&gt;&lt;br /&gt;Viszont például az ilyenek, hogy &amp;quot;A NumberFormatException az IllegalArgumentException leszármazottja&amp;quot;, meg hogy &amp;quot;StringBuffer.delete() második paramétere endIndex&amp;quot;, valamint hogy &amp;quot;A Throwable az osztály&amp;quot; nálam igencsak kiverik a biztosítékot, mégpedig azért mert ez a &amp;quot;magolj be sok-sok API-t totál feleslegesen&amp;quot; kategóriába tartozik számomra.&lt;br /&gt;&lt;br /&gt;Lehet, hogy én számítok &amp;quot;lúzernek&amp;quot;, de - bár gondolkodtam ilyen vizsgán néhány évnyi Java tapasztalattal - azt hiszem, hogy inkább skippelem a témát, mert ilyen formán totál baromságnak tartom az egészet. Ebből nekem az jön le, hogy gyakorlatilag, ha megtanulod az API-t lexikonszerűen, valamint a Java nyelvtanát (szintén lexikonszerűen), akkor überfaszán méltó vagy arra, hogy Java Professionalnak nevezd magad. Csak éppen hiába tudod, hogy például szintaktikailag hányféleképpen lehet egy nyomorék többdimenziós tömböt példányosítani static környezetben, ha emellett alig sajátítottál el valamit az egész szemléletből. &lt;br /&gt;&lt;br /&gt;Szigorúan csak szerintem.&lt;br /&gt;&lt;br /&gt;Félreértés ne essék, respect a szerzőknek, és köszi a gyűjtéseket az összes leeendő SCJP vizsgázó nevében is, csupán azzal a vizsgaszemlélettel van bajom, ami átjön az összegyüjtött érdekességekből.&lt;br /&gt;&lt;br /&gt;Üdv,&lt;br /&gt;M</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6053182487627786968/comments/default/4228159506971676744'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6053182487627786968/comments/default/4228159506971676744'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/10/scjp.html?showComment=1262985971071#c4228159506971676744' title=''/><author><name>Kaszi</name><uri>http://www.blogger.com/profile/12956525493979920741</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='23' height='32' src='http://2.bp.blogspot.com/_6C8nkRAmBVE/SP0EkWABIAI/AAAAAAAAANY/0xPAmL29JbU/S220/Kaszi-Portrait-jobb.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/10/scjp.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6053182487627786968' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6053182487627786968' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1928083152'/><gd:extendedProperty name='blogger.displayTime' value='2010. január 8. 22:26'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3698346996652018502</id><published>2010-01-08T22:32:57.315+01:00</published><updated>2010-01-08T22:32:57.315+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi a REST fogalmának szabatos összefoglalását, ...</title><content type='html'>Köszi a REST fogalmának szabatos összefoglalását, még biztosan hasznomra lesz :)&lt;br /&gt;&lt;br /&gt;Nem tudom, hogy mennyire ismerős számodra a &amp;quot;konkurrens&amp;quot; implementáció, a JBoss-féle &lt;a href="http://jboss.org/resteasy" rel="nofollow"&gt;RESTEasy&lt;/a&gt;. Ha nem ismerős, akkor ajánlom figyelmedbe, ha ismerős, akkor írhatnál róla tapasztalatokat :)&lt;br /&gt;&lt;br /&gt;Üdv,&lt;br /&gt;M</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2978305213591579409/comments/default/3698346996652018502'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2978305213591579409/comments/default/3698346996652018502'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/12/restful-web-szolgaltatasok-jersey-vel.html?showComment=1262986377315#c3698346996652018502' title=''/><author><name>Kaszi</name><uri>http://www.blogger.com/profile/12956525493979920741</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='23' height='32' src='http://2.bp.blogspot.com/_6C8nkRAmBVE/SP0EkWABIAI/AAAAAAAAANY/0xPAmL29JbU/S220/Kaszi-Portrait-jobb.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/12/restful-web-szolgaltatasok-jersey-vel.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2978305213591579409' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2978305213591579409' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1928083152'/><gd:extendedProperty name='blogger.displayTime' value='2010. január 8. 22:32'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3007472655353474747</id><published>2010-01-09T22:13:30.695+01:00</published><updated>2010-01-09T22:13:30.695+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Sajnos nem ismerem a RESTEasy-t, de amint valami m...</title><content type='html'>Sajnos nem ismerem a RESTEasy-t, de amint valami miatt felidegesít a Jersey, kipróbálom azt is.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2978305213591579409/comments/default/3007472655353474747'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2978305213591579409/comments/default/3007472655353474747'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/12/restful-web-szolgaltatasok-jersey-vel.html?showComment=1263071610695#c3007472655353474747' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/12/restful-web-szolgaltatasok-jersey-vel.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2978305213591579409' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2978305213591579409' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. január 9. 22:13'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7165401212974199356</id><published>2010-01-09T22:36:14.277+01:00</published><updated>2010-01-09T22:36:14.277+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Egyetértek veled abban, hogy az SCJP vizsgától nem...</title><content type='html'>Egyetértek veled abban, hogy az SCJP vizsgától nem lesz valaki jó programozó. Viszont szerintem jobb programozó lesz.&lt;br /&gt;Valamint Java-t oktatok, és szerintem ilyen szintű tudás kell ahhoz, hogy biztosan tudj a hallgatóknak bármit állítani. Igen, sokszor kérdeznek rá ilyenre, nem mondhatod nekik azt, hogy bocs, nem tudom fejből az API-t.&lt;br /&gt;&lt;br /&gt;Szóval szerencsére a dolog választható, mindenki döntse el magának, hogy megéri-e a befektetett időt, energiát és pénzt. Feltehetőleg a Java programozók egy részének nem éri meg.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6053182487627786968/comments/default/7165401212974199356'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6053182487627786968/comments/default/7165401212974199356'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/10/scjp.html?showComment=1263072974277#c7165401212974199356' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/10/scjp.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6053182487627786968' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6053182487627786968' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. január 9. 22:36'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3495062475310553636</id><published>2010-01-10T13:01:28.436+01:00</published><updated>2010-01-10T13:01:28.436+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Közben eszembe jutott még egy érv az SCJP mellett....</title><content type='html'>Közben eszembe jutott még egy érv az SCJP mellett. Mostanság egyre több pályázatot látok, ahol szükséges/előny az SCJP vizsga. Azaz a munkáltatók is szeretni fognak, ha az SCJP-del pályázni tudnak különböző projektekre.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6053182487627786968/comments/default/3495062475310553636'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6053182487627786968/comments/default/3495062475310553636'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/10/scjp.html?showComment=1263124888436#c3495062475310553636' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/10/scjp.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6053182487627786968' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6053182487627786968' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. január 10. 13:01'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2266672367774753490</id><published>2010-01-28T09:30:51.083+01:00</published><updated>2010-01-28T09:30:51.083+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Apache Digester nagyon kellemes meglepetést okozot...</title><content type='html'>Apache Digester nagyon kellemes meglepetést okozott olyan esetben amikor a DOM túl erőforrásigényesnek, a SAX pedig macerásnak bizonyult.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2512148931421846139/comments/default/2266672367774753490'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2512148931421846139/comments/default/2266672367774753490'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/01/kedvenc-java-library-k.html?showComment=1264667451083#c2266672367774753490' title=''/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/01/kedvenc-java-library-k.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2512148931421846139' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2512148931421846139' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2068650798'/><gd:extendedProperty name='blogger.displayTime' value='2010. január 28. 9:30'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8070206227249481380</id><published>2010-01-28T09:39:45.962+01:00</published><updated>2010-01-28T09:39:45.962+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>az én bevált musthave listám az elhangzottakon kív...</title><content type='html'>az én bevált musthave listám az elhangzottakon kívül: wicket, mockito, aspectj (és maven2 és mercurial, de java libeket kérdeztél). &lt;br /&gt;&lt;br /&gt;Miért idegenkedsz az Eclipse cuccoktól? BIRT-tel pont nincs tapasztalatom, de alapvetően nagyon jók szerintem.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2512148931421846139/comments/default/8070206227249481380'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2512148931421846139/comments/default/8070206227249481380'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/01/kedvenc-java-library-k.html?showComment=1264667985962#c8070206227249481380' title=''/><author><name>Kristof Jozsa</name><uri>http://www.blogger.com/profile/06607669172500255805</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/01/kedvenc-java-library-k.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2512148931421846139' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2512148931421846139' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-686590949'/><gd:extendedProperty name='blogger.displayTime' value='2010. január 28. 9:39'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-163630966916691588</id><published>2010-01-28T10:02:36.947+01:00</published><updated>2010-01-28T10:02:36.947+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A JQuery-vel szemezgetek én is. Emellett még az ex...</title><content type='html'>A JQuery-vel szemezgetek én is. Emellett még az extjs és a YUI van versenyben.&lt;br /&gt;&lt;br /&gt;Az extjs-t a licenszelés miatt érzem problémásnak. (Ha nem open source projektet akarok csinálni akkor borsos az ára.) A YUI ígéretes, a JQuery-ben viszont nem látok egy homogén GUI komponens könyvtárat, ami miatt az egész kellene nekem. Bár lehet hogy csak rossz helyen keresgélek. Mindenki által írt külső plugineket találok, node ezekben mennyire lehet megbízni? Ezeknek is összevissza van a licenszelése gondolom.&lt;br /&gt;&lt;br /&gt;Egyéb java könyvtárak amiket megelédeséssel használok: mindenféle Apache cuccok (jetty, poi, commons, beanutils, stb.)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2512148931421846139/comments/default/163630966916691588'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2512148931421846139/comments/default/163630966916691588'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/01/kedvenc-java-library-k.html?showComment=1264669356947#c163630966916691588' title=''/><author><name>pcjuzer</name><uri>http://www.blogger.com/profile/02215826552900660449</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/01/kedvenc-java-library-k.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2512148931421846139' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2512148931421846139' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1989835059'/><gd:extendedProperty name='blogger.displayTime' value='2010. január 28. 10:02'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2488613169074943373</id><published>2010-01-28T12:47:14.202+01:00</published><updated>2010-01-28T12:47:14.202+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A YUI-t nehogy használd!!! jQery-hez van a jquery-...</title><content type='html'>A YUI-t nehogy használd!!! jQery-hez van a jquery-ui, nézzd meg azt.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2512148931421846139/comments/default/2488613169074943373'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2512148931421846139/comments/default/2488613169074943373'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/01/kedvenc-java-library-k.html?showComment=1264679234202#c2488613169074943373' title=''/><author><name>sajt</name><uri>http://www.blogger.com/profile/14372378659099251736</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/01/kedvenc-java-library-k.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2512148931421846139' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2512148931421846139' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1372278248'/><gd:extendedProperty name='blogger.displayTime' value='2010. január 28. 12:47'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6738267004061327010</id><published>2010-01-28T12:49:37.522+01:00</published><updated>2010-01-28T12:49:37.522+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Ez egy nagyon jó összefoglaló, köszönöm szépen. Én...</title><content type='html'>Ez egy nagyon jó összefoglaló, köszönöm szépen. Én most egy szervert csinálok, amiben hibernate-et használok. Akérdésem az, hogy érdemes-e ezt spring-el és jdbc-vel csinálni? A szervernek semmilyen felhasználói felülete nincsen. (illetve van, csak az php-ban van megvalósítva.)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2512148931421846139/comments/default/6738267004061327010'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2512148931421846139/comments/default/6738267004061327010'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/01/kedvenc-java-library-k.html?showComment=1264679377522#c6738267004061327010' title=''/><author><name>sajt</name><uri>http://www.blogger.com/profile/14372378659099251736</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/01/kedvenc-java-library-k.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2512148931421846139' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2512148931421846139' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1372278248'/><gd:extendedProperty name='blogger.displayTime' value='2010. január 28. 12:49'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2896260131686151394</id><published>2010-01-28T14:54:31.442+01:00</published><updated>2010-01-28T14:54:31.442+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>@Névtelen: Én ilyen esetekben a standard JAXB-t va...</title><content type='html'>@Névtelen: Én ilyen esetekben a standard JAXB-t vagy ahol fontos a sebesség, a StAX-ot, régebben a JDOM és dom4j is szerepelt a palettán.&lt;br /&gt;&lt;br /&gt;@Kristóf: Wicket és Mockito már régóta a queue-ban van, mindenképp ki fogom őket próbálni. Az Eclipse cuccok nekem mindig kicsit pilótavizsgások voltak, de amúgy nem zárkózom el előlük. Úgy éreztem, hogy nehezebb velük elindulni, de aztán többet lehet kihozni belőlük. Ha a JasperReports-szal valamit nem tudok majd megoldani, tuti a BIRT lesz a következő versenyző.&lt;br /&gt;&lt;br /&gt;@pcjuzer: Mi igyekszünk a standard HTML felhasználói felületnél maradni, amíg lehet, így a csilli-villi komponensekkel nem nagy tapasztalatom van. Eddig a jQuery UI tab-ját használtam, valamint a jsTree fa komponenst, azokkal nem volt baj.&lt;br /&gt;&lt;br /&gt;@sajt: a Spring szerintem mindenképp jó választás, hogy az alatt JDBC-t vagy JPA-t, esetleg Hibernate-et használsz, az már az alkalmazástól függ. Az első kettő közül javaslom, hogy válassz. Ha az alkalmazás már sok meglévő táblát használ, ahol a séma nem egészen 3. NF-ban van, és nagy adattömeggel dolgoznak, esetleg ki akarod használni az adatbáziskezelő tulajdonságait (pl. erősebben támaszkodsz tárolt eljárásokra), akkor JDBC. Ha te tervezheted meg az adatbázist, főleg entitásaid vannak, egyszerűbb táblákkal, kapcsolatokkal, kisebb adatmennyiséggel, és az üzleti logika a Java oldalon van, akkor JPA. Sőt a kettőt keverni is lehet, pl. JPA lehet az üzleti entitásai kezelésére, de JDBC a riportok kezelésére, vagy nagy választási listák kezelésére. Ha jól emlékszem, ez utóbbi a Value List Handler tervezési minta.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2512148931421846139/comments/default/2896260131686151394'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2512148931421846139/comments/default/2896260131686151394'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/01/kedvenc-java-library-k.html?showComment=1264686871442#c2896260131686151394' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/01/kedvenc-java-library-k.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2512148931421846139' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2512148931421846139' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. január 28. 14:54'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1604153255395953753</id><published>2010-01-28T16:45:57.765+01:00</published><updated>2010-01-28T16:45:57.765+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>EHCache, WhirlyCache - cacheléshez
iText - Pdf kés...</title><content type='html'>EHCache, WhirlyCache - cacheléshez&lt;br /&gt;iText - Pdf készítéshez&lt;br /&gt;apache commons-* - Sokmindenhez</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2512148931421846139/comments/default/1604153255395953753'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2512148931421846139/comments/default/1604153255395953753'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/01/kedvenc-java-library-k.html?showComment=1264693557765#c1604153255395953753' title=''/><author><name>Luti</name><uri>http://www.blogger.com/profile/03525307700649486371</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/01/kedvenc-java-library-k.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2512148931421846139' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2512148931421846139' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2075535723'/><gd:extendedProperty name='blogger.displayTime' value='2010. január 28. 16:45'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2841759611136272111</id><published>2010-01-29T13:41:16.374+01:00</published><updated>2010-01-29T13:41:16.374+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Az SLF4J-ben nagyon kellemes a {}-es behelyettesít...</title><content type='html'>Az SLF4J-ben nagyon kellemes a {}-es behelyettesítés.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2512148931421846139/comments/default/2841759611136272111'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2512148931421846139/comments/default/2841759611136272111'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/01/kedvenc-java-library-k.html?showComment=1264768876374#c2841759611136272111' title=''/><author><name>palacsint</name><uri>http://palacsint.hu/</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/01/kedvenc-java-library-k.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2512148931421846139' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2512148931421846139' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-473317360'/><gd:extendedProperty name='blogger.displayTime' value='2010. január 29. 13:41'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5192255580713960502</id><published>2010-02-08T14:22:27.851+01:00</published><updated>2010-02-08T14:22:27.851+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Bug a kodban: az ArrayList kisbetus page-t kap, od...</title><content type='html'>Bug a kodban: az ArrayList kisbetus page-t kap, oda osztalynev (Page) kell.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7801878101879687317/comments/default/5192255580713960502'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7801878101879687317/comments/default/5192255580713960502'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/07/jaxb.html?showComment=1265635347851#c5192255580713960502' title=''/><author><name>George Hron</name><uri>http://www.blogger.com/profile/15406106695993366523</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_DKmHrnCj1NE/SvSwsBa_ZbI/AAAAAAAAAIs/Krfpmmttbmo/S220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/07/jaxb.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7801878101879687317' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7801878101879687317' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-171155537'/><gd:extendedProperty name='blogger.displayTime' value='2010. február 8. 14:22'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2826614769774949235</id><published>2010-02-08T20:44:35.978+01:00</published><updated>2010-02-08T20:44:35.978+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nagyon szépen köszönöm, javítottam! Sajnos a Blogg...</title><content type='html'>Nagyon szépen köszönöm, javítottam! Sajnos a Blogger rendszere HTML tag-nek nézte, így ő konvertálta át, és lezáró html tag-eket is tett.&lt;br /&gt;&lt;br /&gt;Most, hogy &amp;gt; és &amp;lt; egyedhivatkozásokat alkalmaztam, megette.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7801878101879687317/comments/default/2826614769774949235'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7801878101879687317/comments/default/2826614769774949235'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/07/jaxb.html?showComment=1265658275978#c2826614769774949235' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/07/jaxb.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7801878101879687317' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7801878101879687317' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. február 8. 20:44'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-155844986833448588</id><published>2010-02-20T16:16:54.349+01:00</published><updated>2010-02-20T16:16:54.349+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>erről pár napja leveleztem valakivel, én tartom h ...</title><content type='html'>erről pár napja leveleztem valakivel, én tartom h teljes félreértés van a dologban és egész más a stub és a mock közti különbség. abban a vitában is az &amp;#39;art of unit testing&amp;#39; volt a félremagyarázásért a bűnös..</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2956340460285563720/comments/default/155844986833448588'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2956340460285563720/comments/default/155844986833448588'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/02/mockito.html?showComment=1266679014349#c155844986833448588' title=''/><author><name>Kristof Jozsa</name><uri>http://www.blogger.com/profile/06607669172500255805</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/02/mockito.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2956340460285563720' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2956340460285563720' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-686590949'/><gd:extendedProperty name='blogger.displayTime' value='2010. február 20. 16:16'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-735517703998465642</id><published>2010-02-20T16:25:53.009+01:00</published><updated>2010-02-20T16:25:53.009+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Személy szerint nekem mindegy. :) Sajnos ebben a v...</title><content type='html'>Személy szerint nekem mindegy. :) Sajnos ebben a világban nincsenek egységes elnevezések, ezért volt jó a tervezési minták megjelenése, mert adott ilyeneket. Nem volt nagy találmány, mindenki ismerte azokat a megoldásokat, de végre nevet kaptak. A lényeg, hogy a fejlesztők ismerjék a különböző megközelítéseket, és mielőtt elkezdenek beszélgetni, egyeztessék előtte melyikük mire gondol egy név alatt. Én az irodalomból indultam ki, és sajnos már más könyv is átvette ezt a megközelítést, pl. a Next Generation Java Testing is. És igazából az a definíció lesz elfogadott, amelyiket többen idézik. :)&lt;br /&gt;&lt;br /&gt;Szerinted mi a különbség?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2956340460285563720/comments/default/735517703998465642'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2956340460285563720/comments/default/735517703998465642'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/02/mockito.html?showComment=1266679553009#c735517703998465642' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/02/mockito.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2956340460285563720' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2956340460285563720' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. február 20. 16:25'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6598548949953401543</id><published>2010-02-20T16:37:24.739+01:00</published><updated>2010-02-20T16:37:24.739+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>ez igaz h a népszerűbb lesz az &amp;quot;igaz&amp;quot; ha...</title><content type='html'>ez igaz h a népszerűbb lesz az &amp;quot;igaz&amp;quot; ha elég sokáig mondják:) &lt;br /&gt;&lt;br /&gt;idézem amit múltkor írtam az említett levélben:&lt;br /&gt;&amp;quot;- szerintem stub az, ami forráskód szinten megjelenik (XStub.java)&lt;br /&gt;- szerintem mock az, ami forráskód szinten nem jelenik meg, egy&lt;br /&gt;mocking framework generálja automatikusan (mock(X.class).when(..) stb)&amp;quot;&lt;br /&gt;&amp;quot;.. update: előszedtem a Fowler cikket és én abban is azt látom leírva&lt;br /&gt;amit én gondolok.. ha megnézed, a Stub ez:&lt;br /&gt;public class MailServiceStub implements MailService { .. }&lt;br /&gt;&lt;br /&gt;a mock meg ez:&lt;br /&gt;Mock mailer = mock(MailService.class);&lt;br /&gt;&lt;br /&gt;innen józan ésszel nekiugorva látszik hogy a tesztelés szempontjából a&lt;br /&gt;végeredmény közelítőleg ugyanaz, a különbség h stubbal több energiával&lt;br /&gt;de pontosabb eredményt tudsz elérni, mockkal meg hirtelen valami&lt;br /&gt;egyszerűbbet. Az esetek 95%-ában pedig édesmindegy melyiket használod,&lt;br /&gt;csak mockot kisebb energia..&amp;quot;&lt;br /&gt;&lt;br /&gt;ami a további kavart okozza h a &amp;#39;stub&amp;#39; szót igeként is használják angolul, tehát lehet stubbing method callról beszélni amit egy mockkal érsz el, ettől ez még nem stub csak stubbing :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2956340460285563720/comments/default/6598548949953401543'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2956340460285563720/comments/default/6598548949953401543'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/02/mockito.html?showComment=1266680244739#c6598548949953401543' title=''/><author><name>Kristof Jozsa</name><uri>http://www.blogger.com/profile/06607669172500255805</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/02/mockito.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2956340460285563720' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2956340460285563720' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-686590949'/><gd:extendedProperty name='blogger.displayTime' value='2010. február 20. 16:37'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-825698255943180077</id><published>2010-02-20T16:48:24.803+01:00</published><updated>2010-02-20T16:48:24.803+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Ezt is simán elfogadom, de nekem megfér mindkét de...</title><content type='html'>Ezt is simán elfogadom, de nekem megfér mindkét definíció egymás mellett. :)&lt;br /&gt;A cikkben is, mikor az elnevezéseket taglaltam (Mockrunner, spring-mock), pont erre utaltam.&lt;br /&gt;Viszont szerintem a mock-olósdi sokkal alkalmasabb az &amp;#39;Art of unit testing&amp;#39; féle technikára, ugyanis stub-ban nem szoktunk olyanokat implementálgatni, hogy meghívja e az adott metódust, és mennyiszer, milyen sorrendben. Az vár értéket amit lehett assert-elni, meg visszaad értéket, ami meg használ a tesztelendő objektum.&lt;br /&gt;Szóval a te definíciód szerintem feltétele a másodiknak, a második már ahhoz rak hozzá plusz feltételt.&lt;br /&gt;Persze nem biztos, hogy jogosan. :) Szóval a két definíció szerintem nem független egymástól, az egyik a másiknak a továbbvitele.&lt;br /&gt;És ráadásul a másik definíciót erősen használva lehet csapdába esni, mert ott jön elő, hogy nem az input/output-ra figyelsz, hanem a belső működésre, hiszen mindegy, hogy valamit hányszor hív meg, a lényeg, hogy az adott input-ra a kívánt ouput-ot adja.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2956340460285563720/comments/default/825698255943180077'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2956340460285563720/comments/default/825698255943180077'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/02/mockito.html?showComment=1266680904803#c825698255943180077' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/02/mockito.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2956340460285563720' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2956340460285563720' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. február 20. 16:48'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1201772645621602092</id><published>2010-02-20T16:54:41.610+01:00</published><updated>2010-02-20T16:54:41.610+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>http://www.youtube.com/watch?v=GJOcvQpMu2A 1:10</title><content type='html'>http://www.youtube.com/watch?v=GJOcvQpMu2A 1:10</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2956340460285563720/comments/default/1201772645621602092'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2956340460285563720/comments/default/1201772645621602092'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/02/mockito.html?showComment=1266681281610#c1201772645621602092' title=''/><author><name>Kristof Jozsa</name><uri>http://www.blogger.com/profile/06607669172500255805</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/02/mockito.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2956340460285563720' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2956340460285563720' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-686590949'/><gd:extendedProperty name='blogger.displayTime' value='2010. február 20. 16:54'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8188010319360291974</id><published>2010-02-24T10:48:08.473+01:00</published><updated>2010-02-24T10:48:08.473+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Ha lesz egy kis időm, csinálok egy kutatást a nete...</title><content type='html'>Ha lesz egy kis időm, csinálok egy kutatást a neten, hogy kiknek mit jelentenek ezek a fogalmak, és honnan származnak az elnevezések és az egyéni (félre?)értelmezések.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2956340460285563720/comments/default/8188010319360291974'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2956340460285563720/comments/default/8188010319360291974'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/02/mockito.html?showComment=1267004888473#c8188010319360291974' title=''/><author><name>pityufiu</name><uri>http://www.blogger.com/profile/13620561176122999497</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://1.bp.blogspot.com/_jQEHa8Ux_1I/S0eMU6t8VsI/AAAAAAAACrA/YBThKPpIonM/S220/karpatalja24.JPG'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/02/mockito.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2956340460285563720' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2956340460285563720' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1963072178'/><gd:extendedProperty name='blogger.displayTime' value='2010. február 24. 10:48'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7250709203224162405</id><published>2010-02-24T13:44:07.433+01:00</published><updated>2010-02-24T13:44:07.433+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nagyon jó a cikk.
Az &lt;i&gt;osztálydiagrammot&lt;/i&gt; mely...</title><content type='html'>Nagyon jó a cikk.&lt;br /&gt;Az &lt;i&gt;osztálydiagrammot&lt;/i&gt; melyik programmal készítetted?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2956340460285563720/comments/default/7250709203224162405'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2956340460285563720/comments/default/7250709203224162405'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/02/mockito.html?showComment=1267015447433#c7250709203224162405' title=''/><author><name>Belas</name><uri>http://www.blogger.com/profile/15137827325694301125</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/02/mockito.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2956340460285563720' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2956340460285563720' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1487619858'/><gd:extendedProperty name='blogger.displayTime' value='2010. február 24. 13:44'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6321530604403547495</id><published>2010-02-24T15:50:06.992+01:00</published><updated>2010-02-24T15:50:06.992+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szia! Köszönöm! A kép URL-jéből kiderül, hogy ez e...</title><content type='html'>Szia! Köszönöm! A kép URL-jéből kiderül, hogy ez egy webes alkalmazással készül: http://yuml.me/</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2956340460285563720/comments/default/6321530604403547495'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2956340460285563720/comments/default/6321530604403547495'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/02/mockito.html?showComment=1267023006992#c6321530604403547495' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/02/mockito.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2956340460285563720' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2956340460285563720' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. február 24. 15:50'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8048622438665191833</id><published>2010-02-24T16:02:57.735+01:00</published><updated>2010-02-24T16:02:57.735+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Remek cikk!</title><content type='html'>Remek cikk!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2956340460285563720/comments/default/8048622438665191833'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2956340460285563720/comments/default/8048622438665191833'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/02/mockito.html?showComment=1267023777735#c8048622438665191833' title=''/><author><name>Steve</name><uri>http://www.blogger.com/profile/13407946410017714787</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='22' height='32' src='http://4.bp.blogspot.com/_vQZ0v7M3MUE/Se9oqIZ2MkI/AAAAAAAAHAc/Tnkosf-DRm0/S220/Csabi+1+300+x.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/02/mockito.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2956340460285563720' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2956340460285563720' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1169922675'/><gd:extendedProperty name='blogger.displayTime' value='2010. február 24. 16:02'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6014265859486147503</id><published>2010-02-25T22:52:00.045+01:00</published><updated>2010-02-25T22:52:00.045+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Ruby Best Practices (http://sandal.github.com/rbp-...</title><content type='html'>Ruby Best Practices (http://sandal.github.com/rbp-book/pdfs/ch01.pdf), 17. oldal. A stub amikor felülvágja az eredeti metódust konkrét kóddal, a mock amikor a mock frameworkkel átdefiniálja a hívás eredményét. &lt;br /&gt;&lt;br /&gt;(és ha már belenéztek, a 16. oldalon ahogy szórja tömegesen a teszteket a QuestionerTest osztályban kicsit bdd stílusban önleíróan, iszonyú tömören és olvashatóan, azon behasaltam. rubysoktól érdemes tesztelést tanulni nem .NET-es könyvből.. :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2956340460285563720/comments/default/6014265859486147503'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2956340460285563720/comments/default/6014265859486147503'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/02/mockito.html?showComment=1267134720045#c6014265859486147503' title=''/><author><name>Kristof Jozsa</name><uri>http://www.blogger.com/profile/06607669172500255805</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/02/mockito.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2956340460285563720' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2956340460285563720' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-686590949'/><gd:extendedProperty name='blogger.displayTime' value='2010. február 25. 22:52'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1590982944037448856</id><published>2010-03-31T12:09:01.670+02:00</published><updated>2010-03-31T12:09:01.670+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>JMeter helyett szerintem egyszer próbáld ki a Grin...</title><content type='html'>JMeter helyett szerintem egyszer próbáld ki a Grindert, egy nagyságrenddel professzionálisabb, többet tud (pl. https proxy), és ami a legjobb: [PJ]ythonban szkriptelhető!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3404280541226145466/comments/default/1590982944037448856'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3404280541226145466/comments/default/1590982944037448856'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/02/kedvenc-java-eszkozok.html?showComment=1270030141670#c1590982944037448856' title=''/><author><name>radirpok</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/02/kedvenc-java-eszkozok.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3404280541226145466' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3404280541226145466' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-552430629'/><gd:extendedProperty name='blogger.displayTime' value='2010. március 31. 12:09'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1890938783625566814</id><published>2010-04-29T00:52:00.891+02:00</published><updated>2010-04-29T00:52:00.891+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Fasza írás, grat ehhez is. Az eclipse-hez vázolt m...</title><content type='html'>Fasza írás, grat ehhez is. Az eclipse-hez vázolt megoldásod viszont több projektes környezetben már nehézkes, az m2eclipse workspace resolution feature-je (azaz, hogy a függő projektet ne jar-ként keresse a repoban, hanem közvetlen szedje a workspace-ben lévő projektből készített .class-okból) sztem killer.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4550403846114418343/comments/default/1890938783625566814'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4550403846114418343/comments/default/1890938783625566814'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/04/maven-kezdolepesek.html?showComment=1272495120891#c1890938783625566814' title=''/><author><name>jbuzi</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/04/maven-kezdolepesek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4550403846114418343' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4550403846114418343' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1929650762'/><gd:extendedProperty name='blogger.displayTime' value='2010. április 29. 0:52'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-987094525335555882</id><published>2010-04-29T07:35:11.089+02:00</published><updated>2010-04-29T07:35:11.089+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>jbuzi: ha jól csinálod, a maven eclipse pluginnal ...</title><content type='html'>jbuzi: ha jól csinálod, a maven eclipse pluginnal generált eclipse projectek is összefüggőek, nem a repo-s project jarokra dependálnak. Az m2eclipse szép lenne csak nem működik, évek óta szánalmasan instabil, q4e meg még mindig a tojásban..</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4550403846114418343/comments/default/987094525335555882'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4550403846114418343/comments/default/987094525335555882'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/04/maven-kezdolepesek.html?showComment=1272519311089#c987094525335555882' title=''/><author><name>Kristof Jozsa</name><uri>http://www.blogger.com/profile/06607669172500255805</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/04/maven-kezdolepesek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4550403846114418343' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4550403846114418343' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-686590949'/><gd:extendedProperty name='blogger.displayTime' value='2010. április 29. 7:35'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-26011170954326945</id><published>2010-04-29T13:09:25.939+02:00</published><updated>2010-04-29T13:09:25.939+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Kristóf: Köszönöm az infót, utánalesek.</title><content type='html'>Kristóf: Köszönöm az infót, utánalesek.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4550403846114418343/comments/default/26011170954326945'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4550403846114418343/comments/default/26011170954326945'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/04/maven-kezdolepesek.html?showComment=1272539365939#c26011170954326945' title=''/><author><name>jbuzi</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/04/maven-kezdolepesek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4550403846114418343' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4550403846114418343' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2012643543'/><gd:extendedProperty name='blogger.displayTime' value='2010. április 29. 13:09'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-652280461843725949</id><published>2010-04-30T18:32:37.642+02:00</published><updated>2010-04-30T18:32:37.642+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Az m2eclipse-szel nekem speciel semmi bajom, haszn...</title><content type='html'>Az m2eclipse-szel nekem speciel semmi bajom, használom, szerintem működik.&lt;br /&gt;Repository Manager-nek a Nexus jobban bejön, tud p2 repokat is kezelni, ami nekünk jó, mert mi olyan perverzek vagyunk, hogy még az Eclipse pluginjeinket is Maven-nel (Tycho-val) build-eljük ;-)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4550403846114418343/comments/default/652280461843725949'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4550403846114418343/comments/default/652280461843725949'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/04/maven-kezdolepesek.html?showComment=1272645157642#c652280461843725949' title=''/><author><name>G</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/04/maven-kezdolepesek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4550403846114418343' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4550403846114418343' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-225536512'/><gd:extendedProperty name='blogger.displayTime' value='2010. április 30. 18:32'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-426010541957613465</id><published>2010-05-29T11:01:04.623+02:00</published><updated>2010-05-29T11:01:04.623+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Az xml egy olyan formátum, amit még a menedzserek ...</title><content type='html'>Az xml egy olyan formátum, amit még a menedzserek is fel tudnak fogni. Azzal a marketing bullshittel könnyebb mindent eladni, hogy ezt a workflow-t már csak xml-ben kell átkonfigurálni, de amúgy készenvan. Sajna az élet azt mutatja, hogy mindig hozzá kell nyúlni a Java kódhoz, így fejlesztői oldalról teljesen feleslegesen veszti el az alkalmazás egy része a compile time típusellenőrzést, és sodor minket egy nehezebben karbantartható kódhoz.&lt;br /&gt;Érdekes módon viszont pont a spring konfigurációnál xml párti vagyok, azaz annotation ellenes, szerintem sokkal jobban átlátható a layerek és service-ek kapcsolata az applicationContext nézegetésével, mint összekeresni a megfelelő annotációkat. Másrészt pedig így abszolút független maradhat a kódunk a springtől, ami sokszor jól jöhet (gondolom nem csak én szívtam már olyannal, hogy integrálni akartam egy opensource modult, ami kitalálta, hogy springet használ, csaképp más verziót, mint amit én - reméljük java7-tel már ez sem lesz akkora probléma). És erre még az sem megoldás, hogy a spring3 már sok helyen szabványos annotationöket használ.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7575740467544252298/comments/default/426010541957613465'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7575740467544252298/comments/default/426010541957613465'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/05/spring-in-action.html?showComment=1275123664623#c426010541957613465' title=''/><author><name>jbuzi</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/05/spring-in-action.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7575740467544252298' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7575740467544252298' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1424281994'/><gd:extendedProperty name='blogger.displayTime' value='2010. május 29. 11:01'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2228659447791313479</id><published>2010-05-29T15:44:40.613+02:00</published><updated>2010-05-29T15:44:40.613+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A spring referencia megemliti, hogy az appcontexte...</title><content type='html'>A spring referencia megemliti, hogy az appcontextek hiearchiaba rendezhetok. A konyv ir errol valamit, mert a refben nincsen targyalva.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7575740467544252298/comments/default/2228659447791313479'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7575740467544252298/comments/default/2228659447791313479'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/05/spring-in-action.html?showComment=1275140680613#c2228659447791313479' title=''/><author><name>zmb</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/05/spring-in-action.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7575740467544252298' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7575740467544252298' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1273477583'/><gd:extendedProperty name='blogger.displayTime' value='2010. május 29. 15:44'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4912201470135522530</id><published>2010-05-29T23:39:48.637+02:00</published><updated>2010-05-29T23:39:48.637+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>@jbuzi Minden szavad igaz.

@zmb Nem, a könyv nem ...</title><content type='html'>@jbuzi Minden szavad igaz.&lt;br /&gt;&lt;br /&gt;@zmb Nem, a könyv nem ír erről semmit. Itt van egy bejegyzés erről, mely elég jó: http://blog.springsource.com/2007/06/11/using-a-shared-parent-application-context-in-a-multi-war-spring-application/</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7575740467544252298/comments/default/4912201470135522530'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7575740467544252298/comments/default/4912201470135522530'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/05/spring-in-action.html?showComment=1275169188637#c4912201470135522530' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/05/spring-in-action.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7575740467544252298' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7575740467544252298' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. május 29. 23:39'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3260035349001894566</id><published>2010-06-01T12:03:05.783+02:00</published><updated>2010-06-01T12:03:05.783+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Érdemes egy pillantást vetni a &amp;quot;Java Transact...</title><content type='html'>Érdemes egy pillantást vetni a &amp;quot;Java Transaction Design Strategies&amp;quot; könyvre is:&lt;br /&gt;&lt;br /&gt;http://www.infoq.com/minibooks/JTDS</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/633786037997115640/comments/default/3260035349001894566'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/633786037997115640/comments/default/3260035349001894566'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/05/tranzakciokezeles.html?showComment=1275386585783#c3260035349001894566' title=''/><author><name>Atis</name><uri>http://www.blogger.com/profile/01358490431493460093</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/05/tranzakciokezeles.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-633786037997115640' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/633786037997115640' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-990264108'/><gd:extendedProperty name='blogger.displayTime' value='2010. június 1. 12:03'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2261594561603691962</id><published>2010-06-01T18:08:56.355+02:00</published><updated>2010-06-01T18:08:56.355+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Azt szoktak mondani, hogy a MANDATORY es a NEVER h...</title><content type='html'>Azt szoktak mondani, hogy a MANDATORY es a NEVER hibakereseskor johet jol, gyakorlatilag assertkent lehet oket hasznalni, hiszen elhasal, ha nem az tortenik, amire szamitasz.&lt;br /&gt;&lt;br /&gt;Hat, ha igy is van, meg nem lattam senkit, akinek tenyleg kellettek.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/633786037997115640/comments/default/2261594561603691962'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/633786037997115640/comments/default/2261594561603691962'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/05/tranzakciokezeles.html?showComment=1275408536355#c2261594561603691962' title=''/><author><name>viktor</name><uri>http://www.blogger.com/profile/16970231537531048304</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/05/tranzakciokezeles.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-633786037997115640' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/633786037997115640' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-396770260'/><gd:extendedProperty name='blogger.displayTime' value='2010. június 1. 18:08'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8676708787595685875</id><published>2010-06-02T14:25:54.046+02:00</published><updated>2010-06-02T14:25:54.046+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Kiváló összefoglaló, köszi! (Szokás szerint.)</title><content type='html'>Kiváló összefoglaló, köszi! (Szokás szerint.)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/633786037997115640/comments/default/8676708787595685875'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/633786037997115640/comments/default/8676708787595685875'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/05/tranzakciokezeles.html?showComment=1275481554046#c8676708787595685875' title=''/><author><name>Aron G</name><uri>http://www.blogger.com/profile/01760209922407931719</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/05/tranzakciokezeles.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-633786037997115640' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/633786037997115640' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1408648068'/><gd:extendedProperty name='blogger.displayTime' value='2010. június 2. 14:25'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8700017507034580715</id><published>2010-06-02T15:26:37.373+02:00</published><updated>2010-06-02T15:26:37.373+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszönöm a megjegyzéseket!</title><content type='html'>Köszönöm a megjegyzéseket!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/633786037997115640/comments/default/8700017507034580715'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/633786037997115640/comments/default/8700017507034580715'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/05/tranzakciokezeles.html?showComment=1275485197373#c8700017507034580715' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/05/tranzakciokezeles.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-633786037997115640' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/633786037997115640' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. június 2. 15:26'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5429265371279992154</id><published>2010-06-21T22:40:45.458+02:00</published><updated>2010-06-21T22:40:45.458+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>&amp;quot;A conf könyvtárba másoljuk át a bináris köny...</title><content type='html'>&amp;quot;A conf könyvtárba másoljuk át a bináris könyvtárát&amp;quot;&lt;br /&gt;Ennek igy nincs ertelme, az eredeti conf konyvtarat kell atmasolni.&lt;br /&gt;&lt;br /&gt;Valamint nezd meg a &lt;a href="http://httpd.apache.org/docs/2.2/mod/mod_proxy.html#proxypassreversecookiepath" rel="nofollow"&gt;ProxyPassReverseCookiePath&lt;/a&gt; es &lt;a href="http://httpd.apache.org/docs/2.2/mod/mod_proxy.html#proxypassreversecookiedomain" rel="nofollow"&gt;ProxyPassReverseCookieDomain&lt;/a&gt; direktivakat is, a sutizos webappoknal hasznos tud lenni, foleg, ha a ket szerver localhost vagy belso ip.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3613942055503022824/comments/default/5429265371279992154'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3613942055503022824/comments/default/5429265371279992154'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/06/cluster-ezes-altalaban-es-tomcat-en.html?showComment=1277152845458#c5429265371279992154' title=''/><author><name>George Hron</name><uri>http://www.blogger.com/profile/15406106695993366523</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_DKmHrnCj1NE/SvSwsBa_ZbI/AAAAAAAAAIs/Krfpmmttbmo/S220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/06/cluster-ezes-altalaban-es-tomcat-en.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3613942055503022824' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3613942055503022824' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-171155537'/><gd:extendedProperty name='blogger.displayTime' value='2010. június 21. 22:40'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7076794489210957104</id><published>2010-06-21T22:59:21.861+02:00</published><updated>2010-06-21T22:59:21.861+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A &amp;quot;A conf könyvtárba másoljuk át a bináris kö...</title><content type='html'>A &amp;quot;A conf könyvtárba másoljuk át a bináris könyvtárát&amp;quot; mondatommal arra utaltam, hogy a conf könyvtárba másoljuk át a bináris (azaz a CATALINA_HOME alá telepített Tomcat) conf könyvtárát. De javítottam, egyértelműbbé tettem.&lt;br /&gt;&lt;br /&gt;A post-ból sokminden kimaradt, az általad említett direktívák, valamint ha már itt vagyunk, akkor érdemes megemlíteni a Tomcat HTTP Connector-ának proxyName és proxyPort attribútumát is.&lt;br /&gt;&lt;br /&gt;Köszi!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3613942055503022824/comments/default/7076794489210957104'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3613942055503022824/comments/default/7076794489210957104'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/06/cluster-ezes-altalaban-es-tomcat-en.html?showComment=1277153961861#c7076794489210957104' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/06/cluster-ezes-altalaban-es-tomcat-en.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3613942055503022824' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3613942055503022824' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. június 21. 22:59'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-886437809670431831</id><published>2010-06-22T09:36:36.962+02:00</published><updated>2010-06-22T09:36:36.962+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Persze, en is tudom, hogy nem lehet postonkent egy...</title><content type='html'>Persze, en is tudom, hogy nem lehet postonkent egy konyvet kiadni, pedig sokszor jo lenne :D&lt;br /&gt;&lt;br /&gt;Ami miatt azonban megemlitettem a cookie-s problemat, az elsosorban az, hogy mind development, mind production kornyezetben nagyon sokat tud segiteni rejtelyes hibak elleni vedekezesben.&lt;br /&gt;&lt;br /&gt;Mivel en a GF-et jobban kedvelem a TomCat-nal, igy a konfigjaban viszonylag kevesse vagyok ismeros.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3613942055503022824/comments/default/886437809670431831'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3613942055503022824/comments/default/886437809670431831'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/06/cluster-ezes-altalaban-es-tomcat-en.html?showComment=1277192196962#c886437809670431831' title=''/><author><name>George Hron</name><uri>http://www.blogger.com/profile/15406106695993366523</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_DKmHrnCj1NE/SvSwsBa_ZbI/AAAAAAAAAIs/Krfpmmttbmo/S220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/06/cluster-ezes-altalaban-es-tomcat-en.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3613942055503022824' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3613942055503022824' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-171155537'/><gd:extendedProperty name='blogger.displayTime' value='2010. június 22. 9:36'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3035864522505173447</id><published>2010-06-22T10:21:10.882+02:00</published><updated>2010-06-22T10:21:10.882+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Az alkalmazásszerverek cluster-ezése is megérne eg...</title><content type='html'>Az alkalmazásszerverek cluster-ezése is megérne egy külön post-ot, a session bean-ek és entity-k replikálásával!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3613942055503022824/comments/default/3035864522505173447'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3613942055503022824/comments/default/3035864522505173447'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/06/cluster-ezes-altalaban-es-tomcat-en.html?showComment=1277194870882#c3035864522505173447' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/06/cluster-ezes-altalaban-es-tomcat-en.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3613942055503022824' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3613942055503022824' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. június 22. 10:21'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4968684991598656112</id><published>2010-06-22T16:27:56.510+02:00</published><updated>2010-06-22T16:27:56.510+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>No igen, bar en a GF-et is csak sima webappocskak ...</title><content type='html'>No igen, bar en a GF-et is csak sima webappocskak futtatasara hasznalom, es meg csak nem is a Java-n, hanem a Ruby-n (pontosabban a Rails-on) van nalam a hangsuly.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3613942055503022824/comments/default/4968684991598656112'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3613942055503022824/comments/default/4968684991598656112'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/06/cluster-ezes-altalaban-es-tomcat-en.html?showComment=1277216876510#c4968684991598656112' title=''/><author><name>George Hron</name><uri>http://www.blogger.com/profile/15406106695993366523</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_DKmHrnCj1NE/SvSwsBa_ZbI/AAAAAAAAAIs/Krfpmmttbmo/S220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/06/cluster-ezes-altalaban-es-tomcat-en.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3613942055503022824' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3613942055503022824' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-171155537'/><gd:extendedProperty name='blogger.displayTime' value='2010. június 22. 16:27'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7675601112147853424</id><published>2010-07-01T09:15:13.212+02:00</published><updated>2010-07-01T09:15:13.212+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>&amp;quot;az alkalmazásszerver telepítése, üzemeltetés...</title><content type='html'>&amp;quot;az alkalmazásszerver telepítése, üzemeltetése, netalántán üzemeltetése általában vagy egy üzemeltetői hajlamokkal megáldott fejlesztőre marad&amp;quot; azthittem ez csak nálunk van így :). Örök kedvencem a rendszergazda, aki megpróbált lebeszélni minket a Java-ról, mert üzemeltetnek Java alkalmazásokat, de nem győzik a vasakat alátolni. Pár héttel később nekem kellett felvilágosítani, hogy azért hasal el időnként a Glassfish, mert Linux-ban 1024 a maximálisan megnyitható fájlok száma alapértelmezetten, és a GF 800-at indításkor elhasznál belőle, szóval gondolom mennyire jártas lehetett az üzemeltetésben. Az írásra reagálva hasznos, szokásosan színvonalas és részletes. Köszi.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3340228008253492972/comments/default/7675601112147853424'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3340228008253492972/comments/default/7675601112147853424'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/07/jboss-in-action.html?showComment=1277968513212#c7675601112147853424' title=''/><author><name>Kovács Richárd</name><uri>http://www.blogger.com/profile/06849753526791080950</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://3.bp.blogspot.com/_iwfk5KPTXzU/S2vH-RR0JyI/AAAAAAAAABc/aGduniprSBw/S220/profile.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/07/jboss-in-action.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3340228008253492972' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3340228008253492972' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-196939700'/><gd:extendedProperty name='blogger.displayTime' value='2010. július 1. 9:15'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-206017334874336014</id><published>2010-07-01T12:04:07.939+02:00</published><updated>2010-07-01T12:04:07.939+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi!
Nagyon örülök azoknak a hozzászólásoknak, a...</title><content type='html'>Köszi!&lt;br /&gt;Nagyon örülök azoknak a hozzászólásoknak, amiben valaki leírja, hogy náluk hogy is megy ez, akár megerősít, akár ellentmond.&lt;br /&gt;Ez a fejlesztők és üzemeltetők közötti kapcsolat örök téma. :) Így nagyra becsülöm azokat, akik képesek átlépni a határokat.&lt;br /&gt;A Java-val kapcsolatos prekoncepciókat meg már nem lehet kiírtani, jöhet JIT, bármi. :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3340228008253492972/comments/default/206017334874336014'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3340228008253492972/comments/default/206017334874336014'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/07/jboss-in-action.html?showComment=1277978647939#c206017334874336014' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/07/jboss-in-action.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3340228008253492972' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3340228008253492972' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. július 1. 12:04'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1606727615287765591</id><published>2010-07-02T16:04:49.481+02:00</published><updated>2010-07-02T16:04:49.481+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>&amp;quot;rendkívül szimpatikus, hogy ki kell csomagol...</title><content type='html'>&amp;quot;rendkívül szimpatikus, hogy ki kell csomagolni a zip-et, és a saját könyvtárán kívül sehova máshova nem dolgozik&amp;quot;&lt;br /&gt;&lt;br /&gt;Ez nem csak a JBoss eseteben van igy, hanem a GF eseteben is. Igaz, ott a konfiguraciokat domainnek hivjak...&lt;br /&gt;&lt;br /&gt;Apropo, van hasonlo konyv GF-re?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3340228008253492972/comments/default/1606727615287765591'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3340228008253492972/comments/default/1606727615287765591'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/07/jboss-in-action.html?showComment=1278079489481#c1606727615287765591' title=''/><author><name>George Hron</name><uri>http://www.blogger.com/profile/15406106695993366523</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_DKmHrnCj1NE/SvSwsBa_ZbI/AAAAAAAAAIs/Krfpmmttbmo/S220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/07/jboss-in-action.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3340228008253492972' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3340228008253492972' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-171155537'/><gd:extendedProperty name='blogger.displayTime' value='2010. július 2. 16:04'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5898264154090881876</id><published>2010-07-02T17:37:12.510+02:00</published><updated>2010-07-02T17:37:12.510+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nem vagyok annyira otthon GlassFish adminisztráció...</title><content type='html'>Nem vagyok annyira otthon GlassFish adminisztrációban, arra csak fejlesztettem.&lt;br /&gt;De egyrészt jók a szabadon hozzáférhető dokumentációi (https://glassfish.dev.java.net/docs/index.html), valamint van a GlassFish Administration (http://www.amazon.com/GlassFish-Administration-Xuekun-Kou/dp/1847196500/ref=sr_1_5?ie=UTF8&amp;amp;s=books&amp;amp;qid=1278083590&amp;amp;sr=8-5) könyv is, szól a 2-esről és a 3-asról is.&lt;br /&gt;Pl. GlassFish-ben egy DataSource telepítés vagy a grafikus felületen klikkelgetés, vagy egy viszonylag hosszabb asadmin parancs.&lt;br /&gt;JBoss-ban tetszik, hogy a DataSource is ugyanúgy egy deploy-olható valami, egy xml odamásolásával beindul, letörlésével eltávolításra kerül, az alkalmazásokhoz hasonlóan.&lt;br /&gt;De adminisztráció szempontjából nem tudom összehasonlítani őket.&lt;br /&gt;Fejelsztés szempontjából viszont oktatásokon tapasztaltam, hogy a JBoss kicsit instabilabb volt, és kevésbé érthetőek a hibaüzenetei. Persze haladóbb felhasználók kezében lehet más a helyzet, csak a gyakran elkövetett hibákra (lévén tanulás közben gyakrabban írsz el valamit) reagált érzékenyebben, kb ugyanolyan képességű csoportok esetén a JBoss kevésbé tetszett az embereknek. (Kivéve XML és web-szolgáltatások, ahol a GlassFish is nagyon hektikus.)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3340228008253492972/comments/default/5898264154090881876'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3340228008253492972/comments/default/5898264154090881876'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/07/jboss-in-action.html?showComment=1278085032510#c5898264154090881876' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/07/jboss-in-action.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3340228008253492972' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3340228008253492972' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. július 2. 17:37'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3529028221648787774</id><published>2010-07-10T17:18:37.685+02:00</published><updated>2010-07-10T17:18:37.685+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>&amp;quot;A web alkalmazásunk áteresztőképessége ugyan...</title><content type='html'>&amp;quot;A web alkalmazásunk áteresztőképessége ugyan nőhet (kiszolgált kérések/idő), de egy kérés kiszolgálási ideje csökkenni fog, a bonyolultabb architektúra miatt.&amp;quot;&lt;br /&gt;&lt;br /&gt;Egy kiszolgálás ideje nőni fog, nem?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3613942055503022824/comments/default/3529028221648787774'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3613942055503022824/comments/default/3529028221648787774'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/06/cluster-ezes-altalaban-es-tomcat-en.html?showComment=1278775117685#c3529028221648787774' title=''/><author><name>scs</name><uri>http://www.blogger.com/profile/15071228275587131404</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/06/cluster-ezes-altalaban-es-tomcat-en.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3613942055503022824' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3613942055503022824' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-289113639'/><gd:extendedProperty name='blogger.displayTime' value='2010. július 10. 17:18'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2843830505051954727</id><published>2010-07-10T17:41:11.616+02:00</published><updated>2010-07-10T17:41:11.616+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Igen, köszönöm, javítottam.</title><content type='html'>Igen, köszönöm, javítottam.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3613942055503022824/comments/default/2843830505051954727'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3613942055503022824/comments/default/2843830505051954727'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/06/cluster-ezes-altalaban-es-tomcat-en.html?showComment=1278776471616#c2843830505051954727' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/06/cluster-ezes-altalaban-es-tomcat-en.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3613942055503022824' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3613942055503022824' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. július 10. 17:41'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7836083412212020628</id><published>2010-09-10T11:01:04.884+02:00</published><updated>2010-09-10T11:01:04.884+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nagyon jó kis összefoglaló poszt az Enversszel val...</title><content type='html'>Nagyon jó kis összefoglaló poszt az Enversszel való induláshoz!&lt;br /&gt;&lt;br /&gt;Olvasás közben bennem két dolog merült fel:&lt;br /&gt;&lt;br /&gt;Mi történik, ha már élesben fut az alkalmazás, a *_AUD táblák tele vannak verzióállapotokkal, de egy új követelmény miatt át kell alakítani a sémát? Mondjuk a Phone tábla egy külön körzetszámot leíró oszloppal bővülne és még plussz egy egy készüléktípusokat leíró táblára hivatkozó külső kulccsal? Vajon van-e erre valami eszköze az Enversnek (pl. automatikus séma update)?&lt;br /&gt;&lt;br /&gt;Miért nincs a mai napig a modern adatbáziskezelő rendszerekben ilyen funkcionalitás? Mert a standard SQL nem képes ezt kifejezni? Vagy van már ilyen csak én vagyok lemaradva? :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8676689565958825145/comments/default/7836083412212020628'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8676689565958825145/comments/default/7836083412212020628'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/09/entitasok-auditalasa-hibernate-envers.html?showComment=1284109264884#c7836083412212020628' title=''/><author><name>Steve</name><uri>http://www.blogger.com/profile/13407946410017714787</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='21' src='http://4.bp.blogspot.com/_vQZ0v7M3MUE/S4VJrioWN1I/AAAAAAAAHsk/yqUsrfR1zkQ/S220/me_small.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/09/entitasok-auditalasa-hibernate-envers.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8676689565958825145' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8676689565958825145' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1169922675'/><gd:extendedProperty name='blogger.displayTime' value='2010. szeptember 10. 11:01'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7401672477726001131</id><published>2010-09-10T13:26:05.701+02:00</published><updated>2010-09-10T13:26:05.701+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Baromi jó leírás. 
Mi persze megcsináltuk ezt magu...</title><content type='html'>Baromi jó leírás. &lt;br /&gt;Mi persze megcsináltuk ezt magunk (természetesen abszolút projektspecifikusan, nem kiszervezhető formában), mert deklarált idő az nem volt a körbenézésre, csak a billentyű klampírozásra. Na de majd legközelebb meglessük ezt.&lt;br /&gt;Steve kérdése is korrekt.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8676689565958825145/comments/default/7401672477726001131'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8676689565958825145/comments/default/7401672477726001131'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/09/entitasok-auditalasa-hibernate-envers.html?showComment=1284117965701#c7401672477726001131' title=''/><author><name>jbuzi</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/09/entitasok-auditalasa-hibernate-envers.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8676689565958825145' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8676689565958825145' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-437324980'/><gd:extendedProperty name='blogger.displayTime' value='2010. szeptember 10. 13:26'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4225529698429366207</id><published>2010-09-11T22:55:00.875+02:00</published><updated>2010-09-11T22:55:00.875+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Sziasztok, köszi a hozzászólásokat!

Kipróbáltam, ...</title><content type='html'>Sziasztok, köszi a hozzászólásokat!&lt;br /&gt;&lt;br /&gt;Kipróbáltam, ha felvettem egy új mezőt, akkor az Envers által generált táblákba is felkerült az új mező, és a régi adatok érintetlenek maradtak. Feltehetőleg a Hibernate sémagenerálóját, mely update-el is, használja.&lt;br /&gt;&lt;br /&gt;Amúgy a JPA könyvben olvastam, hogy ne használjuk a séma generálást, az csak prototípus építésre való. Igenis használjuk az adatbázis eszközeit, építsük fel mi a sémát, hiszen olyan dolgokat is meg kell adnunk, melyet a JPA nem tud, nem scope-ja. Pl. jogosultsági szintek, indexek, constraint-ek, view-k, triggerek, és sok egyéb dolog.&lt;br /&gt;&lt;br /&gt;Az hogy miért nem támogatják, szerintem üzleti modell. Sok-sok kereskedelmi termék van, ami erre jó, de van ingyenesek is, pl. DdlUtils, Liquibase, DbMaintain, Druid, Carbon Five Database Migration framework. Oracle SQL Developer-je is illeszthető CVS-hez, Subversion-höz. Amúgy van külön megvásárolható termékük is: Oracle Change Management Pack, mely szépen illeszkedik az admin felületbe is. Mondjuk kritikaként fogalmazták meg, hogy ez sem beépül a sémába, adatbázis motorba, hanem attól különálló. Ha az adatbázis-kezelők megjelennének (az árban foglalt) natív megoldásokkal, sokak üzlete megcsappanna.&lt;br /&gt;&lt;br /&gt;De Steve, erről neked kéne írnod!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8676689565958825145/comments/default/4225529698429366207'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8676689565958825145/comments/default/4225529698429366207'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/09/entitasok-auditalasa-hibernate-envers.html?showComment=1284238500875#c4225529698429366207' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/09/entitasok-auditalasa-hibernate-envers.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8676689565958825145' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8676689565958825145' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. szeptember 11. 22:55'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2929611414453015869</id><published>2010-09-21T10:26:53.289+02:00</published><updated>2010-09-21T10:26:53.289+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Hali!

Láttam te is rajta vagy a zsűri listán :) N...</title><content type='html'>Hali!&lt;br /&gt;&lt;br /&gt;Láttam te is rajta vagy a zsűri listán :) Nem is tudom, tényleg létezik olyan, hogy jó és legjobb szoftver, vagy csak olyan, ami tetszik és legjobban tetszik.&lt;br /&gt;&lt;br /&gt;The beauty is in the eye of the beholder. - akárhogy is van ez magyarul :D&lt;br /&gt;&lt;br /&gt;Kocka</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8096242855848459154/comments/default/2929611414453015869'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8096242855848459154/comments/default/2929611414453015869'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/09/legjobb-fejleszto-2010-java-programozo.html?showComment=1285057613289#c2929611414453015869' title=''/><author><name>Kocka</name><uri>http://www.blogger.com/profile/10505773298750628833</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='24' height='32' src='http://photos1.blogger.com/x/blogger/3271/703/320/170223/00024.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/09/legjobb-fejleszto-2010-java-programozo.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8096242855848459154' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8096242855848459154' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1842159747'/><gd:extendedProperty name='blogger.displayTime' value='2010. szeptember 21. 10:26'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6963036572166566657</id><published>2010-09-21T12:20:04.929+02:00</published><updated>2010-09-21T12:20:04.929+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Természetesen, mint a legtöbb versenynél, vannak k...</title><content type='html'>Természetesen, mint a legtöbb versenynél, vannak kiértékelési szempontok, ami alapján lehet sorrendet állítani és pontozni. Persze értékelésnél mindig van benne egy szubjektív tényező.&lt;br /&gt;&lt;br /&gt;De hát láttunk minden nap ilyent, lásd pályázatok. :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8096242855848459154/comments/default/6963036572166566657'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8096242855848459154/comments/default/6963036572166566657'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/09/legjobb-fejleszto-2010-java-programozo.html?showComment=1285064404929#c6963036572166566657' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/09/legjobb-fejleszto-2010-java-programozo.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8096242855848459154' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8096242855848459154' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. szeptember 21. 12:20'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5703554367308452568</id><published>2010-10-30T09:49:05.205+02:00</published><updated>2010-10-30T09:49:05.205+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Kivancsi lennek, vajon subversion-on tul is van-e ...</title><content type='html'>Kivancsi lennek, vajon subversion-on tul is van-e elet. Mert szep-szep az svn, de a git sokmindenben jobb es okosabb.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/214682897237729794/comments/default/5703554367308452568'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/214682897237729794/comments/default/5703554367308452568'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/10/release-maven-nel-es-hudson-nel.html?showComment=1288424945205#c5703554367308452568' title=''/><author><name>George Hron</name><uri>http://www.blogger.com/profile/15406106695993366523</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_DKmHrnCj1NE/SvSwsBa_ZbI/AAAAAAAAAIs/Krfpmmttbmo/S220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/10/release-maven-nel-es-hudson-nel.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-214682897237729794' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/214682897237729794' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-171155537'/><gd:extendedProperty name='blogger.displayTime' value='2010. október 30. 9:49'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3823342142058964212</id><published>2010-10-30T10:17:03.925+02:00</published><updated>2010-10-30T10:17:03.925+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Sajnos úgy látom, hogy a Git-et pár helyen divatbó...</title><content type='html'>Sajnos úgy látom, hogy a Git-et pár helyen divatból vezetik be, és nem megalapozott érvek alapján.&lt;br /&gt;Azt hiszik, hogy a fejlesztési folyamataik is megjavulnak tőle. Pedig szerintem először a fejlesztési módszertant kéne rendbe tenni, a verziókezelő ennek egy eszköze. Nem hiszem, hogy a Subversion annyira megkötné az emberek kezét.&lt;br /&gt;Persze nem azt mondom, hogy a Git-nek nincs értelme, csak azt, hogy ismerve, tapasztalatokkal és érvekkel alátámasztva kell bevetni.&lt;br /&gt;&lt;br /&gt;Tervben van, hogy írok róla, de egyelőre még csak távolról szagolgatom.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/214682897237729794/comments/default/3823342142058964212'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/214682897237729794/comments/default/3823342142058964212'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/10/release-maven-nel-es-hudson-nel.html?showComment=1288426623925#c3823342142058964212' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/10/release-maven-nel-es-hudson-nel.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-214682897237729794' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/214682897237729794' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. október 30. 10:17'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1946355785673044864</id><published>2010-11-14T21:58:32.134+01:00</published><updated>2010-11-14T21:58:32.134+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Jól hangzik a Gupta-s előadás, de csak akkor reáli...</title><content type='html'>Jól hangzik a Gupta-s előadás, de csak akkor reális, ha cég fizeti. Ebből a szempontból tanulhatna az Oracle az MS-től. Ott mindig van valamiféle diák/kutatói engedmény.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4133758495264721147/comments/default/1946355785673044864'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4133758495264721147/comments/default/1946355785673044864'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/11/oracle-java-cafe.html?showComment=1289768312134#c1946355785673044864' title=''/><author><name>gulyasm</name><uri>http://http://teamdistinction.com/</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/11/oracle-java-cafe.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4133758495264721147' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4133758495264721147' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2049400521'/><gd:extendedProperty name='blogger.displayTime' value='2010. november 14. 21:58'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6550532800286355090</id><published>2010-11-15T08:04:53.220+01:00</published><updated>2010-11-15T08:04:53.220+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Igen, én is irigyeltem mindig a Lurdy-ban tartott ...</title><content type='html'>Igen, én is irigyeltem mindig a Lurdy-ban tartott egynapos konferenciákat, ahol egyrészt komoly, és mély szakmai tartalommal rendelkező előadások voltak, jó szakemberekkel, másrészt volt, hogy még könyveket is osztogattak az adott témához.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4133758495264721147/comments/default/6550532800286355090'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4133758495264721147/comments/default/6550532800286355090'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/11/oracle-java-cafe.html?showComment=1289804693220#c6550532800286355090' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/11/oracle-java-cafe.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4133758495264721147' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4133758495264721147' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. november 15. 8:04'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4687791296568088451</id><published>2010-11-15T12:01:00.078+01:00</published><updated>2010-11-15T12:01:00.078+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi a beszámolót!</title><content type='html'>Köszi a beszámolót!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4133758495264721147/comments/default/4687791296568088451'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4133758495264721147/comments/default/4687791296568088451'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/11/oracle-java-cafe.html?showComment=1289818860078#c4687791296568088451' title=''/><author><name>Steve</name><uri>http://www.blogger.com/profile/13407946410017714787</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='21' src='http://4.bp.blogspot.com/_vQZ0v7M3MUE/S4VJrioWN1I/AAAAAAAAHsk/yqUsrfR1zkQ/S220/me_small.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/11/oracle-java-cafe.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4133758495264721147' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4133758495264721147' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1169922675'/><gd:extendedProperty name='blogger.displayTime' value='2010. november 15. 12:01'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-473112272617015643</id><published>2010-11-26T09:14:49.396+01:00</published><updated>2010-11-26T09:14:49.396+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szia.

Lenne egy olyan kerdesem, hogy mikor a jaxb...</title><content type='html'>Szia.&lt;br /&gt;&lt;br /&gt;Lenne egy olyan kerdesem, hogy mikor a jaxb marshall -al letrehozom az xml-t, akkor a namespace is kene az elementek elejere, de nem teszi ki, csak epp nem tudom miert.&lt;br /&gt;&lt;br /&gt;pl:&lt;br /&gt;ezt generalta:&lt;br /&gt;&amp;lt;EContracts xmlns=&amp;quot;adasd&amp;quot;......&lt;br /&gt;&amp;lt;contract ........&lt;br /&gt;&lt;br /&gt;nekem meg ilyen kene:&lt;br /&gt;&amp;lt;alma:EContracts xmlns=&amp;quot;adasd&amp;quot;.....&lt;br /&gt;&amp;lt;alma:contract ........&lt;br /&gt;&lt;br /&gt;Koszi</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7801878101879687317/comments/default/473112272617015643'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7801878101879687317/comments/default/473112272617015643'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/07/jaxb.html?showComment=1290759289396#c473112272617015643' title=''/><author><name>kendermag</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/07/jaxb.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7801878101879687317' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7801878101879687317' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1646131976'/><gd:extendedProperty name='blogger.displayTime' value='2010. november 26. 9:14'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5314353107995827453</id><published>2010-11-26T18:38:02.532+01:00</published><updated>2010-11-26T18:38:02.532+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nekem egyszer org.w3c.dom.Document-be kellett mars...</title><content type='html'>Nekem egyszer org.w3c.dom.Document-be kellett marshall-olni, és ott lehet egy ilyent: Document.getDocumentElement().setPrefix(&amp;quot;alma&amp;quot;).&lt;br /&gt;&lt;br /&gt;Vagy lehet olyant is, hogy annotációt használsz erre:&lt;br /&gt;@javax.xml.bind.annotation.XmlNs, https://jaxb.dev.java.net/tutorial/section_6_2_3-Annotations-for-the-Schema-XmlSchema.html#Annotations%20for%20the%20Schema:%20XmlSchema&lt;br /&gt;&lt;br /&gt;Vagy csinálhatsz namespace prefix mapper-t: https://jaxb.dev.java.net/guide/Changing_prefixes.html&lt;br /&gt;&lt;br /&gt;Szerintem ha rákeresel erre, rengeteg találatot kapsz: jaxb setPrefix</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7801878101879687317/comments/default/5314353107995827453'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7801878101879687317/comments/default/5314353107995827453'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/07/jaxb.html?showComment=1290793082532#c5314353107995827453' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/07/jaxb.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7801878101879687317' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7801878101879687317' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. november 26. 18:38'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2966157915638392006</id><published>2010-11-27T18:59:36.626+01:00</published><updated>2010-11-27T18:59:36.626+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szuper kis összefoglaló, most pont ezekre volt szü...</title><content type='html'>Szuper kis összefoglaló, most pont ezekre volt szükségem!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7801878101879687317/comments/default/2966157915638392006'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7801878101879687317/comments/default/2966157915638392006'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/07/jaxb.html?showComment=1290880776626#c2966157915638392006' title=''/><author><name>Steve</name><uri>http://www.blogger.com/profile/13407946410017714787</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='21' src='http://4.bp.blogspot.com/_vQZ0v7M3MUE/S4VJrioWN1I/AAAAAAAAHsk/yqUsrfR1zkQ/S220/me_small.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/07/jaxb.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7801878101879687317' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7801878101879687317' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1169922675'/><gd:extendedProperty name='blogger.displayTime' value='2010. november 27. 18:59'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8210572775772306225</id><published>2010-12-15T11:42:10.776+01:00</published><updated>2010-12-15T11:42:10.776+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>WebDAV és biztonság: ez vicc? A 2010. decemberi &amp;q...</title><content type='html'>WebDAV és biztonság: ez vicc? A 2010. decemberi &amp;quot;foltozó kedden&amp;quot; szinte csak webdav eredetű, komoly biztonsági hibákra adott ki a Microsoft 17db (!) javítófoltot.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2326763854835297631/comments/default/8210572775772306225'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2326763854835297631/comments/default/8210572775772306225'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/02/webdav-tapasztalatok.html?showComment=1292409730776#c8210572775772306225' title=''/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/02/webdav-tapasztalatok.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2326763854835297631' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2326763854835297631' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-57760898'/><gd:extendedProperty name='blogger.displayTime' value='2010. december 15. 11:42'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4202569067118578397</id><published>2010-12-15T16:37:18.243+01:00</published><updated>2010-12-15T16:37:18.243+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szia!

A WebDAV egy szabvány, RFC 4918, mely a HTT...</title><content type='html'>Szia!&lt;br /&gt;&lt;br /&gt;A WebDAV egy szabvány, RFC 4918, mely a HTTP felett helyezkedik el.&lt;br /&gt;Mivel a HTTP helyett akár HTTP(S) is lehet, elméletileg a biztonság akár protokoll szinten is megoldott lehetne.&lt;br /&gt;&lt;br /&gt;De ismétlem, a WebDAV egy szabvány, az más kérdés, hogy a Microsoft hogyan implementálta. Ez olyan, mintha azt mondanád, hogy a HTTP(S) nem biztonságos, mert az Microsoft IIS webszerverben komoly biztonsági rések vannak.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2326763854835297631/comments/default/4202569067118578397'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2326763854835297631/comments/default/4202569067118578397'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/02/webdav-tapasztalatok.html?showComment=1292427438243#c4202569067118578397' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/02/webdav-tapasztalatok.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2326763854835297631' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2326763854835297631' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. december 15. 16:37'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1919775474373893126</id><published>2010-12-18T12:26:42.079+01:00</published><updated>2010-12-18T12:26:42.079+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>&amp;quot;nem-e rekedt meg&amp;quot; -&amp;gt; nem rekedt-e me...</title><content type='html'>&amp;quot;nem-e rekedt meg&amp;quot; -&amp;gt; nem rekedt-e meg :) amúgy jó cikk köszi!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/1919775474373893126'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/1919775474373893126'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html?showComment=1292671602079#c1919775474373893126' title=''/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-70696356624550932' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/70696356624550932' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-940276074'/><gd:extendedProperty name='blogger.displayTime' value='2010. december 18. 12:26'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7471004311679567972</id><published>2010-12-18T17:28:08.977+01:00</published><updated>2010-12-18T17:28:08.977+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi, javítottam.</title><content type='html'>Köszi, javítottam.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/7471004311679567972'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/7471004311679567972'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html?showComment=1292689688977#c7471004311679567972' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-70696356624550932' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/70696356624550932' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. december 18. 17:28'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7050819214923484372</id><published>2010-12-18T23:22:50.040+01:00</published><updated>2010-12-18T23:22:50.040+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>(epp ujratelepites, meg nincsenek ekezetek, bocs)....</title><content type='html'>(epp ujratelepites, meg nincsenek ekezetek, bocs).&lt;br /&gt;&lt;br /&gt;Koszonet a kimerito beszamoloert. A nyitva maradt kerdest (miert nem kuldtek be vegul tobben megoldast) megvalaszolando, meg lehet kerdezni azokat, akik erdeklodtek, de vegul nem kuldtek be?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/7050819214923484372'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/7050819214923484372'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html?showComment=1292710970040#c7050819214923484372' title=''/><author><name>zsepi</name><uri>http://zsoldosp.blogspot.com</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-70696356624550932' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/70696356624550932' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-645494962'/><gd:extendedProperty name='blogger.displayTime' value='2010. december 18. 23:22'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-9152046484211906047</id><published>2010-12-18T23:38:06.680+01:00</published><updated>2010-12-18T23:38:06.680+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nyitva maradt kérdésre: korhatár</title><content type='html'>Nyitva maradt kérdésre: korhatár</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/9152046484211906047'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/9152046484211906047'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html?showComment=1292711886680#c9152046484211906047' title=''/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-70696356624550932' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/70696356624550932' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1334889353'/><gd:extendedProperty name='blogger.displayTime' value='2010. december 18. 23:38'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4136158283594726512</id><published>2010-12-19T00:10:27.656+01:00</published><updated>2010-12-19T00:10:27.656+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi az ötletet!</title><content type='html'>Köszi az ötletet!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/4136158283594726512'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/4136158283594726512'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html?showComment=1292713827656#c4136158283594726512' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-70696356624550932' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/70696356624550932' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. december 19. 0:10'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4239392321548385997</id><published>2010-12-19T09:43:45.625+01:00</published><updated>2010-12-19T09:43:45.625+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>&amp;quot;Szerencsére azt is ritkán láttam, hogy Java ...</title><content type='html'>&amp;quot;Szerencsére azt is ritkán láttam, hogy Java kód keveredett volna HTML-lel.&amp;quot; -- ritkán? Úgy érted, azért előfordult? Ajaj.&lt;br /&gt;&lt;br /&gt;Tudom hogy ez nem szép de rég röhögtem annyit mint a performancia szón. Ottlapszerkesztőt is használsz?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/4239392321548385997'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/4239392321548385997'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html?showComment=1292748225625#c4239392321548385997' title=''/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-70696356624550932' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/70696356624550932' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-96256005'/><gd:extendedProperty name='blogger.displayTime' value='2010. december 19. 9:43'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2272686182242995562</id><published>2010-12-19T10:51:10.655+01:00</published><updated>2010-12-19T10:51:10.655+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szerintem érdemes lett volna a publikus médiában i...</title><content type='html'>Szerintem érdemes lett volna a publikus médiában is hirdetni a versenyt (pl.:index.hu), így a köztudatba is jobban bekerült volna ami persze a szervező cég népszerűségének is jó. &lt;br /&gt;A legjobb az lett volna ha a verseny előtt pár hónappal és a verseny után egyből megjelent volna egy cikk.&lt;br /&gt;&lt;br /&gt;Láttam, hogy pár egyetem honlapján is megjelent a felhívás (nyme-geo, pte), de kíváncsi lennék hogy ezeket mennyire olvassák a diákok. :)&lt;br /&gt;&lt;br /&gt;Nem tudom, hogy a hazai informatikai intézményekben a plakátolás mennyire volt nálatok hangsúlyos. Ha nem, akkor talán érdemes lett volna ilyen formában is értesíteni a hallgatókat. &lt;br /&gt;&lt;br /&gt;Egy másik ötlet, hogy email-ben felkeresitek a hazai Java/JavaEE-t oktató tanárokat, akik majd nagy valószínűséggel pont annak a célcsoportnak továbbítják a verseny hírét akiket ti kerestek. &lt;br /&gt;Sokszor már csak a sikeres részvételért kapott megajánlott 5-ös is döntő lehet. :)&lt;br /&gt;&lt;br /&gt;Szívesen láttam volna ha a versenyt felbontjátok 2 nevezési korcsoportra (pl.:26 év alatti és feletti).&lt;br /&gt;&lt;br /&gt;Egyébként egy fontos dolgot elfelejtettetek, mégpedig a pontos(!) visszacsatolást a résztvevőktől és a hírlevélre feliratkozóktól.&lt;br /&gt;Szerintem nyugodtan készíthetnétek egy kérdőívet a hírlevélre feliratkozóknak és ahelyett hogy találgatnátok kérdezzétek meg tőlük, hogy miért nem vettek részt végül is a versenyen vagy akár arról hogy honnan értesültek a versenyről.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;Az AOP naplózás igazából nem üzleti szempontból volt érdekes, hanem a fejlesztést/nyomon követést segítette.&lt;br /&gt;&lt;br /&gt;Az üzleti logikai diagramról a JBoss Seam valószínűleg véletlenül maradt ki. Sajnálom hogy sokak &amp;#39;eszköztárában&amp;#39; nem is szerepelnek a JBoss-os technológiák. :(&lt;br /&gt;&lt;br /&gt;Ha valaki egyszer elkezd Seam-el fejleszteni soha nem akar majd másra váltani, nem véletlen hogy a CDI-t is ennek mintájára készítették el.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/2272686182242995562'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/2272686182242995562'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html?showComment=1292752270655#c2272686182242995562' title=''/><author><name>Bakai Balázs</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-70696356624550932' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/70696356624550932' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-27847403'/><gd:extendedProperty name='blogger.displayTime' value='2010. december 19. 10:51'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1520596209495826252</id><published>2010-12-19T11:32:51.766+01:00</published><updated>2010-12-19T11:32:51.766+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi az igényes beszámolót. A forráskódok elérhet...</title><content type='html'>Köszi az igényes beszámolót. A forráskódok elérhetőek lesznek? A GWT-s megoldás különösen érdekelne.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/1520596209495826252'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/1520596209495826252'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html?showComment=1292754771766#c1520596209495826252' title=''/><author><name>Tóthi Tamás</name><uri>http://haromt@gmail.com</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-70696356624550932' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/70696356624550932' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1270358188'/><gd:extendedProperty name='blogger.displayTime' value='2010. december 19. 11:32'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5072121619704370209</id><published>2010-12-19T19:51:09.117+01:00</published><updated>2010-12-19T19:51:09.117+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi a hozzászólásokat. Annyit azonban szeretnék ...</title><content type='html'>Köszi a hozzászólásokat. Annyit azonban szeretnék jelezni, hogy én zsűritag voltam, nem szervező, persze amiben kértek és amiben tudtam besegítettem, de az érdem ilyen szempontból nem engem illet, és ilyen kérdésekre nem is nagyon tudok válaszolni.&lt;br /&gt;&lt;br /&gt;Balázs, az ötleteket köszönjük, mindenképp hasznosítanánk, és egy-kettőt, amit írtál, az már folyamatban is van, nekünk is eszünkbe jutott.&lt;br /&gt;&lt;br /&gt;Személy szerint érdekelne, hol lehet megtalálni a Java/JavaEE oktató tanárokat, kis energiabefektetéssel. Már többször lett volna rá szükség, de viszonylag bonyolult és időigényes feladatnak tűnt. Alig publikálnak, neten nem elérhetőek, és úgy tűnik, ők sem elérhetőek azokon a csatornákon, melyeken próbálkoztunk. Ha van ötleted, tudsz segíteni, ezt szívesen fogadnám. :) A megajánlott ötöst egyedül &lt;a href="http://www.inf.unideb.hu/~nbatfai/" rel="nofollow"&gt;Bátfai Norbi&lt;/a&gt; ajánlotta fel, ezúton is köszönöm neki a segítséget, a verseny terjesztését a debreceni körökben.&lt;br /&gt;&lt;br /&gt;A JBoss Seam-mel kapcsolatban elnézésed, nagyvonalúan belesoroltam az EJB alá, hiszen arra (is) épül. Igazad van, annál sokkal több, külön kategória, javítottam a cikket.&lt;br /&gt;&lt;br /&gt;Persze szép dolog az AOP naplózás, tökéletesen egyetértek, sőt, az AOP mintapéldája minden cikkben és könyvben. Csak szerintem nem elegendő egy üzleti alkalmazásban. De feltehetően éles projektben te sem csak ezt használod.&lt;br /&gt;&lt;br /&gt;Tamás, a forráskódok nem lesznek elérhetőek. A versenyszabályzat szerint nincs joga erre a szervezőknek, és le is lesznek törölve a pályamunkák.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/5072121619704370209'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/5072121619704370209'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html?showComment=1292784669117#c5072121619704370209' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-70696356624550932' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/70696356624550932' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. december 19. 19:51'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2785628508387706815</id><published>2010-12-19T20:36:24.264+01:00</published><updated>2010-12-19T20:36:24.264+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Az ötleteket szívesen. 
Szerintem érdemes lenne a ...</title><content type='html'>Az ötleteket szívesen. &lt;br /&gt;Szerintem érdemes lenne a verseny időpontját nov. 1-ről, inkább szeptember végére vagy október elejére átrakni ugyanis a legtöbb zh-t&lt;br /&gt;pont november szokták iratni. &lt;br /&gt;Jövőhéten átküldök majd egy listát emailben a java/javaEE oktatókról akiket érdemes megkeresni.&lt;br /&gt;Nem olyan nagy probléma a Seam hibás besorolása :) , inkább csak a cikk minőségén javít ha a megfelelő helyre kerül. &lt;br /&gt;Egyetértek veled a naplózás terén, mindkettőnek megvan a maga helye, csak a cikkből kicsit félreérthetően jött le.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;Egyébként összességében tetszik a cikk a versenyről.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/2785628508387706815'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/2785628508387706815'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html?showComment=1292787384264#c2785628508387706815' title=''/><author><name>Bakai Balázs</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-70696356624550932' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/70696356624550932' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-27847403'/><gd:extendedProperty name='blogger.displayTime' value='2010. december 19. 20:36'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3424870223422503601</id><published>2010-12-19T21:03:36.286+01:00</published><updated>2010-12-19T21:03:36.286+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi!

A naplózásos részt kicsit átfogalmaztam.</title><content type='html'>Köszi!&lt;br /&gt;&lt;br /&gt;A naplózásos részt kicsit átfogalmaztam.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/3424870223422503601'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/3424870223422503601'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html?showComment=1292789016286#c3424870223422503601' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-70696356624550932' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/70696356624550932' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. december 19. 21:03'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-977143683721322697</id><published>2010-12-20T08:00:06.746+01:00</published><updated>2010-12-20T08:00:06.746+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Közben rájöttem, hogy a verseny nem is nov 1től, h...</title><content type='html'>Közben rájöttem, hogy a verseny nem is nov 1től, hanem okt 1től volt. :)&lt;br /&gt;Még jó hogy emlékszem rá...&lt;br /&gt;&lt;br /&gt;A tanárok listáját közben átküldtem emailben.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/977143683721322697'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/977143683721322697'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html?showComment=1292828406746#c977143683721322697' title=''/><author><name>Bakai Balázs</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-70696356624550932' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/70696356624550932' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-40141105'/><gd:extendedProperty name='blogger.displayTime' value='2010. december 20. 8:00'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-978747217938884583</id><published>2010-12-20T14:38:51.126+01:00</published><updated>2010-12-20T14:38:51.126+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi, megkaptam!</title><content type='html'>Köszi, megkaptam!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/978747217938884583'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/978747217938884583'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html?showComment=1292852331126#c978747217938884583' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-70696356624550932' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/70696356624550932' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. december 20. 14:38'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1148381635460163818</id><published>2010-12-24T07:54:38.533+01:00</published><updated>2010-12-24T07:57:55.598+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'></title><content type='html'>Ezt a megjegyzést eltávolította a szerző.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3326979225522262721/comments/default/1148381635460163818'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3326979225522262721/comments/default/1148381635460163818'/><author><name>Bakai Balázs</name><uri>http://www.blogger.com/profile/01676249813193193031</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='28' height='32' src='http://2.bp.blogspot.com/_ZlEsDu1k7hA/TRI_cy2K25I/AAAAAAAAAAw/25rfP_hfR_k/S220/bb.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/01/jndi-nevek-tomcat-alatt.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3326979225522262721' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3326979225522262721' type='text/html'/><gd:extendedProperty name='blogger.contentRemoved' value='true'/><gd:extendedProperty name='blogger.itemClass' value='pid-751703941'/><gd:extendedProperty name='blogger.displayTime' value='2010. december 24. 7:54'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2968038911425379613</id><published>2010-12-24T07:59:08.757+01:00</published><updated>2010-12-24T07:59:08.757+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Valószínűleg csak elírás de azért szólnék, hogy a ...</title><content type='html'>Valószínűleg csak elírás de azért szólnék, hogy a server.xml Resource-ben megadott jdbc/JTechLogDS globális jndi nevet a JTechLogDS -re kellene cserélni, így a java:comp/env/jdbc/JTechLogLocalDS -el működni fog a mapping.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3326979225522262721/comments/default/2968038911425379613'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3326979225522262721/comments/default/2968038911425379613'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/01/jndi-nevek-tomcat-alatt.html?showComment=1293173948757#c2968038911425379613' title=''/><author><name>Bakai Balázs</name><uri>http://www.blogger.com/profile/01676249813193193031</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='28' height='32' src='http://2.bp.blogspot.com/_ZlEsDu1k7hA/TRI_cy2K25I/AAAAAAAAAAw/25rfP_hfR_k/S220/bb.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/01/jndi-nevek-tomcat-alatt.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3326979225522262721' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3326979225522262721' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-751703941'/><gd:extendedProperty name='blogger.displayTime' value='2010. december 24. 7:59'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6242310193583921459</id><published>2010-12-24T12:20:31.459+01:00</published><updated>2010-12-24T12:20:31.459+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi, javítottam!</title><content type='html'>Köszi, javítottam!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3326979225522262721/comments/default/6242310193583921459'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3326979225522262721/comments/default/6242310193583921459'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/01/jndi-nevek-tomcat-alatt.html?showComment=1293189631459#c6242310193583921459' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/01/jndi-nevek-tomcat-alatt.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3326979225522262721' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3326979225522262721' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2010. december 24. 12:20'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5560634476746810142</id><published>2011-01-29T09:24:58.652+01:00</published><updated>2011-01-29T09:24:58.652+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi! Találkoztam már vele, de a JMeter-ben pont ...</title><content type='html'>Köszi! Találkoztam már vele, de a JMeter-ben pont az egyszerűsége tetszett, hogy pár kattintással a legtöbb dolgot össze lehet rakni. A JMeter-nek is van script-elési lehetősége, BeanShell-ben. Amennyiben belefutok a korlátaiba, biztos, hog a Grinder lesz a következő.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3404280541226145466/comments/default/5560634476746810142'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3404280541226145466/comments/default/5560634476746810142'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/02/kedvenc-java-eszkozok.html?showComment=1296289498652#c5560634476746810142' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/02/kedvenc-java-eszkozok.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3404280541226145466' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3404280541226145466' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. január 29. 9:24'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1196643227803689798</id><published>2011-02-05T21:44:12.944+01:00</published><updated>2011-02-05T21:44:12.944+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Keytool IUI, és nem, nem olvastam végig :)</title><content type='html'>Keytool IUI, és nem, nem olvastam végig :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/100801776275799553/comments/default/1196643227803689798'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/100801776275799553/comments/default/1196643227803689798'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/02/elektronikus-alairas-es-alkalmazasa.html?showComment=1296938652944#c1196643227803689798' title=''/><author><name>G</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/02/elektronikus-alairas-es-alkalmazasa.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-100801776275799553' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/100801776275799553' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-171991688'/><gd:extendedProperty name='blogger.displayTime' value='2011. február 5. 21:44'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4363070478416515836</id><published>2011-02-05T21:50:12.303+01:00</published><updated>2011-02-05T21:50:12.303+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi, melyik ennek a hivatalos honlapja?</title><content type='html'>Köszi, melyik ennek a hivatalos honlapja?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/100801776275799553/comments/default/4363070478416515836'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/100801776275799553/comments/default/4363070478416515836'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/02/elektronikus-alairas-es-alkalmazasa.html?showComment=1296939012303#c4363070478416515836' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/02/elektronikus-alairas-es-alkalmazasa.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-100801776275799553' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/100801776275799553' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. február 5. 21:50'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6679516193825269470</id><published>2011-02-06T08:36:00.841+01:00</published><updated>2011-02-06T08:36:00.841+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Apró, a lényeget nem érintő pontatlanságok a 3DES ...</title><content type='html'>Apró, a lényeget nem érintő pontatlanságok a 3DES leírásban:&lt;br /&gt;- nem csak 3, de 2 kulccsal is használják;&lt;br /&gt;- nem az Encrypt műveletet használja háromszor, hanem Encrypt - Decrypt - Encrypt műveleteket használ.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/100801776275799553/comments/default/6679516193825269470'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/100801776275799553/comments/default/6679516193825269470'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/02/elektronikus-alairas-es-alkalmazasa.html?showComment=1296977760841#c6679516193825269470' title=''/><author><name>Kofa</name><uri>http://www.blogger.com/profile/09608502634061041209</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/02/elektronikus-alairas-es-alkalmazasa.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-100801776275799553' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/100801776275799553' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-111703032'/><gd:extendedProperty name='blogger.displayTime' value='2011. február 6. 8:36'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8031424179570686346</id><published>2011-02-06T16:15:21.226+01:00</published><updated>2011-02-06T16:15:21.226+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszönöm, javítottam. Érdekes minden irodalom úgy ...</title><content type='html'>Köszönöm, javítottam. Érdekes minden irodalom úgy írja, hogy háromszor rejtjelez (pl. Wikipedia, Elektronikus aláírás és társai könyv).&lt;br /&gt;Valamint az utóbbi könyv 21. lábjegyzetként írja, hogy használják két kulccsal is, de azt ő sem említi, amit a Wikipedia igen, hogy egy kulccsal is használták a visszafele kompatibilitás miatt, bár már nem ajánlott.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/100801776275799553/comments/default/8031424179570686346'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/100801776275799553/comments/default/8031424179570686346'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/02/elektronikus-alairas-es-alkalmazasa.html?showComment=1297005321226#c8031424179570686346' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/02/elektronikus-alairas-es-alkalmazasa.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-100801776275799553' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/100801776275799553' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. február 6. 16:15'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7039262424023478765</id><published>2011-02-07T11:02:53.565+01:00</published><updated>2011-05-16T22:42:23.774+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Ha követelmény a saját honlap, akkor esetleg még e...</title><content type='html'>Ha követelmény a saját honlap, akkor esetleg még ezt érdemes megnézni: http://portecle.sourceforge.net</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/100801776275799553/comments/default/7039262424023478765'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/100801776275799553/comments/default/7039262424023478765'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/02/elektronikus-alairas-es-alkalmazasa.html?showComment=1297072973565#c7039262424023478765' title=''/><author><name>G</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/02/elektronikus-alairas-es-alkalmazasa.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-100801776275799553' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/100801776275799553' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-111270654'/><gd:extendedProperty name='blogger.displayTime' value='2011. február 7. 11:02'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5270279555137539881</id><published>2011-02-28T14:58:03.186+01:00</published><updated>2011-02-28T14:58:03.186+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>GlassFish-hez hogy mukodik a JNDI-s cucc? Mit kell...</title><content type='html'>GlassFish-hez hogy mukodik a JNDI-s cucc? Mit kell konfolni hozza?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5695982303749707840/comments/default/5270279555137539881'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5695982303749707840/comments/default/5270279555137539881'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/02/konfiguracios-parameterek-ejb-retegben.html?showComment=1298901483186#c5270279555137539881' title=''/><author><name>George Hron</name><uri>http://www.blogger.com/profile/15406106695993366523</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_DKmHrnCj1NE/SvSwsBa_ZbI/AAAAAAAAAIs/Krfpmmttbmo/S220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/02/konfiguracios-parameterek-ejb-retegben.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-5695982303749707840' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/5695982303749707840' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-171155537'/><gd:extendedProperty name='blogger.displayTime' value='2011. február 28. 14:58'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7180383992811541480</id><published>2011-03-01T15:17:56.229+01:00</published><updated>2011-03-01T15:17:56.229+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szia!

Azt meg tudnád mondani, hogy a vizsgán volt...</title><content type='html'>Szia!&lt;br /&gt;&lt;br /&gt;Azt meg tudnád mondani, hogy a vizsgán volt-e EJB Web Service-zel kapcsolatos kérdés?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7968961481638103983/comments/default/7180383992811541480'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7968961481638103983/comments/default/7180383992811541480'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/02/ejb-es-jpa-developer-certified-expert.html?showComment=1298989076229#c7180383992811541480' title=''/><author><name>Peter</name><uri>http://www.blogger.com/profile/17580139395998816042</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/02/ejb-es-jpa-developer-certified-expert.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7968961481638103983' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7968961481638103983' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1660034358'/><gd:extendedProperty name='blogger.displayTime' value='2011. március 1. 15:17'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3671766577053968826</id><published>2011-03-01T23:15:34.032+01:00</published><updated>2011-03-01T23:15:34.032+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szia!

Csak érdeklődnék hogy az ötletekből végül t...</title><content type='html'>Szia!&lt;br /&gt;&lt;br /&gt;Csak érdeklődnék hogy az ötletekből végül tudtatok-e hasznosítani valamit? A kérdőívet végül miért nem készítettétek el?&lt;br /&gt;&lt;br /&gt;Így utólag, az első megjegyzésemben lehet egy kicsit elfogultan írtam a JBoss-ról, de tényleg sajnálom, hogy a verseny résztvevői közül nem sokan használtak JBoss-os technológiákat, különösképpen a Seam-et.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/3671766577053968826'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/3671766577053968826'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html?showComment=1299017734032#c3671766577053968826' title=''/><author><name>Bakai Balázs</name><uri>http://www.blogger.com/profile/01676249813193193031</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='28' height='32' src='http://2.bp.blogspot.com/_ZlEsDu1k7hA/TRI_cy2K25I/AAAAAAAAAAw/25rfP_hfR_k/S220/bb.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-70696356624550932' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/70696356624550932' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-751703941'/><gd:extendedProperty name='blogger.displayTime' value='2011. március 1. 23:15'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6420842314493838207</id><published>2011-03-01T23:53:59.976+01:00</published><updated>2011-03-01T23:53:59.976+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Üdv,

Nem emlékszem rá, hogy lett volna. A vizsga ...</title><content type='html'>Üdv,&lt;br /&gt;&lt;br /&gt;Nem emlékszem rá, hogy lett volna. A vizsga honlapján, illetve a felkészítő oktatás tematikájában (, sőt tananyagában sem) található róla említés. Külön tanfolyam és vizsga van rá (CX-310-232 - Java Platform, Enterprise Edition 6 Web Services Developer Certified Expert Exam), gondolom ezért nem keverik bele. Érdekessége annak a vizsgának, hogy mind a servlet, mind az EJB alapú megoldást kérdezik, és mind a SOAP, mind a REST web szolgáltatásokat (lévén Java EE 6).</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7968961481638103983/comments/default/6420842314493838207'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7968961481638103983/comments/default/6420842314493838207'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/02/ejb-es-jpa-developer-certified-expert.html?showComment=1299020039976#c6420842314493838207' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/02/ejb-es-jpa-developer-certified-expert.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7968961481638103983' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7968961481638103983' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. március 1. 23:53'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7227077398476760047</id><published>2011-03-02T22:53:07.961+01:00</published><updated>2011-03-02T22:53:07.961+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>MI évek óta Apache Commons Config-ot használunk. V...</title><content type='html'>MI évek óta Apache Commons Config-ot használunk. Van egy ConfigurationFactory-nk, ami megnézi, hogy a konfiguráció leíró fájl neve meg van-e adva JNDI-ben, ha ott nincs, akkor system property-ben (így használható WAR-ban is, meg command line is) ha meg ott sincs akkor config.xml.&lt;br /&gt;&lt;br /&gt;Elég kellemes. Használtunk DB-it 2005-2007 között, de nyűgös volt nagyon.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5695982303749707840/comments/default/7227077398476760047'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5695982303749707840/comments/default/7227077398476760047'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/02/konfiguracios-parameterek-ejb-retegben.html?showComment=1299102787961#c7227077398476760047' title=''/><author><name>Verhás Péter</name><uri>http://www.blogger.com/profile/06377161363854132582</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/02/konfiguracios-parameterek-ejb-retegben.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-5695982303749707840' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/5695982303749707840' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-377703703'/><gd:extendedProperty name='blogger.displayTime' value='2011. március 2. 22:53'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4963019283986143957</id><published>2011-03-03T23:30:03.410+01:00</published><updated>2011-03-03T23:30:03.410+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szia!

Sajnos egyéb projektek miatt egyikünk sem t...</title><content type='html'>Szia!&lt;br /&gt;&lt;br /&gt;Sajnos egyéb projektek miatt egyikünk sem tudott foglalkozni a dolog továbbgondolásával, megfelelő lezárásával.&lt;br /&gt;&lt;br /&gt;Sajnos azt sem látjuk, hogy tudjuk-e a jövőben az itt megszerzett tapasztalatokat kamatoztatni.&lt;br /&gt;&lt;br /&gt;Amennyiben újra scope lesz, biztos, hogy visszatérünk az ötletekhez.&lt;br /&gt;&lt;br /&gt;Most én is JBoss-ozom, bár egyelőre még csak az alkalmazásszerverrel foglalkozom, és tényleg sok kreativitás van benne, jó ötlet, technológiailag előremutató dolog. Persze itt is vannak sötét oldalak.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/4963019283986143957'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/4963019283986143957'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html?showComment=1299191403410#c4963019283986143957' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-70696356624550932' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/70696356624550932' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. március 3. 23:30'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4903320165337713297</id><published>2011-03-10T00:26:23.143+01:00</published><updated>2011-03-10T00:29:20.785+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'></title><content type='html'>Ezt a megjegyzést eltávolította a szerző.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/4903320165337713297'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/4903320165337713297'/><author><name>Bakai Balázs</name><uri>http://www.blogger.com/profile/01676249813193193031</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='28' height='32' src='http://2.bp.blogspot.com/_ZlEsDu1k7hA/TRI_cy2K25I/AAAAAAAAAAw/25rfP_hfR_k/S220/bb.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-70696356624550932' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/70696356624550932' type='text/html'/><gd:extendedProperty name='blogger.contentRemoved' value='true'/><gd:extendedProperty name='blogger.itemClass' value='pid-751703941'/><gd:extendedProperty name='blogger.displayTime' value='2011. március 10. 0:26'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4446688127093818337</id><published>2011-03-10T00:29:50.845+01:00</published><updated>2011-03-10T00:29:50.845+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Azért remélem, hogy nem fog a Drupal-os verseny so...</title><content type='html'>Azért remélem, hogy nem fog a Drupal-os verseny sorsára jutni. Nagy kár lenne érte...&lt;br /&gt;&lt;br /&gt;Láttam a JBoss-ról szóló cikkeidet, sok hasznos infót tartalmaznak!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/4446688127093818337'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/4446688127093818337'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html?showComment=1299713390845#c4446688127093818337' title=''/><author><name>Bakai Balázs</name><uri>http://www.blogger.com/profile/01676249813193193031</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='28' height='32' src='http://2.bp.blogspot.com/_ZlEsDu1k7hA/TRI_cy2K25I/AAAAAAAAAAw/25rfP_hfR_k/S220/bb.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-70696356624550932' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/70696356624550932' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-751703941'/><gd:extendedProperty name='blogger.displayTime' value='2011. március 10. 0:29'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-663837098788325441</id><published>2011-03-12T10:32:36.554+01:00</published><updated>2011-03-12T10:32:36.554+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi! Mivel most ezzel dolgozom, lesznek még ilye...</title><content type='html'>Köszi! Mivel most ezzel dolgozom, lesznek még ilyen irányú cikkek.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/663837098788325441'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/663837098788325441'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html?showComment=1299922356554#c663837098788325441' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-70696356624550932' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/70696356624550932' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. március 12. 10:32'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2772717534318899514</id><published>2011-04-18T00:33:20.273+02:00</published><updated>2011-04-18T00:33:20.273+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>@George Hron Helló! Leírtam egy későbbi bejegyzésb...</title><content type='html'>@George Hron Helló! Leírtam egy későbbi bejegyzésben: http://jtechlog.blogspot.com/2011/04/konfiguracios-parameterek-ejb-es-web.html</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5695982303749707840/comments/default/2772717534318899514'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5695982303749707840/comments/default/2772717534318899514'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/02/konfiguracios-parameterek-ejb-retegben.html?showComment=1303079600273#c2772717534318899514' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/02/konfiguracios-parameterek-ejb-retegben.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-5695982303749707840' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/5695982303749707840' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. április 18. 0:33'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4568382304054966947</id><published>2011-05-12T01:16:40.720+02:00</published><updated>2011-05-12T01:16:40.720+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Gratulálok a cikkhez! Ilyenekre van szükség. Még, ...</title><content type='html'>Gratulálok a cikkhez! Ilyenekre van szükség. Még, még!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/4568382304054966947'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/4568382304054966947'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1305155800720#c4568382304054966947' title=''/><author><name>Marhefka István</name><uri>http://infokukac.com</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-45427556'/><gd:extendedProperty name='blogger.displayTime' value='2011. május 12. 1:16'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2937528979642262600</id><published>2011-05-12T08:53:38.448+02:00</published><updated>2011-05-12T08:53:38.448+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Hát láttam ilyen saját keretrendszert zseniális fe...</title><content type='html'>Hát láttam ilyen saját keretrendszert zseniális fejlesztővel. Legszivesebben kihagynám a CV-mből, de másfél évig szivattam magam velük.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/2937528979642262600'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/2937528979642262600'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1305183218448#c2937528979642262600' title=''/><author><name>Kocka</name><uri>http://www.blogger.com/profile/10505773298750628833</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='24' height='32' src='http://photos1.blogger.com/x/blogger/3271/703/320/170223/00024.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1842159747'/><gd:extendedProperty name='blogger.displayTime' value='2011. május 12. 8:53'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-945207290387338835</id><published>2011-05-12T08:53:38.449+02:00</published><updated>2011-05-12T08:53:38.073+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszönöm! Ez kevésbé illik az eddigi sorba, kicsit...</title><content type='html'>Köszönöm! Ez kevésbé illik az eddigi sorba, kicsit bizonytalan is voltam, kíváncsi vagyok a visszajelzésekre!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/945207290387338835'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/945207290387338835'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1305183218449#c945207290387338835' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. május 12. 8:53'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2274513504557653765</id><published>2011-05-12T08:58:34.999+02:00</published><updated>2011-05-12T08:58:34.999+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nalunk is sajat keretrendszer van, evek ota probal...</title><content type='html'>Nalunk is sajat keretrendszer van, evek ota probalkozok kulso cuccok (JPA, Spring) bevezetesevel, csak nekem tul lassan halad, meg hat ki vagyok en? sima developer ;)&lt;br /&gt;&lt;br /&gt;A cikk jo, gratula ;D</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/2274513504557653765'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/2274513504557653765'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1305183514999#c2274513504557653765' title=''/><author><name>boci</name><uri>http://www.blogger.com/profile/06722116406933460588</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-724084990'/><gd:extendedProperty name='blogger.displayTime' value='2011. május 12. 8:58'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2780756916757812990</id><published>2011-05-12T09:05:19.506+02:00</published><updated>2011-05-12T09:05:19.506+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nagyon jó írás, bár sajnos még nem tudtam végig ol...</title><content type='html'>Nagyon jó írás, bár sajnos még nem tudtam végig olvasni a meló miatt :) Ilyen cikkek jöhetnek bármikor!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/2780756916757812990'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/2780756916757812990'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1305183919506#c2780756916757812990' title=''/><author><name>NagyI</name><uri>http://www.blogger.com/profile/16546339946308075352</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-187867716'/><gd:extendedProperty name='blogger.displayTime' value='2011. május 12. 9:05'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3244445243802198888</id><published>2011-05-12T10:35:08.386+02:00</published><updated>2011-05-27T09:20:29.693+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'></title><content type='html'>Ezt a megjegyzést eltávolította a szerző.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/3244445243802198888'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/3244445243802198888'/><author><name>Dávid</name><uri>http://www.blogger.com/profile/00710153828559591247</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://1.bp.blogspot.com/_Yme_dFoqzfc/SwubYGtP0NI/AAAAAAAAELg/QYv4MF6xWyM/S220/user_8585765_1223537720536_box__.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.contentRemoved' value='true'/><gd:extendedProperty name='blogger.itemClass' value='pid-767725649'/><gd:extendedProperty name='blogger.displayTime' value='2011. május 12. 10:35'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1083264318741221193</id><published>2011-05-12T14:14:33.209+02:00</published><updated>2011-05-12T14:14:33.209+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszönöm a pozitív visszajelzéseket! Ez a post nem...</title><content type='html'>Köszönöm a pozitív visszajelzéseket! Ez a post nem annyira technikai jellegű, kíváncsi voltam, mit szóltok hozzá!&lt;br /&gt;&lt;br /&gt;Milyen téma lehet érdekes még számotokra a metodológia vonalon?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/1083264318741221193'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/1083264318741221193'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1305202473209#c1083264318741221193' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. május 12. 14:14'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-997993617198727963</id><published>2011-05-12T16:42:44.157+02:00</published><updated>2011-05-12T16:42:44.157+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nagyon jó cikk! Itt is nagy sikert aratott kollégá...</title><content type='html'>Nagyon jó cikk! Itt is nagy sikert aratott kollégák között. A z 1.4-es Java-nál volt nagy mosoly - most mentünk 1.3-ról 1.5-re :)&lt;br /&gt;&lt;br /&gt;Amúgy ez a keretrendszer dolog - mindig lesz/van olyan dolog/igény, hogy valami minimál keretrendszert készíteni kell. Lehetőség szerint ezt kell minimalizálni - és bele kellene venni a fejlesztési/élettartam ciklusba azt is, hogy a meglévő, régebben fejlesztett keretrendszereket az aktuális/új szabványokhoz kell húzni/portolni. Szerintem ez a migrálás &amp;quot;fáj&amp;quot; mindenkinek.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/997993617198727963'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/997993617198727963'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1305211364157#c997993617198727963' title=''/><author><name>szilsan</name><uri>http://www.blogger.com/profile/09601377815329289487</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1109829282'/><gd:extendedProperty name='blogger.displayTime' value='2011. május 12. 16:42'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2924046392761989976</id><published>2011-05-12T16:49:58.924+02:00</published><updated>2011-05-12T16:49:58.924+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Sokan azt is keretrendszernek hívják, amikor a kiv...</title><content type='html'>Sokan azt is keretrendszernek hívják, amikor a kiválasztott eszközöket (3rd party library-ket) integrálod, és fejlesztési szabályokat alakítasz ki, hogy hogyan kell azokat alkalmazni, esetleg ezekhez segédosztályokat is gyártasz, vagy egy példa funkciót megvalósítasz benne. (Erre Maven-ben szép példa az archetype.) Gyakorlatilag egy best practice, hogy milyen konvenciókat tartsunk be az alkalmazásban. Ezt teljesen elfogadhatónak tartom.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/2924046392761989976'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/2924046392761989976'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1305211798924#c2924046392761989976' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. május 12. 16:49'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-307744950033138652</id><published>2011-05-14T11:54:43.767+02:00</published><updated>2011-05-14T11:54:43.767+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Egyetértek, bár egy keretrendszernek nem feltétlen...</title><content type='html'>Egyetértek, bár egy keretrendszernek nem feltétlenül kell akkorára nőnie, mint az itt leírtak és nem kell minden egyes problémát egyedi módon megoldania. Használhat különféle libeket a küldönböző problémákra és maradhat kicsi, egyszerű.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/307744950033138652'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/307744950033138652'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1305366883767#c307744950033138652' title=''/><author><name>tistvan</name><uri>http://www.blogger.com/profile/05315780008913687079</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-57287119'/><gd:extendedProperty name='blogger.displayTime' value='2011. május 14. 11:54'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6040338622627529287</id><published>2011-05-15T17:31:55.595+02:00</published><updated>2011-05-15T17:31:55.595+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Kicsit hasonlítanám a saját keretrendszer fejleszt...</title><content type='html'>Kicsit hasonlítanám a saját keretrendszer fejlesztését az új platformra/verzióra portolásához - kell az izgalom, a kihívás. Mindenfajta tudományos megalapozottság igénye nélkül én ezt az érdekes problémák hiányával (is) magyaráznám - sajnos még a ma is jellemző, hogy a fejlesztőt nem az üzleti igények megvalósítása motiválja, mert számára az csak egy újabb if beleépítése vagy egy újabb konfigurációs opció bepipálása, s mint ilyen, nem motiváló. De a kreativitást ki kell élni, s mivel az üzleti területet nem, a technológiát meg ismeri, ezért ott keresi (s találja meg) a kihívást. &lt;br /&gt;&lt;br /&gt;Lehet, te több helyen jártál mint én - azoknál a kis csapatoknál is megfigyelhető ez a frameworkitis, ahol közelebb állnak az üzlethez a fejlesztők?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/6040338622627529287'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/6040338622627529287'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1305473515595#c6040338622627529287' title=''/><author><name>Zsoldos Peter</name><uri>http://zsoldosp.blogspot.com</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-243665405'/><gd:extendedProperty name='blogger.displayTime' value='2011. május 15. 17:31'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6551010189450985082</id><published>2011-05-16T00:10:16.952+02:00</published><updated>2011-05-16T00:10:16.952+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Messze bonyolultabb a témakör mint amit egy megjeg...</title><content type='html'>Messze bonyolultabb a témakör mint amit egy megjegyzésbe beleférne, de lenne pár gondolatom:&lt;br /&gt;Nagyrészt igazad van, általában semmi értelme keretrendszer fejlesztésébe kezdeni, projekttel együtt pedig kimondottan öngyilkosság.&lt;br /&gt;A framework fejlesztési vágyat általában az kelti fel, hogy az évek óta fejlesztett, toldozott foldozott &amp;quot;szabványos&amp;quot; rendszerek lassan/nehezen tanulhatók, legalább egy sikeres projekt tapasztalata kell a hatékony használathoz, és többnyire nem elég gyors velük a munka, nem beszélve az elkészült cuccok módosíthatóságáról.&lt;br /&gt;Pl. részt vettem egy projektben, amit struts 2-ben kezdtünk írni, mert &amp;quot;ahhoz mindenki ért&amp;quot;, &amp;quot;a struts 1 már bizonyított&amp;quot;. Óriási hiba volt. A kb. 30 fejlesztőből senki nem ismerte alaposan, lényeges követelményeket nem lehetett vele teljesíteni, és sebeségre sem remekelt (ognl miatt pl.). A sok ész nélküli belenyúlkálás után gyakorlatilag egy beépített feature sem működött rendesen.&lt;br /&gt;Vagy láttam már megerőszakolt liferay-es projektet is, ami koloncként húzza magával az egész portál funkcionalitást. Működni már semmi nem működik belőle.&lt;br /&gt;Nem azt mondom hogy nincsenek használható eszközök, de nagyon kell tudni választani, és ha már választott az ember, ki kell ismerni a specialitásait, mert messze nem szabványos minden. Pl. klaszterezés, deployment, monitorozás.&lt;br /&gt;Aztán megváltoztatják itt ott, és lehet tanulni az új hülyeségeket.&lt;br /&gt;Én és a programozók többsége nem olyan eszközökkel szeretne dolgozni, amiket kiválasztani integrálni, kiismerni, optimalizálni kell. Csak működjön és tudjam elvégezni vele a munkám.&lt;br /&gt;&lt;br /&gt;Szomorú látni, hogy mennyi a rossz eszköz, és hiába a java tool-ok fejlettsége és bonyolultsága, ha egy jó php-s csapat fejlesztési időre és akár a megvalósított funkcionalitásra nézve is nagyobb javas team-eket aláz porba.&lt;br /&gt;Félre ne érts, a java és a php nem említhető egy lapon, de sajnos az ügyfelet nem érdekli, hogy mi hogy van megoldva. Ha agyon kell egy oldalt ajaxozni, én nem mondhatom, hogy nem támogatja a framework, a több perces fordítás és deployment szintén nem fér bele. (Tudom, elvileg ez újabban kikerülhető, de könnyű belecsúszni)&lt;br /&gt;Ha annak idején felteszem a karrierem a j2ee valamelyik korai verziójára, hát igen csúnya bukás lett volna belőle. &lt;br /&gt;&lt;br /&gt;A gyakorlatban nálunk egy php-s saját keretrendszer vált be. Évek óta fejlesztjük, és nagy projekteket is csinálunk vele. Erről legalább tudom, hogy nincs benne semmi felesleges, nincsenek integrációs problémák, és mindent támogat amit kell, ha pedig nem, akkor hagy teret az egyéni megoldásoknak. Van par feature benne, aminek máshol nem sok nyomát láttam: metaadatok, adatbázisszerkezet és adat menedzsment, egy gombnyomásos deploy (nem csak kódra, db-re is), jól kereshető automatikus adatmódosítás és híváslog, jogrendszer, perzisztencia (nem olyan profi mint a hibernate, de elég), query builder, ajax támogatás, stb.&lt;br /&gt;Azt gondolom, most ezzel a rendszerrel messze versenyképesek vagyunk, ha az ügyfél elfogadja a php-t. Hosszú távon portolni szeretnénk java-ra, de nem sok előnye lenne, főleg ha a php-s eclipsen még javítanak egy kicsit.&lt;br /&gt;Egyébként van benne java is, a nyomtatás jasper, az aszinkron üzenetkezelőt pedig épp most írjuk grizzly alapokon.&lt;br /&gt; &lt;br /&gt;A ciklikusság amit említettél az azért van, mert rossz alapokra építve előbb utóbb összedől bármi, ha elég nagy lesz. Nem lehet az információkat össze vissza kódban, uml rajzokban, xml-ben, annotációkban, html-ben stb. tartani.&lt;br /&gt;&lt;br /&gt;Nekem is vannak egyébként hosszú távú framework terveim, szeretnék egy teljesen formális alapokra helyezett rendszert, de nem tudom hogy lesz-e energiám és időm rá. Egyelőre még a szükséges elmélet is csak félkész állapotban van, az pedig biztos, hogy másképp nem lehet a meglévő rendszereknél jobb eredményt elérni.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/6551010189450985082'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/6551010189450985082'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1305497416952#c6551010189450985082' title=''/><author><name>Csiszár Tibor</name><uri>http://www.initon.hu</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-29039425'/><gd:extendedProperty name='blogger.displayTime' value='2011. május 16. 0:10'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5704061296866494820</id><published>2011-05-16T02:24:10.713+02:00</published><updated>2011-05-16T02:24:10.713+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Arra gondoltál már, hogy több energiát elvisz a kü...</title><content type='html'>Arra gondoltál már, hogy több energiát elvisz a különböző keretrendszerek tanulása, mint egy saját megírása? Elsőre vadul hangzik, de én sokszor éreztem így.&lt;br /&gt;&lt;br /&gt;Továbbá: egy idegen keretrendszert soha nem fogok annyira töviről-hegyire ismerni, mint amit én írtam.&lt;br /&gt;&lt;br /&gt;Ezzel együtt minden igaz, ami a posztban van.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/5704061296866494820'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/5704061296866494820'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1305505450713#c5704061296866494820' title=''/><author><name>scs</name><uri>http://www.blogger.com/profile/15071228275587131404</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-289113639'/><gd:extendedProperty name='blogger.displayTime' value='2011. május 16. 2:24'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4588963634165686635</id><published>2011-05-20T10:17:20.490+02:00</published><updated>2011-05-20T10:17:20.490+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A konfiguracion keresztuli programozashoz szeretne...</title><content type='html'>A konfiguracion keresztuli programozashoz szeretnem hozzatenni a leirtakon tul, hogy erre is rengetegfele kiforrott eszkoz van, amik akar integralva is lehetnek elterjedtebb frameworkokhoz.&lt;br /&gt;Beagyazhato scriptnyelvek, MVEL, rule engine, satobbi.&lt;br /&gt;A testreszabando funkciok rendszerint csak gombok a kabaton, es nem forditva.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/4588963634165686635'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/4588963634165686635'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1305879440490#c4588963634165686635' title=''/><author><name>Szocske</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-534018261'/><gd:extendedProperty name='blogger.displayTime' value='2011. május 20. 10:17'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3006999709583660273</id><published>2011-05-20T17:21:24.366+02:00</published><updated>2011-05-20T17:21:24.366+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Hi

A lényeggel egyetértek, általában nem érdemes ...</title><content type='html'>Hi&lt;br /&gt;&lt;br /&gt;A lényeggel egyetértek, általában nem érdemes keretrendszert fejleszteni. Csak akkor mint korábban Csiszár Tibor irta, ha a saját keretrendszerére tudja építeni az üzletet. Ekkor jó lehet, de nagyon el kell tudni kapni a célt.&lt;br /&gt;&lt;br /&gt;Emlékezem, amikor korábbi munkahelyemen a rendszer fejlesztés átcsapott keretrendszer fejlesztésbe aztán a végén ár driverekt is akartak irni a fejlesztők. A projekt sohasem fejeződőtt be ...</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/3006999709583660273'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/3006999709583660273'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1305904884366#c3006999709583660273' title=''/><author><name>PIF73</name><uri>http://unixos.blog.hu</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1701364885'/><gd:extendedProperty name='blogger.displayTime' value='2011. május 20. 17:21'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3119928778642857504</id><published>2011-05-22T00:24:30.554+02:00</published><updated>2011-05-22T00:24:30.554+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szia,

Szereny szemelyem felelos az alkalmazas mag...</title><content type='html'>Szia,&lt;br /&gt;&lt;br /&gt;Szereny szemelyem felelos az alkalmazas magyar forditasaert. Irod, hogy sok a hiba az alkalmazas forditasaban.&lt;br /&gt;&lt;br /&gt;Bar folyamatosan igyekszek atnezni a forditast, javitani, ahol lehet, mindig vannak olyan hibak, amik felett elsiklok, elsiklunk. Ha gondolod, akkor jelentsd fel a talalt hibakat itt: http://bug.openscope.org/browse/VIRTUALBOX . Mindig a kovetkezo kiadassal erkezik az uj forditas, ugyhogy egy kicsit el kell viselni a problemakat, azonban eleg gyorsan jonnek az uj kiadasok, hogy ez ne legyen elviselhetetlen.&lt;br /&gt;Remelem tudunk segiteni.&lt;br /&gt;&lt;br /&gt;Garami Gabor</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7294342172766860875/comments/default/3119928778642857504'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7294342172766860875/comments/default/3119928778642857504'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/09/virtualizacio-fejlesztoi-gepen.html?showComment=1306016670554#c3119928778642857504' title=''/><author><name>Gábor</name><uri>http://www.blogger.com/profile/16328831533238731170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/09/virtualizacio-fejlesztoi-gepen.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7294342172766860875' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7294342172766860875' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2145961406'/><gd:extendedProperty name='blogger.displayTime' value='2011. május 22. 0:24'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1484579390477456492</id><published>2011-05-22T20:45:48.994+02:00</published><updated>2011-05-22T20:45:48.994+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Kedves Gábor,

Örülök, hogy olvastad a postot, és ...</title><content type='html'>Kedves Gábor,&lt;br /&gt;&lt;br /&gt;Örülök, hogy olvastad a postot, és köszönöm a hozzászólásod. Ezt 2009 szeptemberében írtam, azóta nem nagyon használtam, biztos sokat fejlődött, biztosan a fordítás is. Amennyiben használni fogom, és találok hibát, bejelentem az általad megadott címen.&lt;br /&gt;&lt;br /&gt;Szerintem ha a nyelvi állományon a kiadás előtt lefuttatsz egy helyesírás ellenőrzést, a hibáknak ki kell jönniük, mert ahogy írtam, sok elgépelést találtam akkor.&lt;br /&gt;&lt;br /&gt;A másik, az &amp;quot;érdekes szóhasználat&amp;quot;, engem nem zavar, sajnos nagyon sok angol kifejezésnek nincs magyar megfelelője, így nagyon nehéz a dolgod a fordítással. Ezeket én totál elfogadom, tudom, hogy nehéz döntés, és szerintem nincs jó és rossz megoldás.&lt;br /&gt;&lt;br /&gt;Kitartást a további munkához!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7294342172766860875/comments/default/1484579390477456492'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7294342172766860875/comments/default/1484579390477456492'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/09/virtualizacio-fejlesztoi-gepen.html?showComment=1306089948994#c1484579390477456492' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/09/virtualizacio-fejlesztoi-gepen.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7294342172766860875' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7294342172766860875' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. május 22. 20:45'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-89243432249158742</id><published>2011-05-23T11:06:03.194+02:00</published><updated>2011-05-23T11:06:03.194+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Sajnos már találkoztam a saját keretrendszer probl...</title><content type='html'>Sajnos már találkoztam a saját keretrendszer problémájával, néha még ma is szívunk miatta. Persze aki írta már nincs a cégnél, de ő tipikusan az az ember aki mindenből sajátot ír. Nyilván ez is még több nehéz napot idézett elő.&lt;br /&gt;&lt;br /&gt;Grat a cikkhez!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/89243432249158742'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/89243432249158742'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1306141563194#c89243432249158742' title=''/><author><name>bh</name><uri>http://www.blogger.com/profile/06985106361377703994</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='24' height='32' src='http://3.bp.blogspot.com/-kq9928Yk8nI/TdohnSS9mvI/AAAAAAAAAFg/xJjPzw3KQ0A/s220/b.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-422360243'/><gd:extendedProperty name='blogger.displayTime' value='2011. május 23. 11:06'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-643478514463737454</id><published>2011-05-23T12:58:42.490+02:00</published><updated>2011-05-23T12:58:42.490+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Alapvetően egyet értek, de azért lenne két megjegy...</title><content type='html'>Alapvetően egyet értek, de azért lenne két megjegyzésem:&lt;br /&gt;&lt;br /&gt;1. Szerintem kifejezetten hasznos, ha ír valaki egy saját framework-öt, csak utána tegye félre, és használjon valami mást. Ebből rengeteg tapasztalatot lehet szerezni, és olyan dolgokat is meg lehet ismerni, amit amúgy ma már egy fejlettebb framework simán elfedne.&lt;br /&gt;&lt;br /&gt;2. Lehetnek azért speciálisabb esetek is, pl. nálunk (Ustream) annó azért csináltam egy sajátot (előttem is mondjuk saját volt), mert fontos volt a teljesítmény. Sikerült elérni, hogy egy hello world appból egy kb. butított symfony tudású framework-ben átlagos szerveren 2-3000 req/sec-et ki tudott szolgálni, akkor a népszerűbb framework-ök ennek a nyomában sem voltak. Utólag elég sok mindnet belepakoltunk még (van jó pár olyan feature is, ami pl. a symfony2-ben lett csak a symfony esetén), de így is jóval hatékonyabb, mint a létező frameworkök (nyilván speciálisabb is).</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/643478514463737454'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/643478514463737454'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1306148322490#c643478514463737454' title=''/><author><name>Hodicska Gergely</name><uri>http://blog.felho.hu</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-782836755'/><gd:extendedProperty name='blogger.displayTime' value='2011. május 23. 12:58'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7226710523688632707</id><published>2011-06-03T11:47:35.188+02:00</published><updated>2011-06-03T11:47:35.188+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nagyon jó post gratulálok. A saját keretrendszer k...</title><content type='html'>Nagyon jó post gratulálok. A saját keretrendszer készítése tényleg őrült munka... De még őrültebb amikor a vezetőség mindent szeretne legeneráltatni egy 3rd party cuccal, nálunk már volt pár microsoft bemutató ahol a &amp;quot;neves&amp;quot; szakember mindent legenerált pár kattintással és páran tényleg elhitték, hogy működik. Sajnos tapasztaltam hogy mostanában az oracle marketingje is hasonlo a jdeveloper + adf + ora trioval.Idősebb korosztályba akik magicen, delphin és nem tudom milyen egyéb dolgokon nőttek fel vagy az jellemző, hogy nem akarnak kódolni vagy hogy mindent egy saját noname megoldással akarnak megoldani...</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/7226710523688632707'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/7226710523688632707'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1307094455188#c7226710523688632707' title=''/><author><name>György Szimeonov</name><uri>http://www.blogger.com/profile/12129665373296785371</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-871390908'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 3. 11:47'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7929661025071270856</id><published>2011-06-07T20:12:58.639+02:00</published><updated>2011-06-07T20:12:58.639+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>En csak par dologra reagalnek a kommentek kozul.

...</title><content type='html'>En csak par dologra reagalnek a kommentek kozul.&lt;br /&gt;&lt;br /&gt;Eloszor is, ha az architect olyan frameworkot valaszt, amihez senki sem ert a fejlesztok kozul, vagy a kisebbseg ert csak hozza, akkor ezt jelezni kell fele, ha ez nem eleg, akkor el kell tole koszonni. Egy ilyen architect barmikor barmilyen projektet megolhet a hozza nem ertesevel. Szerintem.&lt;br /&gt;&lt;br /&gt;Egy framework megtanulasa valoban neheznek tunhet, es egy-egy projekt eseteben nem is biztos hogy kifizetodo, de ezt &amp;quot;hosszutavu befektetes&amp;quot; cimszo alatt ismeri a bankszakma. Lehet, hogy akkor, ott nem fogod tudni hasznalni az adott keretrendszert, vagy kiderul, hogy rossz dontes volt, de barmikor johet egy olyan projekt, amikor azt mondod, hogy &amp;quot;jee, hiszen ehhez fel lehet hasznalni az XY keretrendszert!&amp;quot;. Es ez sokszor nagyon jol tud jonni.&lt;br /&gt;Egy kisebb csapatnal, egy nagyobb projektnel siman elojohet az, hogy az adott keretrendszer megsem valtja be a remenyeket, le kell cserelni. Ettol az adott keretrendszerrel szerzett tapasztalat nem vesz el a semmibe, ott marad a fejekben. En ugyan rendszergazdai vonalon mozgok inkabb, de rengetegszer volt olyan esetem, hogy tudtam segiteni egy olyan problemaban, amihez senki meg csak hozza sem tudott szagolni, pusztan azert, mert en messzirol, tavcsovel lattam mar ilyet. &lt;br /&gt;&lt;br /&gt;A sajat keretrendszer irasaval kapcsolatban en is csak azt tudom mondani: csak akkor, ha mar minden mas ut jarhatatlannak bizonyult. Es akkor is, lehet hogy erdemes egy meglevo keretrendszerbol kiindulni, azt lebutitani/atirni, hogy gyorsabb legyen. Igy meg lesz az az elony is, hogy ha a kiindulo rendszer szabvany feluletekkel kompatibilis volt, akkor a mi rendszerunk is az lesz, kovetkezeskeppen jobban fog illeszkedni barmilyen mas rendszerhez, mintha nekunk kellene a biteket atlapatolni.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/7929661025071270856'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/7929661025071270856'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1307470378639#c7929661025071270856' title=''/><author><name>Gábor</name><uri>http://www.blogger.com/profile/16328831533238731170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2145961406'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 7. 20:12'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6838419351819650925</id><published>2011-06-07T23:08:55.270+02:00</published><updated>2011-06-07T23:08:55.270+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>@Hodicska Gergely: azt állítod, hogy jelenleg ninc...</title><content type='html'>@Hodicska Gergely: azt állítod, hogy jelenleg nincs/vagy nem ismersz olyan keretrendszert, mely megfelelő teljesítményt lenne képes leadni? Én ezzel együtt tudok élni, csak nagyon elszomorodnék. Egyszerűbb, de nagyobb forgalmú webes rendszerek létrehozására nem alkalmas a Java a létező keretrendszereivel? Nem lehet, hogy itt maga a Java és a hozzá tartozó programozási paradigmák lehet egy szűk keresztmetszet? És mindenki a horizontális skálázhatóság irányába megy, ahelyett, hogy ettől a kolonctól válna meg? Ha viszont nektek sikerült egy nagy teljesítményt biztosító keretrendszert megalkotni, nem akarjátok megnyitni a forrását? :)&lt;br /&gt;&lt;br /&gt;@Gábor ötlete, hogy érdemes lehet egy már meglévő keretrendszert lebutítani, nagyon érdekes ötlet!&lt;br /&gt;&lt;br /&gt;Köszönöm a véleményeiteket, látom ez a téma mindenki fantáziáját megmozgatja. Magasan a legolvasottabb cikkem lett. Van még olyan téma, amiről szívesen olvasnátok?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/6838419351819650925'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/6838419351819650925'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1307480935270#c6838419351819650925' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 7. 23:08'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-219607158097016582</id><published>2011-06-07T23:10:37.539+02:00</published><updated>2011-06-07T23:10:37.539+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Úgy látszik, ami hiányzott a cikkből, az annak def...</title><content type='html'>Úgy látszik, ami hiányzott a cikkből, az annak definíciója, hogy én mit tartok keretrendszernek. Én a nagyra nőtt monstrumokat hívom így, melyek bonyolultak, betanulása lassú. Többen említettétek, hogy egy projektnél egy ragasztó jellegű keretrendszer kellhet, apró, pár osztállyal, egyszerűen. Természetesen ezeknek én is mellette vagyok, de ezeket max. egy óra alatt át lehet látni, és a kiválasztott technológiákat integrálja.&lt;br /&gt;&lt;br /&gt;Sajnos eddig én még csak olyan csapatokat láttam, ahol előbb vagy utóbb előbukkant a probléma, és lehet, hogy egy eldugott zugból, de kezdett egy keretrendszer előburjánzani. A fejlesztők még mindig jobban szeretik a technológiai kihívásokat, és az üzleti problémák elől szeretnek saját kis zugaikba elmenekülni, ahol kiélhetik kreativitásukat. Erre egy keretrendszer kitűnő eszköz.&lt;br /&gt;&lt;br /&gt;Elhangzott az is, hogy a szabványos keretrendszerek gyakran rosszul kerülnek kiválasztásra, nincs velük éles tapasztalat, és a projekt során derül ki, hogy ez nem lesz megfelelő. Én is azt az elvet vallom, hogy ott az architect rontotta el az elején, nem lehet egy fejlesztésbe így belemenni. Sajnos rengeteg cég projekten tanulja meg az új technológiákat, ami alapvetően hibás. Sajnos nálunk még nem terjedt el a nézet, hogy hívunk egy szakértőt, aki segít az elindulásnál, akár kis kód review-t tart. Így beleugranak egy meglévő keretrendszerbe, hogy majdcsak megoldják. És persze ismeret és tapasztalat hiányában rosszul használják a keretrendszert, utána elkezdik minden fórumon szidni.&lt;br /&gt;&lt;br /&gt;Sajnos a Java-nak vannak hátrányai, és igen el lehet csúszni. PHP-val szembeállítva elhangzott, hogy sokkal lassabb a fejlesztési ciklus (kódolás, telepítés, tesztelés), valamint voltak bukott dolgok, mint a J2EE. Mindkettővel egyetértek. Lassan én is úgy érzem, hogy üzleti logikára nincs alkalmasabb nyelv a Java-nál, de webes fejlesztésre nem biztos, hogy a legmegfelelőbb. A J2EE-nél mi kivártunk, és mikor már az úttörő cégek belefutottak, és levonták a következtetéseket, hogy nagyon körülményes a használata, akkor döntöttünk, hogy ebbe nem ugrunk bele. Más tapasztalataiból is rengeteget lehet tanulni. Az élet fura fintora, hogy most pont egy J2EE projektet fejlesztünk tovább, és annyira jól van megírva a J2EE réteg (kb. 6 éve lett kifejlesztve), hogy nem migrálunk fel, hanem ezt használjuk. Élő példa, hogy lehet rossz keretrendszerrel is szép, tiszta üzleti alkalmazásokat írni. A mai, modern, annotációkkal teletűzdelt keretrendszerekkel írt alkalmazásainkat fogjuk több év múlva is érteni? És meg is válaszolom. Nem a keretrendszer a lényeg, hanem hogy hogy lett az alkalmazás felépítve. De a J2EE-hez találtam most is dokumentációt, egy saját keretrendszerhez nem találnék.&lt;br /&gt;&lt;br /&gt;Elhiszem azt is, hogy egy saját keretrendszer kifejlesztése van, hogy rövidebb idő, de... És visszautalnék a cikkre. A befektetett tanulás később meg fog térülni. Saját fejlesztése esetén nem nyersz annyit.&lt;br /&gt;&lt;br /&gt;Másrészt igaz, hogy egy idegen keretrendszert nem ismersz annyira, mint a sajátod, de egy másik fejlesztő, aki a projekten van, tuti, hogy nem a tiedet szeretné megismerni, hanem egy elterjedtebbet. Az ok egyszerű, talán túl egyszerű. Ha egy szabványos keretrendszer belekerül az önéletrajzába, nő a fejlesztő piaci értéke.&lt;br /&gt;&lt;br /&gt;Testre szabandó funkciókkal kapcsolatban igaz, hogy azoknak csak plusz funkcióknak kéne lenniük, de láttam olyan keretrendszert, melyet át és átfűzött az az igény, hogy az ügyfél bárhol be tudjon avatkozni. Itt is az van, mint sok helyen, hogy nagyon nehéz meghúzni a határt. Az ügyfélnek nagyon nehéz elmagyarázni, aki nem ért a technológiához, hogy valamit miért konfigurálhatnak, valamit meg miért nem. És akkor jön egyrészt az új igény, hogy akkor azt is, meg hallottam a gyakran bevethető mondatot is, hogy a konkurencia terméke viszont tudja. Ezzel kapcsolatban mindig felvetődik bennem, hogy abból az energiából, melyből egy általános keretrendszer kerül kifejlesztésre, vajon hány egyedi funkciót lehetne kifejleszteni? Itt egyedül a bizalom hiányzik, az ügyfél és a fejlesztő cég között.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/219607158097016582'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/219607158097016582'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1307481037539#c219607158097016582' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 7. 23:10'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3414314671697287358</id><published>2011-06-08T19:48:36.688+02:00</published><updated>2011-06-08T19:48:36.688+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>István:
&amp;quot;üzleti logikára nincs alkalmasabb ny...</title><content type='html'>István:&lt;br /&gt;&amp;quot;üzleti logikára nincs alkalmasabb nyelv a Java-nál, de webes fejlesztésre nem biztos, hogy a legmegfelelőbb&amp;quot;&lt;br /&gt;&lt;br /&gt;Csak érdeklődésképpen van jobbnak tűnő megoldás, annál ha GWT -t a megfelelő kliens oldali patternekkel és architektúrával alkalmazzák (MVP, események felületi elemek között, Command -ok küldése a szerver oldalra...) ? Még amiatt is sokkal egyszerűbbnek tűnik, mert így a kliens oldalon is Java -ban lehet fejleszteni és nem kell html, jsp, javascript stb.&lt;br /&gt;&lt;br /&gt;---------&lt;br /&gt;&lt;br /&gt;Ahogy látom még nem írtál az Distributed version control megoldásokról (Git, Mercurial...). Ha vannak ezekkel tapasztalataid, miben jobb mint az SVN, lehet -e egyszerűen migrálni, mennyire kiforrott az IDE integrációjuk stb. az engem érdekelne.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/3414314671697287358'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/3414314671697287358'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1307555316688#c3414314671697287358' title=''/><author><name>Gyuri</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2051790314'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 8. 19:48'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7326709320941733137</id><published>2011-06-14T01:10:36.965+02:00</published><updated>2011-06-14T01:10:36.965+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nekem ez forditott, a Java nekem masodlagos nyelv,...</title><content type='html'>Nekem ez forditott, a Java nekem masodlagos nyelv, a Ruby az elsodleges.&lt;br /&gt;&lt;br /&gt;A dologhoz hozzatartozik, hogy en nagyon sokaig Pythonoztam, belekezdtem a webes feluletekbe is, mod_python, megvolt az elso helloworldom djangoban - azutan valtottam Rubyra.&lt;br /&gt;&lt;br /&gt;Tetszik a nyelv formazas-alapusaga, de nagyon elvittek egy olyan szintre, ahova en mar ugy gondoltam, hogy nem feltetlen felel meg az igenyeimnek. De meg ezzel egyutt tudtam volna elni. Ami a legjobban eldontotte nalam a Ruby vs Python kerdest, az az objektumorientaltsag volt.&lt;br /&gt;En nagyon szeretem az OOP szemleletet, valahogy konnyebben ertem meg az ilyen programokat, mint egy alapvetoen proceduralis valamit (PHP, C, ...). Engem borzasztoan zavartak az olyan apro kulonbsegek, mint pl:&lt;br /&gt;&lt;br /&gt;Python:&lt;br /&gt;array = [&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;]&lt;br /&gt;length = len(array)&lt;br /&gt;&lt;br /&gt;Ruby:&lt;br /&gt;array = %w(a b c)&lt;br /&gt;length = array.size&lt;br /&gt;&lt;br /&gt;Szoval a ruby sokkal inkabb objektumorientaltabb. Sajnos rubyban lehet olyan kodokat irni, amik rosszul vannak indentalva - bar en mindig figyelek arra, hogy jol indentaljak -, ez nem volt olyan komoly szempont, ami a python melle kotott volna.&lt;br /&gt;A Ruby van annyira elismert es nepszeru nyelv mint a python, a Rails framework rengeteget ad a webes fejleszteshez, es szinte minden platformra elerheto. Erdemes lenne kiprobalnod...&lt;br /&gt;&lt;br /&gt;(Uhh, ez hosszu lett, bocsi)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/7326709320941733137'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/7326709320941733137'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html?showComment=1308006636965#c7326709320941733137' title=''/><author><name>Gábor</name><uri>http://www.blogger.com/profile/16328831533238731170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3752345250697097633' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3752345250697097633' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2145961406'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 14. 1:10'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5126469587122100626</id><published>2011-06-14T01:12:11.968+02:00</published><updated>2011-06-14T01:12:11.968+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Ja, es elfelejtettem: van JRuby... :-)</title><content type='html'>Ja, es elfelejtettem: van JRuby... :-)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/5126469587122100626'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/5126469587122100626'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html?showComment=1308006731968#c5126469587122100626' title=''/><author><name>Gábor</name><uri>http://www.blogger.com/profile/16328831533238731170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3752345250697097633' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3752345250697097633' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2145961406'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 14. 1:12'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8878157220413929189</id><published>2011-06-14T06:47:29.744+02:00</published><updated>2011-06-14T06:47:29.744+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Én sok év C/C++ után kb. 8 éve Java-zom, és a köve...</title><content type='html'>Én sok év C/C++ után kb. 8 éve Java-zom, és a következő áldozat a Scala lenne... &lt;br /&gt;&lt;br /&gt;Azért feltételes módban egyelőre, mert az OO -&amp;gt; functional váltás elég kemény mental switch-et jelent, ezt meg kell erősítenem, sajnos.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/8878157220413929189'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/8878157220413929189'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html?showComment=1308026849744#c8878157220413929189' title=''/><author><name>Áron</name><uri>http://www.midori.hu</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3752345250697097633' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3752345250697097633' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-206999850'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 14. 6:47'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8825654117887217906</id><published>2011-06-14T09:12:39.444+02:00</published><updated>2011-06-14T09:12:39.444+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Megint jó lett a cikk! Gratulálok!

Érdekes volt o...</title><content type='html'>Megint jó lett a cikk! Gratulálok!&lt;br /&gt;&lt;br /&gt;Érdekes volt olvasni erről a témáról is, és ami számomra még érdekesebb volt, azok a téma kapcsán felmerülő egyéb meglátások, gondolatok, tapasztalatok.&lt;br /&gt;&lt;br /&gt;Várom a következőt! :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/8825654117887217906'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/8825654117887217906'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html?showComment=1308035559444#c8825654117887217906' title=''/><author><name>Marhefka István</name><uri>http://infokukac.com</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3752345250697097633' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3752345250697097633' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2131752108'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 14. 9:12'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4965542710799016778</id><published>2011-06-14T09:16:47.833+02:00</published><updated>2011-06-14T09:16:47.833+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Személy szerint Java előtt Python volt a favorit. ...</title><content type='html'>Személy szerint Java előtt Python volt a favorit. Nagyon szeretem azt a nyelvet, az átláthatósága, és a &amp;quot;végtelen&amp;quot; felhasználhatósága miatt. Pythonban lehet scriptet írni, de komolyabb desktop alkalmazást is, ahogyan pda-ra is írtam már progit tcl/tk-val annó, webre is alkalmasabb, mint a PHP. Egy igazi általános célú programozási nyelv. Egy-két esettől &amp;quot;len(array)&amp;quot; eltekintve objektumorientált a Python is. Személy szerint PHP-ban is programoztam éveket, de ott zavart a következetlenség, ami a metódusok paraméter-listájában felfedezhető. Kezdőknek és haladóknak egyaránt csak ajánlani tudom (én is), egy kicsit talán a magyar nyelvű könyvek hiányoznak, ez talán hátráltathatja a tanulást. Létezik Python 3 könyv, bár olvasni nem olvastam, elég vaskos, de még így is töredéke a Java, C, vagy PHP könyvekhez képest.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/4965542710799016778'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/4965542710799016778'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html?showComment=1308035807833#c4965542710799016778' title=''/><author><name>Kovács Richárd</name><uri>http://www.blogger.com/profile/06849753526791080950</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://3.bp.blogspot.com/_iwfk5KPTXzU/S2vH-RR0JyI/AAAAAAAAABc/aGduniprSBw/S220/profile.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3752345250697097633' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3752345250697097633' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-196939700'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 14. 9:16'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4693050500853429755</id><published>2011-06-14T09:28:27.120+02:00</published><updated>2011-06-14T09:28:27.120+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nálam JavaScript és Scala.

Nem értek egyet a cikk...</title><content type='html'>Nálam JavaScript és Scala.&lt;br /&gt;&lt;br /&gt;Nem értek egyet a cikkben lévő azon kijelentéssel, hogy a JS szorosan a GUI tervezéshez tartozik. A tipográfiai, dizájn elemeket általában CSS-ben és HTML-ben kell megoldani. Dizájnernek átadható. A trend az, hogy egyre több kommunikációs logika kerül a JS rétegbe. Az a JS programozó, aki nem tudja magáról lepattintani a dizájn feladatokat rosszul szervezi a kódot.&lt;br /&gt;&lt;br /&gt;Áron: A funkcionális nyelvre való váltás szvsz annyira nem nagy durranás, főleg nem a Scala esetében, ahol nem muszáj ezt a paradigmát követni. Egyébként néhány Java &amp;quot;enterprise best practice&amp;quot;-ben is fel lehet fedezni a funkcionális programozás elveit, pl. amikor az állapotmentességre törekednek.&lt;br /&gt;&lt;br /&gt;Jóacikk!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/4693050500853429755'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/4693050500853429755'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html?showComment=1308036507120#c4693050500853429755' title=''/><author><name>tvik</name><uri>http://kodzaj.blog.hu</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3752345250697097633' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3752345250697097633' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2144484515'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 14. 9:28'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4660282935789740342</id><published>2011-06-14T11:20:07.959+02:00</published><updated>2011-06-14T11:20:07.959+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A cikk mondanivalója tökéletes, bár egy kicsit fáj...</title><content type='html'>A cikk mondanivalója tökéletes, bár egy kicsit fájt látni az ilyen nyelvtani helytelenségeket, pl. &amp;quot;abba hasonlít&amp;quot;, etc. (helyesen: abban hasonlít) Ez kicsit olyan, mint a helyes kódformázás, nem kötelező, de sokkal jobb, ha nyelvtanilag helyes.&lt;br /&gt;&lt;br /&gt;A tartalmat illetően: Én pont ugyanígy tanultam meg a Java mellé második nyelvként a Pythont, miután futottam egy kört a Javascript-tel és a Scala-val. Azok számára, akik JVM alapú, egyszerű és Java-ra hasonlító nyelvet szeretnének, merem még ajánlani a Gosu-t is. ( http://gosu-lang.org/ )&lt;br /&gt;&lt;br /&gt;Áron: Egyetértek tvik-kel, a Scala nem funkcionális, hanem kevert paradigmájú nyelv (az alkotók is így jellemzik) így tökéletes arra, hogy az ember megtanulja a funkcionális gondolkozást.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/4660282935789740342'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/4660282935789740342'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html?showComment=1308043207959#c4660282935789740342' title=''/><author><name>Vagabond</name><uri>http://lusta.hu</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3752345250697097633' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3752345250697097633' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-961793315'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 14. 11:20'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-389941470448467232</id><published>2011-06-14T15:36:26.249+02:00</published><updated>2011-06-14T15:36:26.249+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>PHP-t használok már a kezdetek óta. Az egyetemen J...</title><content type='html'>PHP-t használok már a kezdetek óta. Az egyetemen Java és C# képzés van, én mégis vittem szakirányon a PHP-s elképzeléseimet.&lt;br /&gt;&lt;br /&gt;Hogy miért?&lt;br /&gt;&lt;br /&gt;Mert nem kell hozzá semmi, bármelyik tárhelyszolgáltatónál jelen van, minimális költségekkel üzemeltethető.&lt;br /&gt;&lt;br /&gt;Rossz kódot pedig bármelyik nyelven lehet írni, én Java-ban is láttam durván redundáns kódot, 1 osztályban megvalósított programot, ékezetes változóneveket. :)&lt;br /&gt;Ezek a dolgok a programozón múlnak. PHP-ban is lehet szép OO kódokat írni és nem kell hozzá fejlesztő eszköz, se fordító, se futtató környezet (legalábbis Java-s értelemben vett virtuális gép, vagy C# esetén célszerver).&lt;br /&gt;&lt;br /&gt;Ami talán plusz nehezítés, hogy szinte minden esetben kell hozzá tudni html-t, css-t, javascriptet (utóbbihoz valami frameworkot (jQuery)), tehát alapból nem elég a PHP ismerete, a többi webes dologgal és böngészők képességeivel is tisztában kell lenni. Ez Java, C# esetén gondolom nem igazán jön fel, mert ezek is az adott nyelvre meg vannak írva osztályokban és automatikusan generálódik a felhasználói felület és az AJAX visszahívás is (így láttam).&lt;br /&gt;&lt;br /&gt;A Python nekem is tetszik és figyelemmel követem a róla szóló híreket, jó lenne, ha a tárhelyszolgáltatók is követnék, de amíg nem teszik, addig marad a PHP elsődlegesnek, mivel ha itthon megírom, akkor azt bárhol máshol fel tudják másolni és megy (most verziók dolgától tekintsünk el, az minden nyelvnél elő jön).&lt;br /&gt;&lt;br /&gt;Amit még figyelembe szoktam venni az az erőforrás-használat, teljesítmény, skálázhatóság.. sokat olvastam ebben a témakörben és sehol sem győztek meg arról, hogy ha a PHP-nál maradok az rossz döntés lenne. &lt;br /&gt;&lt;br /&gt;Végül pedig valamennyire az OO ellen szólva, engem borzalmasan idegesít, hogy egy fájlt nem lehet Java-ban(/C#-ban) beolvasni 1 sornyi kóddal, hanem kell FileReader, BufferedReader, ciklus, stb., PHP esetén pedig egy file_get_contents() megoldja. Nekem ez valahogy számít, amikor programot írok, hogy mennyit is kell írni. &lt;br /&gt;Ezért szimpatikus a Python is, mert még rövidebb is tud lenni, mint a PHP.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/389941470448467232'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/389941470448467232'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html?showComment=1308058586249#c389941470448467232' title=''/><author><name>Tommey</name><uri>http://tommey.hu</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3752345250697097633' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3752345250697097633' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1794869416'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 14. 15:36'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7627714628841748399</id><published>2011-06-14T17:16:38.167+02:00</published><updated>2011-06-14T17:16:38.167+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>&amp;quot;PHP-ban is lehet szép OO kódokat&amp;quot; ebbe ...</title><content type='html'>&amp;quot;PHP-ban is lehet szép OO kódokat&amp;quot; ebbe belekötnék. Egyrészt az OO eszköztár elég vékony szegmensét prezentálja a PHP, ráadásul azt is &amp;quot;ocsmányul&amp;quot;. Ez a new \HU\BAR\FOO ... inkább nem is írok semmit. Hiába a nagy oop, ha a nyelvi dolgok nem azok, tehát bukott az OOP szemlélet. A függvények paraméterlistálya teljesen következetlen, tök random, hogy az amiben, amit, amire hármast melyik függvény hogy kéri be (igazából az egész nyelvre jellemző ez a következetlenség). Szerintem komolyabb alkalmazásoknál nem az kell, hogy döntő legyen, hogy fel tudom-e tenni Pistike szerverére :D ez elmegy egy darabig, de egy bizonyos projektméret után nem kifizetődő szemlélet. A file_get_contents szerinted mit csinál? Azért mert egy magasabb szinten elfedik előled az ilyen alacsonyabb szintű dolgokat nem jelent semmit. Ez azért van, mert a PHP-t egy bizonyos feladatra szánták, amire jó + gyors meg minden, de biztosan lenne olyan fájlkezelési probléma, amire a file_get_contents nem volna megoldás, de valamelyik Readerrel biztos meg lehetne oldani. Egy szó mint 100 a PHP egy template nyelv, amibe bele&amp;quot;hekkeltek&amp;quot; egyéb dolgokat is. Arra jó amire kitalálták.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/7627714628841748399'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/7627714628841748399'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html?showComment=1308064598167#c7627714628841748399' title=''/><author><name>Kovács Richárd</name><uri>http://www.blogger.com/profile/06849753526791080950</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://3.bp.blogspot.com/_iwfk5KPTXzU/S2vH-RR0JyI/AAAAAAAAABc/aGduniprSBw/S220/profile.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3752345250697097633' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3752345250697097633' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-196939700'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 14. 17:16'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8721290048109934938</id><published>2011-06-14T22:49:11.767+02:00</published><updated>2011-06-14T22:49:11.767+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>+1 a Jython-nak. A wsadmin is ezt használja a konf...</title><content type='html'>+1 a Jython-nak. A wsadmin is ezt használja a konfigurációs feladatok automatizálásához.&lt;br /&gt;&lt;br /&gt;Talán még a Ceylon Project is érdekes lehet a számodra!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/8721290048109934938'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/8721290048109934938'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html?showComment=1308084551767#c8721290048109934938' title=''/><author><name>Bakai Balázs</name><uri>http://www.blogger.com/profile/01676249813193193031</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='28' height='32' src='http://2.bp.blogspot.com/_ZlEsDu1k7hA/TRI_cy2K25I/AAAAAAAAAAw/25rfP_hfR_k/S220/bb.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3752345250697097633' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3752345250697097633' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-751703941'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 14. 22:49'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-576527831822079744</id><published>2011-06-15T00:01:25.731+02:00</published><updated>2011-06-15T00:01:25.731+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Tényleg remek poszt ismét.

Én a javascript mellet...</title><content type='html'>Tényleg remek poszt ismét.&lt;br /&gt;&lt;br /&gt;Én a javascript mellett tettem le a voksot jelenleg (mint második/harmadik nyelv), mert:&lt;br /&gt;&lt;br /&gt;1, viccesnek tartom, hogy MongoDB, NodeJS és kliensoldali JS kód segítségével egy nyelvvel megoldható a teljes stack &lt;br /&gt;2, rendkívül poén ágyban fekve pötyögni vim-be, azonnal visszatesztelni brózerrefresh-sel (ezt írtad Te is a pythonhoz, abszolút fun)... Java-s IDE-t indítani itthon már kevés a lelkierőm&lt;br /&gt;3, lehet kapni kis funkcionális programozás szájízt, ha épp arra van kedv, pl. underscore.js segítségével</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/576527831822079744'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/576527831822079744'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html?showComment=1308088885731#c576527831822079744' title=''/><author><name>jbuzi</name><uri>http://jbuzi.blogspot.com</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3752345250697097633' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3752345250697097633' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-866783739'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 15. 0:01'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4029833159539573744</id><published>2011-06-16T22:51:02.962+02:00</published><updated>2011-06-16T22:51:02.962+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Én is nem rég kezdtem Python -ozni. A PyDev nevű E...</title><content type='html'>Én is nem rég kezdtem Python -ozni. A PyDev nevű Eclipse plugin -t használom, így az IDE is ismerős (elég sok shortcut ugyanaz, mint a JDT -ben).&lt;br /&gt;Viszont a Java után a duck typing marha idegesítő: felcseréltem két ősosztály konstruktor paramétert és csak futási időben szólt be, aztán mehettem debugolni (a kódot nézve nem tűnt fel...).&lt;br /&gt;Ennek ellenére elég jól kitalált nyelv, bash és bat szkript után milliószor értelmesebb.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/4029833159539573744'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/4029833159539573744'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html?showComment=1308257462962#c4029833159539573744' title=''/><author><name>Gyuri</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3752345250697097633' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3752345250697097633' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-133158315'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 16. 22:51'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5654553373866029524</id><published>2011-06-18T16:52:28.906+02:00</published><updated>2011-06-18T16:52:28.906+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nekem az a bajom a Pythonnal, hogy régi, és nem a ...</title><content type='html'>Nekem az a bajom a Pythonnal, hogy régi, és nem a nyelv, hanem a környezet, és a megoldások csomó olyan dolgot hurcolnak magukkal, amiket azóta másként, -- és ahogy az idő megmutatta -- jobban oldunk meg.&lt;br /&gt;&lt;br /&gt;Python környezetben (tehát nem a nyelvben) nagyon nem értem, hogy miért kell egy virtualenv kialakítása, miért kell az egész interpretert átmásolni (symlinkeket csinálni), ahhoz, hogy olyan környezetet hozzak léátre, ami nem interferál a többi, ugyanazon a gépen telepített Python alkalmazással. Java-ban ezt egyszerűen megoldottuk:&lt;br /&gt;&lt;br /&gt;Van a JRE, vagy a JDK, ahova a JAVA_HOME mutat, meg azt a java-t indítottuk el, és a CLASSPATH-ban benne van, hogy a classloader honnan vegye. Ha akarok, akár classloader-t is írhatok, ha Vicián István meg nem tiltja, minthogy az már keretrendszernek számít.&lt;br /&gt;&lt;br /&gt;Pythonban is van PYTHONPATH, de miért nem azt használja a Pythonos közösség? Persze én használhatom, de akkor az nem lesz Python like, és nem illeszkedik az elterjedt konvenciókba. Nem fog működni az easy_install, meg még nem tudom, hogy mi.&lt;br /&gt;&lt;br /&gt;A virtualenv.py pedig 64bites windows-on elhasalt.&lt;br /&gt;&lt;br /&gt;Ebből azt érzem, hogy nincs mögötte akkora támogatás, mint a Java mögött. Amatőrebb, bizonyos értelemben.&lt;br /&gt;&lt;br /&gt;Az sem tetszik, hogy a string az nem unicode, hanem byte tömb. (Na ez pl. az egyik nem kompatibilis változás a Python 3-ben, mert ott már unicode a string.)&lt;br /&gt;&lt;br /&gt;Régen, még 2000 előtt pythonoztam keveset, de nekem először assembly, C, Perl, BASIC, PASCAL, FORTRAN (nem ebben a sorrendben voltak), és csak ezt követően jött a Java. Így nekem azokra a feladatokra, amikre Isván elkezdte használni a Pythont inkább a Perl volt ott. Viszont most szembe jött a feladat, egy Python/Pylons/SQLAlchemy trióval.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/5654553373866029524'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/5654553373866029524'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html?showComment=1308408748906#c5654553373866029524' title=''/><author><name>Verhás Péter</name><uri>http://www.blogger.com/profile/06377161363854132582</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3752345250697097633' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3752345250697097633' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-377703703'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 18. 16:52'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2017272059860236366</id><published>2011-06-18T17:39:44.306+02:00</published><updated>2011-06-18T17:39:44.306+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Ami nem tetszik a Python-ban, az a GC elégtelenség...</title><content type='html'>Ami nem tetszik a Python-ban, az a GC elégtelensége (egy jó leírás erről példával: http://www.kylev.com/2009/11/03/finding-my-first-python-reference-cycle/)&lt;br /&gt;&lt;br /&gt;(amúgy nagyon nem kiabálhatok, mert pontosan ezt az algoritmust implementáltam egy saját interpreteremben 1997-től kezdve)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/2017272059860236366'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/2017272059860236366'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html?showComment=1308411584306#c2017272059860236366' title=''/><author><name>Verhás Péter</name><uri>http://www.blogger.com/profile/06377161363854132582</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3752345250697097633' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3752345250697097633' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-377703703'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 18. 17:39'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5150835950346938466</id><published>2011-06-18T17:40:17.798+02:00</published><updated>2011-06-18T17:40:17.798+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>És mi a helyzet a Groovy-val?</title><content type='html'>És mi a helyzet a Groovy-val?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/5150835950346938466'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/5150835950346938466'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html?showComment=1308411617798#c5150835950346938466' title=''/><author><name>Verhás Péter</name><uri>http://www.blogger.com/profile/06377161363854132582</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3752345250697097633' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3752345250697097633' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-377703703'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 18. 17:40'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4519308676951024092</id><published>2011-06-20T09:08:14.843+02:00</published><updated>2011-06-20T09:08:14.843+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>&amp;quot;És mi a helyzet a Groovy-val?&amp;quot; Szerinte...</title><content type='html'>&amp;quot;És mi a helyzet a Groovy-val?&amp;quot; Szerintem Java mellett második nyelvnek nem pont a Groovyt érdemes választani. Szerintem ha az ember körbe akar nézni, akkor ne csak a dobozon belül forgassa a fejét, nyissa ki az ajtót.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/4519308676951024092'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/4519308676951024092'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html?showComment=1308553694843#c4519308676951024092' title=''/><author><name>Kovács Richárd</name><uri>http://www.blogger.com/profile/06849753526791080950</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://3.bp.blogspot.com/_iwfk5KPTXzU/S2vH-RR0JyI/AAAAAAAAABc/aGduniprSBw/S220/profile.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3752345250697097633' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3752345250697097633' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-196939700'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 20. 9:08'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8751824533159060149</id><published>2011-06-20T23:29:04.635+02:00</published><updated>2011-06-20T23:29:04.635+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Ha ki akarsz kerülni a dobozból, akkor a Scala sem...</title><content type='html'>Ha ki akarsz kerülni a dobozból, akkor a Scala sem jön szóba.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/8751824533159060149'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/8751824533159060149'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html?showComment=1308605344635#c8751824533159060149' title=''/><author><name>Verhás Péter</name><uri>http://www.blogger.com/profile/06377161363854132582</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3752345250697097633' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3752345250697097633' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-377703703'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 20. 23:29'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5035681396580680562</id><published>2011-06-25T17:58:04.981+02:00</published><updated>2011-06-25T17:58:04.981+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Jómagam a PHP, JavaScript, (PL/)SQL, VB/C#.NET út ...</title><content type='html'>Jómagam a PHP, JavaScript, (PL/)SQL, VB/C#.NET út után kezdtem el alternatívákat keresni. Próbálkoztam Scalaval, ami remek volt, viszont akkor még (egy-másfél éve) az eszköztámogatás pocsék volt, s még erős gépen is szörnyű lassú volt a fordítás, így végül otthagytam. Viszont hatással volt arra, hogy programozom C#-ban, s ennek örülök :). Jelenleg én is a Pythonnál kötöttem ki:  többplatformú (IronPython .NET-re) és párom netbookján is villámgyorsan fut.&lt;br /&gt;&lt;br /&gt;Legnagyobb fájdalmam a 3.x backward incompatibility. Jó, hogy van 2to3, de az egész 3.0 élmény döcögős, még sok népszerű library nem támogatja (pl.: BeautifulSoup).&lt;br /&gt;&lt;br /&gt;A virtualenv egyébként nekem pont pozitív élményem, még ha értem is Verhás kolléga fenntartásait (mondjuk CLASSPATH-ot debugolni nem szeretek!) Én szeretem a lokális, bináris függőség tárolást (pl. a Microsoft is ebbe az irányba megy fejlesztéshez (NuGet), pedig a GAC pont a verzióproblémák megoldására lett kitalálva). Ha csak egy setup.bat/sh kell a verziókezelőbe, s utána nem akadnak össze a különböző  projektek különböző verziójú függőségei, már boldog vagyok. A virtualenv-el ezt meg tudtam oldani :)&lt;br /&gt;&lt;br /&gt;Az is nagy élmény volt, hogy a nemrég talált distutil problémát helyben tudtam javítani pár perc alatt (meg persze nyitottam egy bugot is https://bitbucket.org/tarek/distribute/issue/212/reading-bytes-instead-of-string-from :), s tudtam tovább haladni.&lt;br /&gt;&lt;br /&gt;A 64 bites problémák sajnos számos más platformra is igazak. Ez persze nem felmentés/magyarázkodás, inkább csak a döbbenet, hogy miért-is-nem-működnek-már-ezek jellegű tehetetlen karszéttárás. A http://ndc2011.no videók között van egy Richard Campbell-el a skálázásról, ahol is az a tanácsa, hogy 64 bites windows, de 32bites assemblyt használjanak, mert valamiért úgysem fog működni az AnyPlatform/x64)... Javaban annyire nem vagyok járatos, ott a 64 bit már megoldott probléma (driverek, stb)?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/5035681396580680562'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/5035681396580680562'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html?showComment=1309017484981#c5035681396580680562' title=''/><author><name>Zsoldos Peter</name><uri>http://zsoldosp.blogspot.com</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3752345250697097633' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3752345250697097633' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-160445616'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 25. 17:58'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1438234857404735713</id><published>2011-06-27T14:23:53.006+02:00</published><updated>2011-06-27T14:23:53.006+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nálam PHP volt a fő csapásirány, de mellette volt ...</title><content type='html'>Nálam PHP volt a fő csapásirány, de mellette volt PL/SQL, Transact SQL, Perl, Javascript, kis .Net&lt;br /&gt;&lt;br /&gt;Most java a fő irány. &lt;br /&gt;Az a PHP után tetszik a javaban, hogy sokkal jobban kikényszeríti az OOP használatát, ezért nagyobb alkalmazások esetén sokkal jobban &amp;quot;kénytelen&amp;quot; vagy jobb szerkezetű alkalmazást írni. Php esetén ehhez több önfegyelem kell. Ezzel együtt php-ban nagyon gyorsan lehet valami működőt létrehozni. Ameddig az embernek a php-n kívül nincs másra rálátása, addig nem zavarja nagyon a php nevezéktana és a névterek kezelése. Viszont Javaból visszanézve ezek már igen zavaróak.&lt;br /&gt;&lt;br /&gt;A korábbi hozzászólásokhoz még annyit hozzátennék, hogy bár a webes alkalmazások esetén elvileg kb. mindent meg lehet csinálni phpben és javaban is, mégis a felhasználás körében csak részben van átfedésben. Üzleti környezetben (legalábbis nálunk) meglátásom szerint .net és java dominál, a kevesebb üzleti logikát tartalmazó inkább webes fejlesztésekben a php dominál. Komolyabb üzleti rendszerek futtatásakor  nem releváns szempont, hogy van sok tárhelyszolgáltató, ami támogatja.&lt;br /&gt;&lt;br /&gt;Mostanában kicsit több időm volt, hogy körbenézzek mindenféle nyelvek, technológiák között. Az én választások a CouchDB-re esett és a  Ruby on Railsre (és ezzel együtt persze a rubyra is). CouchDB érdekes volt, de azokban a problémakörökben, ahol mozgok, nem tudnám használni, ezért végül hagytam. A RoR környezet ezzel szemben sok szépet és érdekeset mutatott. Ezeket sem biztos, hogy tudom napi szintű munkában használni, de sok olyan megoldást láttam, amiből tanulni lehet, mégha megmaradok továbbra is php/java vonalon.&lt;br /&gt;Az utóbbi idők másik érdekes felismerése volt számomra, hogy végignézve a mostani legdivatosabb web2-es szolgáltatások, amik nem régen (&amp;lt;5év) indultak, a felhasznált nyelvek, eszközök teljesen megváltoztak. Korábban ezeket jellemzően valamilyen php-mysql kombó segítségével követték el, de az újabb esetekben sokkal inkább rubyt, pythont használnak sok esetben valamilyen nosql megoldással kiegészítve. Web2-es szolgálatások esetén java, .net (itt egy érdekes kivétel a stackexchange.com) továbbra sem nagyon tört előre.&lt;br /&gt;&lt;br /&gt;Az eredeti felvetés az volt, hogy ki milyen nyelvet tanult meg kedvtelésből. A választásban ezzel együtt mégis szempont lehet, hogy a megtanult technológiát hogyan lehet a napi munkában is kamatoztatni.&lt;br /&gt;Ezzel kapcsolatban kérdezném azokat, akik pythont, rubyt jelöltek meg iránynak, hogy magyar viszonylatban mennyire látják ezeket eladható tudásnak, illetve jellemzően milyen jellegű projekteket szoktak ezeken a nyelveken megvalósítani (egyedi szoftver, termék, szolgáltatás, stb.)?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/1438234857404735713'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/1438234857404735713'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html?showComment=1309177433006#c1438234857404735713' title=''/><author><name>Hubidubi</name><uri>http://www.blogger.com/profile/17752083420533796569</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3752345250697097633' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3752345250697097633' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1322454888'/><gd:extendedProperty name='blogger.displayTime' value='2011. június 27. 14:23'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5695411702918540635</id><published>2011-07-03T00:10:27.433+02:00</published><updated>2011-07-03T00:10:27.433+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Volt szerencsém az elmúlt egy 1.5 év első felében ...</title><content type='html'>Volt szerencsém az elmúlt egy 1.5 év első felében GWT-zni, majd swingezni. Minden szavaaddal egyet tudok érteni.&lt;br /&gt;GWT után a swing maga a paradicsom, sőt, általában véve a vastag klienses fejlesztés.&lt;br /&gt;Az a macera, amit egy GWT buildnél végig kellett csinálni, hogy néha a GWT-s kód nem ugyanúgy megy minden  böngészőn, hogy mire elindul valami, hogy a debug néha milyen macerás...&lt;br /&gt;Viszont amit látok, hogy mindenki számára a webes megoldás ma kizárólag a böngésző alapú megoldást jelenti - és ez a felfogás szerintem káros. A vastag kliens is tud annyit, sőt, sokkal többet, mint egy böngésző alapú - és ehhez nem kell sok kompromisszum.&lt;br /&gt;&lt;br /&gt;A cikk amúgy nagyon jó, élvezetes, jöhet ilyen gyakran :)&lt;br /&gt;&lt;br /&gt;+1 kérdés: menedzsmentet hogyan lehetett meggyőzni, hogy ne böngészőben fusson?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/5695411702918540635'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/5695411702918540635'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html?showComment=1309644627433#c5695411702918540635' title=''/><author><name>szilsan</name><uri>http://www.blogger.com/profile/09601377815329289487</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-535551803739667071' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/535551803739667071' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1109829282'/><gd:extendedProperty name='blogger.displayTime' value='2011. július 3. 0:10'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-380189269746422579</id><published>2011-07-03T07:41:24.949+02:00</published><updated>2011-07-03T07:41:24.949+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A cikkel személy szerint teljesen egyetértek (kösz...</title><content type='html'>A cikkel személy szerint teljesen egyetértek (köszi). A Netbeans sok tekintetben felűlmúlja az Eclipset, és sok &amp;quot;felesleges&amp;quot; konfigurációt levesz a fejlesztő válláról.&lt;br /&gt;A vékony-kliensekkel az a legnagyobb probléma, hogy a legkissebb alkalmazás fejlesztésénél már számolni kell a környezet sajátosságaival, mint pl session kezelés, különböző böngésző verziók, etc, amik sokszor feleslegesen megbonyolítják a dolgokat. A különböző rétegek nagyon eltérően működnek, és (tényleg, ahogy írtad) egy rakás elméleti alapismeret szükséges ahhoz, hogy egyetlen mezőt kitegyél az oldalra, majd azt validáld Js-el, zután elküldd a szervernek, ahol szintén validálódik, végül a hiba esetén gondoskodni kell a hiba megjelenítéséről, és az eredeti adatok visszaírásáról (tudom léteznek keretrendszerek, de azzal egy újabb réteget kell behozni, tovább bonyolítva az alkalmazást)  stb. Ugyanez a dolog vastag kliens esetén egy zárt rendszerben működik, ami egy csomó biztonsági kérdés is megold eleve. Vékony klienst ott érdemes használni, ahol a kliensek annyira eltérőek, hogy egy egységes vastag-kliensréteg nem elképzelhető, vagy az információk publikusak, és szükséges egy minden gépen elérhető megoldás. Minden más esetben sokkal fájdalommentesebb a vastag kliens.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/380189269746422579'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/380189269746422579'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html?showComment=1309671684949#c380189269746422579' title=''/><author><name>Kovács Richárd</name><uri>http://www.blogger.com/profile/06849753526791080950</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://3.bp.blogspot.com/_iwfk5KPTXzU/S2vH-RR0JyI/AAAAAAAAABc/aGduniprSBw/S220/profile.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-535551803739667071' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/535551803739667071' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-196939700'/><gd:extendedProperty name='blogger.displayTime' value='2011. július 3. 7:41'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6213352713104728715</id><published>2011-07-03T07:43:57.433+02:00</published><updated>2011-07-03T07:43:57.433+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Egy dolog lemaradt. Nekem személy szerint nagy ked...</title><content type='html'>Egy dolog lemaradt. Nekem személy szerint nagy kedvencem a Vaadin keretrendszer, mely pont azt a szakadékot kívánja áthidalni, ami a vékon és vastag kliens-fejlesztés között tátong.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/6213352713104728715'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/6213352713104728715'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html?showComment=1309671837433#c6213352713104728715' title=''/><author><name>Kovács Richárd</name><uri>http://www.blogger.com/profile/06849753526791080950</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://3.bp.blogspot.com/_iwfk5KPTXzU/S2vH-RR0JyI/AAAAAAAAABc/aGduniprSBw/S220/profile.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-535551803739667071' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/535551803739667071' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-196939700'/><gd:extendedProperty name='blogger.displayTime' value='2011. július 3. 7:43'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3077457615683545360</id><published>2011-07-03T08:31:34.159+02:00</published><updated>2011-07-03T08:31:34.159+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>ha már provokáció, te használtál már rendes éles p...</title><content type='html'>ha már provokáció, te használtál már rendes éles projecten Eclipse RCP-t vagy csak beszélünk róla? :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/3077457615683545360'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/3077457615683545360'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html?showComment=1309674694159#c3077457615683545360' title=''/><author><name>Kristof Jozsa</name><uri>http://www.blogger.com/profile/06607669172500255805</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-535551803739667071' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/535551803739667071' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-686590949'/><gd:extendedProperty name='blogger.displayTime' value='2011. július 3. 8:31'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7486691591717302020</id><published>2011-07-03T13:32:55.780+02:00</published><updated>2011-07-03T13:32:55.780+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszönöm a hozzászólásokat, két dolog tényleg lema...</title><content type='html'>Köszönöm a hozzászólásokat, két dolog tényleg lemaradt. Egyrészt az, hogy a biztonsági problémák megoldása is egyszerűbb lehet, másrészt lehet a plugint már futó NetBeans-be telepíteni, így még jobban felgyorsul a fejlesztési folyamat.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/7486691591717302020'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/7486691591717302020'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html?showComment=1309692775780#c7486691591717302020' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-535551803739667071' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/535551803739667071' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. július 3. 13:32'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4478958544209084284</id><published>2011-07-03T13:41:05.614+02:00</published><updated>2011-07-03T13:41:05.614+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>@Kristóf:
A projekt elején egy három hónapos pilot...</title><content type='html'>@Kristóf:&lt;br /&gt;A projekt elején egy három hónapos pilotban választhattunk technológiákat. Ez bőven elég volt a döntéshez. Ha ennyi idő alatt nem lehet egy eszközbe belerázódni, akkor az eleve felejtős. Van projekt, ami ennyi idő alatt le is fut (vagy bedöglik :). Szerencsére abban a helyzetben voltunk, hogy amit választottunk és számunkra jobbnak ítéltük, azt használhattuk.&lt;br /&gt;&lt;br /&gt;Amúgy a post pont arról szólt, hogy nincs abszolút nyertes technológiák között, általában nem lehet kimondani azt, hogy az egyik jobb, vagy a másik.&lt;br /&gt;&lt;br /&gt;Azt lehet kimondani, hogy a projekt szempontjából az egyik jobb választás, mert egyrészt 2004 óta fejlesztünk egy Swing-es alkalmazást és rengeteg tapasztalat gyűlt már össze, másrészt több kollégám is szívott már OSGi-val, és nem rajongtak az ötletért, valamint a Matisse ingyenes grafikus szerkesztőt előszeretettel használjuk, és nem találtunk megfelelő alternatívát. Ezen körülmények miatt badarság lett volna mást válaztani. Csak akkor, ha nem a projekt, hanem a személyes érdeklődés lett volna erősebb.&lt;br /&gt;&lt;br /&gt;Persze más projektnek mások a körülményei, így máshol az Eclipse lehet a célravezetőbb. Pl. ahol OSGi expert-ek vannak, és szeretik is csinálni, vagy sem a Swing-et, sem az SWT-t nem ismerik.&lt;br /&gt;&lt;br /&gt;A baj, hogy úgy formál mindenki véleményt, hogy nem ismeri a körülményeket, nem érdekli a projekt, csak a saját rajongása tárgyát.&lt;br /&gt;&lt;br /&gt;Persze érted te ezt, csak hergelsz.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/4478958544209084284'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/4478958544209084284'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html?showComment=1309693265614#c4478958544209084284' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-535551803739667071' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/535551803739667071' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. július 3. 13:41'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3807647958423445267</id><published>2011-07-03T13:53:06.330+02:00</published><updated>2011-07-03T13:53:06.330+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>najó elröhögtem a végét :) 

a cikkel, a választás...</title><content type='html'>najó elröhögtem a végét :) &lt;br /&gt;&lt;br /&gt;a cikkel, a választással és a végkövetkeztetéssel egyetértek, pár apróság sántított csak:&lt;br /&gt;- RCP fejlesztőként OSGI-vel alapvetően semmi dolgod nincs, a tooling mindent hibátlanul kezelt már 5 éve is, komplex esetekben is&lt;br /&gt;- az h Rod &amp;#39;tegnap&amp;#39; beismerte h az egységsugarú gyalogos JEE fejlesztő célközönségüknek meredek az OSGI az igaz, csak nincs köze a témához&lt;br /&gt;- az új eclipseben van gui builder (bár én se néztem még)&lt;br /&gt;- a swing külsőre még most se keverhető össze egy natív alkalmazással és nem is látok rá esélyt hogy ez valaha megváltozzon [linuxon]&lt;br /&gt;&lt;br /&gt;egyébként meg a szokásos pontok állnak, ésszel döntsünk a problémából és a körülményekből kiindulva..</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/3807647958423445267'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/3807647958423445267'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html?showComment=1309693986330#c3807647958423445267' title=''/><author><name>Kristof Jozsa</name><uri>http://www.blogger.com/profile/06607669172500255805</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-535551803739667071' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/535551803739667071' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-686590949'/><gd:extendedProperty name='blogger.displayTime' value='2011. július 3. 13:53'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2676468919441052873</id><published>2011-07-03T14:29:31.983+02:00</published><updated>2011-07-03T14:29:31.983+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>@Kristóf:

Igen, teljesen igazad van az első kettő...</title><content type='html'>@Kristóf:&lt;br /&gt;&lt;br /&gt;Igen, teljesen igazad van az első kettőben, kicsit csúsztattam. :)&lt;br /&gt;A GUI builderhez annyit, hogy amikor a projekt elkezdődött, még sehol nem volt új Eclipse. Ennyire friss eszközökkel meg elvből nem dolgozunk, projektet pláne nem építünk rá.&lt;br /&gt;Az, hogy nem hasonlít a natív alkalmazáshoz, tökéletesen igaz, de engem nem is zavar.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/2676468919441052873'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/2676468919441052873'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html?showComment=1309696171983#c2676468919441052873' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-535551803739667071' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/535551803739667071' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. július 3. 14:29'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1039581340405674884</id><published>2011-07-03T18:58:36.574+02:00</published><updated>2011-07-03T18:58:36.574+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Megjelent egy könyv, The Architecture of Open Sour...</title><content type='html'>Megjelent egy könyv, The Architecture of Open Source Applications címmel, és el is olvasható a http://www.aosabook.org/en/index.html címen. Ez a könyv 25 nyílt forráskódú projekt architektúráját mutatja be, köztük az Eclipse-ét is, érdemes elolvasni.&lt;br /&gt;&lt;br /&gt;Szól az Eclipse 4-ről is, ahol az újdonságok közül megemlíti a modell alapú GUI-t, a CSS-sel történő design-t, valamint a JSR 330 alapú dependency injection-t. Természetesen visszafele kompatibilis.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/1039581340405674884'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/1039581340405674884'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html?showComment=1309712316574#c1039581340405674884' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-535551803739667071' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/535551803739667071' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. július 3. 18:58'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2972674178424277973</id><published>2011-07-04T01:11:16.218+02:00</published><updated>2011-07-04T01:12:14.346+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'></title><content type='html'>Ezt a megjegyzést eltávolította a szerző.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/2972674178424277973'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/2972674178424277973'/><author><name>]-[appy</name><uri>http://www.blogger.com/profile/08200110534596245590</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-535551803739667071' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/535551803739667071' type='text/html'/><gd:extendedProperty name='blogger.contentRemoved' value='true'/><gd:extendedProperty name='blogger.itemClass' value='pid-1096147672'/><gd:extendedProperty name='blogger.displayTime' value='2011. július 4. 1:11'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7708670872990535638</id><published>2011-07-04T01:15:14.171+02:00</published><updated>2011-07-04T01:15:14.171+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Jo volt olvasni ezt a cikket. Mar jopar projektet ...</title><content type='html'>Jo volt olvasni ezt a cikket. Mar jopar projektet csinaltam vegig eclipse rcp alapon (es sosem bantam meg). &lt;br /&gt;Viszont az irasod, most meghozta a kedvem ahhoz, hogy egy projekten mindenkepp kirpobaljam majd a netbeans platformjat.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/7708670872990535638'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/7708670872990535638'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html?showComment=1309734914171#c7708670872990535638' title=''/><author><name>Ferenc Boldog</name><uri>http://www.blogger.com/profile/08200110534596245590</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-535551803739667071' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/535551803739667071' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1096147672'/><gd:extendedProperty name='blogger.displayTime' value='2011. július 4. 1:15'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3009955427941464472</id><published>2011-07-04T09:53:07.163+02:00</published><updated>2011-07-04T09:53:07.163+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Hola!
Először gy helyesbítés az április 1. témával...</title><content type='html'>Hola!&lt;br /&gt;Először gy helyesbítés az április 1. témával kapcsolatban. Ez a dolog Roman Strobl blogján merült fel a Netbeans-szel kapcsolatban. Persze ez nem zárja ki hogy Eclipse-re is van ilyen hoax. Íme a releváns post:&lt;br /&gt;&lt;br /&gt;http://blogs.oracle.com/roumen/entry/netbeans_7_0_plans_uncovered&lt;br /&gt;&lt;br /&gt;Engem egyébként az érdekelne, hogy -bár olvastam hogy ez a két vastagkliens versenyző van- nincs-e véletlenül valami harmadik, pehelysúlyúbb versenyző. Nekünk szoktak lenni 1-2 emberhónap bonyolultságú 2-3 funkciós vastagkliens projektjeink, amihez az Eclipse meg a Netbeans is overkill lenne, viszont ezen projektek során önkéntelenül is elkezdett kialakulni egy saját kis &amp;quot;rich client keretrendszer&amp;quot;, ami nem szerencsés.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/3009955427941464472'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/3009955427941464472'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html?showComment=1309765987163#c3009955427941464472' title=''/><author><name>tvik</name><uri>http://kodzaj.blog.hu</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-535551803739667071' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/535551803739667071' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2144484515'/><gd:extendedProperty name='blogger.displayTime' value='2011. július 4. 9:53'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7317036058024734063</id><published>2011-07-04T10:38:21.651+02:00</published><updated>2011-07-04T10:38:21.651+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nagyszerű, jól átgondolt bejegyzés megint. Ahogy h...</title><content type='html'>Nagyszerű, jól átgondolt bejegyzés megint. Ahogy haladtam az olvasásban, mindig felmerült egy kérdés, amit a köv. bekezdés megválaszolt :)&lt;br /&gt;&lt;br /&gt;Sok sikert az NB platformmal. Van némi tapasztalatom a Netbeans Visual Library-vel (gondolom ezt akarjátok használni a fenti cucchoz) és úgy kb. az a véleményem róla, hogy egy nagyon egyszerűen kezelhető cucc, amíg azt csinálod vele, amit a fejlesztők kitaláltak, de amint olyasmit szeretnél, amire nem gondoltak, akkor belefutsz a private/final metódusokba, amit át kéne írnod, de nem lehet.. Remélem, nektek nem lesz ilyen :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/7317036058024734063'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/7317036058024734063'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html?showComment=1309768701651#c7317036058024734063' title=''/><author><name>Moonson</name><uri>http://www.blogger.com/profile/08311596722917196822</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-535551803739667071' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/535551803739667071' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-61216384'/><gd:extendedProperty name='blogger.displayTime' value='2011. július 4. 10:38'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1325502794324943300</id><published>2011-07-05T12:25:00.239+02:00</published><updated>2011-07-05T12:25:00.239+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>@tvik:
Az Eclipse már el is indította a projektet:...</title><content type='html'>@tvik:&lt;br /&gt;Az Eclipse már el is indította a projektet: http://eclipse.org/rap/. Komolyan gondolják: http://wiki.eclipse.org/E4, http://wiki.eclipse.org/E4/Web-based_IDE&lt;br /&gt;&lt;br /&gt;Sajnos én még nem próbáltam pehelysúlyú Swing keretrendszert.&lt;br /&gt;&lt;br /&gt;@Moonson&lt;br /&gt;Igen, Visual Library API. Sajnos pl. egy Maven bug-ba már belefutottam a NetBeans Platform-mal kapcsolatban, ami miatt nem tudtunk továbbmenni, így patch-elttel futunk. Submit-oltam a megoldással együtt, benne lesz a következő release-ben. Bízom benne, hogy nem lesz szükség rá, de a Visual Library API-nál is ez egy kerülőút. Éljen a nyílt forrás.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/1325502794324943300'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/1325502794324943300'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html?showComment=1309861500239#c1325502794324943300' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-535551803739667071' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/535551803739667071' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. július 5. 12:25'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7975379064777332730</id><published>2011-07-06T10:21:10.928+02:00</published><updated>2011-07-06T10:21:10.928+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>En Javaban elsosorban vastagklienseket irok, vagyi...</title><content type='html'>En Javaban elsosorban vastagklienseket irok, vagyis inkabb desktop alkalmazasokat (mind a logika, mind a megjelenites egy alkalmazason belul van). &lt;br /&gt;Sokan kritizaljak a Swing-et, hogy nem epul be elegge. Ez igaz, am altalaban ez nem is cel, a felhasznalo nem azert nem fog egy alkalmazasra rabolintani, mert &amp;quot;az a gomb harom pixellel, erted harom pixellel keskenyebb, mint egy nativ alkalmazasban!&amp;quot;. Vagy mert nem olyan szinu.&lt;br /&gt;Az &amp;quot;elegge hasonlit&amp;quot; kategoria bosegesen eleg a legtobb alkalmazashoz, ahova meg nem, oda van mas keretrendszer is.&lt;br /&gt;&lt;br /&gt;+ Kerdes: A projekttol fuggetlenul mi a velemenyed a JSR 296-rol? Erdemes vele ismerkedni? Van egy mukodo, fejlesztett implementacio, ami egesz igeretesnek tunik...</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/7975379064777332730'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/7975379064777332730'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html?showComment=1309940470928#c7975379064777332730' title=''/><author><name>Gábor</name><uri>http://www.blogger.com/profile/16328831533238731170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-535551803739667071' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/535551803739667071' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2145961406'/><gd:extendedProperty name='blogger.displayTime' value='2011. július 6. 10:21'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7295720329311978417</id><published>2011-07-11T11:58:57.193+02:00</published><updated>2011-07-11T11:58:57.193+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Amikor arról beszélünk, hogy nem elég native a swi...</title><content type='html'>Amikor arról beszélünk, hogy nem elég native a swing, akkor a SystemLookAndFeel vagyis a native L&amp;amp;F már be van kapcsolva? Java 6u10 -től vagyis inkább Java 7-től Nimbus Look and Feel az már elég tetszetős lesz?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/7295720329311978417'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/7295720329311978417'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html?showComment=1310378337193#c7295720329311978417' title=''/><author><name>vi</name><uri>http://www.blogger.com/profile/04422179881036855160</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='22' src='http://4.bp.blogspot.com/-lLqa92wFTRI/TcKhlDEv-zI/AAAAAAAAAAM/Uz18XKmPw9Y/s1600/istvan.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-535551803739667071' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/535551803739667071' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2010359704'/><gd:extendedProperty name='blogger.displayTime' value='2011. július 11. 11:58'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5490627935351103732</id><published>2011-07-26T21:48:01.449+02:00</published><updated>2011-07-26T21:48:01.449+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Évek óta jsp, html, javascript , extjs ben nyomom ...</title><content type='html'>Évek óta jsp, html, javascript , extjs ben nyomom a fejlesztéseket. Teljesen egyetértek a cikk írójával agyrém ami böngésző oldalon van és egyre fokozódik.&lt;br /&gt;&lt;br /&gt;1, Más más op-rendszer alatt másként jelennek meg a betűtípusok a divek eltolódnak...&lt;br /&gt;2, Ehhez jön a javascript értelmező ami megint más és más böngészőnként amiből ha csak a 4 legnépszerűbbnél ellenőrizzük az aktuális és az előző verzióra az 8-teszt. &lt;br /&gt;3, Erre jönnek a javascript keretrendszerek amit noname  cégek hegesztgetnek a verziókompatibilitásra magasról tesznek.&lt;br /&gt;4, majd erre tolnak rá guikat lásd ExtJS ami szintén tesz a verziókompatibilitásra. &lt;br /&gt;Recseg ropog az egész rendszer. Garancia gyakorlatilag arra van hogy az első komolyabb böngészőszabvány váltásakor kártyavárként omlik össze az összes rendszer. &lt;br /&gt;&lt;br /&gt;Nem is kérdés, hogy a swing mérföldekkel jobb.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/5490627935351103732'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/535551803739667071/comments/default/5490627935351103732'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html?showComment=1311709681449#c5490627935351103732' title=''/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/07/vastag-kliens-java-ban-netbeans.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-535551803739667071' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/535551803739667071' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1680038587'/><gd:extendedProperty name='blogger.displayTime' value='2011. július 26. 21:48'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4794604643849805686</id><published>2011-07-29T14:12:44.706+02:00</published><updated>2011-08-09T17:05:50.536+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'></title><content type='html'>Ezt a megjegyzést eltávolította a szerző.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/4794604643849805686'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/4794604643849805686'/><author><name>Unknown</name><uri>http://www.blogger.com/profile/17954689286998223572</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.contentRemoved' value='true'/><gd:extendedProperty name='blogger.itemClass' value='pid-1520602535'/><gd:extendedProperty name='blogger.displayTime' value='2011. július 29. 14:12'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8442037346295521514</id><published>2011-08-04T11:15:12.802+02:00</published><updated>2011-08-04T11:15:12.802+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A cikk megjelent a Liferay Hungary falán: http://w...</title><content type='html'>A cikk megjelent a Liferay Hungary falán: http://www.facebook.com/LiferayHungary</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/8442037346295521514'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/8442037346295521514'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1312449312802#c8442037346295521514' title=''/><author><name>Lőr</name><uri>http://www.blogger.com/profile/00235722018090555974</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='24' height='32' src='http://1.bp.blogspot.com/_IXcD7q8LX_w/Ss24FxJ67KI/AAAAAAAAEWc/seuS6zyHtSE/S220/berlin.jpeg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1136132185'/><gd:extendedProperty name='blogger.displayTime' value='2011. augusztus 4. 11:15'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8920492036741831304</id><published>2011-08-04T12:58:06.031+02:00</published><updated>2011-08-04T12:58:06.031+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Jó írás.

Egy kis részét még értettem is.

Hol van...</title><content type='html'>Jó írás.&lt;br /&gt;&lt;br /&gt;Egy kis részét még értettem is.&lt;br /&gt;&lt;br /&gt;Hol vannak tutorialok-e témában, amik segítenek megérteni, mit is olvastam az előbb? :(</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4550403846114418343/comments/default/8920492036741831304'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4550403846114418343/comments/default/8920492036741831304'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/04/maven-kezdolepesek.html?showComment=1312455486031#c8920492036741831304' title=''/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/04/maven-kezdolepesek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4550403846114418343' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4550403846114418343' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-785386012'/><gd:extendedProperty name='blogger.displayTime' value='2011. augusztus 4. 12:58'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3924582760591994335</id><published>2011-08-04T13:05:49.006+02:00</published><updated>2011-08-04T13:05:49.006+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>@Névtelen:

A cikkb van rá hivatkozás, szerintem a...</title><content type='html'>@Névtelen:&lt;br /&gt;&lt;br /&gt;A cikkb van rá hivatkozás, szerintem a legjobb az ingyenesen letölthető Sonatype könyv, a Maven by Example, és letölthető a következő címről: http://www.sonatype.com/index.php/Support/Books/Maven-By-Example&lt;br /&gt;&lt;br /&gt;Magyar forrásról nem tudok.&lt;br /&gt;&lt;br /&gt;Hogy hogyan használd NetBeans-ből, arra itt egy cikk:&lt;br /&gt;&lt;br /&gt;http://wiki.netbeans.org/MavenBestPractices</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4550403846114418343/comments/default/3924582760591994335'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4550403846114418343/comments/default/3924582760591994335'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/04/maven-kezdolepesek.html?showComment=1312455949006#c3924582760591994335' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/04/maven-kezdolepesek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4550403846114418343' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4550403846114418343' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. augusztus 4. 13:05'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1290727736014586866</id><published>2011-08-08T09:57:59.026+02:00</published><updated>2011-08-08T09:57:59.026+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A cikk címe lehetne: Egy nap a magenta T-nél :) Na...</title><content type='html'>A cikk címe lehetne: Egy nap a magenta T-nél :) Nagyon jó anyag, köszi</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/1290727736014586866'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/1290727736014586866'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1312790279026#c1290727736014586866' title=''/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1653056472'/><gd:extendedProperty name='blogger.displayTime' value='2011. augusztus 8. 9:57'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5794985888938826127</id><published>2011-08-09T07:44:07.875+02:00</published><updated>2011-08-09T07:44:07.875+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>nyilván helyzet, de főleg eszközfüggő. gittel vidá...</title><content type='html'>nyilván helyzet, de főleg eszközfüggő. gittel vidáman feature brancheltünk, a sprintre sikerült storykat stasholva a mainlineba, hgvel általában version branchelek + lokálisan több repom van a featurek fejlesztéséhez mert ott nem dobálja el úgy az ember a shared brancheket. &lt;br /&gt;&lt;br /&gt;svn-nel nem branchelek mert hirtelen nem jut eszembe hülyébb sport mint ez, TFS-sel meg két identikus filet sem tudok automatikusan összmergelni úgyhogy remélem senkinek nem fog eszébejutni h ránkerőltesse.&lt;br /&gt;&lt;br /&gt;ps. Fowler mint mindenki pápája amúgyse a kedvencem de amit a téma kapcsán firkál az konkrétan hülyeség (osszatok érte, ez van :))</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5347349015396857015/comments/default/5794985888938826127'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5347349015396857015/comments/default/5794985888938826127'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/08/branch-eljunk-e-vagy-sem.html?showComment=1312868647875#c5794985888938826127' title=''/><author><name>Kristof Jozsa</name><uri>http://www.blogger.com/profile/06607669172500255805</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/08/branch-eljunk-e-vagy-sem.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-5347349015396857015' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/5347349015396857015' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-686590949'/><gd:extendedProperty name='blogger.displayTime' value='2011. augusztus 9. 7:44'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8730117417800433851</id><published>2011-08-09T09:14:37.034+02:00</published><updated>2011-08-09T09:14:37.034+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Az, hogy egy eszköz határozza meg a fejlesztési mu...</title><content type='html'>Az, hogy egy eszköz határozza meg a fejlesztési munkafolyamatot, nekem egy kicsit erős addig, amíg választási lehetőséged van.&lt;br /&gt;&lt;br /&gt;Pont arra szerettem volna utalni, hogy előbb vizsgáld meg a projektet, az embereket, az ügyfelet, és utána válassz eszköz.&lt;br /&gt;&lt;br /&gt;Sajnos több helyen láttam divatból git-et bevezetni, és emiatt állni egy darabig a fejlesztést. Persze ahol a fejlesztők nyitottak, esetleg már rendelkeznek a tudással, akkor nem probléma.&lt;br /&gt;&lt;br /&gt;Láttam olyan helyen is bevezetni, ahol valami egyéb dolgot próbáltak vele elfedni. A rendszer architektúrálisan volt rossz, ezért állandóan branch-elni és merge-ölni kellett, és a git-től várták a megoldást. Nyilván a rendszert kellett volna rendbe tenni.&lt;br /&gt;&lt;br /&gt;Fowlernek az érvei nem rosszak, csupán a végkövetkeztetése. :) Nem rossz tudni a feature/release branch előnyeit, hátrányait, de ezek nem feltétlen fájóak, és nem feltétlenül a CI a megoldás.&lt;br /&gt;&lt;br /&gt;Ismétlem, mi boldogan CI-zünk, kb. egy branch-ünk volt egyszer, és nem azért, mert SVN-ünk van, hanem azért, mert ilyen a projekt.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5347349015396857015/comments/default/8730117417800433851'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5347349015396857015/comments/default/8730117417800433851'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/08/branch-eljunk-e-vagy-sem.html?showComment=1312874077034#c8730117417800433851' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/08/branch-eljunk-e-vagy-sem.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-5347349015396857015' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/5347349015396857015' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. augusztus 9. 9:14'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3904467622384429574</id><published>2011-08-09T10:02:31.091+02:00</published><updated>2011-08-09T10:02:31.091+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szerencsére igen ritkán kell branchelnem, mert tol...</title><content type='html'>Szerencsére igen ritkán kell branchelnem, mert tolerálja a projekt a ki-be kapcsolható funkciókat.&lt;br /&gt;&lt;br /&gt;Volt olyan munkatárs aki minduntalan elvonult az elefántcsonttornyába a feature branch-ével hetekre, aztán két napig mergelt, nekünk meg addig hátra tett kézzel kellett ülnünk a gép előtt. Szerettem.&lt;br /&gt;&lt;br /&gt;A CI-s részben talán félreértek valamit. Ha bármi (megrendelő, platform, verzió) miatt kód szinten szét van ágaztatva a projekt külön release-ekre, ott minden ágat külön le kell integrációs tesztelni. Nem mondhatom hogy az 1.1 verziót nem tesztelem csak a 2.0-t, mert a CI elvei szerint ez így szép.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5347349015396857015/comments/default/3904467622384429574'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5347349015396857015/comments/default/3904467622384429574'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/08/branch-eljunk-e-vagy-sem.html?showComment=1312876951091#c3904467622384429574' title=''/><author><name>tvk</name><uri>http://kodzaj.blog.hu</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/08/branch-eljunk-e-vagy-sem.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-5347349015396857015' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/5347349015396857015' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2123636453'/><gd:extendedProperty name='blogger.displayTime' value='2011. augusztus 9. 10:02'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5897540402329519716</id><published>2011-08-09T10:18:31.480+02:00</published><updated>2011-08-09T10:18:31.480+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A CI nem engedi a szétágazást.
Mindig a mainline t...</title><content type='html'>A CI nem engedi a szétágazást.&lt;br /&gt;Mindig a mainline tartalmazza az összes funkciót, akár platformonként, pláne megrendelőnként. Itt a modularizáció a kulcs. A specifikus moduloknak meg ugyanúgy egy mainline-ja lehet.&lt;br /&gt;Annyit enged maximum, hogy bug-fix branch-eket csinálj. Igen, arra tenni kell egy job-ot, ami build-el, unit és integrációs tesztel (bár ez utóbbinál jön be a staging).</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5347349015396857015/comments/default/5897540402329519716'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5347349015396857015/comments/default/5897540402329519716'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/08/branch-eljunk-e-vagy-sem.html?showComment=1312877911480#c5897540402329519716' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/08/branch-eljunk-e-vagy-sem.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-5347349015396857015' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/5347349015396857015' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. augusztus 9. 10:18'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7921928213515893592</id><published>2011-08-09T10:23:59.081+02:00</published><updated>2011-08-09T10:23:59.081+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>pedig a rendelkezésre álló és használható eszközök...</title><content type='html'>pedig a rendelkezésre álló és használható eszközök felülről határolják a használható munkafolyamatot. ha nálad nincsenek ilyen körülmények akkor szerencsés helyen vagy, én mindenfelé ezt tapasztalom.&lt;br /&gt;&lt;br /&gt;a git nem a végső válasz, én pl a hg-t jobban szeretem (használni is és bevezetni is), csak röviden összeszedtem h milyen tapasztalatok voltak az elmúlt 10+ évben :)&lt;br /&gt;&lt;br /&gt;ami nekem fáj a version control témában h az svn fanok olyan értően nyilatkoznak a témáról mintha nem lennének legalább 5 évvel elmaradva szemléletmódban és az általuk használt eszköz korlátaiból (merge pl) vonnak le általános következtetéseket - és itt ismét ott tartunk h az eszköz felülről korlátol.. :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5347349015396857015/comments/default/7921928213515893592'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5347349015396857015/comments/default/7921928213515893592'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/08/branch-eljunk-e-vagy-sem.html?showComment=1312878239081#c7921928213515893592' title=''/><author><name>Kristof Jozsa</name><uri>http://www.blogger.com/profile/06607669172500255805</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/08/branch-eljunk-e-vagy-sem.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-5347349015396857015' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/5347349015396857015' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-686590949'/><gd:extendedProperty name='blogger.displayTime' value='2011. augusztus 9. 10:23'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2960569108274800564</id><published>2011-08-09T10:35:15.622+02:00</published><updated>2011-08-09T10:35:15.622+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Én több helyen tapasztaltam azt, hogy a fejlesztők...</title><content type='html'>Én több helyen tapasztaltam azt, hogy a fejlesztők mindenféle eszközöket fogalom (, és fejlesztési módszertan) nélkül össze-vissza használnak, mint azt, hogy kötöttségük lenne. Persze az ellenkezőjére is volt példa, de kevesebb, és onnan menekültem. :)&lt;br /&gt;&lt;br /&gt;Az svn fanok többsége nem csak az svn-nél, hanem az svn egy bizonyos verziójánál ragadtak le, ami még rosszabb.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5347349015396857015/comments/default/2960569108274800564'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5347349015396857015/comments/default/2960569108274800564'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/08/branch-eljunk-e-vagy-sem.html?showComment=1312878915622#c2960569108274800564' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/08/branch-eljunk-e-vagy-sem.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-5347349015396857015' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/5347349015396857015' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. augusztus 9. 10:35'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-9031847498206659509</id><published>2011-08-16T16:04:40.763+02:00</published><updated>2011-08-16T16:04:40.763+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Egy kis adalék.

Azért azt Fowler is elismeri, hog...</title><content type='html'>Egy kis adalék.&lt;br /&gt;&lt;br /&gt;Azért azt Fowler is elismeri, hogy bizonyos esetekben a feature branchelés módszertanilag igenis szükséges és kihagyhatatlan. Pl. open source projektek esetén, ahol gyakorlatilag bárki commitálhat. Fowler agilis, egy légtérben szorosan együtt dolgozó kisméretű csapatok esetén nem javasolja a feature branchinget.&lt;br /&gt;&lt;br /&gt;És ez nem csak Fowler véleménye. Javaslom irodalomként mindenkinek a Continuous Deliveryt (http://www.amazon.com/Continuous-Delivery-Deployment-Automation-Addison-Wesley/dp/0321601912/ )&lt;br /&gt;&lt;br /&gt;Ez a cikk (http://continuousdelivery.com/2011/07/on-dvcs-continuous-integration-and-feature-branches/ ) is ezen szerzők tollából származik, és szerény véleményük szerint a DVCS és a feature branchek használata egymástól független választás.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5347349015396857015/comments/default/9031847498206659509'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5347349015396857015/comments/default/9031847498206659509'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/08/branch-eljunk-e-vagy-sem.html?showComment=1313503480763#c9031847498206659509' title=''/><author><name>Marhefka, István</name><uri>http://www.blogger.com/profile/13620561176122999497</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://1.bp.blogspot.com/_jQEHa8Ux_1I/S0eMU6t8VsI/AAAAAAAACrA/YBThKPpIonM/S220/karpatalja24.JPG'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/08/branch-eljunk-e-vagy-sem.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-5347349015396857015' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/5347349015396857015' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1963072178'/><gd:extendedProperty name='blogger.displayTime' value='2011. augusztus 16. 16:04'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7547892038669951703</id><published>2011-09-07T10:13:08.344+02:00</published><updated>2011-09-07T10:13:08.344+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nagyon jó cikk! Azért azt jegyezzük meg, hogy GIT/...</title><content type='html'>Nagyon jó cikk! Azért azt jegyezzük meg, hogy GIT/Mercurial/Bazaar esetén a branch és a merge jóval egyszerűbb!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3931037512697146491/comments/default/7547892038669951703'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3931037512697146491/comments/default/7547892038669951703'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/09/subversion-branch-akar-maven-release.html?showComment=1315383188344#c7547892038669951703' title=''/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/09/subversion-branch-akar-maven-release.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3931037512697146491' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3931037512697146491' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-701081494'/><gd:extendedProperty name='blogger.displayTime' value='2011. szeptember 7. 10:13'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-306538797063385876</id><published>2011-09-07T10:41:03.731+02:00</published><updated>2011-09-07T10:41:03.731+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>&amp;quot;Bizonyos dolgok mások, bizonyos dolgok egysz...</title><content type='html'>&amp;quot;Bizonyos dolgok mások, bizonyos dolgok egyszerűbbek elosztott verziókezelő rendszer (pl. GIT, Mercurial, stb.) esetén.&amp;quot;</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3931037512697146491/comments/default/306538797063385876'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3931037512697146491/comments/default/306538797063385876'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/09/subversion-branch-akar-maven-release.html?showComment=1315384863731#c306538797063385876' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/09/subversion-branch-akar-maven-release.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3931037512697146491' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3931037512697146491' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. szeptember 7. 10:41'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4351204150734204635</id><published>2011-09-14T08:24:58.954+02:00</published><updated>2011-09-14T08:24:58.954+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szimpi megoldas. Regebben mondjuk jobban szerettem...</title><content type='html'>Szimpi megoldas. Regebben mondjuk jobban szerettem kozvetlenul eclipse-vel elstartolni az appot mondjuk wtp-ben, ez nem futtatta le a buildet. Utobb aztan atszoktam a maven jetty pluginra, abban nem volt annyi bug, mint a wtp-ben :D szoval azzal valoszinuleg ez is korrekten mukodik.&lt;br /&gt;&lt;br /&gt;Legkozelebb azt hiszem mar ez kerul bevetesre. Most hogy az svn kb eltunt.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6632348504802797991/comments/default/4351204150734204635'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6632348504802797991/comments/default/4351204150734204635'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/09/verzioszam-megjelenitese-az.html?showComment=1315981498954#c4351204150734204635' title=''/><author><name>Kocka</name><uri>http://www.blogger.com/profile/10505773298750628833</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='24' height='32' src='http://photos1.blogger.com/x/blogger/3271/703/320/170223/00024.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/09/verzioszam-megjelenitese-az.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6632348504802797991' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6632348504802797991' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1842159747'/><gd:extendedProperty name='blogger.displayTime' value='2011. szeptember 14. 8:24'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3931239948481960423</id><published>2011-09-14T11:36:32.469+02:00</published><updated>2011-09-14T11:36:32.469+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Örülök! :)

Későn írtam a cikket, ezért pár dolog ...</title><content type='html'>Örülök! :)&lt;br /&gt;&lt;br /&gt;Későn írtam a cikket, ezért pár dolog kimaradt. Egyrészt az, hogy a build number plugin nem csak Subversion-t támogat. Valamint az, hogy a buildNumber.properties állományokat nem commit-olja, egyszerűen módosítja, amit nekünk kell commit-olni. Ez szerintem elég nagy hibalehetőség. E miatt is biztosabb a csak verziószám használata.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6632348504802797991/comments/default/3931239948481960423'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6632348504802797991/comments/default/3931239948481960423'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/09/verzioszam-megjelenitese-az.html?showComment=1315992992469#c3931239948481960423' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/09/verzioszam-megjelenitese-az.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6632348504802797991' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6632348504802797991' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. szeptember 14. 11:36'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3328109758840117</id><published>2011-09-14T19:06:31.149+02:00</published><updated>2011-09-14T19:06:31.149+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>..és ha webappunk van, tegyük a felületen elérhető...</title><content type='html'>..és ha webappunk van, tegyük a felületen elérhetővé a verziószámot, build id-t és version control id-t (pl egy /version url-en), jól tud jönni</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6632348504802797991/comments/default/3328109758840117'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6632348504802797991/comments/default/3328109758840117'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/09/verzioszam-megjelenitese-az.html?showComment=1316019991149#c3328109758840117' title=''/><author><name>Kristof Jozsa</name><uri>http://www.blogger.com/profile/06607669172500255805</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/09/verzioszam-megjelenitese-az.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6632348504802797991' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6632348504802797991' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-686590949'/><gd:extendedProperty name='blogger.displayTime' value='2011. szeptember 14. 19:06'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5874925009833765101</id><published>2011-09-23T19:32:34.486+02:00</published><updated>2011-09-23T19:32:34.486+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nagyon hasznos dolgokról írsz pont megfelelő mélys...</title><content type='html'>Nagyon hasznos dolgokról írsz pont megfelelő mélységben! Csak így tovább!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6632348504802797991/comments/default/5874925009833765101'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6632348504802797991/comments/default/5874925009833765101'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/09/verzioszam-megjelenitese-az.html?showComment=1316799154486#c5874925009833765101' title=''/><author><name>András</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/09/verzioszam-megjelenitese-az.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6632348504802797991' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6632348504802797991' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-570035333'/><gd:extendedProperty name='blogger.displayTime' value='2011. szeptember 23. 19:32'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6501908345663744217</id><published>2011-09-23T21:52:23.194+02:00</published><updated>2011-09-23T21:52:23.194+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi! :)</title><content type='html'>Köszi! :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6632348504802797991/comments/default/6501908345663744217'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6632348504802797991/comments/default/6501908345663744217'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/09/verzioszam-megjelenitese-az.html?showComment=1316807543194#c6501908345663744217' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/09/verzioszam-megjelenitese-az.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6632348504802797991' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6632348504802797991' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. szeptember 23. 21:52'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2459243128385731633</id><published>2011-12-29T12:14:08.875+01:00</published><updated>2011-12-29T12:14:08.875+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szokásosan jó írás, viszont a github-os link rossz...</title><content type='html'>Szokásosan jó írás, viszont a github-os link rossz, kimaradt a userneved, gondoltam szólok.&lt;br /&gt;&lt;br /&gt;Kellemes ünnepeket!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/43432132572840305/comments/default/2459243128385731633'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/43432132572840305/comments/default/2459243128385731633'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/12/instrumentation-javassist-tal.html?showComment=1325157248875#c2459243128385731633' title=''/><author><name>jbuzi</name><uri>http://jbuzi.blogspot.com</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/12/instrumentation-javassist-tal.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-43432132572840305' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/43432132572840305' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-303642389'/><gd:extendedProperty name='blogger.displayTime' value='2011. december 29. 12:14'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6760475929990208086</id><published>2011-12-29T13:06:22.150+01:00</published><updated>2011-12-29T13:06:22.150+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszönöm szépen, javítottam. Minden hibajelzést sz...</title><content type='html'>Köszönöm szépen, javítottam. Minden hibajelzést szívesen fogadok!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/43432132572840305/comments/default/6760475929990208086'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/43432132572840305/comments/default/6760475929990208086'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/12/instrumentation-javassist-tal.html?showComment=1325160382150#c6760475929990208086' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/12/instrumentation-javassist-tal.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-43432132572840305' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/43432132572840305' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. december 29. 13:06'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5977533950011813489</id><published>2011-12-30T10:53:06.065+01:00</published><updated>2011-12-30T10:53:06.065+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi a cikket, jól összeszedett anyag.</title><content type='html'>Köszi a cikket, jól összeszedett anyag.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/5977533950011813489'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/5977533950011813489'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html?showComment=1325238786065#c5977533950011813489' title=''/><author><name>Richárd Kovács</name><uri>http://www.blogger.com/profile/06849753526791080950</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8365011667058151286' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8365011667058151286' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-196939700'/><gd:extendedProperty name='blogger.displayTime' value='2011. december 30. 10:53'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3667477298811019943</id><published>2011-12-30T11:48:24.805+01:00</published><updated>2011-12-30T11:48:24.805+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nagyon korrekt írás (szokás szerint), köszönet ért...</title><content type='html'>Nagyon korrekt írás (szokás szerint), köszönet érte.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/3667477298811019943'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/3667477298811019943'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html?showComment=1325242104805#c3667477298811019943' title=''/><author><name>Aron Gombas</name><uri>http://www.midori.hu</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8365011667058151286' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8365011667058151286' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-359501607'/><gd:extendedProperty name='blogger.displayTime' value='2011. december 30. 11:48'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7290246537687179586</id><published>2011-12-30T12:09:35.759+01:00</published><updated>2011-12-30T12:09:35.759+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi, most már a képeket is rendbe tettem, mert v...</title><content type='html'>Köszi, most már a képeket is rendbe tettem, mert volt egy kis kavar. :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/7290246537687179586'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/7290246537687179586'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html?showComment=1325243375759#c7290246537687179586' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_czKgycLvmNo/SgBZGh_VftI/AAAAAAAADlA/j1jL02Uw6Tc/S220/foto3_kicsi.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8365011667058151286' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8365011667058151286' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2011. december 30. 12:09'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5470183491227817085</id><published>2012-01-01T20:13:23.562+01:00</published><updated>2012-01-01T20:13:23.562+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Out of memory error esetén néha szoktam egy kis tr...</title><content type='html'>Out of memory error esetén néha szoktam egy kis trükköt használni: előre lefoglalok egy egy megás statikus tömböt, aminek ilyenkor törlöm a referenciáját, és máris van annyi szabad memória, hogy tisztességesen ki lehessen lépni, azaz logolni és értesíteni a felhasználót hogy hiba történt. Ennek természetesen kliens oldalon van értelme ...</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/5470183491227817085'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/5470183491227817085'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html?showComment=1325445203562#c5470183491227817085' title=''/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8365011667058151286' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8365011667058151286' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-14456618'/><gd:extendedProperty name='blogger.displayTime' value='2012. január 1. 20:13'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3615926204454093281</id><published>2012-01-02T00:32:13.431+01:00</published><updated>2012-01-02T00:32:13.431+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Kicsit kétkedve fogadtam a tippet, de kipróbáltam,...</title><content type='html'>Kicsit kétkedve fogadtam a tippet, de kipróbáltam, és működik! Köszönöm!&lt;br /&gt;&lt;br /&gt;Itt megtalálható a teszt program, akit érdekel, rápillanthat, hogy nem-e néztem be valamit:&lt;br /&gt;&lt;br /&gt;&lt;a href="https://gist.github.com/1548642" rel="nofollow"&gt;https://gist.github.com/1548642&lt;/a&gt;</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/3615926204454093281'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/3615926204454093281'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html?showComment=1325460733431#c3615926204454093281' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8365011667058151286' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8365011667058151286' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2012. január 2. 0:32'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6463188461363538424</id><published>2012-01-02T14:57:42.587+01:00</published><updated>2012-01-02T14:57:42.587+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szuper cikk. Köszönöm. Sok év Java után végre egy ...</title><content type='html'>Szuper cikk. Köszönöm. Sok év Java után végre egy olyan cikk, amelyiktől nem rettentem el az elején, és így annyi tudást adott, hogy most már akár tovább is tudom olvasni amikor kell a részletesebb irodalmat.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/6463188461363538424'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/6463188461363538424'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html?showComment=1325512662587#c6463188461363538424' title=''/><author><name>Verhás Péter</name><uri>http://www.blogger.com/profile/06377161363854132582</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8365011667058151286' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8365011667058151286' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-377703703'/><gd:extendedProperty name='blogger.displayTime' value='2012. január 2. 14:57'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2182804350227117908</id><published>2012-01-02T16:08:22.317+01:00</published><updated>2012-01-02T16:08:22.317+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi! Próbálok még ilyeneket írni, de kéne témaja...</title><content type='html'>Köszi! Próbálok még ilyeneket írni, de kéne témajavaslat. Java téren most eléggé nehéz friss, aktuális, érdekes, hasznos témáról írni.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/2182804350227117908'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/2182804350227117908'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html?showComment=1325516902317#c2182804350227117908' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8365011667058151286' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8365011667058151286' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2012. január 2. 16:08'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2779771994389680053</id><published>2012-01-03T13:30:03.853+01:00</published><updated>2012-01-03T13:30:03.853+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Azért a memory leakek ennél gyakoribbak, és ha csa...</title><content type='html'>Azért a memory leakek ennél gyakoribbak, és ha csak nem éppen saját ArrayList/Vector implementációt csinálunk, szinte kizárt, hogy pont egy array mezőjében ragadna egy felesleges referencia. Sokkal kevésbé triviális hibák szoktak lenni, tapasztalataim szerint. Pl egy anonim inner class referenciát tart a külső osztályra, feleslegesen, vagy egy map-be kerülnek bele olyan kulccsal objektumok, ahol a kulcs equals/hash függvénye nem tökéletes, vagy egyszerűen nem törlik időben a felesleges értékeket. ThreadLocal-okban is megbújhatnak sokáig objektumok, stb</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/2779771994389680053'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/2779771994389680053'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html?showComment=1325593803853#c2779771994389680053' title=''/><author><name>Zsombor</name><uri>http://www.blogger.com/profile/09474963503409488329</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8365011667058151286' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8365011667058151286' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-454917018'/><gd:extendedProperty name='blogger.displayTime' value='2012. január 3. 13:30'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-9012686140646665522</id><published>2012-01-03T17:14:54.840+01:00</published><updated>2012-01-03T17:14:54.840+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>@Zsombor: Igazad van, rosszul fogalmaztam. Nem ily...</title><content type='html'>@Zsombor: Igazad van, rosszul fogalmaztam. Nem ilyenkor a leggyakoribb, csak én ezt a szót, hogy memóriaszivárgás, két helyen hallottam. SCJP vizsgán és állásinterjúkon. Mind a két helyen ez volt a leggyakrabban felhozott példa. Természetesen éles alkalmazásban ez azért ritkán fordul elő, de ezt a legegyszerűbb elmagyarázni. :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/9012686140646665522'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/9012686140646665522'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html?showComment=1325607294840#c9012686140646665522' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8365011667058151286' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8365011667058151286' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2012. január 3. 17:14'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8082453077185617217</id><published>2012-01-06T22:31:45.575+01:00</published><updated>2012-01-06T22:31:45.575+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szia István!

Köszi a cikket! Szívesen olvasnék ar...</title><content type='html'>Szia István!&lt;br /&gt;&lt;br /&gt;Köszi a cikket! Szívesen olvasnék arról, hogy hogyan látod a Java jövőjét 5,10,20 év múlva. Amióta az Oracle megvette a Sun-t valahogy kevesebbet hallani a Java-ról, te hogy látod?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/8082453077185617217'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/8082453077185617217'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html?showComment=1325885505575#c8082453077185617217' title=''/><author><name>Bakai Balázs</name><uri>http://www.blogger.com/profile/01676249813193193031</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='29' src='http://4.bp.blogspot.com/-7s3n1L5adNU/TwLnngVVw-I/AAAAAAAAALo/-5RatYayER8/s220/kep.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8365011667058151286' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8365011667058151286' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-751703941'/><gd:extendedProperty name='blogger.displayTime' value='2012. január 6. 22:31'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4432874750616153477</id><published>2012-01-06T23:15:35.684+01:00</published><updated>2012-01-06T23:15:35.684+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>@Balázs: Így év elején divat visszatekintéseket, e...</title><content type='html'>@Balázs: Így év elején divat visszatekintéseket, elemzéseket írni. Ezt viszont nem tudom felvállalni. Cikkeimből szerintem kiderül, hogy szeretem a tényeken alapuló, minél pontosabb dolgokat, a jövőt illetően nem találgatnék.&lt;br /&gt;&lt;br /&gt;Kétségtelen, hogy sokakat foglalkoztat, pl. Kocka ez irányú írásaival gyakran egyet értek, egy ezek közül:&lt;br /&gt;&lt;br /&gt;&lt;a href="http://iwillworkforfood.blogspot.com/2011/12/java-ketsegek.html" rel="nofollow"&gt;http://iwillworkforfood.blogspot.com/2011/12/java-ketsegek.html&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;Napról napra töménytelen mennyiségű kód keletkezik Java-ban, amit majd karban kell tartani.&lt;br /&gt;Másfelől viszont mostanában párszor feltették a kérdést, tudsz-e valami izgalmas, érdekes, új Java témáról előadást tartani. Erősen gondolkodnom kellett.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/4432874750616153477'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/4432874750616153477'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html?showComment=1325888135684#c4432874750616153477' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8365011667058151286' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8365011667058151286' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2012. január 6. 23:15'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1933660319383252300</id><published>2012-01-08T19:05:09.877+01:00</published><updated>2012-01-08T19:05:09.877+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi a választ!

Szerintem azért van még egy-két ...</title><content type='html'>Köszi a választ!&lt;br /&gt;&lt;br /&gt;Szerintem azért van még egy-két téma, amiről magyar nyelven nincs túl sok írás, a &lt;a href="http://seamplex.blogspot.com/" rel="nofollow"&gt; seamplex &lt;/a&gt;-en is ilyenekről próbálok írni!&lt;br /&gt;&lt;br /&gt;Egyébként meg lehet érdemes elővenni a régi témákat egy kicsit más megközelítésben vagy egy kicsit elmenni a gyakorlatiasabb témák felé!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/1933660319383252300'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/1933660319383252300'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html?showComment=1326045909877#c1933660319383252300' title=''/><author><name>Bakai Balázs</name><uri>http://www.blogger.com/profile/01676249813193193031</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='29' src='http://4.bp.blogspot.com/-7s3n1L5adNU/TwLnngVVw-I/AAAAAAAAALo/-5RatYayER8/s220/kep.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8365011667058151286' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8365011667058151286' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-751703941'/><gd:extendedProperty name='blogger.displayTime' value='2012. január 8. 19:05'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5583626722530050087</id><published>2012-01-09T22:10:53.415+01:00</published><updated>2012-01-09T22:10:53.415+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szia! 
Szerintem is nagyon jó írás, köszi!

( Egy ...</title><content type='html'>Szia! &lt;br /&gt;Szerintem is nagyon jó írás, köszi!&lt;br /&gt;&lt;br /&gt;( Egy apró pontosítás: nem kell egyenlőségjel az X-es int típusú kapcsolókhoz. Tehát: -Xmx512m oké, de az -Xmx=512m hibát dob. )</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/5583626722530050087'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/5583626722530050087'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html?showComment=1326143453415#c5583626722530050087' title=''/><author><name>László Bukodi</name><uri>http://www.blogger.com/profile/02878851004390194274</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8365011667058151286' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8365011667058151286' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1776426194'/><gd:extendedProperty name='blogger.displayTime' value='2012. január 9. 22:10'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1594358053305107809</id><published>2012-01-09T22:57:05.803+01:00</published><updated>2012-01-09T22:57:05.803+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>@László: Köszönöm, nem volt jó példa, javítottam a...</title><content type='html'>@László: Köszönöm, nem volt jó példa, javítottam a -XX:NewSize=64m developer kapcsolóra, aminek tényleg olyan a formátuma.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/1594358053305107809'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8365011667058151286/comments/default/1594358053305107809'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html?showComment=1326146225803#c1594358053305107809' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/12/java-memoriakezeles-szemetgyujto.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8365011667058151286' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8365011667058151286' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2012. január 9. 22:57'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3952218089217367683</id><published>2012-01-16T09:36:25.649+01:00</published><updated>2012-01-16T09:36:25.649+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Alapos, összefoglaló cikk, köszönjük! 

Kér kérdés...</title><content type='html'>Alapos, összefoglaló cikk, köszönjük! &lt;br /&gt;&lt;br /&gt;Kér kérdésem lenne:&lt;br /&gt;&lt;br /&gt;1. Miért kellett a Java a címbe? Mert mindez igaz akár .NET-es, akár C++-os, akár Ruby on Rails-es környezetre is (az utolsó pár Oracle specifikus bekezdést leszámítva).&lt;br /&gt;&lt;br /&gt;2. Mekkora cég/csapat mérettől kezdve van szerinted igény architectre?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/340189829288615845/comments/default/3952218089217367683'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/340189829288615845/comments/default/3952218089217367683'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/01/ki-is-az-java-architect.html?showComment=1326702985649#c3952218089217367683' title=''/><author><name>Zsoldos Péter</name><uri>http://zsoldosp.blogspot.com</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/01/ki-is-az-java-architect.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-340189829288615845' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/340189829288615845' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-253417610'/><gd:extendedProperty name='blogger.displayTime' value='2012. január 16. 9:36'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2602104852351076409</id><published>2012-01-16T13:40:45.059+01:00</published><updated>2012-01-16T13:40:45.059+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>@Péter: Mikor elkezdtem írni, azt hittem, több Jav...</title><content type='html'>@Péter: Mikor elkezdtem írni, azt hittem, több Java specifikus rész lesz. :) Most így tényleg csak az utolsó bejegyzés miatt.&lt;br /&gt;&lt;br /&gt;Igazából az architect is lehet szerepkör, azaz pl. egy kis cég, project esetén is van, aki ilyesmivel foglalkozik, általában a vezető fejlesztő. Akkor kell architect, mikor már az ilyen irányú teendők elveszik a teljes idejét.&lt;br /&gt;&lt;br /&gt;Nagyon függ amúgy projekttől, mert ha nincs benne különös technikai kihívás, vagy az n+1-edik ugyanolyan projekt, akkor nem érdemes fenntartani.&lt;br /&gt;&lt;br /&gt;Ha egy átlagot kell mondanom, akkor azt mondanám, hogy 25-30 fejlesztőnél már elkel egy olyan, aki semmi mással nem foglalkozik. Tapasztalatom szerint egy 20 fejlesztős projektet még el tud vinni egy vezető fejlesztő egy személyben (dolgoztam így), aki aktívan kódol is, ha csak egy-két integrációs feladat van.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/340189829288615845/comments/default/2602104852351076409'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/340189829288615845/comments/default/2602104852351076409'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/01/ki-is-az-java-architect.html?showComment=1326717645059#c2602104852351076409' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/01/ki-is-az-java-architect.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-340189829288615845' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/340189829288615845' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2012. január 16. 13:40'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6485174778826228279</id><published>2012-01-17T13:04:33.609+01:00</published><updated>2012-01-17T13:04:33.609+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszönjük ismét a cikket, nekem nagyon tetszett!

...</title><content type='html'>Köszönjük ismét a cikket, nekem nagyon tetszett!&lt;br /&gt;&lt;br /&gt;Az architect szót leginkább vezetőktől szoktam hallani, és az a tapasztalatom, hogy mindenki mást ért alatta.&lt;br /&gt;&lt;br /&gt;Még nem találtam (igaz, nem is kerestem :)) erre a kifejezésre létező definíciót, de abszolút el tudom fogadni azokat, amiket Te itt most összeszedtél. &lt;br /&gt;&lt;br /&gt;Gratu!:)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/340189829288615845/comments/default/6485174778826228279'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/340189829288615845/comments/default/6485174778826228279'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/01/ki-is-az-java-architect.html?showComment=1326801873609#c6485174778826228279' title=''/><author><name>Marhefka, István</name><uri>http://www.blogger.com/profile/13620561176122999497</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://1.bp.blogspot.com/_jQEHa8Ux_1I/S0eMU6t8VsI/AAAAAAAACrA/YBThKPpIonM/S220/karpatalja24.JPG'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/01/ki-is-az-java-architect.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-340189829288615845' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/340189829288615845' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1963072178'/><gd:extendedProperty name='blogger.displayTime' value='2012. január 17. 13:04'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1533171853102117088</id><published>2012-01-17T13:28:16.485+01:00</published><updated>2012-01-17T13:28:16.485+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>@István: Köszönöm, igyekeztem összeszedni a gondol...</title><content type='html'>@István: Köszönöm, igyekeztem összeszedni a gondolataimat ezzel kapcsolatban, hátha másoknak is hasznára válik.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/340189829288615845/comments/default/1533171853102117088'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/340189829288615845/comments/default/1533171853102117088'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/01/ki-is-az-java-architect.html?showComment=1326803296485#c1533171853102117088' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/01/ki-is-az-java-architect.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-340189829288615845' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/340189829288615845' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2012. január 17. 13:28'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8240820901094905485</id><published>2012-01-25T13:44:20.795+01:00</published><updated>2012-01-25T13:44:20.795+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nagyon jól összeszedett cikk, köszönjük.
Nekem van...</title><content type='html'>Nagyon jól összeszedett cikk, köszönjük.&lt;br /&gt;Nekem van ilyen Oracle Java EE 5 Enterprise Architect certification-öm, de még egy állásinterjún sem jött szóba. Úgy vettem észre, hogy ez nem érdekli a munkaadókat (sem itthon, sem külföldön). Ennek mi lehet az oka?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/340189829288615845/comments/default/8240820901094905485'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/340189829288615845/comments/default/8240820901094905485'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/01/ki-is-az-java-architect.html?showComment=1327495460795#c8240820901094905485' title=''/><author><name>Sanyi</name><uri>http://www.blogger.com/profile/08820009851020593415</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/01/ki-is-az-java-architect.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-340189829288615845' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/340189829288615845' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1889557131'/><gd:extendedProperty name='blogger.displayTime' value='2012. január 25. 13:44'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1201211256097765924</id><published>2012-01-25T13:54:30.984+01:00</published><updated>2012-01-25T13:54:30.984+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi!
Itthon így van. Németeknél nagyobb elismert...</title><content type='html'>Köszi!&lt;br /&gt;Itthon így van. Németeknél nagyobb elismertsége van, de gondolom ott is állásonként változik.&lt;br /&gt;Az Oracle egyik ígérete, hogy feljebb viszi az elismertségét, hiszen pl. egy Oracle db certification fontos itthon is. Én bízom benne.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/340189829288615845/comments/default/1201211256097765924'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/340189829288615845/comments/default/1201211256097765924'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/01/ki-is-az-java-architect.html?showComment=1327496070984#c1201211256097765924' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/01/ki-is-az-java-architect.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-340189829288615845' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/340189829288615845' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2012. január 25. 13:54'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7148121292476295447</id><published>2012-04-02T13:20:21.358+02:00</published><updated>2012-04-02T13:20:21.358+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Huhh, nagyon erdekes a tema.</title><content type='html'>Huhh, nagyon erdekes a tema.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/266912075707296739/comments/default/7148121292476295447'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/266912075707296739/comments/default/7148121292476295447'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/03/java-performance.html?showComment=1333365621358#c7148121292476295447' title=''/><author><name>Gábor</name><uri>http://www.blogger.com/profile/16328831533238731170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://3.bp.blogspot.com/-ewx-jYATMUo/Tkchuk0byMI/AAAAAAAAAAY/953les7GhGc/s220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/03/java-performance.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-266912075707296739' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/266912075707296739' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2145961406'/><gd:extendedProperty name='blogger.displayTime' value='2012. április 2. 13:20'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1037474078441770460</id><published>2012-04-23T23:53:32.957+02:00</published><updated>2012-04-23T23:53:32.957+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nem vagyok JPA szakértő, de valamit nem értek. Ha ...</title><content type='html'>Nem vagyok JPA szakértő, de valamit nem értek. Ha azt szeretnéd, hogy egyszerre töltődjön be egy objektum és a listája, az csak akkor lehetséges, ha a JPA motor támogatja. Az SQL az összekapcsolás során pontosan azt csinálja amit írtál, azaz duplázza a sorokat, a kapcsolódó telefonszámok száma szerint. Ha az eredményt a JPA motor hajlandó szétválogatni akkor jó, ha nem akkor nem, ezen a distinct nem segít, sőt semmilyen hatással sincs a kiadott query eredményére (Wllenőrizd le nyugodtan. Legalábbis SQL92 szabványt implementáló DB alatt)&lt;br /&gt;Gondolj bele, ha egyszerre két listát akarnál betölteni, akkor valamiféle 3-as keresztszorzat jönne létre, amit már senki nem vállal be. Emiatt aztán egy listára sem szokták megírni.&lt;br /&gt;Postgres-el amúgy lehetséges mezőbe listát lekérni, de az eredményt nem tudom hogy a JDBC tudja-e egyáltalán értelmezni.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1949829407110462171/comments/default/1037474078441770460'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1949829407110462171/comments/default/1037474078441770460'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/04/jpa-lazy-loading.html?showComment=1335218012957#c1037474078441770460' title=''/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/04/jpa-lazy-loading.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-1949829407110462171' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/1949829407110462171' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1719612129'/><gd:extendedProperty name='blogger.displayTime' value='2012. április 23. 23:53'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7081619861357912745</id><published>2012-04-24T22:53:53.476+02:00</published><updated>2012-04-24T22:53:53.476+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szia!

Ahhoz, hogy egyszerre töltődjön be, használ...</title><content type='html'>Szia!&lt;br /&gt;&lt;br /&gt;Ahhoz, hogy egyszerre töltődjön be, használható a join fetch. Ezt minden providernek támogatnia kell. &lt;br /&gt;És ahogy írtad, többszörözi a sorokat.&lt;br /&gt;Erre ezt írja az említett JPA könyv:&lt;br /&gt;&amp;quot;Because it is not possible to write a SQL query that uses the &lt;br /&gt;DISTINCT operator while preserving the semantics of the fetch join, the provider will have to eliminate duplicates in memory after the results have been fetched. This could have performance implications for large result sets.&amp;quot;&lt;br /&gt;Azaz az SQL-t nem tudod rábeszélni, hogy úgy szedje be a gyerekeket, hogy a szülőt csak egyszer, szóval a provider csinálja Java oldalon. Igen, ennek teljesítmény következményei lehetnek.&lt;br /&gt;Amúgy ha megnézel egy bonyolult JPA-s alkalmazást, tele van oldalnyi generált join-olt query-kkel. Ezzel szoktak is szembesülni, hogy prototípust készíteni vele egyszerű, de egy bonyolult adathalmaznál már durva lekérdezések generálódnak.&lt;br /&gt;Amúgy van lehetőség JPA-ban is listát használni, de ugyanott vagy, @ElementCollection, JPA 2.0-ban, és ugyanúgy külön táblába képzi le, és join-t használ.&lt;br /&gt;JDBC-vel lehet array típust lekérdezni, ezt többször használtuk is. Persze innentől ugrik a platformfüggetlenség általában, de ezzel együtt lehet élni.&lt;br /&gt;Az Oracle teljesítményhangolásról szóló könyve is azt írja, hogy bizonyos esetekben jobb eredmény érhetünk el, ha nem egy nagy lekérdezést használunk, hanem pl. tárolttal szedjük össze a megfelelő adatokat.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1949829407110462171/comments/default/7081619861357912745'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/1949829407110462171/comments/default/7081619861357912745'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/04/jpa-lazy-loading.html?showComment=1335300833476#c7081619861357912745' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/04/jpa-lazy-loading.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-1949829407110462171' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/1949829407110462171' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2012. április 24. 22:53'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1079010891129839894</id><published>2012-07-22T09:26:40.336+02:00</published><updated>2012-07-22T09:26:40.336+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Tudsz valamit a verseny jövőbeli sorsáról?</title><content type='html'>Tudsz valamit a verseny jövőbeli sorsáról?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/1079010891129839894'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/1079010891129839894'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html?showComment=1342942000336#c1079010891129839894' title=''/><author><name>Bakai Balázs</name><uri>http://www.blogger.com/profile/01676249813193193031</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='24' src='http://4.bp.blogspot.com/-jYwNLyhbMSc/T-Ybh9cYbLI/AAAAAAAAAXs/lER7hinnQE0/s220/blog.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-70696356624550932' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/70696356624550932' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-751703941'/><gd:extendedProperty name='blogger.displayTime' value='2012. július 22. 9:26'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1579666951663456256</id><published>2012-07-23T10:15:31.555+02:00</published><updated>2012-07-23T10:15:31.555+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szia!

Tudok, jelenleg úgy tűnik, sajnos nincs jöv...</title><content type='html'>Szia!&lt;br /&gt;&lt;br /&gt;Tudok, jelenleg úgy tűnik, sajnos nincs jövőbeli sorsa, egyszeri esemény volt.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/1579666951663456256'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/70696356624550932/comments/default/1579666951663456256'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html?showComment=1343031331555#c1579666951663456256' title=''/><author><name>Viczián István</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/12/legjobb-fejleszto-2010-verseny.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-70696356624550932' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/70696356624550932' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2012. július 23. 10:15'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2053745785317228376</id><published>2012-08-19T20:42:30.527+02:00</published><updated>2012-08-19T20:42:30.527+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Ez annyira nem tiszta, szoval az Endpoint.publish(...</title><content type='html'>Ez annyira nem tiszta, szoval az Endpoint.publish()  elindit egy com.sun.net.httpserver.HttpServer -t? Vagy azt meg elotte fel kell izgatni valahogy?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7550091435364332920/comments/default/2053745785317228376'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7550091435364332920/comments/default/2053745785317228376'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/08/soapui-junit-teszteles.html?showComment=1345401750527#c2053745785317228376' title=''/><author><name>Gábor</name><uri>http://www.blogger.com/profile/16328831533238731170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://3.bp.blogspot.com/-ewx-jYATMUo/Tkchuk0byMI/AAAAAAAAAAY/953les7GhGc/s220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/08/soapui-junit-teszteles.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7550091435364332920' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7550091435364332920' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2145961406'/><gd:extendedProperty name='blogger.displayTime' value='2012. augusztus 19. 20:42'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2364684412141742029</id><published>2012-08-21T10:47:55.939+02:00</published><updated>2012-08-21T10:47:55.939+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Elindít. Lást a GitHub-on a kódot, a teszt esetet:...</title><content type='html'>Elindít. Lást a GitHub-on a kódot, a teszt esetet:&lt;br /&gt;&lt;br /&gt;https://github.com/vicziani/jtechlog-soapui-testing/blob/master/src/test/java/jtechlog/soapui/test/TempConvertIntegrationTest.java</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7550091435364332920/comments/default/2364684412141742029'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7550091435364332920/comments/default/2364684412141742029'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/08/soapui-junit-teszteles.html?showComment=1345538875939#c2364684412141742029' title=''/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/08/soapui-junit-teszteles.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7550091435364332920' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7550091435364332920' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2012. augusztus 21. 10:47'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4792619859786599421</id><published>2012-08-31T10:28:43.053+02:00</published><updated>2012-08-31T10:28:43.053+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nagyon jó leírás ;)</title><content type='html'>Nagyon jó leírás ;)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4180001514533033810/comments/default/4792619859786599421'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4180001514533033810/comments/default/4792619859786599421'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/09/ibm-websphere-mq.html?showComment=1346401723053#c4792619859786599421' title=''/><author><name>Tamas Kajfis</name><uri>http://www.blogger.com/profile/07041771231536507443</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh3.googleusercontent.com/-leE-ByWKqEM/AAAAAAAAAAI/AAAAAAAAABY/KbeDs3JIyGs/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/09/ibm-websphere-mq.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4180001514533033810' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4180001514533033810' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1053348325'/><gd:extendedProperty name='blogger.displayTime' value='2012. augusztus 31. 10:28'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2011624559409404743</id><published>2012-08-31T21:28:32.304+02:00</published><updated>2012-08-31T21:28:32.304+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi, pedig már nem mai darab.</title><content type='html'>Köszi, pedig már nem mai darab.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4180001514533033810/comments/default/2011624559409404743'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4180001514533033810/comments/default/2011624559409404743'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/09/ibm-websphere-mq.html?showComment=1346441312304#c2011624559409404743' title=''/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/09/ibm-websphere-mq.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4180001514533033810' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4180001514533033810' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2012. augusztus 31. 21:28'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1890482788098393655</id><published>2012-09-18T15:14:59.997+02:00</published><updated>2012-09-18T15:14:59.997+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Gondolkodok az 1-es letetelen. Vannak tesztkerdese...</title><content type='html'>Gondolkodok az 1-es letetelen. Vannak tesztkerdesek is, hogy kb. mik a temakorok kozelebbrol?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/761129547306460114/comments/default/1890482788098393655'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/761129547306460114/comments/default/1890482788098393655'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/09/oracle-java-vizsgak.html?showComment=1347974099997#c1890482788098393655' title=''/><author><name>Gábor</name><uri>http://www.blogger.com/profile/16328831533238731170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://3.bp.blogspot.com/-ewx-jYATMUo/Tkchuk0byMI/AAAAAAAAAAY/953les7GhGc/s220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/09/oracle-java-vizsgak.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-761129547306460114' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/761129547306460114' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2145961406'/><gd:extendedProperty name='blogger.displayTime' value='2012. szeptember 18. 15:14'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7135472049660872130</id><published>2012-09-18T15:59:42.574+02:00</published><updated>2012-09-18T15:59:42.574+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Annyi van, ami a postban szereplő első külső linke...</title><content type='html'>Annyi van, ami a postban szereplő első külső linken található: &lt;a href="http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=41&amp;amp;p_org_id=&amp;amp;lang=&amp;amp;p_exam_id=1Z0_803" rel="nofollow"&gt;http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=41&amp;amp;p_org_id=&amp;amp;lang=&amp;amp;p_exam_id=1Z0_803&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;Azon az oldalon an egy Sample Questions link is: &lt;a href="http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=303&amp;amp;p_certName=SQ1Z0_803" rel="nofollow"&gt;http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=303&amp;amp;p_certName=SQ1Z0_803&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;Valamint a könyv is kiemelkedően jó.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/761129547306460114/comments/default/7135472049660872130'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/761129547306460114/comments/default/7135472049660872130'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/09/oracle-java-vizsgak.html?showComment=1347976782574#c7135472049660872130' title=''/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/09/oracle-java-vizsgak.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-761129547306460114' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/761129547306460114' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2012. szeptember 18. 15:59'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6496159654983522880</id><published>2012-09-19T10:40:46.304+02:00</published><updated>2012-09-19T10:40:46.304+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nem értek hozzá, de fentiek alapján úgy tűnik, hog...</title><content type='html'>Nem értek hozzá, de fentiek alapján úgy tűnik, hogy Java-ra van jópár kiváló minőségű framework, boldogok lehetnek a Java prgmozók.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/6496159654983522880'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/6496159654983522880'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1348044046304#c6496159654983522880' title=''/><author><name>ern0</name><uri>http://www.blogger.com/profile/10560853500686689739</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1186890472'/><gd:extendedProperty name='blogger.displayTime' value='2012. szeptember 19. 10:40'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3406531439534662225</id><published>2012-09-19T15:14:18.267+02:00</published><updated>2012-09-19T15:14:18.267+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>http://education.oracle.com/pls/web_prod-plq-dad/d...</title><content type='html'>http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=303&amp;amp;p_certName=SQ1Z0_803&lt;br /&gt;&lt;br /&gt;Az 5. kérdés megoldása nem rossz? A helyett E (?)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/761129547306460114/comments/default/3406531439534662225'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/761129547306460114/comments/default/3406531439534662225'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/09/oracle-java-vizsgak.html?showComment=1348060458267#c3406531439534662225' title=''/><author><name>A.</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/09/oracle-java-vizsgak.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-761129547306460114' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/761129547306460114' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-447774124'/><gd:extendedProperty name='blogger.displayTime' value='2012. szeptember 19. 15:14'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6949808839608532904</id><published>2012-09-20T11:27:01.908+02:00</published><updated>2012-09-20T11:27:01.908+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Igazad van, mekkora találat!

Hogy másoknak is vil...</title><content type='html'>Igazad van, mekkora találat!&lt;br /&gt;&lt;br /&gt;Hogy másoknak is világos legyen: az interfészben definiált metódus módosítószó nélkül implicit public, ezért az osztályban is public módosítószóval kéne szerepeltetni, mert az implementáló metódus láthatósága nem lehet szűkebb.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/761129547306460114/comments/default/6949808839608532904'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/761129547306460114/comments/default/6949808839608532904'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/09/oracle-java-vizsgak.html?showComment=1348133221908#c6949808839608532904' title=''/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/09/oracle-java-vizsgak.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-761129547306460114' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/761129547306460114' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2012. szeptember 20. 11:27'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-387614992297812547</id><published>2012-09-20T11:29:28.234+02:00</published><updated>2012-09-20T11:29:28.234+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Ez így van. Ha valaki azt mondja, hogy neki viszon...</title><content type='html'>Ez így van. Ha valaki azt mondja, hogy neki viszont olyan igényei vannak, ami eddig senkinek nem merült fel, pláne alap infrastrukturális szinten, az kicsit gyanús. Az is, hogyha a létező keretrendszerek közül egyik sem tetszik. Persze vannak kivételek.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/387614992297812547'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/387614992297812547'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1348133368234#c387614992297812547' title=''/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2012. szeptember 20. 11:29'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3406803161199568922</id><published>2012-09-20T12:37:30.752+02:00</published><updated>2012-09-20T12:37:30.752+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Jó a cikk. 
Sok kérdés felmerült bennem, miközben ...</title><content type='html'>Jó a cikk. &lt;br /&gt;Sok kérdés felmerült bennem, miközben olvastam. Nemcsak Java-ra igaz, hiszen más nyelvekben is léteznek/léteztek keretrendszerek. Láttam már olyan eszközöket, esetleg lehet keretrendszer kezdeményezésnek is nevezni egyeseket, amiket kisebb fejlesztő csapatok vagy egy ember hozott létre abból a célból, hogy gyorsan és egyszerűen generálja a kódot - adatbázis struktúrához, megjelenítéshez, lekérdezéshez, kimutatáshoz, navigációhoz/menühöz, stb. Voltak olyan időszakok, amikor ezek a kezdeményezések nagy haszonnal is jártak. &lt;br /&gt;Nem biztos, hogy hihető, ha valaki a Java körüli FOSS keretrendszer világban általános szakértőnek nevezi magát. Hiszen a világ, amit általánosan ismernie kellene szakértői szinten, az gyorsabban fejlődik, mint ahogy el tudja olvasni. &lt;br /&gt;Ahelyett, hogy azt mondanánk - de a cikkírónak is ez a véleménye -, hogy nincs jelenleg jobb, mindenképpen úgy fogalmaznék, hogy egy adott open source keretrendszert azért választ valaki, mert nem ismer jobbat. De azt legalább ismernie kell. A project-nek pedig el kell viselnie azt, hogy a kiválasztott már kész keretrendszert megismeri a csapat vagy az egyedüli fejlesztő. Az is lehet ugyanis, hogy nem ismeri és drága lesz, mire megismeri, sőt arra is rájöhet, hogy mégse a keretrendszerrel oldja meg a felmerülő feladatot, hanem saját maga, mert az működik, a keretrendszer meg még mindig nem azt csinálja, amit elvár tőle. Hatékony eljárásnak tűnik, ilyenre láttam példát, ha van arra pénz és idő, hogy egy adott keretrendszer - vagy több - alkalmazásában már szakértelmet, tapasztalatot szerzett csapattól a knowhow-t akár tanfolyam vagy pilot formában megvegyük. &lt;br /&gt;Érdekelne a véleményetek, mi alapján döntötök egy adott Java open source keretrendszer alkalmazása mellett és milyen módszert tartotok leghatékonyabbnak annak elsajátítására?&lt;br /&gt;zmbrgy</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/3406803161199568922'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7709122161237145798/comments/default/3406803161199568922'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html?showComment=1348137450752#c3406803161199568922' title=''/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/05/miert-ne-fejlesszunk-sajat.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7709122161237145798' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7709122161237145798' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-470818062'/><gd:extendedProperty name='blogger.displayTime' value='2012. szeptember 20. 12:37'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-522601764721174587</id><published>2012-10-03T03:07:18.087+02:00</published><updated>2012-10-03T03:07:18.087+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Kedves István, úgy tűnik, hogy a könyv csak 2013 f...</title><content type='html'>Kedves István, úgy tűnik, hogy a könyv csak 2013 februárjában fog sajnos megjelenni, tehát akinek nincsen semmi tapasztalata időutazással kapcsolatban, az egyelőre nem tudja megrendelni. :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/761129547306460114/comments/default/522601764721174587'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/761129547306460114/comments/default/522601764721174587'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/09/oracle-java-vizsgak.html?showComment=1349226438087#c522601764721174587' title=''/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/09/oracle-java-vizsgak.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-761129547306460114' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/761129547306460114' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-690084783'/><gd:extendedProperty name='blogger.displayTime' value='2012. október 3. 3:07'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1539621961877995617</id><published>2012-10-03T11:56:12.621+02:00</published><updated>2012-10-03T11:56:12.621+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi, ezt benéztem. Ebben az a szép, hogy az Orac...</title><content type='html'>Köszi, ezt benéztem. Ebben az a szép, hogy az Oracle ezt írja róla: &amp;quot;From Oracle Press—the definitive, bestselling guide&amp;quot;&lt;br /&gt;&lt;br /&gt;Az első vizsgához (Exam 1Z0-803) azonban már van:&lt;br /&gt;&lt;br /&gt;http://www.amazon.com/Programmer-Study-Guide-1Z0-803-Oracle/dp/0071789421</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/761129547306460114/comments/default/1539621961877995617'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/761129547306460114/comments/default/1539621961877995617'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/09/oracle-java-vizsgak.html?showComment=1349258172621#c1539621961877995617' title=''/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/09/oracle-java-vizsgak.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-761129547306460114' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/761129547306460114' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2012. október 3. 11:56'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8607925990225750036</id><published>2012-10-03T12:00:37.015+02:00</published><updated>2012-10-03T12:00:37.015+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Egyebkent en nem tartom elkepzelhetetlennek, hogy ...</title><content type='html'>Egyebkent en nem tartom elkepzelhetetlennek, hogy a blog irojanak esetleg megiscsak van valami tapasztalata az idoutazas teren :-)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/761129547306460114/comments/default/8607925990225750036'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/761129547306460114/comments/default/8607925990225750036'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/09/oracle-java-vizsgak.html?showComment=1349258437015#c8607925990225750036' title=''/><author><name>Gábor</name><uri>http://www.blogger.com/profile/16328831533238731170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://3.bp.blogspot.com/-ewx-jYATMUo/Tkchuk0byMI/AAAAAAAAAAY/953les7GhGc/s220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/09/oracle-java-vizsgak.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-761129547306460114' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/761129547306460114' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2145961406'/><gd:extendedProperty name='blogger.displayTime' value='2012. október 3. 12:00'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-793566623234631600</id><published>2012-10-15T23:43:54.381+02:00</published><updated>2012-10-15T23:43:54.381+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Egy hete tettem le a &amp;quot;1Z0-851 Java Standard E...</title><content type='html'>Egy hete tettem le a &amp;quot;1Z0-851 Java Standard Edition 6 Programmer Certified Professional&amp;quot; vizsgát.&lt;br /&gt;A &amp;quot;Java SE 7 Programmer II&amp;quot; vizsgánál vázolt követelményekből csak a JDBC hiányzott. &lt;br /&gt;Hogy aztán ez mennyivel komolyabb mint az SJCP vizsga, azt nem tudom, minden esetre aki kapásból eléri a 61%-ot a &amp;quot;OCP Java SE 6 Programmer Practice Exams&amp;quot; című könyvben található teszteken, az nyugodtan neki vághat a vizsgának, ugyanis ott könnyebb kérdésekkel találkoztam. &lt;br /&gt;Innen letölthető: http://xa.yimg.com/kq/groups/4069851/1046822621/name/OCP+Java+SE+6+Programmer+Practice+Exams.pdf&lt;br /&gt;</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/761129547306460114/comments/default/793566623234631600'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/761129547306460114/comments/default/793566623234631600'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/09/oracle-java-vizsgak.html?showComment=1350337434381#c793566623234631600' title=''/><author><name>GyurcIT</name><uri>http://www.blogger.com/profile/06514458316039079662</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/09/oracle-java-vizsgak.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-761129547306460114' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/761129547306460114' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1160396809'/><gd:extendedProperty name='blogger.displayTime' value='2012. október 15. 23:43'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4962759882697524745</id><published>2012-10-16T07:56:50.468+02:00</published><updated>2012-10-16T07:56:50.468+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nagyon jó cikk. Köszi.</title><content type='html'>Nagyon jó cikk. Köszi.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2324167374630342322/comments/default/4962759882697524745'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2324167374630342322/comments/default/4962759882697524745'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/10/esemenykuldes-szerver-oldalrol.html?showComment=1350367010468#c4962759882697524745' title=''/><author><name>Tamás Barta</name><uri>http://www.blogger.com/profile/03219987672532392770</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/10/esemenykuldes-szerver-oldalrol.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2324167374630342322' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2324167374630342322' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1727244803'/><gd:extendedProperty name='blogger.displayTime' value='2012. október 16. 7:56'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7382711124827776144</id><published>2012-10-16T09:25:34.550+02:00</published><updated>2012-10-16T09:25:34.550+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi!</title><content type='html'>Köszi!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2324167374630342322/comments/default/7382711124827776144'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2324167374630342322/comments/default/7382711124827776144'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/10/esemenykuldes-szerver-oldalrol.html?showComment=1350372334550#c7382711124827776144' title=''/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/10/esemenykuldes-szerver-oldalrol.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2324167374630342322' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2324167374630342322' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2012. október 16. 9:25'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8324574011903643565</id><published>2012-10-18T15:10:08.909+02:00</published><updated>2012-10-18T15:10:08.909+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A közelmúltban mi is sokat foglalkoztunk szerverol...</title><content type='html'>A közelmúltban mi is sokat foglalkoztunk szerveroldali push technológiával. Mi végül a socket.io választottuk, és viszonylag könnyedén tudtuk Javahoz is integrálni külső (bonyolult, nem megbízható) technológiák nélkül.&lt;br /&gt;&lt;br /&gt;Jó ideje élesben, stabilan működik az alkalmazásunk, és volt pár tapasztalat, ami - természetesen - az idők során derült ki :) Mi nem az általad említett technológiai stackkel dolgozunk (Spring, DWR, Guava Eventbus). De a felmerült kérdések igazából ugyanazok:&lt;br /&gt;&lt;br /&gt;- Ha a DWR-nél úgy döntesz, Commetet használsz, támogatja-e a DWR, hogy a fenntartott kapcsolat (long polling) újra épülhessen, ha megszakad? Ha igen, hogyan értesülhet az alkalmazás erről a hibáról, hogy a menet közben elveszett üzeneteket vmilyen módon kompenzálhassa?&lt;br /&gt;&lt;br /&gt;- Lehet, hogy nem voltam figyelmes a cikk olvasása közben. Hogyan valósul meg a kliensek feliratkozása a szerverre, támogatja-e a DWR a broadcastot? Van-e lehetőség feliratkozni bizonyos csatornákra (topicokra)?&lt;br /&gt;&lt;br /&gt;- Ha elszáll a tranzakció, és előtte már kiküldtük az üzenetet a kliensnek, akkor nincs lehetőség az üzenet &amp;quot;visszavonására&amp;quot;. Esetleg a DWR támogatja-e a tranzakciókat?&lt;br /&gt;&lt;br /&gt;Köszi a cikket, azt hiszem, érdemes a push technológiával foglalkozni, mert - ha sikerül túllendülni a kezdeti problémákon - a felhasználónak hasznos funkciókat tudunk vele előállítani.&lt;br /&gt;</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2324167374630342322/comments/default/8324574011903643565'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2324167374630342322/comments/default/8324574011903643565'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/10/esemenykuldes-szerver-oldalrol.html?showComment=1350565808909#c8324574011903643565' title=''/><author><name>Marhefka, István</name><uri>http://www.blogger.com/profile/13620561176122999497</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://1.bp.blogspot.com/_jQEHa8Ux_1I/S0eMU6t8VsI/AAAAAAAACrA/YBThKPpIonM/S220/karpatalja24.JPG'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/10/esemenykuldes-szerver-oldalrol.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2324167374630342322' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2324167374630342322' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1963072178'/><gd:extendedProperty name='blogger.displayTime' value='2012. október 18. 15:10'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7526736102246769153</id><published>2012-11-12T15:24:05.903+01:00</published><updated>2012-11-12T15:24:05.903+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szia!

Nagyon jó kis példa, win7 alatt akadt egy k...</title><content type='html'>Szia!&lt;br /&gt;&lt;br /&gt;Nagyon jó kis példa, win7 alatt akadt egy kis problémám a JConsole-al, egyszerűen nem látta a local processeket.&lt;br /&gt;Kis keresgélés után több megoldást is kipróbáltam, ami működött, az az ha az alábbi könyvtárra adunk írási jogot (én teljes hozzáférést adtam mindenkinek):&lt;br /&gt;C:\Users\[LOGIN_NAME]\AppData\Local\Temp\hsperfdata_[LOGIN_NAME]&lt;br /&gt;&lt;br /&gt;A pontos okát nem tudom, annyit írtak, hogy valami windows security miatt van így. Miután ez megoldotta a gondomat, tovább már nem is kutattam utána.&lt;br /&gt;&lt;br /&gt;Gondoltam leírom ide, hátha más is belefut.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6087464391832021768/comments/default/7526736102246769153'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6087464391832021768/comments/default/7526736102246769153'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/11/jmx-peldaprogram.html?showComment=1352730245903#c7526736102246769153' title=''/><author><name>esikgabi</name><uri>http://www.blogger.com/profile/08856705174684355543</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://4.bp.blogspot.com/-xV9SLNjdMfY/TWUjh3GR4pI/AAAAAAAAAfg/HGElLTp2ElE/s1600/android.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/11/jmx-peldaprogram.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6087464391832021768' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6087464391832021768' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1066145208'/><gd:extendedProperty name='blogger.displayTime' value='2012. november 12. 15:24'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-627570996811751446</id><published>2012-11-12T16:44:48.771+01:00</published><updated>2012-11-12T16:44:48.771+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szia!

Nagyon köszönöm, ez igazán hasznos! Igazábó...</title><content type='html'>Szia!&lt;br /&gt;&lt;br /&gt;Nagyon köszönöm, ez igazán hasznos! Igazából mindenkit csak bátorítani tudok, hogy hasonló tapasztalatokat itt megosszon.&lt;br /&gt;&lt;br /&gt;Köszönöm!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6087464391832021768/comments/default/627570996811751446'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6087464391832021768/comments/default/627570996811751446'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/11/jmx-peldaprogram.html?showComment=1352735088771#c627570996811751446' title=''/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/11/jmx-peldaprogram.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6087464391832021768' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6087464391832021768' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2012. november 12. 16:44'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-513687667015762556</id><published>2012-11-16T10:37:20.158+01:00</published><updated>2012-11-16T10:37:20.158+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Valószínűleg a költözés miatt a cikk letöltés link...</title><content type='html'>Valószínűleg a költözés miatt a cikk letöltés link nem működik.&lt;br /&gt;Ugyebár az abszolút URL-ek hátránya...&lt;br /&gt;&lt;br /&gt;A bevezetőben nem volt említve a &amp;quot;tab fülön megnyitás&amp;quot; kérdése, ami a munkamenetet képes teljességgel összezavarni, ha nem RESTes az alkalmazás.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/912143685418710554/comments/default/513687667015762556'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/912143685418710554/comments/default/513687667015762556'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/11/szabad-navigacio-okozta-problemak-webes.html?showComment=1353058640158#c513687667015762556' title=''/><author><name>Schermann Gábor</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/11/szabad-navigacio-okozta-problemak-webes.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-912143685418710554' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/912143685418710554' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1205757454'/><gd:extendedProperty name='blogger.displayTime' value='2012. november 16. 10:37'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-660564583454720283</id><published>2012-11-16T11:10:51.343+01:00</published><updated>2012-11-16T11:10:51.343+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi, javítottam! Sajnos a Bloggerre nem tudok fe...</title><content type='html'>Köszi, javítottam! Sajnos a Bloggerre nem tudok feltölteni fájlokat.&lt;br /&gt;&lt;br /&gt;Igen, ha a felhasználó új ablakot nyit, vagy új tabot, akkor képes összezavarni az alkalmazást. A cikkben kitérek amúgy erre, hogy ablakonként kell külön azonosítót tartani. Amúgy vannak olyan technológiák, amik erre figyelnek, pl. a Flex-ben van külön sessionId, és van egy windowId is.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/912143685418710554/comments/default/660564583454720283'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/912143685418710554/comments/default/660564583454720283'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2011/11/szabad-navigacio-okozta-problemak-webes.html?showComment=1353060651343#c660564583454720283' title=''/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/11/szabad-navigacio-okozta-problemak-webes.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-912143685418710554' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/912143685418710554' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2012. november 16. 11:10'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-9035840927924789153</id><published>2012-12-31T14:07:26.450+01:00</published><updated>2012-12-31T14:07:26.450+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Egész fejezet  szól erről a problémáról: http://mo...</title><content type='html'>Egész fejezet  szól erről a problémáról: http://moly.hu/konyvek/bill-karwin-sql-antipatterns</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7149056741139538034/comments/default/9035840927924789153'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7149056741139538034/comments/default/9035840927924789153'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/08/fa-abrazolasa-adatbazisban.html?showComment=1356959246450#c9035840927924789153' title=''/><author><name>takacsot</name><uri>http://www.blogger.com/profile/04091265918316757733</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/08/fa-abrazolasa-adatbazisban.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7149056741139538034' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7149056741139538034' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-603099388'/><gd:extendedProperty name='blogger.displayTime' value='2012. december 31. 14:07'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-525825334309032906</id><published>2013-01-01T00:05:18.577+01:00</published><updated>2013-01-01T00:05:18.577+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszönöm szépen, ez egy jó tipp, mindenképp el fog...</title><content type='html'>Köszönöm szépen, ez egy jó tipp, mindenképp el fogom olvasni az egész könyvet! Elolvastam az idevágó fejezetét, egyrészt említi a csak bizonyos adatbázisok által támogatott rekurzív lekérdezést (pedig az SQL-99-ben benne van), valamint a Path Enumeration-t, Nested Sets (ez az, amiről írtam), valamint a Closure Table módszereket is.&lt;br /&gt;&lt;br /&gt;Sőt említ könyveket is csak ezzel a témával kapcsolatosan: &lt;a href="http://www.amazon.com/Hierarchies-Smarties-Kaufmann-Management-Systems/dp/1558609202" rel="nofollow"&gt;Joe Celko&amp;#39;s Trees and Hierarchies in SQL for Smarties&lt;/a&gt;</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7149056741139538034/comments/default/525825334309032906'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7149056741139538034/comments/default/525825334309032906'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/08/fa-abrazolasa-adatbazisban.html?showComment=1356995118577#c525825334309032906' title=''/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/08/fa-abrazolasa-adatbazisban.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7149056741139538034' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7149056741139538034' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2013. január 1. 0:05'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6432445397123781146</id><published>2013-01-02T14:13:33.327+01:00</published><updated>2013-01-02T14:13:33.327+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>&amp;quot;a atch Applications&amp;quot;
A B betu elment, h...</title><content type='html'>&amp;quot;a atch Applications&amp;quot;&lt;br /&gt;A B betu elment, hogy a hutobe turkalhasson egy kis kajat, nem eleg nagy meg a hasa... :-)&lt;br /&gt;&lt;br /&gt;Egyebkent hajra, bar orulnek, ha a JSON.org-os referencia implementaciohoz is lenne provider e fole, hogy konnyu legyen a migracio.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7792248082197894811/comments/default/6432445397123781146'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7792248082197894811/comments/default/6432445397123781146'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/12/java-api-for-json-processing.html?showComment=1357132413327#c6432445397123781146' title=''/><author><name>Gabor Garami</name><uri>http://www.blogger.com/profile/15406106695993366523</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_DKmHrnCj1NE/SvSwsBa_ZbI/AAAAAAAAAIs/Krfpmmttbmo/S220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/12/java-api-for-json-processing.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7792248082197894811' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7792248082197894811' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-171155537'/><gd:extendedProperty name='blogger.displayTime' value='2013. január 2. 14:13'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7089370017440616505</id><published>2013-01-02T16:17:17.936+01:00</published><updated>2013-01-02T16:17:17.936+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi, javítottam.

Pontosabban lesz egy referenci...</title><content type='html'>Köszi, javítottam.&lt;br /&gt;&lt;br /&gt;Pontosabban lesz egy referencia implementáció, ami megvalósítja az API-t, és ugyanezt az API-t kell majd a JSON.org-nak is implementálnia. Van esély rá, hiszen ugyanez történt a JPA esetén is, hogy a Hibernate, TopLink, stb. fejlesztői összeültek, kifejlesztették a közös API-t, majd mindegyik implementálta is.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7792248082197894811/comments/default/7089370017440616505'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7792248082197894811/comments/default/7089370017440616505'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/12/java-api-for-json-processing.html?showComment=1357139837936#c7089370017440616505' title=''/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/12/java-api-for-json-processing.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7792248082197894811' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7792248082197894811' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2013. január 2. 16:17'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2487897933037679610</id><published>2013-01-27T00:47:59.056+01:00</published><updated>2013-01-27T00:47:59.056+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nem erted a problemat. Ma a legtobb JSON implement...</title><content type='html'>Nem erted a problemat. Ma a legtobb JSON implementacio a JSON.org -os interfeszt tekinti standardnak, vagyis kb. minden, ami JSON-t hasznal, es tamogatja az implementacio lecsereleset, a JSON.org -os API-t feltetelezi (masik oldalrol pedig nyilvan minden JSON parser a JSON.org-os implementacio feluletet majmolja). &lt;br /&gt;&lt;br /&gt;Ha most jon egy ettol akarmiben eltero API, ami standardda valik, akkor a valamiert nem adaptalodo programok elornek, mint macska a kanyarban telen. Ezert mondtam azt, hogy remelhetoleg lesz e fole egy olyan API, ami leemulalja a JSON.org interfeszt (a szot itt nem a nyelvi interfeszre ertem), vagy minden ilyen API mindket interfeszt biztositani fogja.&lt;br /&gt;&lt;br /&gt;Mondjuk a legjobb megoldas az lenne, ha a JSON.org API valna standardda, ahogy az a JPA eseteben is tortent.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7792248082197894811/comments/default/2487897933037679610'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7792248082197894811/comments/default/2487897933037679610'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/12/java-api-for-json-processing.html?showComment=1359244079056#c2487897933037679610' title=''/><author><name>Gabor Garami</name><uri>http://www.blogger.com/profile/15406106695993366523</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_DKmHrnCj1NE/SvSwsBa_ZbI/AAAAAAAAAIs/Krfpmmttbmo/S220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/12/java-api-for-json-processing.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7792248082197894811' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7792248082197894811' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-171155537'/><gd:extendedProperty name='blogger.displayTime' value='2013. január 27. 0:47'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-418366974886494014</id><published>2013-01-27T08:29:14.379+01:00</published><updated>2013-01-27T08:29:14.379+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Ismételten az ORM példára térnék vissza. A JPA meg...</title><content type='html'>Ismételten az ORM példára térnék vissza. A JPA megjelenésével, illetve azáltal, hogy a Hibernate implementálta ezt az API-t, még a Hibernate-nek megmaradt a saját API-ja is. Tehát idővel át lehetett állni az újra, de még kötelező sem volt.&lt;br /&gt;&lt;br /&gt;Az EclipseLink sem adott a JPA mellé Hibernate API implementációt, csak azért, mert a Hibernate elterjedtebb volt. Mindkettő megvalósította a JPA-t is a sajátja mellett. Sőt, JPA felett lévő Hibernate API-ról sem hallottam, pedig nem is rossz ötlet, Hibernate API-t használni, EclipseLink motorral, melyet egy JPA API fordít át. :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7792248082197894811/comments/default/418366974886494014'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7792248082197894811/comments/default/418366974886494014'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2012/12/java-api-for-json-processing.html?showComment=1359271754379#c418366974886494014' title=''/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2012/12/java-api-for-json-processing.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7792248082197894811' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7792248082197894811' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2013. január 27. 8:29'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2787781862467816982</id><published>2013-02-02T19:01:32.906+01:00</published><updated>2013-02-02T19:01:32.906+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Kiraly cikk! Nagyon jol osszeszedted! Par megjegyz...</title><content type='html'>Kiraly cikk! Nagyon jol osszeszedted! Par megjegyzes:&lt;br /&gt;A flex mar akkor is open source volt evek ota, amikor az apache-hoz koltozott. Mostanaban mindent az apache-nak adnak hogy ha ott se lesz felkapott akkor dogoljon meg.&lt;br /&gt;&lt;br /&gt;Az IDE support ezek szerint meg mindig nem valami popec, Mar akkor is csak vindozra volt, amikor foglalkoztam vele, na meg az is csak sok penzert :( &lt;br /&gt;&lt;br /&gt;Ennek ellenere nekem pozitiv elmeny volt az a kis ido amit foglalkoztam vele, par koncepcio komolyan nagyon tetszett, pl a data binding meg mindig nagyon hianyzik.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6577035106335169594/comments/default/2787781862467816982'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6577035106335169594/comments/default/2787781862467816982'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/02/az-apache-flex-multja-jelene-jovoje.html?showComment=1359828092906#c2787781862467816982' title=''/><author><name>Kocka</name><uri>http://www.blogger.com/profile/10505773298750628833</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='24' height='32' src='http://photos1.blogger.com/x/blogger/3271/703/320/170223/00024.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/02/az-apache-flex-multja-jelene-jovoje.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6577035106335169594' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6577035106335169594' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1842159747'/><gd:extendedProperty name='blogger.displayTime' value='2013. február 2. 19:01'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5790658475092378180</id><published>2013-02-02T21:57:22.477+01:00</published><updated>2013-02-02T21:57:22.477+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi!

Igen, az IDE-ből vagy van az Eclipse alapú...</title><content type='html'>Köszi!&lt;br /&gt;&lt;br /&gt;Igen, az IDE-ből vagy van az Eclipse alapú Flash Builder, immár vizuális szerkesztő nélkül, vagy van a IDEA. A vizuális szerkesztő hiánya nem gáz, gyakorlatilag minden fejlesztő elhagyja a használatát, direktben az MXML-t szerkeszti. (Persze egy drótvázat összedobni nem rossz, de az viszonylag ritkán használható fel újra.) Az IDEA nagyon szépen támogatja, mindent tud, amit Java-ra is. De sajnos aranyárban.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6577035106335169594/comments/default/5790658475092378180'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6577035106335169594/comments/default/5790658475092378180'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/02/az-apache-flex-multja-jelene-jovoje.html?showComment=1359838642477#c5790658475092378180' title=''/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/02/az-apache-flex-multja-jelene-jovoje.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6577035106335169594' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6577035106335169594' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2013. február 2. 21:57'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6310743643330802662</id><published>2013-02-04T11:10:18.655+01:00</published><updated>2013-02-04T11:10:18.655+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A téma nagyon aktuális nálam és ezért különösen ks...</title><content type='html'>A téma nagyon aktuális nálam és ezért különösen kszönöm ezt a remek helyzetleírás és körképet!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6577035106335169594/comments/default/6310743643330802662'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6577035106335169594/comments/default/6310743643330802662'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/02/az-apache-flex-multja-jelene-jovoje.html?showComment=1359972618655#c6310743643330802662' title=''/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/02/az-apache-flex-multja-jelene-jovoje.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6577035106335169594' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6577035106335169594' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1840081121'/><gd:extendedProperty name='blogger.displayTime' value='2013. február 4. 11:10'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8994174157422263131</id><published>2013-02-09T09:09:12.347+01:00</published><updated>2013-02-09T09:09:12.347+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nagyon jopofa technologianak hangzik elsore. Ha te...</title><content type='html'>Nagyon jopofa technologianak hangzik elsore. Ha tenyleg lesz neki maven pluginje, lehet ranezek, de addig nem biztos, hogy szivni szeretnek az SDK-val. &lt;br /&gt;&lt;br /&gt;Amit viszont nagyon fajlalok, az az Adobe teljes kivonulasa a Linux piacrol (except Chrome/Flash). Ez foleg azert problema, mert a legutolso flash player eleg bugosra sikeredett, illetve mert azota semmilyen masfajta flash player nem allt elo megvaltani a vilagot. Az osszes opensource megoldas nagysagrendekkel tobb sebbol verzik, mint az Adobe fele valaha is.&lt;br /&gt;Az AIR gyakorlatilag ugyanez a nota, annyi kulonbseggel, hogy itt semmifele alternativa nincs. &lt;br /&gt;&lt;br /&gt;Ez utobbi foleg azert nagy gond, mert rengeteg kisebb-nagyobb ceg nyitott a Linux fele amikor az elso AIR verziok kijottek oda, akik aztan a vegen hoppon maradtak. Illetve furcsa is az Adobe hozzaallasa egy olyan kornyezetben, ahol mar a Microsoft is jelentos lepeseket tesz az opensource platform tamogatasara. Mara talan a Linux megerett arra a szintre, hogy a gyartok elkezdenek platformkent gondolni ra, es nem hobbiprojektkent. Persze, nagyon sok viz fog lefolyni a Dunan, mire eljon a Linux Desktop eve, talan soha nem jon el, de elkezdett noni a platform tamogatasa, es felek, az Adobe le fog maradni.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6577035106335169594/comments/default/8994174157422263131'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6577035106335169594/comments/default/8994174157422263131'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/02/az-apache-flex-multja-jelene-jovoje.html?showComment=1360397352347#c8994174157422263131' title=''/><author><name>Gábor</name><uri>http://www.blogger.com/profile/16328831533238731170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://3.bp.blogspot.com/-ewx-jYATMUo/Tkchuk0byMI/AAAAAAAAAAY/953les7GhGc/s220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/02/az-apache-flex-multja-jelene-jovoje.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6577035106335169594' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6577035106335169594' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2145961406'/><gd:extendedProperty name='blogger.displayTime' value='2013. február 9. 9:09'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3057427170054605754</id><published>2013-02-09T17:58:47.135+01:00</published><updated>2013-02-09T17:58:47.135+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Gábor, tökéletesen egyetértek veled. Sajnos nem az...</title><content type='html'>Gábor, tökéletesen egyetértek veled. Sajnos nem az Adobe az egyetlen (nagy) cég, amelyik figyelmen kívül hagyja a Linuxot. &lt;br /&gt;&lt;br /&gt;Mindig egy mostanában már elég jól menő cég hozzáállásával szoktam példálózni, ez az Evernote. A következő olvasható a honlapjukon:&lt;br /&gt;&lt;br /&gt;&amp;quot;While we appreciate and value the Linux community, we are a relatively small organization without sufficient resources to build and maintain a native Linux client for Evernote, particularly given the relatively small number of users of the platform in a desktop context.&amp;quot;</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6577035106335169594/comments/default/3057427170054605754'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6577035106335169594/comments/default/3057427170054605754'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/02/az-apache-flex-multja-jelene-jovoje.html?showComment=1360429127135#c3057427170054605754' title=''/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/02/az-apache-flex-multja-jelene-jovoje.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6577035106335169594' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6577035106335169594' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2013. február 9. 17:58'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-973873899970634770</id><published>2013-02-12T22:58:59.559+01:00</published><updated>2013-02-12T22:58:59.559+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Tudod, sokszor azt kivanom, bar figyelmen kivul ha...</title><content type='html'>Tudod, sokszor azt kivanom, bar figyelmen kivul hagyta volna a Linuxot. Egy ismeretlen ember kozonye kevesbe faj, mint egy olyane, akivel korabban megjartatok a haloszobat is.&lt;br /&gt;&lt;br /&gt;Vagyis nekem nem az otthagyassal van a bajom. Nem volt eroforrasuk: oke. De ezt a legtobbszor nem utolag talaljak ki, hanem mar elore ugy szokas kommunikalni: emberek, ez egy low-cost projekt, mivel a platform kicsi. Ezt mindenki megerti, es senkit nem er varatlanul, ha hoppon marad. Amit az Adobe csinalt, az legalabbis gusztustalan, amennyiben egre-foldre hirdette, hogy milyen fontos szamara a Linux, mint platform. Ez inkabb marketing hiba, persze - de ettol meg nem lesz jobb az Adobe megitelese.&lt;br /&gt;&lt;br /&gt;Na mindegy, a frusztraciom elegge offtopik ebben a blogban.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6577035106335169594/comments/default/973873899970634770'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6577035106335169594/comments/default/973873899970634770'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/02/az-apache-flex-multja-jelene-jovoje.html?showComment=1360706339559#c973873899970634770' title=''/><link rel='related' type='application/atom+xml' href='http://www.blogger.com/feeds/7370998606556338092/6577035106335169594/comments/default/3057427170054605754'/><author><name>Gábor</name><uri>http://www.blogger.com/profile/16328831533238731170</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://3.bp.blogspot.com/-ewx-jYATMUo/Tkchuk0byMI/AAAAAAAAAAY/953les7GhGc/s220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/02/az-apache-flex-multja-jelene-jovoje.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6577035106335169594' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6577035106335169594' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2145961406'/><gd:extendedProperty name='blogger.displayTime' value='2013. február 12. 22:58'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5972453376959259783</id><published>2013-03-01T15:20:09.106+01:00</published><updated>2013-03-01T15:20:09.106+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Kedves István!

Van Websphere Brokerben /MQ -ban l...</title><content type='html'>Kedves István!&lt;br /&gt;&lt;br /&gt;Van Websphere Brokerben /MQ -ban lehetőség arra, hogy a BOQ-ból ne kézzel, hanem programból, esetleg valamilyen automatizmus hatására kerüljenek vissza az &amp;quot;elbekáutolt&amp;quot; üzenetek az input Q-ba?&lt;br /&gt;&lt;br /&gt;Programból úgy gondolom, hogy a Q-kat használó program szerint már a feltételek adottak a végrehajtásra, ekkor kerülhetnének vissza az input Q-ba az üzenetek a BOQ-ból. &lt;br /&gt;&lt;br /&gt;Előre is köszönöm</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4180001514533033810/comments/default/5972453376959259783'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4180001514533033810/comments/default/5972453376959259783'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/09/ibm-websphere-mq.html?showComment=1362147609106#c5972453376959259783' title=''/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/09/ibm-websphere-mq.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4180001514533033810' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4180001514533033810' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1943226422'/><gd:extendedProperty name='blogger.displayTime' value='2013. március 1. 15:20'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1707818434906728265</id><published>2013-03-01T15:32:24.077+01:00</published><updated>2013-03-01T15:32:24.077+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Üdv,

Erről szól egy másik cikkem:

http://jtechlo...</title><content type='html'>Üdv,&lt;br /&gt;&lt;br /&gt;Erről szól egy másik cikkem:&lt;br /&gt;&lt;br /&gt;http://jtechlog.blogspot.hu/2010/04/mergezett-uzenetek.html</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4180001514533033810/comments/default/1707818434906728265'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4180001514533033810/comments/default/1707818434906728265'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/09/ibm-websphere-mq.html?showComment=1362148344077#c1707818434906728265' title=''/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/09/ibm-websphere-mq.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4180001514533033810' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4180001514533033810' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2013. március 1. 15:32'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2765066733230031679</id><published>2013-03-01T15:51:43.660+01:00</published><updated>2013-03-01T15:51:43.660+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Üdv,

lehet, én voltam figyelmetlen, de már végigo...</title><content type='html'>Üdv,&lt;br /&gt;&lt;br /&gt;lehet, én voltam figyelmetlen, de már végigolvastam azt a cikked, és csak kézi megoldást találtam ott, illetve treshold beállítást.&lt;br /&gt;&lt;br /&gt;De olyat nem, hogy ondemand kerüljenek vissza a BOQ-ból az inputba.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4180001514533033810/comments/default/2765066733230031679'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4180001514533033810/comments/default/2765066733230031679'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/09/ibm-websphere-mq.html?showComment=1362149503660#c2765066733230031679' title=''/><link rel='related' type='application/atom+xml' href='http://www.blogger.com/feeds/7370998606556338092/4180001514533033810/comments/default/1707818434906728265'/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/09/ibm-websphere-mq.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4180001514533033810' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4180001514533033810' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1943226422'/><gd:extendedProperty name='blogger.displayTime' value='2013. március 1. 15:51'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5124130126033479327</id><published>2013-03-01T16:34:31.624+01:00</published><updated>2013-03-01T16:34:31.624+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Akkor nem is lenne értelme a BOQ-nak, ha odakerüln...</title><content type='html'>Akkor nem is lenne értelme a BOQ-nak, ha odakerülnek, majd vissza a Q-ba. Akkor ugyanúgy végtelen ciklus lenne. Ez a mechanizmus pont arra való, hogy ha hiba van, az üzenetek a BOQ-ba kerülnek, és ha kijavítod a hibát, akkor kézzel (alkalmazással) pakolod vissza őket. Tehát egy üzemeltetői beavatkozás mindenképp szükséges. Persze ugyanolyan Q az is, mint a többi, tehát lehet tenni rá funkcionalitást, hogy kézzel belökve kerüljenek vissza.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4180001514533033810/comments/default/5124130126033479327'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4180001514533033810/comments/default/5124130126033479327'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/09/ibm-websphere-mq.html?showComment=1362152071624#c5124130126033479327' title=''/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/09/ibm-websphere-mq.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4180001514533033810' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4180001514533033810' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2013. március 1. 16:34'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6589299719176802221</id><published>2013-03-02T12:02:37.900+01:00</published><updated>2013-03-02T12:02:37.900+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszönöm a választ! És gratulálok a blogodhoz!

Tö...</title><content type='html'>Köszönöm a választ! És gratulálok a blogodhoz!&lt;br /&gt;&lt;br /&gt;Több lábas környezetben fut az egyik alkalmazásunk, és szinte biztos, hogy az üzenetet feldolgozó modul néha nem fogja elérni a háttérrendszereket. Ilyenkor vagy elszáll(RunTimeException--&amp;gt;BOQ), vagy a program átpakolja egy temp queue-ba az üzeneteket, és onnan kell majd visszapakolni.&lt;br /&gt;&lt;br /&gt;Volna egy olyan megoldás is, hogy ilyenkor leállítja a modul a Springes listenert, hogy ne vegye ki a Q-ból az üzeneteket addig, amíg gond van a háttérrendszer(ek)kel. &lt;br /&gt;Ez az, amire nem jöttünk rá: tudsz olyan megoldást, amivel minden lábon le lehet állítani a Springes listenereket?&lt;br /&gt;A gond ugye ott kezdődik, hogy ezek a lábak nem tudnak egymásról...</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4180001514533033810/comments/default/6589299719176802221'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4180001514533033810/comments/default/6589299719176802221'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2009/09/ibm-websphere-mq.html?showComment=1362222157900#c6589299719176802221' title=''/><link rel='related' type='application/atom+xml' href='http://www.blogger.com/feeds/7370998606556338092/4180001514533033810/comments/default/5124130126033479327'/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2009/09/ibm-websphere-mq.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4180001514533033810' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4180001514533033810' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-887334498'/><gd:extendedProperty name='blogger.displayTime' value='2013. március 2. 12:02'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3322580466434082560</id><published>2013-05-21T13:15:57.346+02:00</published><updated>2013-05-21T13:15:57.346+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>na én még sose gondoltam semmi ilyesmit.. :) az ex...</title><content type='html'>na én még sose gondoltam semmi ilyesmit.. :) az exkollégának viszont nagy kalappal, sok sikert!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3351568542494398544/comments/default/3322580466434082560'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3351568542494398544/comments/default/3322580466434082560'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/05/ut-szolobe.html?showComment=1369134957346#c3322580466434082560' title=''/><author><name>Kristof Jozsa</name><uri>http://www.blogger.com/profile/06607669172500255805</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/05/ut-szolobe.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3351568542494398544' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3351568542494398544' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-686590949'/><gd:extendedProperty name='blogger.displayTime' value='2013. május 21. 13:15'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3116017524468473411</id><published>2013-05-24T14:14:08.921+02:00</published><updated>2013-05-24T14:14:08.921+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Keserves melo lehet azert Irorszagig elhajtani 100...</title><content type='html'>Keserves melo lehet azert Irorszagig elhajtani 1000 birkat. Nem tudom is tudnak-e annyit uszni.&lt;br /&gt;&lt;br /&gt;De ertem az otletet, egyszer en is falhoz vagom az egeret</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3351568542494398544/comments/default/3116017524468473411'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3351568542494398544/comments/default/3116017524468473411'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/05/ut-szolobe.html?showComment=1369397648921#c3116017524468473411' title=''/><author><name>Kocka</name><uri>http://www.blogger.com/profile/10505773298750628833</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='24' height='32' src='http://photos1.blogger.com/x/blogger/3271/703/320/170223/00024.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/05/ut-szolobe.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3351568542494398544' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3351568542494398544' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1842159747'/><gd:extendedProperty name='blogger.displayTime' value='2013. május 24. 14:14'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4183897161615668797</id><published>2013-05-31T16:02:27.628+02:00</published><updated>2013-05-31T16:02:27.628+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Skot kollegam meselt szepeket arrol mi is tortenik...</title><content type='html'>Skot kollegam meselt szepeket arrol mi is tortenik ezekben a falvakban ahol lakik 25 ember es van 1 millio birka :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3351568542494398544/comments/default/4183897161615668797'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3351568542494398544/comments/default/4183897161615668797'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/05/ut-szolobe.html?showComment=1370008947628#c4183897161615668797' title=''/><author><name>György Szimeonov</name><uri>http://www.blogger.com/profile/12129665373296785371</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/05/ut-szolobe.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3351568542494398544' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3351568542494398544' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-871390908'/><gd:extendedProperty name='blogger.displayTime' value='2013. május 31. 16:02'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8439286067876823567</id><published>2013-08-12T23:14:13.536+02:00</published><updated>2014-01-18T15:52:11.351+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'></title><content type='html'>Ezt a megjegyzést eltávolította a szerző.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/8439286067876823567'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3752345250697097633/comments/default/8439286067876823567'/><author><name>Kornél Kiss</name><uri>http://www.blogger.com/profile/10186062112736043714</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh3.googleusercontent.com/-j1YE0oht6X4/AAAAAAAAAAI/AAAAAAAAABc/g0e3QPj8UU0/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2011/06/masodik-nyelv-python.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3752345250697097633' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3752345250697097633' type='text/html'/><gd:extendedProperty name='blogger.contentRemoved' value='true'/><gd:extendedProperty name='blogger.itemClass' value='pid-1569591111'/><gd:extendedProperty name='blogger.displayTime' value='2013. augusztus 12. 23:14'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2646935296996042238</id><published>2013-11-01T13:47:57.521+01:00</published><updated>2013-11-01T13:47:57.521+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Ez elképesztő :)</title><content type='html'>Ez elképesztő :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3351568542494398544/comments/default/2646935296996042238'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3351568542494398544/comments/default/2646935296996042238'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/05/ut-szolobe.html?showComment=1383310077521#c2646935296996042238' title=''/><author><name>butcher</name><uri>http://www.blogger.com/profile/00286133874500783936</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/05/ut-szolobe.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3351568542494398544' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3351568542494398544' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1435084483'/><gd:extendedProperty name='blogger.displayTime' value='2013. november 1. 13:47'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-850985903101116307</id><published>2013-11-11T12:47:01.127+01:00</published><updated>2013-11-11T12:47:01.127+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Mi Grails-t használunk, bár nem az általad megjelö...</title><content type='html'>Mi Grails-t használunk, bár nem az általad megjelölt területen, ettöl függetlenül nekem pont az a mérhetetlen szabadság fogott meg benne, amit a Groovy,  a pluginek, és az outputok széles választéka adnak. Egyetlen annotáció elhelyezésével a domain osztályon teljes REST stack jön létre akár JSON akár XML ki és bemenettel, amivel lehet CRUD-olni a domain osztályt (ezt Controller szinten is meg lehet csinálni természetesen), vagy egy mozdulattal lehet a tetszőleges osztályból JSON vagy XML outputot generálni. Ennek fényében a GSP-re egyáltalán nincs szükség ízlés dolga. A plugineknek hála, amik bár aluldokumentáltak, de legalább stabilan működnek, nagyon sok irányba el lehet vinni az alkalmazást, nincs megkötve a fejlesztők keze. Nem hiszem azt, hogy a szent grál a rendszer, de rengeteg problémára igen hatákony és rugalmas eszköz.&lt;br /&gt;&lt;br /&gt;Mostanában szemezgettem a Griffon (http://groovy.codehaus.org/Griffon), bár személyes tapasztalatot még nem gyűjtöttem be, egy próbát mindenféleképpen megér. </content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/850985903101116307'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/850985903101116307'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html?showComment=1384170421127#c850985903101116307' title=''/><author><name>Richárd Kovács</name><uri>http://www.blogger.com/profile/06849753526791080950</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh3.googleusercontent.com/-tot8TfbGAJs/AAAAAAAAAAI/AAAAAAAAAvg/5qkBKyA1ISg/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-501890045491464373' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/501890045491464373' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-196939700'/><gd:extendedProperty name='blogger.displayTime' value='2013. november 11. 12:47'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5143545761203215778</id><published>2013-11-11T13:36:51.565+01:00</published><updated>2013-11-11T13:36:51.565+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A JUM-os előadásod vastagon benne volt abban, hogy...</title><content type='html'>A JUM-os előadásod vastagon benne volt abban, hogy a Grails-nek nekiálltam. :) http://wiki.javaforum.hu/display/JAVAFORUM/JUM1209&lt;br /&gt;&lt;br /&gt;Ez a Griffon jó találat!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/5143545761203215778'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/5143545761203215778'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html?showComment=1384173411565#c5143545761203215778' title=''/><link rel='related' type='application/atom+xml' href='http://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/850985903101116307'/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-501890045491464373' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/501890045491464373' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2013. november 11. 13:36'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-670273073518033031</id><published>2013-11-11T14:01:26.867+01:00</published><updated>2013-11-11T14:01:26.867+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Vastagkliens nem bejövős, mi is irtjuk. Nem szeret...</title><content type='html'>Vastagkliens nem bejövős, mi is irtjuk. Nem szeretik a kliensek, ha installálgatniuk kell. Ugyanezért nem szereti a support sem. A válaszidővel kapcsolatban az van, hogy sok helyen már az intranet is országokon ível át, szóval ha sok a pingpongozás a szerverrel, elfogadhatatlanul lassú lesz a GUI.&lt;br /&gt;&lt;br /&gt;Annó az Echo-t próbálgattuk, viszonylag bejött. http://echo.nextapp.com/site/ Főleg intranet alkalmazásokhoz jó. Java-ban kell programozni, szerveroldali renderelés van.&lt;br /&gt;&lt;br /&gt;Jelenlegi melóhelyemen saját GUI keretrendszert használunk, ami 1-2 év múlva talán open source lesz.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/670273073518033031'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/670273073518033031'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html?showComment=1384174886867#c670273073518033031' title=''/><author><name>tvik</name><uri>http://kodzaj.blog.hu</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-501890045491464373' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/501890045491464373' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1368951012'/><gd:extendedProperty name='blogger.displayTime' value='2013. november 11. 14:01'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7390557094165998500</id><published>2013-11-11T14:32:44.216+01:00</published><updated>2013-11-11T14:32:44.216+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A vastag kliens esetén nekünk sokat segített a Jav...</title><content type='html'>A vastag kliens esetén nekünk sokat segített a Java Web Start, ennek használatával csak a JRE telepítését kell megoldani.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/7390557094165998500'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/7390557094165998500'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html?showComment=1384176764216#c7390557094165998500' title=''/><link rel='related' type='application/atom+xml' href='http://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/670273073518033031'/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-501890045491464373' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/501890045491464373' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2013. november 11. 14:32'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7958850693084342379</id><published>2013-11-12T11:21:02.434+01:00</published><updated>2013-11-12T11:21:02.434+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>&amp;quot;Ó, mondd, te kit választanál?&amp;quot;
Ha a kli...</title><content type='html'>&amp;quot;Ó, mondd, te kit választanál?&amp;quot;&lt;br /&gt;Ha a kliensoldalon csak pucér böngészőben futó JS/HTML jöhet szóba, akkor az már a lehetséges jelöltek számát csökkenti, de a következő szempont (nálam) a meglévő tudásbázist lenne. Úgyse látok a jövőbe, bármilyen technológia mehet a süllyesztőben elég rövid idő alatt.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/7958850693084342379'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/7958850693084342379'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html?showComment=1384251662434#c7958850693084342379' title=''/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-501890045491464373' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/501890045491464373' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1898869915'/><gd:extendedProperty name='blogger.displayTime' value='2013. november 12. 11:21'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-654486513148715764</id><published>2013-11-13T18:23:43.167+01:00</published><updated>2013-11-13T18:23:43.167+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Wicket+Bootstrap3 gyakorlatilag minden kommunikáci...</title><content type='html'>Wicket+Bootstrap3 gyakorlatilag minden kommunikáció ajax.&lt;br /&gt;Kellett vele dolgozni, de megérte. Kliens oldalról a komponensek kivételével minden logikát el lehetett vinni szerver oldalra, és a wicket felépítése miatt sitebuilderek is hozzá tudnak nyúlni.&lt;br /&gt;Bootstrap segítségével különböző méretű kijelzőkön is elfogadható.&lt;br /&gt;Mondjuk egy szerkesztő nagyon hiányzik hozzá.&lt;br /&gt;Élesben a wicket-bootstrap integráció gyenge volta miatt nem ajánlom.&lt;br /&gt;</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/654486513148715764'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/654486513148715764'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html?showComment=1384363423167#c654486513148715764' title=''/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-501890045491464373' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/501890045491464373' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-862747594'/><gd:extendedProperty name='blogger.displayTime' value='2013. november 13. 18:23'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2316787289950046788</id><published>2013-11-19T19:57:56.680+01:00</published><updated>2013-11-19T19:57:56.680+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Mi EJB3 + Eclipse RCP kombóval megyünk. Kliens tel...</title><content type='html'>Mi EJB3 + Eclipse RCP kombóval megyünk. Kliens telepítés web start-tal, update pedig headless P2-val megy. Teljesen korrektül működik.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/2316787289950046788'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/2316787289950046788'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html?showComment=1384887476680#c2316787289950046788' title=''/><link rel='related' type='application/atom+xml' href='http://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/670273073518033031'/><author><name>László Egerszegi</name><uri>http://www.blogger.com/profile/06071924289806778048</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-501890045491464373' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/501890045491464373' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-318128818'/><gd:extendedProperty name='blogger.displayTime' value='2013. november 19. 19:57'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7507661840963741223</id><published>2013-12-01T18:09:53.445+01:00</published><updated>2013-12-01T18:09:53.445+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Thymeleaf SpringMVC párosról esetleg vélemény? JSF...</title><content type='html'>Thymeleaf SpringMVC párosról esetleg vélemény? JSF-ről úgy gondolom parasztvatiktás, hogy jaj milyen szép komponens paletták vannak (pl. PF)  és hogy magától megy az ajax stb. de amikor saját komponoensek kellenének akkor meg sz....s a köbön, miközben html+css3+jquery-vel triviális a probléma. Azért megjegyezném ez a HTML5 beharangozás is messze áll a tökéletestől. Magam is használtam az Adobe féle fxml+actionscript+css hármast és megvoltam elégedve vele, de az Apple sajnos tényleg jól kibaszott velük, mert hogy ők inkább ezt a csodás html5-t támogatják ugye.  Vaadin testszik, de nekem nincs kedvem javaban GUI-t írni, nagyon hiányzik a dekleratív nyelv hozzá.  De ha lenne akkor sem biztos, hogy használnám. A JavaFX-ről meg annyit, hogy még tényleg gyerekcipőben jár, és siralmas a paletta készlet valamint szerintem elég nehézkes a használata, performancia problémákról nem is beszélek.&lt;br /&gt;&lt;br /&gt;Bootstrap3 és CSS3-al tényleg jól lehet responsive html oldalalt összedobni.&lt;br /&gt;&lt;br /&gt;Viczián István köszönöm ezt a blogbejegyzést. Most végre megnyugodtam, hogy nem csak mi nem látjuk a tökéletest. </content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/7507661840963741223'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/7507661840963741223'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html?showComment=1385917793445#c7507661840963741223' title=''/><author><name>Gubancs</name><uri>http://www.blogger.com/profile/14818609464092826865</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='28' height='32' src='http://4.bp.blogspot.com/-RMMrr3AqbdQ/TW15ygC6B0I/AAAAAAAAACc/zXIyu1a9JAk/s220/gabor.kokeny.PNG'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-501890045491464373' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/501890045491464373' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-748861521'/><gd:extendedProperty name='blogger.displayTime' value='2013. december 1. 18:09'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4028349107865053025</id><published>2013-12-01T19:59:04.224+01:00</published><updated>2013-12-01T19:59:04.224+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A Thymeleafre mindig ránézek, és sosem érzem, hogy...</title><content type='html'>A Thymeleafre mindig ránézek, és sosem érzem, hogy miért kéne a jól működő JSP-t vagy Velocity-t leváltanom rá. Mi az ami annyival jobb benne?&lt;br /&gt;&lt;br /&gt;Örülök, hogy egyet értünk! De még jobban örülnék, ha mindketten megtalálnánk az igényeinknek megfelelő keretrendszert, mely nem késztet kompromisszumokra. :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/4028349107865053025'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/4028349107865053025'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html?showComment=1385924344224#c4028349107865053025' title=''/><link rel='related' type='application/atom+xml' href='http://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/7507661840963741223'/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-501890045491464373' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/501890045491464373' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2013. december 1. 19:59'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2964150241892459137</id><published>2013-12-13T16:44:12.312+01:00</published><updated>2013-12-13T16:44:12.312+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>ZK-t kihagytad, vajon miért? :D</title><content type='html'>ZK-t kihagytad, vajon miért? :D</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/2964150241892459137'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/2964150241892459137'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html?showComment=1386949452312#c2964150241892459137' title=''/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-501890045491464373' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/501890045491464373' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1162080078'/><gd:extendedProperty name='blogger.displayTime' value='2013. december 13. 16:44'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5247386603693975996</id><published>2013-12-13T17:06:05.394+01:00</published><updated>2013-12-13T17:06:05.394+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nem volt semmilyen okom. Van gyakorlati tapasztala...</title><content type='html'>Nem volt semmilyen okom. Van gyakorlati tapasztalatod?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/5247386603693975996'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/5247386603693975996'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html?showComment=1386950765394#c5247386603693975996' title=''/><link rel='related' type='application/atom+xml' href='http://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/2964150241892459137'/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-501890045491464373' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/501890045491464373' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2013. december 13. 17:06'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1359755216732766103</id><published>2013-12-13T19:09:59.608+01:00</published><updated>2013-12-13T19:09:59.608+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nézz rá, xml- leíró, javascript bind, vagy akár ja...</title><content type='html'>Nézz rá, xml- leíró, javascript bind, vagy akár java server oldal esetleg jsp vagy webservice integráció.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/1359755216732766103'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/1359755216732766103'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html?showComment=1386958199608#c1359755216732766103' title=''/><link rel='related' type='application/atom+xml' href='http://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/2964150241892459137'/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-501890045491464373' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/501890045491464373' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1162080078'/><gd:extendedProperty name='blogger.displayTime' value='2013. december 13. 19:09'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2714089139560719401</id><published>2013-12-25T17:43:25.341+01:00</published><updated>2013-12-25T17:43:25.341+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nikojava blogjat ketszer linkelted :-)

Egyebkent ...</title><content type='html'>Nikojava blogjat ketszer linkelted :-)&lt;br /&gt;&lt;br /&gt;Egyebkent grat, igy utolag is.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8235707600371192448/comments/default/2714089139560719401'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8235707600371192448/comments/default/2714089139560719401'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/11/web-component-developer.html?showComment=1387989805341#c2714089139560719401' title=''/><author><name>Gabor Garami</name><uri>http://www.blogger.com/profile/15406106695993366523</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_DKmHrnCj1NE/SvSwsBa_ZbI/AAAAAAAAAIs/Krfpmmttbmo/S220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/11/web-component-developer.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8235707600371192448' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8235707600371192448' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-171155537'/><gd:extendedProperty name='blogger.displayTime' value='2013. december 25. 17:43'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6280550622998712666</id><published>2013-12-25T18:05:01.248+01:00</published><updated>2013-12-25T18:05:01.248+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Szerintem a Thymeleaf affele izlesek es pofonok vo...</title><content type='html'>Szerintem a Thymeleaf affele izlesek es pofonok volgye, nem erdemes sokat vitazni rajta. Megmondom oszinten, engem nem nagyon fogott meg a Velocity, a JSP meg szamomra nehezkes, foleg, hogy en alapvetoen inkabb a JSPX iranyt favorizalnam, ami meg egy pottyet aluldokumentalt, minden pelda JSP-re van megadva, es koroket kell csapni, hogy atportold JSPX-re - aztan vagy mukodik a naiv modon atirt kod, vagy nem, raadasul nem mindig van az embernek ideje/turelme _mindent_ atportolni. A Thymeleaf tenyleg megadja azt a szabadsagot, hogy atveszem a frontendestol a HTML kepernyoket, beleirom a Thymeleaf tageket, es koszonjuk. Adott esetben egy-az-egyben visszaadom a frontendesnek a HTML-t, hogy lecci, itt el van csuszva a betu, javitsd ki. Ez meggyorsitja annyival a fejlesztest, hogy erdemes elgondolkodni rajta.&lt;br /&gt;&lt;br /&gt;Nyilvan korbe kell tesztelni, kell egy pici projektet talalni, ahol ki lehet probalni a lehetosegeit. En azonban latok benne fantaziat, raadasul jol integralodik Springgel...</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/6280550622998712666'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/6280550622998712666'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html?showComment=1387991101248#c6280550622998712666' title=''/><link rel='related' type='application/atom+xml' href='http://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/7507661840963741223'/><author><name>Gabor Garami</name><uri>http://www.blogger.com/profile/15406106695993366523</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_DKmHrnCj1NE/SvSwsBa_ZbI/AAAAAAAAAIs/Krfpmmttbmo/S220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-501890045491464373' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/501890045491464373' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-171155537'/><gd:extendedProperty name='blogger.displayTime' value='2013. december 25. 18:05'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5792360044194973565</id><published>2013-12-25T20:34:19.290+01:00</published><updated>2013-12-25T20:34:19.290+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi, javítottam. Te is karácsonyi szünetben póto...</title><content type='html'>Köszi, javítottam. Te is karácsonyi szünetben pótolod az olvasnivalókat? :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8235707600371192448/comments/default/5792360044194973565'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8235707600371192448/comments/default/5792360044194973565'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/11/web-component-developer.html?showComment=1388000059290#c5792360044194973565' title=''/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/11/web-component-developer.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8235707600371192448' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8235707600371192448' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2013. december 25. 20:34'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6596343276819072479</id><published>2013-12-25T20:37:26.964+01:00</published><updated>2013-12-25T20:37:26.964+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A JSPX irányt a Web Component Developer vizsga jól...</title><content type='html'>A JSPX irányt a Web Component Developer vizsga jól a fejedbe veri. :) Amúgy kényelmetlenebb, biztos nem jó irány.&lt;br /&gt;&lt;br /&gt;Az írásod alapján azért nem vagyok nyitott a Thymeleafre, mert nem dolgozom frontendessel, és szeretem a JSP-t. :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/6596343276819072479'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/6596343276819072479'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html?showComment=1388000246964#c6596343276819072479' title=''/><link rel='related' type='application/atom+xml' href='http://www.blogger.com/feeds/7370998606556338092/501890045491464373/comments/default/7507661840963741223'/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/11/milyen-gui-keretrendszert-szeretnek.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-501890045491464373' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/501890045491464373' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2013. december 25. 20:37'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2303241423360127193</id><published>2014-01-06T23:23:25.180+01:00</published><updated>2014-01-06T23:23:25.180+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>http://infokukac.com 8-)</title><content type='html'>http://infokukac.com 8-)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3812191713339137641/comments/default/2303241423360127193'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3812191713339137641/comments/default/2303241423360127193'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/01/forrasok.html?showComment=1389047005180#c2303241423360127193' title=''/><author><name>Marhefka, István</name><uri>http://www.blogger.com/profile/13620561176122999497</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://1.bp.blogspot.com/_jQEHa8Ux_1I/S0eMU6t8VsI/AAAAAAAACrA/YBThKPpIonM/S220/karpatalja24.JPG'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/01/forrasok.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3812191713339137641' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3812191713339137641' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1963072178'/><gd:extendedProperty name='blogger.displayTime' value='2014. január 6. 23:23'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-380861005824049070</id><published>2014-01-06T23:32:27.941+01:00</published><updated>2014-01-06T23:32:27.941+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Az &amp;quot;Elektronikus aláírás és társai&amp;quot; című...</title><content type='html'>Az &amp;quot;Elektronikus aláírás és társai&amp;quot; című könyvet Almási Jánosként írtam. :) Lásd: &lt;br /&gt;http://www.sansserif.hu/ealairas/konyv.htm</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6190185992411799485/comments/default/380861005824049070'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6190185992411799485/comments/default/380861005824049070'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/12/minstett-elektronikus-alrs.html?showComment=1389047547941#c380861005824049070' title=''/><author><name>János Almási</name><uri>http://www.blogger.com/profile/03236144431628377437</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh3.googleusercontent.com/-zq3yYIqxV9s/AAAAAAAAAAI/AAAAAAAAACs/-j0m0aBY_yA/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2008/12/minstett-elektronikus-alrs.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6190185992411799485' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6190185992411799485' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-307800372'/><gd:extendedProperty name='blogger.displayTime' value='2014. január 6. 23:32'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4607648122963432940</id><published>2014-01-06T23:33:59.679+01:00</published><updated>2014-01-06T23:33:59.679+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Tudod, hogy olvasom! :) Agyaltam is rajta, hogy be...</title><content type='html'>Tudod, hogy olvasom! :) Agyaltam is rajta, hogy bekerüljön-e, de nem Java, és régen írtál. De most azért betettem. :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3812191713339137641/comments/default/4607648122963432940'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3812191713339137641/comments/default/4607648122963432940'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/01/forrasok.html?showComment=1389047639679#c4607648122963432940' title=''/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/01/forrasok.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3812191713339137641' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3812191713339137641' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2014. január 6. 23:33'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-9200209700566402484</id><published>2014-01-06T23:42:52.328+01:00</published><updated>2014-01-06T23:42:52.328+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Kedves János! Elnézést a hibáért, javítottam. Nem ...</title><content type='html'>Kedves János! Elnézést a hibáért, javítottam. Nem is tudom, hogy hibázhattam, hiszen itt van a könyv a polcomon, és gyakran olvasom is. Még személyesen öntől kaptam, azóta is sajnálom, hogy nem kértem bele egy (nem elektronikus) aláírást. :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6190185992411799485/comments/default/9200209700566402484'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/6190185992411799485/comments/default/9200209700566402484'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/12/minstett-elektronikus-alrs.html?showComment=1389048172328#c9200209700566402484' title=''/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2008/12/minstett-elektronikus-alrs.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-6190185992411799485' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/6190185992411799485' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2014. január 6. 23:42'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8997970661583979498</id><published>2014-01-08T20:17:37.070+01:00</published><updated>2014-01-08T20:17:37.070+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>szegény microsec ismer vajon ukránokat ? :)</title><content type='html'>szegény microsec ismer vajon ukránokat ? :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3812297852319041819/comments/default/8997970661583979498'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3812297852319041819/comments/default/8997970661583979498'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/12/pdf-elektronikus-alairasa-es.html?showComment=1389208657070#c8997970661583979498' title=''/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/12/pdf-elektronikus-alairasa-es.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3812297852319041819' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3812297852319041819' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1986707104'/><gd:extendedProperty name='blogger.displayTime' value='2014. január 8. 20:17'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7470282852368148383</id><published>2014-01-08T20:47:59.638+01:00</published><updated>2014-01-08T20:47:59.638+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Előző cikkemből: &amp;quot;(Zárójelben megjegyzem, hog...</title><content type='html'>Előző cikkemből: &amp;quot;(Zárójelben megjegyzem, hogy ugyanilyen teszt tanúsítvány a Microsec honlapjáról is letölthető.)&amp;quot;&lt;br /&gt;&lt;br /&gt;Amúgy próbáltam a Microsec tanúsítvánnyal és időbélyeggel is, és szépen működött. Ott annyi izgalom van, hogy https-en kell menni, ezért annak tanúsítványát is be kell tenni a truststore-ba, valamint felhasználónév és jelszó megadása is kötelező.&lt;br /&gt;&lt;br /&gt;Amúgy az időbélyegről szóló oldaluk sokkal informatívabb: https://srv.e-szigno.hu/index.php?lap=idobelyeg&lt;br /&gt;&lt;br /&gt;(Így már megmaradok? :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3812297852319041819/comments/default/7470282852368148383'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3812297852319041819/comments/default/7470282852368148383'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/12/pdf-elektronikus-alairasa-es.html?showComment=1389210479638#c7470282852368148383' title=''/><link rel='related' type='application/atom+xml' href='http://www.blogger.com/feeds/7370998606556338092/3812297852319041819/comments/default/8997970661583979498'/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/12/pdf-elektronikus-alairasa-es.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3812297852319041819' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3812297852319041819' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2014. január 8. 20:47'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6708301313088362170</id><published>2014-01-12T04:39:14.869+01:00</published><updated>2014-01-12T04:39:14.869+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Nekem is ott vagy a feedemben. Tessek kicsit gyakr...</title><content type='html'>Nekem is ott vagy a feedemben. Tessek kicsit gyakrabban irni :-)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3812191713339137641/comments/default/6708301313088362170'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3812191713339137641/comments/default/6708301313088362170'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/01/forrasok.html?showComment=1389497954869#c6708301313088362170' title=''/><link rel='related' type='application/atom+xml' href='http://www.blogger.com/feeds/7370998606556338092/3812191713339137641/comments/default/2303241423360127193'/><author><name>Gabor Garami</name><uri>http://www.blogger.com/profile/15406106695993366523</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_DKmHrnCj1NE/SvSwsBa_ZbI/AAAAAAAAAIs/Krfpmmttbmo/S220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/01/forrasok.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3812191713339137641' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3812191713339137641' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-171155537'/><gd:extendedProperty name='blogger.displayTime' value='2014. január 12. 4:39'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4851254652255142504</id><published>2014-01-12T08:46:38.243+01:00</published><updated>2014-01-12T08:46:38.243+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Azért írtam, mer nekik pont erre van termékük. Sze...</title><content type='html'>Azért írtam, mer nekik pont erre van termékük. Szerver, kliens, webes. De lehet hogy ukránok helyett egy irodát kapsz és egy LiveCD-t .net fraework 9-cel : (Nem java-zz inkább, jobb lesz nekik) :)&lt;br /&gt;&lt;br /&gt;Esetleg egy Hawaii nyaralót kapsz K+F-es projecttel, internet elérés nélkül :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3812297852319041819/comments/default/4851254652255142504'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3812297852319041819/comments/default/4851254652255142504'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/12/pdf-elektronikus-alairasa-es.html?showComment=1389512798243#c4851254652255142504' title=''/><link rel='related' type='application/atom+xml' href='http://www.blogger.com/feeds/7370998606556338092/3812297852319041819/comments/default/8997970661583979498'/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/12/pdf-elektronikus-alairasa-es.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3812297852319041819' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3812297852319041819' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1481325835'/><gd:extendedProperty name='blogger.displayTime' value='2014. január 12. 8:46'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8198467334433606244</id><published>2014-01-12T21:26:46.953+01:00</published><updated>2014-01-12T21:26:46.953+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A másik cikkemben írtam, hogy legalább hét cég van...</title><content type='html'>A másik cikkemben írtam, hogy legalább hét cég van, melyeknek erre van termékük. De azok sokkal komplexebbek, ez a típusú PDF aláírás/időbélyegzés egy feature a sok közül.&lt;br /&gt;&lt;br /&gt;Másrészt pl. minősített elektronikus aláírást csak minősített szoftverrel lehet csinálni, ha az eredmény bitre megegyezik, akkor sem használható ez.&lt;br /&gt;&lt;br /&gt;És ahogy mondod, van az az érv, amivel letörlöm ezt a cikket mindenestül. :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3812297852319041819/comments/default/8198467334433606244'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3812297852319041819/comments/default/8198467334433606244'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2013/12/pdf-elektronikus-alairasa-es.html?showComment=1389558406953#c8198467334433606244' title=''/><link rel='related' type='application/atom+xml' href='http://www.blogger.com/feeds/7370998606556338092/3812297852319041819/comments/default/8997970661583979498'/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2013/12/pdf-elektronikus-alairasa-es.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3812297852319041819' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3812297852319041819' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2014. január 12. 21:26'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-9164675148119060284</id><published>2014-01-22T13:56:51.255+01:00</published><updated>2014-01-22T13:56:51.255+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A Takari oldalán még &amp;quot;upcoming event&amp;quot;-ké...</title><content type='html'>A Takari oldalán még &amp;quot;upcoming event&amp;quot;-ként látszik. Nem tudod, megvan (vagy meg lesz) valahol felvételen?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8443530112508871347/comments/default/9164675148119060284'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8443530112508871347/comments/default/9164675148119060284'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/01/maven-feltamadasa.html?showComment=1390395411255#c9164675148119060284' title=''/><author><name>Kofa</name><uri>http://www.blogger.com/profile/09608502634061041209</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/01/maven-feltamadasa.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8443530112508871347' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8443530112508871347' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-111703032'/><gd:extendedProperty name='blogger.displayTime' value='2014. január 22. 13:56'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5749652842668295893</id><published>2014-01-22T14:34:26.765+01:00</published><updated>2014-01-22T14:34:26.765+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Azt ígérte, hogy igen, és végig villogott a record...</title><content type='html'>Azt ígérte, hogy igen, és végig villogott a record ikon. Sajnos belépve az egyedi kódommal sem visszanézhető, csak azt írja ki a rendszer, hogy &amp;quot;This webinar is over&amp;quot;.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8443530112508871347/comments/default/5749652842668295893'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8443530112508871347/comments/default/5749652842668295893'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/01/maven-feltamadasa.html?showComment=1390397666765#c5749652842668295893' title=''/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/01/maven-feltamadasa.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8443530112508871347' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8443530112508871347' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2014. január 22. 14:34'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-487429837276529614</id><published>2014-01-22T16:34:46.930+01:00</published><updated>2014-01-22T16:34:46.930+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>OK, köszi, a választ is, a bejegyzést is. :-)</title><content type='html'>OK, köszi, a választ is, a bejegyzést is. :-)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8443530112508871347/comments/default/487429837276529614'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8443530112508871347/comments/default/487429837276529614'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/01/maven-feltamadasa.html?showComment=1390404886930#c487429837276529614' title=''/><author><name>Kofa</name><uri>http://www.blogger.com/profile/09608502634061041209</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/01/maven-feltamadasa.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8443530112508871347' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8443530112508871347' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-111703032'/><gd:extendedProperty name='blogger.displayTime' value='2014. január 22. 16:34'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4291449314623325472</id><published>2014-01-22T21:48:42.356+01:00</published><updated>2014-01-22T21:48:42.356+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Kijött a videó: http://www.youtube.com/watch?v=UGU...</title><content type='html'>Kijött a videó: http://www.youtube.com/watch?v=UGUC5utrEEM</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8443530112508871347/comments/default/4291449314623325472'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8443530112508871347/comments/default/4291449314623325472'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/01/maven-feltamadasa.html?showComment=1390423722356#c4291449314623325472' title=''/><link rel='related' type='application/atom+xml' href='http://www.blogger.com/feeds/7370998606556338092/8443530112508871347/comments/default/487429837276529614'/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/01/maven-feltamadasa.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8443530112508871347' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8443530112508871347' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2014. január 22. 21:48'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6005826888275205586</id><published>2014-01-23T10:09:12.807+01:00</published><updated>2014-01-23T10:09:12.807+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi!</title><content type='html'>Köszi!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8443530112508871347/comments/default/6005826888275205586'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8443530112508871347/comments/default/6005826888275205586'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/01/maven-feltamadasa.html?showComment=1390468152807#c6005826888275205586' title=''/><author><name>Kofa</name><uri>http://www.blogger.com/profile/09608502634061041209</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/01/maven-feltamadasa.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8443530112508871347' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8443530112508871347' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-111703032'/><gd:extendedProperty name='blogger.displayTime' value='2014. január 23. 10:09'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6041989586927605752</id><published>2014-01-26T08:32:29.949+01:00</published><updated>2014-01-26T08:32:29.949+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Meghoztad az ihletet és a lamda feelengel odaver s...</title><content type='html'>Meghoztad az ihletet és a lamda feelengel odaver sztem. :)&lt;br /&gt;&lt;br /&gt;JOOQ&lt;br /&gt;http://www.javacodegeeks.com/2014/01/java-8-friday-goodies-lambdas-and-xml.html&lt;br /&gt;</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5773820276886795280/comments/default/6041989586927605752'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5773820276886795280/comments/default/6041989586927605752'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/01/java-es-az-xml.html?showComment=1390721549949#c6041989586927605752' title=''/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/01/java-es-az-xml.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-5773820276886795280' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/5773820276886795280' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1367539294'/><gd:extendedProperty name='blogger.displayTime' value='2014. január 26. 8:32'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4055212991673057120</id><published>2014-03-17T13:08:04.026+01:00</published><updated>2014-03-17T13:08:04.026+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Tippek: 

1) clusterezes (igy, egyben a helyes).
2...</title><content type='html'>Tippek: &lt;br /&gt;&lt;br /&gt;1) clusterezes (igy, egyben a helyes).&lt;br /&gt;2) Ne azt ird, hogy HTTP Server. Meg ha tulajdonnevkent irod, akkor is nehez erteni, mire gondolsz. Siman ird azt, hogy Apache webserver, ugy egyertelmu, mimre gondolsz. Annak, aki hibasan irt angol szovegeken szocializalodott, a HTTP Server mindig is egy altalanos fogalom lesz, nehezebben fogja erteni a lenyeget, hogy itt konkretan az Apache webszerverrol van szo (aminek egyebkent kb mindenutt Apache server a neve).</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3613942055503022824/comments/default/4055212991673057120'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3613942055503022824/comments/default/4055212991673057120'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/06/cluster-ezes-altalaban-es-tomcat-en.html?showComment=1395058084026#c4055212991673057120' title=''/><author><name>Gabor Garami</name><uri>http://www.blogger.com/profile/15406106695993366523</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_DKmHrnCj1NE/SvSwsBa_ZbI/AAAAAAAAAIs/Krfpmmttbmo/S220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/06/cluster-ezes-altalaban-es-tomcat-en.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3613942055503022824' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3613942055503022824' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-171155537'/><gd:extendedProperty name='blogger.displayTime' value='2014. március 17. 13:08'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2914056229548189422</id><published>2014-03-17T13:15:26.442+01:00</published><updated>2014-03-17T13:15:26.442+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>1) Igazad van, javítom, kb. három éve már mindenüt...</title><content type='html'>1) Igazad van, javítom, kb. három éve már mindenütt ezt a szabályt követem, sajnos ez a cikk régebbi.&lt;br /&gt;2) Ez a neve. Apache HTTP Server. http://httpd.apache.org/ Minden esetben ha leírok egy termék vagy projektnevet, megnézem, hogy ők hogyan írják. És mindig az követem.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3613942055503022824/comments/default/2914056229548189422'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/3613942055503022824/comments/default/2914056229548189422'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2010/06/cluster-ezes-altalaban-es-tomcat-en.html?showComment=1395058526442#c2914056229548189422' title=''/><link rel='related' type='application/atom+xml' href='http://www.blogger.com/feeds/7370998606556338092/3613942055503022824/comments/default/4055212991673057120'/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2010/06/cluster-ezes-altalaban-es-tomcat-en.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-3613942055503022824' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/3613942055503022824' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2014. március 17. 13:15'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3587354137437297478</id><published>2014-04-05T21:29:18.449+02:00</published><updated>2014-04-05T21:29:18.449+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi, hasznos volt!</title><content type='html'>Köszi, hasznos volt!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8396345615099149715/comments/default/3587354137437297478'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8396345615099149715/comments/default/3587354137437297478'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/04/mongodb.html?showComment=1396726158449#c3587354137437297478' title=''/><author><name>Bakai Balázs</name><uri>http://www.blogger.com/profile/01676249813193193031</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='33' height='30' src='http://4.bp.blogspot.com/-MU-u989Nc0g/Uxl2pfOfuqI/AAAAAAAABKo/aTV6yVuA3pU/s220/bb.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/04/mongodb.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8396345615099149715' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8396345615099149715' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-751703941'/><gd:extendedProperty name='blogger.displayTime' value='2014. április 5. 21:29'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8509612488754497510</id><published>2014-05-18T15:30:17.502+02:00</published><updated>2014-05-18T15:30:17.502+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Egyetértek, itt van még két megerősítése a témában...</title><content type='html'>Egyetértek, itt van még két megerősítése a témában:&lt;br /&gt;&lt;br /&gt;A Trónok harca írója még mindig DOS-t használ: http://pcworld.hu/kultura/a-tronok-harca-iroja-meg-mindig-dos-t-hasznal.html&lt;br /&gt;&lt;br /&gt;Kickstarteren fundolt blog engine, amiben markdownban írhatod a bejegyzéseket, és egyből látod is, hogy hogy néz ki a renderelt változat (Ghost): &lt;br /&gt;- videó: https://www.youtube.com/watch?v=6rP5R5bIJk0 &lt;br /&gt;- site: https://ghost.org/&lt;br /&gt;</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4869583495293648195/comments/default/8509612488754497510'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4869583495293648195/comments/default/8509612488754497510'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/05/az-idealis-dokumentum-eloallitasi.html?showComment=1400419817502#c8509612488754497510' title=''/><author><name>Marhefka, István</name><uri>http://www.blogger.com/profile/13620561176122999497</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://1.bp.blogspot.com/_jQEHa8Ux_1I/S0eMU6t8VsI/AAAAAAAACrA/YBThKPpIonM/S220/karpatalja24.JPG'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/05/az-idealis-dokumentum-eloallitasi.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4869583495293648195' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4869583495293648195' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1963072178'/><gd:extendedProperty name='blogger.displayTime' value='2014. május 18. 15:30'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-8448061749381336431</id><published>2014-05-23T08:38:15.073+02:00</published><updated>2014-05-23T08:38:15.073+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>nice post</title><content type='html'>nice post</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/9136625273765151611/comments/default/8448061749381336431'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/9136625273765151611/comments/default/8448061749381336431'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/11/tbb-tblzat-egy-oldalon-display-tag-gel.html?showComment=1400827095073#c8448061749381336431' title=''/><author><name>Amani Phoenix</name><uri>http://www.scrumstudy.com/</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2008/11/tbb-tblzat-egy-oldalon-display-tag-gel.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-9136625273765151611' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/9136625273765151611' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1242820651'/><gd:extendedProperty name='blogger.displayTime' value='2014. május 23. 8:38'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5570693166582831231</id><published>2014-05-23T08:40:39.684+02:00</published><updated>2014-05-23T08:40:39.684+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Very well written.</title><content type='html'>Very well written.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/9136625273765151611/comments/default/5570693166582831231'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/9136625273765151611/comments/default/5570693166582831231'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/11/tbb-tblzat-egy-oldalon-display-tag-gel.html?showComment=1400827239684#c5570693166582831231' title=''/><author><name>Miah Charley</name><uri>http://www.pmstudy.com/</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2008/11/tbb-tblzat-egy-oldalon-display-tag-gel.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-9136625273765151611' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/9136625273765151611' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1242820651'/><gd:extendedProperty name='blogger.displayTime' value='2014. május 23. 8:40'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-2090286405453002095</id><published>2014-05-23T09:04:45.528+02:00</published><updated>2014-05-23T09:04:45.528+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>I agree organizing systematically (ie, creating a ...</title><content type='html'>I agree organizing systematically (ie, creating a process in place) is the most essential step. However, its easier said than done. Thats one area where its wise for small business to invest money on professional project management certifications like &lt;br /&gt;&lt;a href="http://www.scrumstudy.com/" rel="nofollow"&gt;agile scrum certification&lt;/a&gt; courses.&lt;br /&gt;.&lt;br /&gt;</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5490890653937846270/comments/default/2090286405453002095'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5490890653937846270/comments/default/2090286405453002095'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/11/javaone-2007-2008-tmk.html?showComment=1400828685528#c2090286405453002095' title=''/><author><name>sarah nelson</name><uri>http://www.scrumstudy.com/</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2008/11/javaone-2007-2008-tmk.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-5490890653937846270' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/5490890653937846270' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1242820651'/><gd:extendedProperty name='blogger.displayTime' value='2014. május 23. 9:04'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-6696798022922437013</id><published>2014-05-23T09:07:09.377+02:00</published><updated>2014-05-23T09:07:09.377+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>To stop making avoidable mistakes in project manag...</title><content type='html'>To stop making avoidable mistakes in project management one can also try attending good &lt;a href="http://www.PMstudy.com/" rel="nofollow"&gt;PMP classes&lt;/a&gt; conducted by any of the PMI registered REP&amp;#39;s for gainig expertise best processes of project management. Any good &lt;a href="http://www.PMstudy.com/" rel="nofollow"&gt;PMP prep course&lt;/a&gt; will provide students with lots of actionable insights in project management along with preparing them for PMP certification.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5490890653937846270/comments/default/6696798022922437013'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5490890653937846270/comments/default/6696798022922437013'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/11/javaone-2007-2008-tmk.html?showComment=1400828829377#c6696798022922437013' title=''/><author><name>Perry Joel</name><uri>http://www.pmstudy.com/</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2008/11/javaone-2007-2008-tmk.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-5490890653937846270' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/5490890653937846270' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1242820651'/><gd:extendedProperty name='blogger.displayTime' value='2014. május 23. 9:07'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7605235130596092798</id><published>2014-05-23T09:17:53.592+02:00</published><updated>2014-05-23T09:17:53.592+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>:- Hi , I am pondering over attending any &lt;a href=...</title><content type='html'>:- Hi , I am pondering over attending any &lt;a href="http://www.PMstudy.com/" rel="nofollow"&gt;PMP prep course&lt;/a&gt; / &lt;a href="http://www.PMstudy.com/" rel="nofollow"&gt;PMP classes&lt;/a&gt; to get PMP credentials. What are your thoughts? Would that be worth the money spent professionally?</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2397947430693517402/comments/default/7605235130596092798'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2397947430693517402/comments/default/7605235130596092798'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/11/oracle-fusion-middleware.html?showComment=1400829473592#c7605235130596092798' title=''/><author><name>Alexia Marthoon</name><uri>http://www.pmstudy.com/</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2008/11/oracle-fusion-middleware.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2397947430693517402' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2397947430693517402' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1242820651'/><gd:extendedProperty name='blogger.displayTime' value='2014. május 23. 9:17'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-3855051075197532986</id><published>2014-05-23T09:18:52.628+02:00</published><updated>2014-05-23T09:18:52.628+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Certifications will definitely increase the salary...</title><content type='html'>Certifications will definitely increase the salary significantly. For project management professionals, I would suggest them to attend any genuine &lt;a href="http://www.scrumstudy.com/" rel="nofollow"&gt;agile scrum certification&lt;/a&gt; courses (eg. &lt;a href="http://www.scrumstudy.com/scrum-master-certification.asp" rel="nofollow"&gt;Scrum Master Certification&lt;/a&gt;). If not anything, at least it will give a boost to your career and salary.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2397947430693517402/comments/default/3855051075197532986'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2397947430693517402/comments/default/3855051075197532986'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2008/11/oracle-fusion-middleware.html?showComment=1400829532628#c3855051075197532986' title=''/><author><name>Olivia Jennifer</name><uri>http://www.scrumstudy.com/</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2008/11/oracle-fusion-middleware.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2397947430693517402' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2397947430693517402' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1242820651'/><gd:extendedProperty name='blogger.displayTime' value='2014. május 23. 9:18'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1960095393914339523</id><published>2014-05-26T21:23:29.988+02:00</published><updated>2014-05-26T21:23:29.988+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Komplex technikai szövegeknél megfontolandó még az...</title><content type='html'>Komplex technikai szövegeknél megfontolandó még az [Asciidoc](http://www.methods.co.nz/asciidoc/).  Ayokat a lyukakat tömi be, amit Markdown nem (nem tud vagy nem akar).</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4869583495293648195/comments/default/1960095393914339523'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/4869583495293648195/comments/default/1960095393914339523'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/05/az-idealis-dokumentum-eloallitasi.html?showComment=1401132209988#c1960095393914339523' title=''/><author><name>takacsot</name><uri>http://www.blogger.com/profile/04091265918316757733</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img2.blogblog.com/img/b16-rounded.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/05/az-idealis-dokumentum-eloallitasi.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-4869583495293648195' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/4869583495293648195' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-603099388'/><gd:extendedProperty name='blogger.displayTime' value='2014. május 26. 21:23'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1095971048035339285</id><published>2014-07-12T21:18:28.292+02:00</published><updated>2014-07-12T21:18:28.292+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Pont jókor jött ez a poszt, épp most ugrok neki eg...</title><content type='html'>Pont jókor jött ez a poszt, épp most ugrok neki egy régi projekt átírásának, adok neki egy esélyt, bár a Hibernate eléggé bevált.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2322684734980758092/comments/default/1095971048035339285'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2322684734980758092/comments/default/1095971048035339285'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/07/spring-data.html?showComment=1405192708292#c1095971048035339285' title=''/><author><name>Névtelen</name><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/07/spring-data.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2322684734980758092' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2322684734980758092' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2024620411'/><gd:extendedProperty name='blogger.displayTime' value='2014. július 12. 21:18'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-9090065852343017348</id><published>2014-07-17T10:41:53.911+02:00</published><updated>2014-07-17T10:41:53.911+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>&amp;quot;Ehhez úgy metódusokat adhatunk hozzá&amp;quot;.r...</title><content type='html'>&amp;quot;Ehhez úgy metódusokat adhatunk hozzá&amp;quot;.replace(&amp;quot;úgy&amp;quot;, &amp;quot;új&amp;quot;)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2322684734980758092/comments/default/9090065852343017348'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2322684734980758092/comments/default/9090065852343017348'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/07/spring-data.html?showComment=1405586513911#c9090065852343017348' title=''/><author><name>Gabor Garami</name><uri>http://www.blogger.com/profile/15406106695993366523</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_DKmHrnCj1NE/SvSwsBa_ZbI/AAAAAAAAAIs/Krfpmmttbmo/S220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/07/spring-data.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2322684734980758092' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2322684734980758092' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-171155537'/><gd:extendedProperty name='blogger.displayTime' value='2014. július 17. 10:41'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5072885020554246928</id><published>2014-07-17T12:55:20.320+02:00</published><updated>2014-07-17T12:55:20.320+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Hibernate fölé tökéletes lesz.</title><content type='html'>Hibernate fölé tökéletes lesz.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2322684734980758092/comments/default/5072885020554246928'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2322684734980758092/comments/default/5072885020554246928'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/07/spring-data.html?showComment=1405594520320#c5072885020554246928' title=''/><link rel='related' type='application/atom+xml' href='http://www.blogger.com/feeds/7370998606556338092/2322684734980758092/comments/default/1095971048035339285'/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/07/spring-data.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2322684734980758092' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2322684734980758092' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2014. július 17. 12:55'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-9095114999462067958</id><published>2014-07-17T12:59:47.855+02:00</published><updated>2014-07-17T12:59:47.855+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Kösz, javítottam.</title><content type='html'>Kösz, javítottam.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2322684734980758092/comments/default/9095114999462067958'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/2322684734980758092/comments/default/9095114999462067958'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/07/spring-data.html?showComment=1405594787855#c9095114999462067958' title=''/><link rel='related' type='application/atom+xml' href='http://www.blogger.com/feeds/7370998606556338092/2322684734980758092/comments/default/9090065852343017348'/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/07/spring-data.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-2322684734980758092' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/2322684734980758092' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2014. július 17. 12:59'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5741694250836855654</id><published>2014-08-05T08:07:24.656+02:00</published><updated>2014-08-05T08:07:24.656+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>A cikked kapcsán felvettem én is az egyik kurzust ...</title><content type='html'>A cikked kapcsán felvettem én is az egyik kurzust (a Node.JS fejlesztőnek szólót), nagyon tetszett. Most kaptam meg én is az oklevelet. :)&lt;br /&gt;Köszönöm, hogy felvívtad rá a figyelmemet!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8396345615099149715/comments/default/5741694250836855654'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8396345615099149715/comments/default/5741694250836855654'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/04/mongodb.html?showComment=1407218844656#c5741694250836855654' title=''/><author><name>Túri Gábor</name><uri>http://google.com/+TuriGabor</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='16' height='16' src='http://img1.blogblog.com/img/blank.gif'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/04/mongodb.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8396345615099149715' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8396345615099149715' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-2060580863'/><gd:extendedProperty name='blogger.displayTime' value='2014. augusztus 5. 8:07'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-4283909722577798492</id><published>2014-08-05T12:22:38.570+02:00</published><updated>2014-08-05T12:22:38.570+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Gratula!
Van még pár MOOC a csőben. :)</title><content type='html'>Gratula!&lt;br /&gt;Van még pár MOOC a csőben. :)</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8396345615099149715/comments/default/4283909722577798492'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/8396345615099149715/comments/default/4283909722577798492'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/04/mongodb.html?showComment=1407234158570#c4283909722577798492' title=''/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/04/mongodb.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-8396345615099149715' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/8396345615099149715' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2014. augusztus 5. 12:22'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-7409844167685140660</id><published>2014-09-04T11:05:08.862+02:00</published><updated>2014-09-04T11:05:08.862+02:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Ezek a hamcrest matcherek nagyon tetszenek, sokkal...</title><content type='html'>Ezek a hamcrest matcherek nagyon tetszenek, sokkal egyszerubbe teszik az osszehasonlitasokat.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7077911891492137156/comments/default/7409844167685140660'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/7077911891492137156/comments/default/7409844167685140660'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/08/spring-testexecutionlistener.html?showComment=1409821508862#c7409844167685140660' title=''/><author><name>Gabor Garami</name><uri>http://www.blogger.com/profile/15406106695993366523</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_DKmHrnCj1NE/SvSwsBa_ZbI/AAAAAAAAAIs/Krfpmmttbmo/S220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/08/spring-testexecutionlistener.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-7077911891492137156' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/7077911891492137156' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-171155537'/><gd:extendedProperty name='blogger.displayTime' value='2014. szeptember 4. 11:05'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-1772492731064959153</id><published>2014-11-14T00:06:37.561+01:00</published><updated>2014-11-14T00:06:37.561+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>+1

[Ceki Gülcü blog](http://ceki.blogspot.hu/) va...</title><content type='html'>+1&lt;br /&gt;&lt;br /&gt;[Ceki Gülcü blog](http://ceki.blogspot.hu/) valamint iroja a [The complete log4j manual](http://www.qos.ch/shop/products/log4jManual) konyvnek</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5333547079656484912/comments/default/1772492731064959153'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5333547079656484912/comments/default/1772492731064959153'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/11/java-ki-kicsoda.html?showComment=1415919997561#c1772492731064959153' title=''/><author><name>Gabor Garami</name><uri>http://www.blogger.com/profile/15406106695993366523</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_DKmHrnCj1NE/SvSwsBa_ZbI/AAAAAAAAAIs/Krfpmmttbmo/S220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/11/java-ki-kicsoda.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-5333547079656484912' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/5333547079656484912' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-171155537'/><gd:extendedProperty name='blogger.displayTime' value='2014. november 14. 0:06'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-328999549891551223</id><published>2014-11-14T00:08:45.306+01:00</published><updated>2014-11-14T00:08:45.306+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Oooo, ez a tetves blogger. Az elozo kommentemet sz...</title><content type='html'>Oooo, ez a tetves blogger. Az elozo kommentemet szo nelkul nyelte el. Akkor reposzt:&lt;br /&gt;&lt;br /&gt;Ez jo, igy nem nezek nagyon butan, ha hallom a neveiket. Volt olyan, akit hallottam mar, de gozom nem volt kicsoda (Gupta, Bien), sokat nem is ismertem, vagy legalabbis a rendes neven nem.&lt;br /&gt;&lt;br /&gt;Hibalista:&lt;br /&gt; - A linkek tobb helyen nem sikerultek, a markdown-t valamiert nem szereti a blog.&lt;br /&gt; - &amp;quot;Prágában kezdett el vele foglalkozni, először mint technical writer, ahonnan a NetBeans is származik. &amp;quot; - Prágában kezdett el vele foglalkozni - ahonnan a NetBeans is származik -, először mint technical writer.&lt;br /&gt;&lt;br /&gt; - Rod Johnson-nal es Juergen Hoeller-nel van egy csomo felsorolas. Ebben a mondatszerkesztesben mindenhova kell ne&amp;#39;velo&amp;quot; is sajnos, illetve az utolso felsorolt elem ele oda illik tenni a &amp;quot;vagy&amp;quot; szocskat is (nem olyan piros, mint cseresznye, alma, ribizli hanem olyan piros, mint **a** cseresznye, **az** alma **vagy** a ribizli) . Vagy ird at ugy, hogy ne kelljen, vagy tedd ki a neveloket. Ha veletlenul tortenetesen egy eloadasban szo szerint idezi (ez ilyen temaban nem lehetetlen), folyamatosan hianyerzete lesz. Van ahol jol hasznalod (Matt Raible), van ahol nem.&lt;br /&gt; -  &amp;quot;nagyszabású fejlesztéssel foglalkozik, képessé tenni a Mavent arra&amp;quot; - &amp;quot;nagyszabású fejlesztéssel foglalkozik, képessé akarja tenni a Mavent arra&amp;quot; vagy &amp;quot;nagyszabású fejlesztéssel foglalkozik, nevezetesen: képessé tenni a Mavent arra&amp;quot;. &lt;br /&gt; - &amp;quot; a legfrissebb az Angular.JS-ről,&amp;quot; -  a legfrissebbet az Angular.JS-ről,&lt;br /&gt; - Ugyanitt: ne ismeteld a pl. -t. &lt;br /&gt;&lt;br /&gt;Remelem, hogy tudtam ezekkel segiteni. &lt;br /&gt;</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5333547079656484912/comments/default/328999549891551223'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5333547079656484912/comments/default/328999549891551223'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/11/java-ki-kicsoda.html?showComment=1415920125306#c328999549891551223' title=''/><author><name>Gabor Garami</name><uri>http://www.blogger.com/profile/15406106695993366523</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='http://2.bp.blogspot.com/_DKmHrnCj1NE/SvSwsBa_ZbI/AAAAAAAAAIs/Krfpmmttbmo/S220/18fddee34c2ec9f584f198aa4785d6f0.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/11/java-ki-kicsoda.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-5333547079656484912' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/5333547079656484912' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-171155537'/><gd:extendedProperty name='blogger.displayTime' value='2014. november 14. 0:08'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-378664448823032683</id><published>2014-11-14T10:50:01.166+01:00</published><updated>2014-11-14T10:50:01.166+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi, javítottam. Nem ismeri a Markdownt, de én r...</title><content type='html'>Köszi, javítottam. Nem ismeri a Markdownt, de én rontottam el, felcserélve használtam a zárójeleket.&lt;br /&gt;&lt;br /&gt;Több embernél nem írtam a blogját, mivel régóta nem posztolt.</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5333547079656484912/comments/default/378664448823032683'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5333547079656484912/comments/default/378664448823032683'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/11/java-ki-kicsoda.html?showComment=1415958601166#c378664448823032683' title=''/><link rel='related' type='application/atom+xml' href='http://www.blogger.com/feeds/7370998606556338092/5333547079656484912/comments/default/328999549891551223'/><author><name>István Viczián</name><uri>http://www.blogger.com/profile/03827423551468696573</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='32' height='32' src='//lh6.googleusercontent.com/-WO4Mwoq2oFg/AAAAAAAAAAI/AAAAAAAAHkQ/db6vYh-R_6M/s512-c/photo.jpg'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/11/java-ki-kicsoda.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-5333547079656484912' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/5333547079656484912' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-1469536758'/><gd:extendedProperty name='blogger.displayTime' value='2014. november 14. 10:50'/></entry><entry><id>tag:blogger.com,1999:blog-7370998606556338092.post-5423191900158369393</id><published>2014-11-15T20:43:46.099+01:00</published><updated>2014-11-15T20:43:46.099+01:00</updated><category scheme='http://schemas.google.com/g/2005#kind' term='http://schemas.google.com/blogger/2008/kind#comment'/><title type='text'>Köszi, ez hasznos volt!</title><content type='html'>Köszi, ez hasznos volt!</content><link rel='edit' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5333547079656484912/comments/default/5423191900158369393'/><link rel='self' type='application/atom+xml' href='https://www.blogger.com/feeds/7370998606556338092/5333547079656484912/comments/default/5423191900158369393'/><link rel='alternate' type='text/html' href='http://www.jtechlog.hu/2014/11/java-ki-kicsoda.html?showComment=1416080626099#c5423191900158369393' title=''/><author><name>Bakai Balázs</name><uri>http://www.blogger.com/profile/01676249813193193031</uri><email>noreply@blogger.com</email><gd:image rel='http://schemas.google.com/g/2005#thumbnail' width='33' height='30' src='http://4.bp.blogspot.com/-MU-u989Nc0g/Uxl2pfOfuqI/AAAAAAAABKo/aTV6yVuA3pU/s220/bb.png'/></author><thr:in-reply-to href='http://www.jtechlog.hu/2014/11/java-ki-kicsoda.html' ref='tag:blogger.com,1999:blog-7370998606556338092.post-5333547079656484912' source='http://www.blogger.com/feeds/7370998606556338092/posts/default/5333547079656484912' type='text/html'/><gd:extendedProperty name='blogger.itemClass' value='pid-751703941'/><gd:extendedProperty name='blogger.displayTime' value='2014. november 15. 20:43'/></entry></feed>