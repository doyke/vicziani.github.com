---
layout: post
title: JAXB trükkök
date: '2009-07-03T01:09:00.004+02:00'
author: István Viczián
tags:
- JAXB
- Java SE
modified_time: '2014-01-25T22:34:46.897+01:00'
blogger_id: tag:blogger.com,1999:blog-7370998606556338092.post-4930170574388966834
blogger_orig_url: http://www.jtechlog.hu/2009/07/jaxb-trukkok.html
---

<p>Frissítve: 2014. január 25.</p>

<p>Felhasznált technológiák: JAXB</p>

<p>A poszthoz tartozó példaprogram elérhető a <a href="https://github.com/vicziani/jtechlog-xml">GitHubon</a>.</p>

<h3 id="körkörös-referencia">Körkörös referencia</h3>

<p>Amennyiben JAXB esetén azt szeretnénk, hogy két osztály között a kapcsolat kétirányú legyen, azaz pl. a <code>Catalog</code> osztály is hivatkozzon a <code>Book</code> osztályra, és fordítva, a következő kivételt kapjuk: <code>com.sun.istack.internal.SAXException2: A cycle is detected in the object graph. This will cause infinitely deep XML:</code>. Ez azt jelenti, hogy először mentené a <code>Catalog</code> példányát, majd a <code>Book</code> példányát, majd újra a <code>Catalog</code> példányt, és így tovább, tehát egy körkörös hivatkozás alakul ki. Ennek <a href="https://jaxb.dev.java.net/guide/Mapping_cyclic_references_to_XML.html">elkerülésére</a> a visszamutató getterét <code>@Transient</code> annotációval lássuk el, és a <code>Book</code> objektumba vegyük fel az <code>afterUnmarshal</code> metódust.</p>

<div class="separator" style="clear: both; text-align: center;"><a href="http://yuml.me/11c7cc4d" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://yuml.me/11c7cc4d" alt="UML diagram a körkörös referenciáról"/></a></div>

<pre class="brush: java">public class Book {

  private Catalog catalog;
 
  @XmlTransient
  public Catalog getCatalog() {
    return catalog;
  }

  public void afterUnmarshal(Unmarshaller u, Object parent) {
    this.catalog = (Catalog) catalog;
  }

  // ... stb...
}</pre>

<p>Az <code>afterUnmarshal</code> használatakor kiderült még egy érdekes dolog. A JDK 1.6.0_13-asban lévő JAXB 2.1.3 a kivételt elnyeli, és a program fut tovább. A 1.6.0_14-es verziószámú JDK-ba <a href="http://www.oracle.com/technetwork/java/javase/6u14-137039.html">került</a> JAXB RI 2.1.10-es verziója viszont nem kezeli le, hanem kivételt okoz. Azaz a kivétel elnyelése, az üres catch ágak használata nem csak azért rossz, mert amennyiben hiba van, nehezen találjuk meg, hanem azért is, mert amikor a hibát kijavítjuk, melyre egy másik hibát építettünk, az első javításakor előjön a másik. Tanulság, hogy két update között is lehetnek kompatibilitási problémák, így érdemes minden szóbajöhető JDK verzión letesztelni az alkalmazásunkat, vagy specifikáljuk a verziószámot kínosan pontosan. Az előbbi tovább erősíti az automatikusan futtatható teszt esetek hasznosságát.</p>

<p>A JAXB RI 2.1 EA2-ban a körkörös referencia feloldására jelent meg a <code>CycleRecoverable</code> interfész is.</p>

<h3 id="ős-és-leszármazott">Ős és leszármazott</h3>

<p>Amennyiben azt szeretnénk, hogy legyen egy <code>Item</code> osztály, annak két leszármazottja legyen, pl. <code>Book</code> és<code>Magazine</code>, és azt szeretnénk, hogy az XML-ben a <code><catalog></code> tag alatt egyszer a <code><book></code>, egyszer a <code><magazine></code> tag szerepeljen, mindkettő leszármazotton definiáljuk az <code>@XmlRootElement</code> annotációt, és adjuk meg <code>name</code> paraméterül a kívánt nevet, és a <code>Catalog</code> osztály <code>items</code> változójára tegyük rá a <code>@XmlElementRef</code> annotációt. Ez megoldja, hogy ne az attribútum neve alapján nevezze el a taget, hanem dinamikusan, a konkrét példány osztályában az <code>@XmlRootElement</code> annotáció name attribútuma alapján.</p>

<div class="separator" style="clear: both; text-align: center;"><a href="http://yuml.me/7340b799" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img width="500" height="138" border="0" src="http://yuml.me/7340b799" alt="UML diagram a leszármazottakhoz"/></a></div>

<h3 id="típuskonverzió">Típuskonverzió</h3>

<p>Van, hogy nem megfelelő nekünk a JAXB által választott típus, hanem saját osztályunk példányát akarjuk példányosítani. Pl. legyen az, hogy a <code>Book</code> osztályunk <code>isbn</code> attribútuma ne <code>String</code>, hanem <code>Isbn10</code> típusú legyen (mely egy saját osztály).</p>

<p>Ez könnyedén megtehető. Egyrészt kell írnunk egy adaptert, mely a típusok közötti konverziót elvégzi.</p>

<pre class="brush:java">public class Isbn10Adapter extends XmlAdapter&lt;String, Isbn10&gt; {

    public Isbn10 unmarshal(String value) {
        return new Isbn10(value);
    }

    public String marshal(Isbn10 value) {
        return value.getValue();
    }
}</pre>

<p>Másrészt használjuk az <code>@XmlJavaTypeAdapter</code> annotációt.</p>

<pre class="brush:java">public class Book {

    @XmlAttribute
    @XmlJavaTypeAdapter(Isbn10Adapter.class)
    public Isbn10 getIsbn10() {
        return isbn10;
    }
    
    // stb...
}</pre>