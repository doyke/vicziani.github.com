---
layout: post
title: JAXB
date: '2009-07-03T00:58:00.008+02:00'
author: István Viczián
tags:
- JAXB
- Java SE
modified_time: '2014-01-20T15:09:03.777+01:00'
blogger_id: tag:blogger.com,1999:blog-7370998606556338092.post-7801878101879687317
blogger_orig_url: http://www.jtechlog.hu/2009/07/jaxb.html
---

<p>Frissítve: 2014. január 20.</p>

<p>Mostanában, ha XML-t kell használnom Java-ból, először mindig a JAXB (JavaTM Architecture for XML Binding) jut eszembe, ami egy nagyon egyszerűen, gyorsan használatba vehető binding framework, melynek feladata a Java objektumok és az XML elemek egymáshoz rendelése, egymással való megfeleltetése. Magasabb absztrakciós szintet képvisel, mint a SAX, vagy a DOM, hiszen itt gyakorlatilag a programból csak Java objektumokkal kell dolgoznunk, az oda és vissza alakítást elvégzi a framework. Hasonló az ORM-hez, csak ott a feladat Java objektumok relációs adatbázis elemekké (sorokká) alakítása.</p>

<p>A binding és a mapping szavakat általában keverik, nincs is kiforrott definíció, azonban érdemes megfontolnunk Mark D. Hansen SOA Using Web Services című könyében az általa kifejlesztett terminológiát. Szerinte a binding esetén az XML séma egy megvalósulása a belőle képzett Java osztály, míg mapping esetén a Java osztályt például az üzleti logikánkban használjuk, csak egy megjelenési formája, hogy XML-be is mentjük, vagy onnan betöltjük, esetleg adatbázisba perzisztáljuk. Emiatt szerinte a JAXB egy binding framework.</p>

<p>A JAXB egy szabvány (<a href="http://jcp.org/en/jsr/detail?id=222">JSR-222</a>, melynek a referencia implementációja a stílusosan csak <a href="https://jaxb.dev.java.net/">JAXB Reference Implementation</a>-nek hívott projekt, mely már a JDK része is. A legújabb, 1.6.0_14-es verziószámú JDK-ba került a JAXB RI 2.1.10-es verziója (ez könnyen ellenőrizhető a <code>xjc -version</code> paranccsal).</p>

<p>Fejlesztésnél választhatjuk azt, hogy a Java kódból indulunk ki, és abból generáljuk le az XML sémát a séma generátor (schema generator) segítségével. Vagy kiindulhatunk az XML sémából, és abból generáljuk le a Java kódot a séma fordító (schema compiler) segítségével. A kettő közötti megfeleltetést Java annotációkkal lehet konfigurálni, amiket az előbbi esetben magunk írunk, az utóbbi esetben a séma fordító generálja le az osztályokba. Szerencsére az előbbi esetben viszonylag kevés annotációt kell használni, hiszen a JAXB is követi az EJB 3 azon törekvését, hogy az annotációknak alapértelmezett értékeik legyenek, amivel már működik a programunk.</p>

<div class="separator" style="clear: both; text-align: center;"><a href="http://java.sun.com/javaee/5/docs/tutorial/doc/figures/jaxb-overview.gif" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://java.sun.com/javaee/5/docs/tutorial/doc/figures/jaxb-overview.gif" width="500" height="267" alt="JAXB működése"/></a></div>

<p>A legrosszabb eset, ha XML sémánk is van, és annak megfelelő XML dokumentumot kell gyártani, valamint Java osztályaink is vannak, amik valamilyen üzleti logikát valósítanak meg. Ekkor megpróbálhatunk a JAXB-vel trükközni, hogy úgy helyezzük el az annotációkat a Java osztályokon, hogy pont az az XML jöjjön ki, amit szeretnénk (nehezebb, mert nagy JAXB ismeret kell hozzá), vagy az XML sémából kigeneráljuk a Java osztályokat, mint DTO objektumok, és programból alakítgatjuk a business domaint megvalósítandó osztályainkra (redundánsabb a kód). Tehát a sémának az annotált Java osztályok felelnek meg, míg az XML dokumentumnak a Java objektumok. XML dokumentumból Java objektumok az unmarshall művelettel keletkeznek, fordítva a marshall művelet használható.</p>

<div class="separator" style="clear: both; text-align: center;"><a href="http://java.sun.com/javaee/5/docs/tutorial/doc/figures/jaxb-dataBindingProcess.gif" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://java.sun.com/javaee/5/docs/tutorial/doc/figures/jaxb-dataBindingProcess.gif" alt="Binding" /></a></div>

<p>Nézzünk is egy egyszerű példát, mely <a href="https://github.com/vicziani/jtechlog-xml">letölthető a GitHub-ról</a>. Adott egy dokumentum, és annak több oldala. UML diagramja a következő ábrán látható. A kapcsolat egyirányú, csak a dokumentum hivatkozik az oldalakra.</p>

<div class="separator" style="clear: both; text-align: center;"><a href="http://yuml.me/d966b4dd" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://yuml.me/d966b4dd" /></a></div>

<p>Ahhoz, hogy XML-lé alakítható legyen, a <code>Catalog</code> osztályra tegyük rá az <code>@XmlRootElement</code> annotációt. A JAXB miatt mindkét osztálynak rendelkeznie kell paraméter nélküli konstruktorral is.</p>

<pre class="brush:java">@XmlRootElement
public class Catalog {

    private List&lt;Book&gt; books;

    @XmlElement(name = &quot;book&quot;)
    public List&lt;Book&gt; getBooks() {
        return books;
    }

    public void setBooks(List&lt;Book&gt; books) {
        this.books = books;
    }
}</pre>

<p>Az <code>@XmlElement</code> annotáció hatására a tag neve nem az attribútum neve lesz, hanem a <code>name</code> paraméterként megadott.</p>

<p>Ahhoz, hogy ezt XML-be mentsük, a marshall műveletet kell meghívni a következőképpen. Először egy <code>JAXBContext</code>-et kell létrehoznunk, és adjuk meg neki az XML-be menteni kívánt osztályokat. Utána létrehozzuk a Marshaller objektumot, majd meghívjuk a marshal metódust.</p>

<pre class="brush:java">JAXBContext ctx = JAXBContext.newInstance(Catalog.class, Book.class);
Marshaller marshaller = ctx.createMarshaller();
marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,
  Boolean.TRUE);
marshaller.setProperty(Marshaller.JAXB_FRAGMENT,
  Boolean.FALSE);


StringWriter writer = new StringWriter();
marshaller.marshal(catalog, writer);
return writer.toString();</pre>

<p>És máris megjelenik a kívánt XML.</p>

<pre class="brush:xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;catalog&gt;
    &lt;book&gt;
        &lt;isbn10&gt;059610149X&lt;/isbn10&gt;
        &lt;title&gt;Java and XML&lt;/title&gt;
        &lt;author&gt;Brett McLaughlin, Justin Edelson&lt;/author&gt;
        &lt;publisher&gt;O'Reilly Media&lt;/publisher&gt;
        &lt;year&gt;2006&lt;/year&gt;
    &lt;/book&gt;
    &lt;book&gt;
        &lt;isbn10&gt;1590597060&lt;/isbn10&gt;
        &lt;title&gt;Pro XML Development with Java Technology&lt;/title&gt;
        &lt;author&gt;Ajay Vohra&lt;/author&gt;
        &lt;publisher&gt;Apress&lt;/publisher&gt;
        &lt;year&gt;2005&lt;/year&gt;
    &lt;/book&gt;
&lt;/catalog&gt;</pre>

<p>Ez az alapértelmezett működés, de ezt tetszőleges módon testre szabhatjuk. Például:</p>

<ul>
<li>Ha azt akarjuk, hogy az <code>isbn10</code> attribútum legyen, tegyük rá a <code>getIsbn10()</code> metódusra az <code>@XmlAttribute</code> annotációt</li>
<li>Ha ezt a field-re akarjuk tenni, akkor használjuk osztály szinten a <code>@XmlAccessorType(XmlAccessType.FIELD)</code> annotációt, ez jelzi, hogy nem metódusra akarjuk rakni a többi annotációt</li>
<li>Az <code>@XmlType(propOrder={...})</code> annotációval adhatjuk meg az elemek sorrendjét</li>
<li>Az <code>@XmlTransient</code> annotációval megmondhatjuk egy attribútumra, hogy ne mentődjön az XML-be</li>
<li>Az <code>@XmlElementWrapper</code> annotációval az ismétlődő elemek köré tehetünk egy wrapper XML tag-et</li>
<li>Amennyiben névteret is meg akarunk adni, tegyük ezt a <code>package-info.java</code> állományban a <code>@XmlSchema</code> annotáció segítségével.</li>
</ul>

<p>Ilyenkor az alapértelmezett binding működik, azaz meg van adva, hogy melyik XML séma típushoz milyen Java típus tartozik, és fordítva. Persze ezt is felüldefiniálhatjuk.</p>

<p>Az XML-bel objektumok visszanyerése hasonlóan egyszerű:</p>

<pre class="brush:java">JAXBContext ctx = JAXBContext.newInstance(Catalog.class, Book.class);
Unmarshaller unmarshaller = ctx.createUnmarshaller();
return (Catalog) unmarshaller.unmarshal(source);</pre>

<p>A Java forrásból XML sémát a <code>schemagen</code> paranccsal generálhatunk. Amennyiben az XML séma felől szeretnénk elindulni, az <code>xjc</code> parancsot kell kiadnunk, ami legenerálja a Java osztályokat.</p>

<p>A Java EE 5 Tutorial-ban van egy <a href="http://java.sun.com/javaee/5/docs/tutorial/doc/bnazf.html">fejezet</a> a JAXB-ről is.</p>