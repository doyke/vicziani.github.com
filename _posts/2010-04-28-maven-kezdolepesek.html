---
layout: post
title: Maven kezdőlépések
date: '2010-04-28T23:44:00.007+02:00'
author: István Viczián
tags: 
modified_time: '2014-02-02T16:32:15.794+01:00'
thumbnail: http://3.bp.blogspot.com/_czKgycLvmNo/TT8OoNqhjtI/AAAAAAAAFq4/SP2A7_Eh56E/s72-c/sonatype_maven_the_complete_reference.png
blogger_id: tag:blogger.com,1999:blog-7370998606556338092.post-4550403846114418343
blogger_orig_url: http://www.jtechlog.hu/2010/04/maven-kezdolepesek.html
---

<h3>Bevezetés</h3><p>Lassan már az összes magyar Java-val foglalkozó blogger írt tapasztalatokat a Maven-ről, így hát én sem maradhatok ki a sorból. Túl vagyunk egy teljes egészében Maven-nel fejlesztett projekten, egy már létező projekt Maven-re átállításán, valamint jópár Maven oktatáson.</p><p>A blog statisztikája (Google Analytics) szerint a leglátogatottabb cikkek a bevezető jellegű cikkek, így a Maven-ről is egy ilyent írnék, tanácsokat egy kezdő számára, hogy merre érdemes elindulni, és néhány trükköt, amit ismerni érdemes. Nem magyarázom a fogalmakat, csupán jelzem, hogy mely fogalmakat kell ismerni. Amennyiben tapasztalt Maven olvasó vagy, kérlek jelezd a comment-ek között, ha valamit rosszul írtam, nem így használsz, vagy tipped, ötleted van.</p><p>A Maven-nel kapcsolatban a legtöbbet megfogalmazott kritika az, hogy a tanulási görbéje nem elég meredek, azaz ahhoz, hogy <emp>jól</emp> használjuk, sokat kell tudni róla. Ezt tükrözik sajnos a publikus repository-kban található silány minőségű artifact-ok is, amiből látszik, hogy ugyan sokan használják a Maven-t, de nem ismerik. Ezzel azonban a többi fejlesztő dolgát keserítik meg.</p><h3>Források</h3><p>Ezért azt javaslom, hogy amennyiben valaki Maven-t akar használni, egy-két bevezető jellegű cikk után igenis olvasson el két könyvet. Az egyik az O'Reilly által is kiadott <a href="http://oreilly.com/catalog/9780596517335">Maven: The Definitive Guide</a>. A könyv egyik fő szerzője, a Maven első verzióját készítő Jason Van Zyl, aki jelenleg a <a href="http://www.sonatype.com/">Sonatype</a>-nál CTO. Azonban a papíron kiadott könyv már igencsak elavult, ugyanis a Sonatype honlapjáról mindig <a href="http://www.sonatype.com/documentation/books">letölthető</a> a legfrissebb verzió. A könyvet időközben két külön könyvre bontották, Maven by Example és Maven: The Complete Reference címmel.</p>

<a rel="lightbox[maven-kezdolepesek]" href="http://3.bp.blogspot.com/_czKgycLvmNo/TT8OoNqhjtI/AAAAAAAAFq4/SP2A7_Eh56E/s1600/sonatype_maven_the_complete_reference.png"><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 246px; height: 320px;" src="http://3.bp.blogspot.com/_czKgycLvmNo/TT8OoNqhjtI/AAAAAAAAFq4/SP2A7_Eh56E/s320/sonatype_maven_the_complete_reference.png" border="0" alt=""id="BLOGGER_PHOTO_ID_5566183748478799570" /></a>

<p>Az első könyvbe az eredeti könyv Part II. része került, míg a második könyvbe pedig a többi. Ezen kívül rengeteg dologgal kiegészült időközben az eredeti könyvhöz képest:</p><ul><li>Running Maven fejezet - a parancssori paramétereket, a Reactor paramétereit, valamint a Help Plugin használatát részletezi</li><li>Using Maven Archetypes - archetype-ok használatát, és saját archetype-ok készítését és publikálását részletezi</li><li>Developing with Flexmojos - fejlesztés a Flex pluginnal</li><li>Android Application Development with Maven - Android fejlesztés Maven-nel</li><li>stb.</li></ul><p>Az eredeti könyvben szerepel egy-egy fejezet a Nexus-ról, illetve a m2eclipse Eclipse plugin-ról is. Ezekből szintén egy-egy könyv lett, Repository Management with Nexus és Developing with Eclipse and Maven néven. Érdemes figyelemmel kísérni a honlapot, mert gyakran frissül. A Sonatype-nak ezen kívül magyar vonatkozása is van, hiszen a Nexus elődjét Cservenák Tamás fejlesztette Proximity néven, és eztán kérte fel a Sonatype, hogy készítsen egy hasonló terméket, Nexus néven.</p><p>A másik könyv a <a href="http://www.maestrodev.com/better-build-maven">Better Builds with Maven</a>, mely szintén ingyenesen letölthető. Szintén a Maven fejlesztésében résztvevők írták, és most a MaestroDev tartja karban. Nem olyan részletes és jól karbantartott, mint az előbb említett könyvek, azonban mégis érdemes elolvasni, mert kicsit más oldalról közelíti meg a Maven-nel történő fejlesztést.</p><h3>Fogalmak</h3><p>A Maven definíció szerint "software project management and comprehension tool". Tehát nem egy egyszerű build tool, melyben az Ant-hoz hasonlóan leírjuk az egymás utáni lépéseket, hanem annál sokkal fejlettebb, magasabb szintű megoldás. Alapja a project object model (POM), melyet XML-ben leírva tudunk megadni (pom.xml), és ez alapján a Maven képes további leírások nélkül elvégezni a build folyamatot, különböző riportok, dokumentációk, gyakorlatilag a teljes projekt website-jának legenerálását. A Maven nem titkolt célja, hogy a Java fejlesztők körében egyfajta szabvány legyen, mely a konvenciók megtartását előnybe helyezi az egyéni konfigurációkkal szemben (convention over configuration). Sajnos a Java nagyon sokáig nem adott szabványt arra, hogy hogyan kell egy projektet felépíteni, a Maven ezt az űrt próbálja betölteni. Azaz ha tartjuk magunkat egy projekt struktúrához, azaz a különböző állományainkat a megfelelő könyvtárakba helyezzük el, a Maven képes lesz elvégezni a build folyamatot, a források lefordítását, a különböző erőforrás állományok megfelelő helyre másolását, és az alkalmazásunk összecsomagolását.</p><p>A Maven alapfogalma a projekt, mely a koordináták alapján van azonosítva, melyek a következők: groupId, artifactId, version, packaging, classifier. Pl. a legfrissebb Log4J esetén a groupId:log4j, artifactId:log4j, version:1.2.16. A többi megadása opcionális. A groupId megadásánál elterjedt az egyedi azonosítás miatt a domain név megadása, mint a Java package-eknél (pl. org.springframework). A projektek egymástól öröklődhetnek, valamint van lehetőség több modulból álló projektek megadására is (mindegyik modul saját pom.xml-lel). A pom.xml-ben lehet megadni a projektre jellemző olyan információkat is, mint a licence, szervezet, fejlesztők, közreműködők, valamint olyan fejlesztési környezet információkat is, mint a verziókezelő, issue management, continuous integration eszköz elérése, stb. Ráadásul a projektre jellemző POM, az un. effective POM több részből épül fel. Egyrészt a Super POM, mely a maven-[version]-uber.jar-ban szerepel org.apache.maven.project.pom-4.0.0.xml néven, a szülő POM-jából, valamint a projekthez tartozó POM-ból aggregálva.</p><p>A Maven nagy előnye ezen kívül, hogy beépített mechanizmus van a különböző projekt függőségek definiálására és feloldására (pl. tranzitív függőség, A projekt függ B-től, B projket függ C-től, akkor a C-re is szükség van). Itt fontos ismerni a scope fogalmát. Sokat segíthet a függőségi fa kirajzolása. A függőségek megadásánál használhatunk pontos verziószámokat, de akár verzióintervallumokat is (range). Megadhatóak opcionális függőségek is, melyeket nem muszáj igénybe vennünk.</p><p>A Maven build folyamat kimenetele az artifact. Ezen artifact 3rd party library esetén a JAR állomány, webes alkalmazás esetén a WAR állomány, nagyvállalati alkalmazás esetén az EAR állomány, stb. A Maven megkülönbözteti a release és snapshot fogalmát, ahol az előző a kiadható verzió, míg az utóbbi a fejlesztés közben használatos verzió.</p><p>Az artifact-okat egy központi helyen, un. repository-ban helyezi el, hierarchikus rendben. A legtöbb kritikai itt éri a Maven-t, hogy miért is nem jó a függő library-k tárolása egyszerűen a verziókövető rendszerben, miért kell ehhez egy külön repository-t használni. A Maven használhat publikus repository-kat, valamint használ az adott gépen egy lokális repository-t is, ez alapesetben a felhasználó home könyvtárában .m2/repository könyvtárában található. Ezen kívül a repository manager-ek elterjedésével (pl. Nexus vagy Artifactory) érdemes kialakítani egy cégen belül használatos belső repository-t is, melyben tárolhatóak a saját projektek állományai, valamint egyfajta proxy-ként működnek a publikus repository-k felé. Az alapértelmezett publikus repository a http://repo1.maven.org/maven2/. A repository-k is csoportosíthatók, hogy release vagy snapshot verziókat tárolnak-e.</p><p>A Maven teljesen moduláris felépítésű, minden un. Maven plugin-ben van megvalósítva. Ezen Maven plugin-ek is artifact-ok. Ezért van az, hogy a Maven telepítőcsomagja alig pár mega, az összes többi funkcionalitást biztosító plugin-t (artifact) akkor tölt le, amikor szükség van rá. Persze emiatt az első futtatás tovább tarthat, hiszen ekkor nagy mennyiségű artifact-ot kell letöltenie. A pom.xml-ben ezen plugin-eket konfigurálhatjuk is. A plugin-ek tulajdonképpen összetartozó goal-ok gyűjteménye, ahol egy goal egy egyedi, önmagában is futtatható funkció. Ilyen pl. a compiler plugin compile goal-ja, ami a forrás állományok fordításáért felelős. Valamint a Maven-ben vannak definiálva un. életciklusok (lifecycle). Pl. build lifecycle (default), site és clean lifecycle. Minden lifcycle fázisokból áll, és minden fázishoz alapértelmezetten tartozik egy vagy több plugin goal. Pl. a build lifecycle egyik fázisa package, mely a jar plugin jar goal-ját hívja meg bizonyos esetekben. Persze ezt magunk személyre is szabhatjuk. Első feladat megérteni a Maven tanulásakor, mikor kiadunk egy parancsot, mi is fut le, milyen életciklus milyen fázis, milyen plugin milyen goal-ja. A plugin-ek kaphatnak paramétereket.</p><p>A Maven előnye, hogy nagyban megkönnyíti a csapattagok kommunikációját, valamint a fejlesztésbe bekapcsolódást, ugyanis képes kigenerálni különböző riportokat (pom.xml-ben definiálandó), dokumentációt, a projekt site-ját (természetesen nagymértékben testreszabható módon). Ezért különösen elosztott, open source fejlesztésre különösen alkalmas.</p><p>A Maven-ben vannak un. profilok is, melyek a build folyamat portabilitását biztosítják különböző build környezetekben. Pl. lehet, hogy másképp kell, hogy működjön a build folyamat különböző architektúrákon, JDK verziókon és operációs rendszereken, teszt és élest környezetben, sőt akár <a href="http://jhacks.anzix.net/space/maven/maven2/IDE+support">különböző fejlesztőeszközök használatakor</a>. Lehetőség van arra, hogy mi adjuk meg parancssorból a profilt (-P kapcsolóval), de van profile activation is, ahol valamely környezeti beállítás hatására automatikusan egy profil kerül kiválasztásra.</p><p>A másik érdekesség az assembly-k használata. A Maven beépítetten ismeri a gyakoribb csomagolási módokat, a packaging-től függően JAR, WAR, EAR (bin). Képes arra is, hogy olyan distribution-t készítsen, amibe bele vannak csomagolva a függő osztályok is (jar-with-dependencies), valamint képes a teljes projektet becsomagolni (project), valamint csak a forráskódot kiadni (src). Ezen kívül saját assembly-t is definiálhatunk assembly descriptor megadásával.</p><p>A Maven-ben a személyes kedvencem az archetype. Az archetype egy projekt sablon, melyből létre lehet hozni egy üres projektet különböző paraméterek megadásával. Ha gyakran indítunk projektet, érdemes egy ilyent gyártanunk, mely a megfelelő kiindulási alapot biztosítja. Vannak beépített archetype-ok is, ezelből is sok öteletet lehet meríteni. Ezek is artifact-ok, azaz a repository-ban is elhelyezhetők.</p><p>A Maven-ben ezen kívül lehetőség van saját plugin-ek implementálására is. Egy goal-t egy mojo-ban implementálhatunk (Maven plain Old Java Object). Egy plugin mojo-k gyűjteménye.</p><p>A Maven könnyen integrálható az összes continuous integration eszközzel.</p><h3>Tippek és személyes tapasztalatok</h3><p>Ide a személyes tapasztalataimat próbálom összegyűjteni, és azokat a problémákat és megoldásaikat, melyekkel egy Maven felhasználó először találkozik. Ezek egy részével a <a href="http://maven.apache.org/general.html">FAQ</a> is foglalkozik.</p><h4>Java verzió</h4><p>Alapesetben a Maven compiler plugin a Java 1.4-re fordít, ahhoz, hogy az 1.5 újdonságait ki tudjuk használni, át kell ezt állítani, pl. a legfrissebb 1.6-os verzióra a pom.xml-ben.</p><pre class="brush: xml">&lt;build&gt;
&lt;plugins&gt;
&lt;plugin&gt;
  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
  &lt;configuration&gt;
    &lt;source&gt;1.6&lt;/source&gt;
    &lt;target&gt;1.6&lt;/target&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;
&lt;/plugins&gt;
&lt;/build&gt;</pre><h4>Kevés memória</h4><p>Amennyiben a Maven build vagy site generálás hibát dob (java.lang.OutOfMemoryError: Java heap space), hogy nincs elég memória, akkor be kell állítanunk a MAVEN_OPTS környezeti változót.</p><pre>MAVEN_OPTS="-Xmx1024m -Xms512m"</pre><h4>Karakterkódolás</h4><p>Az ékezetes karakterek használata itt is problémát okoz, így hogy ezt elkerüljük, mindenütt deklarálni kell a karakterkódolást. Javasolt az UTF-8 használata. Nagyon sok plugin-nak van encoding property-je, ezt kell állítani. Pl. ha a Java forrásállományokban ékezeteket használunk (pl. dokumentációs megjegyzésekben).</p><pre class="brush: xml">&lt;build&gt;
&lt;plugins&gt;
&lt;plugin&gt;
  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
  &lt;configuration&gt;
    &lt;encoding&gt;UTF-8&lt;/encoding&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;
&lt;/plugins&gt;
&lt;/build&gt;
</pre><p>De ezen kívül meg kell adnunk a maven-resources-plugin, maven-site-plugin (inputEncoding, outputEncoding néven), maven-checkstyle-plugin, maven-javadoc-plugin, maven-pmd-plugin, taglist-maven-plugin plugin-oknak. Amennyiben nem adjuk meg, a Maven warning-ot ír, hogy nincs megadva a karakterkódolás, emiatt build környezetfüggő, mert az operációs rendszer default kódolását használja.</p><h4>Hiányzó artifact</h4><p>Amennyiben egy artifact hiányzik a repository-ból, a következő paranccsal tudjuk oda installálni:</p><pre>mvn install:install-file
-Dfile=<path-to-file>
-DgroupId=<group-id>
-DartifactId=<artifact-id>
-Dversion=<version>
-Dpackaging=<packaging>
-DgeneratePom=true</packaging></version></artifact-id></group-id></path-to-file></pre><p>Azaz pl az Oracle jdbc driver esetén:</p><pre>mvn install:install-file
-Dfile=ojdbc6-11.2.0.1.0.jar
-DgroupId=com.oracle
-DartifactId=ojdbc6
-Dversion=11.2.0.1.0
-Dpackaging=jar
-DgeneratePom=true</pre><p>Utána persze ezen koordinátákkal kell hivatkozni rá a függőség megadásánál.</p><h4>Debug mód</h4><p>Futtassuk a Maven-t a -X kapcsolóval.</p><h4>Teszt esetek</h4><p>A Maven Surefire plugin-ja alapértelmezésben futtat JUnit és TestNG teszt eseteket is. A kizárólag teszteléshez szükséges függőségeket test scope-pal kell elhelyezni a függőségek között. Meg lehet adni, hogy amennyiben egy teszt eset hibázik, a build még folytatódjon (maven-surefire-plugin testFailureIgnore tulajdonsága). Valamint azt is meg lehet adni, hogy ne futtassa le a teszt eseteket (–Dmaven.test.skip=true vagy -DskipTests=true parancssori kapcsolóval, de a POM-ban is megadható maven-surefire-plugin skipTests property-jének állításával). Ha csak egy teszt esetet akarunk futtatni, használjuk a -Dtest=MyTest kapcsolót (csomag megadása nélkül).</p><h4>Artifact neve</h4><p>Alapesetben a Maven artifact neve a koordinátákból jön, azonban war állomány esetén ez nem lenne szerencsés, így felüldefiniálható a POM-ban a finalName tag-gel.</p><h4>Riportok generálása</h4><p>A site lifecycle része a riportok generálása is. Azonban, ha mi a site többi részére vagyunk kíváncsiak, és nem akarjuk a riportokat kigeneráltatni, akkor ezt megtehetjük a -DgenerateReports=false használatával.</p><h4>Repository manager</h4><p>Egy cégen belül mindenképp alkalmazzunk repository manager eszközt. Ez egyrészt tartalmazza a saját artifact-jainkat, másrészt egy proxy a publikus repositry-k felé. Webes felületen menedzselhetőek (artifact keresés és feltöltés), valamint mindenféle jogosultsági szinteket tudunk megadni, és képesek archiválni a repository-t. Érdemes az Artifactory és a Nexus közül választani, én az előbbire tettem le a voksom, és egyelőre nem tapasztaltam hiányosságot.</p><h4>Log4j 1.2.15</h4><p>A repository-k minőségét jellemzi a Log4J 1.2.15 verziója, melyben a javax.mail:mail, javax.jms:jms, com.sun.jdmk:jmxtools és a com.sun.jmx:jmxri artifact-ok kötelező függőségként voltak megadva. Ezen jar-ok használata pedig nem kötelező, csak akkor szükséges, ha a hozzájuk tartozó megfelelő appender-eket akarjuk használni, a JMX meg már része a JDK-nak. Szerencsére ezt azóta <a href="http://svn.apache.org/viewvc?view=revision&amp;revision=575804">javították</a>.</p><h4>IDE integráció - NetBeans</h4><p>A Maven NetBeans integrációját gyakran használtam, és igen jónak tartom, nem ütköztem vele problémába. Kicsit féltem tőle, mert elsődleges szempont a gyors fejleszt-tesztel iterációs ciklus, és régebbi verzióval voltak gondjaim. Most ilyenről nem számolhatok be. Nem jelentősen lassabb a beépített Ant-ra épülő build folyamatnál, hiszen mindegyik egy külső, megfelelően integrált eszköz. A <a href="http://wiki.netbeans.org/MavenBestPractices">MavenBestPractices</a> cikk rengeteg jó tanácsot ad a NetBeans felhasználóknak.</p><h4>IDE integráció - Eclipse</h4><p>Az Eclipse esetén az <a href="http://m2eclipse.sonatype.org/">m2eclipse</a> hatékonyságáról hallottam rossz híreket, különösen nagy, több modulból álló projektek esetén, így azt nem próbáltam, helyette a <a href="http://maven.apache.org/plugins/maven-eclipse-plugin/">maven-eclipse-plugin plugin</a>-t használtam, mely a POM alapján képes módosítani az Eclipse projekt állományokat. A recept egyszerű:</p><ul><li>Hozzuk létre az Eclipse workspace-t</li><li>A mvn eclipse:configure-workspace -Declipse.workspace=C:/workspace paranccsal konfiguráljuk a workspace-t (a C:\workspace\.metadata\.plugins\org.eclipse.core.runtime\.settings\org.eclipse.jdt.core.prefs állományban létrehoz egy org.eclipse.jdt.core.classpathVariable.M2_REPO=C\:\\Documents and Settings\\jtechlog\\.m2\\repository bejegyzést, szóval létrehoz egy M2_REPO változót, mely a repository helyére mutat)</li><li>A mvn eclipse:eclipse paranccsal generáltassuk le a projekt állományokat, melyekkel már megnyitható a projekt Eclipse-ben</li><li>Amikor webes projektet hoztam létre, még a következő konfigurációt is el kellett helyeznem a POM-ban.<pre class="brush: xml">&lt;plugin&gt;
&lt;artifactId&gt;maven-eclipse-plugin&lt;/artifactId&gt;
&lt;configuration&gt;
  &lt;wtpmanifest&gt;true&lt;/wtpmanifest&gt;
    &lt;wtpapplicationxml&gt;true&lt;/wtpapplicationxml&gt;
    &lt;wtpversion&gt;2.0&lt;/wtpversion&gt;
&lt;/configuration&gt;
&lt;/plugin&gt;</pre></li></ul><p>Számomra meglepően jól működött az, hogyha változott a POM-ban valami, csak újrafuttattam az eclipse:eclipse goal-t, majd az Eclipse-ben újraolvastattam a projektet. Ha a NetBeans nem Ant alapú lenne, ott is jobban preferálnám ezt a módot.</p><h4>Code complete</h4><p>Különösen meglepő volt számomra, hogy mind a NetBeans-ben, mint az Eclipse-ben elérhető a POM code complete, sőt, működik a dependency megadásnál is, ugyanis automatikusan felajánlja az elérhető artifact-ek koordinátáit. A NetBeans esetén alul a státuszsorban látszik, hogy a hálózathoz kapcsolódik, és átviszi a repository indexét.</p><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_czKgycLvmNo/S9itjs4Z0wI/AAAAAAAAFQg/KmXZWGmTAxE/s1600/pom_code_complete.png"><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 320px; height: 143px;" src="http://2.bp.blogspot.com/_czKgycLvmNo/S9itjs4Z0wI/AAAAAAAAFQg/KmXZWGmTAxE/s320/pom_code_complete.png" border="0" alt="" id="BLOGGER_PHOTO_ID_5465308976668857090" /></a>
<h4>Provided</h4><p>Ha szükségünk van egy JAR-ra a fordításhoz, de nem akarjuk, hogy pl. webes alkalmazásnál a WAR-ba kerüljön, mert futtatáskor a konténer úgyis biztosítja azt a CLASSPATH-on ( ilyen pl. a servlet.jar, mail.jar stb.), akkor használjuk a provided scope-ot.</p><h4>Repository-k</h4><p></p><p>A default repository a http://repo1.maven.org/maven2/. Azonban itt elég sokminden nincs fenn, így más publikus repository-kat is használnunk kell. Ezek pl. (a legtöbbjük az Artifactory-ban alapban konfigurálva van):</p><ul><li>http://download.java.net/maven/1</li><li>http://download.java.net/maven/2</li><li>http://repository.jboss.com/maven2</li><li>http://repository.codehaus.org</li><li>http://maven.springframework.org/release</li><li>http://jasperreports.sourceforge.net/maven2/</li><li>http://stat-scm.sourceforge.net/maven2/</li><li>http://google-maven-repository.googlecode.com/svn/repository</li></ul><p>Ezeket beállíthatjuk a settings.xml-ünkben, de beállíthatjuk a POM-ban is. Az <a href="http://subversion.jfrog.org/artifactory/public/trunk/pom.xml">Artifactory POM</a>-jában láttam, hogy ott a repository-kat egy profile-ban adták meg, és ezt használva a -P kapcsolóval kell a profile-t megadni.</p><h4>Hiányzó artifact</h4><p>Abban az esetben, ha nem tudjuk a pontos koordinátákat a függőség megadásakor, érdemes valamilyen keresőt használni. Nekem ezek jöttek be:</p><ul><li>http://mvnrepository.com</li><li>http://repository.sonatype.org/</li><li>http://repository.apache.org</li></ul><h4>Servlet, JSP, JSTL</h4><p>A repo1-ben sokáig nem volt fenn a servlet, JSP és JSTL, <a href="http://maven.apache.org/guides/mini/guide-coping-with-sun-jars.html">licence-elési okokból</a>, és ezért azt javasolták, hogy helyette használjuk a Glassfish ide vonatkozó artifact-jait. Azonban ez megváltozott, ezen artifact-ok <a href="http://repo1.maven.org/maven2/javax/servlet/">megtalálhatóak</a> repo1-ben. Azonban, ha olyannal szembesülünk, ami nem található meg, akkor érdemes szétnézni a java.net-es repository-kban.</p><h4>Létező NetBeans projektről átállás</h4><p>Két projektben is a NetBeans projekt állományai mellé felvettem egy POM-ot is, hogy a Maven bevezethet legyen, de párhuzamosan mindkét build folyamat működjön. Ez azért körülményes, mert a könyvtárstruktúra nem a Maven konvencióinak felel meg. A cél az volt, hogy bitre megegyező war állományt állítson elő a NetBeans és a Maven. Az időm 90%-ában azon dolgoztam, hogy pont azokat a JAR-okat, és pont annyit tegyen oda, mint az eredeti projektben voltak. Az, hogy a könyvtárnevek eltértek, semmi gondot nem okozott. Három estém ment rá.</p><p>Egy kis statisztika:</p><table><tbody><tr><td>Technológia:</td><td>Spring, Struts, JSP</td></tr><tr><td>JAR-ok száma az eredeti projektben:</td><td>35</td></tr><tr><td>Dependency tag-ek a POM-ban:</td><td>30</td></tr><tr><td>Exclusions tag-ek nélkül a JAR-ok száma:</td><td>62</td></tr><tr><td>Exclusions tag-ek a POM-ban:</td><td>17 (!!!)</td></tr><tr><td>Egy repository-ban sem talált JAR-ok száma, melyeket kézzel kellett telepíteni:</td><td>3</td></tr></tbody></table><p>Ahhoz, hogy a NetBeans-es projekt azonnal leforduljon a Maven-nel is, a következő konfigurációkat kellett a POM-ban megtenni:</p><pre class="brush: xml">&lt;build&gt;
 &lt;!-- WAR neve --&gt;
 &lt;finalName&gt;app&lt;/finalName&gt;
 &lt;sourceDirectory&gt;src/java&lt;/sourceDirectory&gt;
 &lt;plugins&gt;
 &lt;!-- Fentebb említett 1.6-os Java és UTF-8 kódolások --&gt;
  &lt;plugin&gt;
   &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
   &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
   &lt;configuration&gt;
    &lt;warSourceDirectory&gt;web&lt;/warSourceDirectory&gt;
   &lt;/configuration&gt;
  &lt;/plugin&gt;
 &lt;/plugins&gt;
&lt;/build&gt;</pre><h3>Zárszó</h3><p></p><p>Abba a vitába nem mennék bele, hogy mikor van értelme Maven-t használni, és mikor érdemes Ant-nál, vagy valami másnál maradni. A Maven-t ki kell próbálni. A Maven-t előbb-utóbb nem tudod elkerülni. Egy biztos, aki használni akarja, az ne vegye félvállról, mert a megítélése szerintem az ezen a területen félig képzett programozók miatt van. És érdemes igyekezni, mert nyakunkon a <a href="http://java.dzone.com/articles/maven-3-rides-town">3-as verzió</a>.</p>