---
layout: post
title: SCJP
date: '2009-10-16T16:29:00.006+02:00'
author: István Viczián
tags:
- scjp
modified_time: '2014-02-02T16:34:13.253+01:00'
thumbnail: http://4.bp.blogspot.com/_czKgycLvmNo/StiELlgzvQI/AAAAAAAAEw8/mY6ogUFPd48/s72-c/scjp_book.jpg
blogger_id: tag:blogger.com,1999:blog-7370998606556338092.post-6053182487627786968
blogger_orig_url: http://www.jtechlog.hu/2009/10/scjp.html
---

<p>A mai nap sikeresen letettem a <a href="http://www.sun.com/training/catalog/courses/CX-310-065.xml">Sun Certified Programmer for the Java Platform, Standard Edition 6 (CX-310-065)</a>, rövid nevén SCJP vizsgát. Már rég meg kellett volna lépnem, a voucher is már majdnem egy éve megvan, de most tudtam rászánni magam. Leírnám a tapasztalataimat, hátha más is tudja kamatoztatni.</p><h3>Felkészülés</h3>Szinte kizárólag Katherine Sierra, Bert Bates: SCJP Sun Certified Programmer for Java 6 Exam 310-065 könyvet használtam felkészülésre. A könyv tíz fejezetből áll, és kifejezetten a vizsgára koncentrál, nagyon kevés plusz tudnivalót ír le, bár így is a tananyaggal foglakozó rész kb. 800 oldal. Azért érdemes ezt választani, mert írói részt vettek a vizsgakérdések kidolgozásában, egyértelműen definiálja a tananyagot, és példa teszt sorok is járnak hozzá. A könyvet mindig frissítették, ahogy új verziók jöttek ki a vizsgából.<p></p><p>
<a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_czKgycLvmNo/StiELlgzvQI/AAAAAAAAEw8/mY6ogUFPd48/s1600-h/scjp_book.jpg"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 246px; height: 320px;" src="http://4.bp.blogspot.com/_czKgycLvmNo/StiELlgzvQI/AAAAAAAAEw8/mY6ogUFPd48/s320/scjp_book.jpg" alt="" id="BLOGGER_PHOTO_ID_5393205888359316738" border="0" /></a></p><p>A könyv egy bevezetéssel indul, mely a vizsga lebonyolításáról szól, hogyan kell jelentkezni, hogyan zajlik a vizsga, stb. Majd mindegyik fejezet hosszasan kifejti a tananyagot, tudnivalókat. A szöveg közben vannak un. Exam Watch keretes írások, melyek azt írják le, hogy mire kell a vizsgán odafigyelni, és viszonylag kevés On The Job keretes írás, hogy az ismeretett témakört hogyan érdemes a gyakorlatban alkalmazni. Mindegyik fejezet leírja Certification Objective fejezethez tartozó részét, azaz a Sun által kiadott témakörökre való hivatkozásokat.
Mindegyik fejezet végén van egy összefoglaló, egy Two-Minute Drill mely felsorolásszerűen tartalmazza a fontosabb tudnivalókat (nevükkel ellentétbe nekem darabjának áttanulmányozása vagy 15 percig tartott). Itt vannak még a témakörhöz kapcsolódó példa kérdések és válaszok is (nagyon zavaró, mikor a kérdés felénél, a forráskódban van a sortörés). Különösen kiakasztott, hogy olyanokra kérdezett rá, melyeket az előző fejezetben nem írt le.</p><p>A CD mellékleten található két teljes vizsgasor is. Ezt meg lehet oldani úgy is, mintha a vizsgán lennénk (MasterExam), ugyanazokkal a feltételekkel, valamint quiz-szerűen is (Quiz). A CD mellékleten lévő vizsga  72 kérdéssel számol és 210 perccel. A quiz esetén 90 perc van a maximum 70 kérdésre, ez ne zavarjon meg minket, és ne keseredjünk el, reménytelen annyi idő alatt. A vizsga azonban nemrég változott, csak 60 kérdés van, melyeket 180 perc alatt kell megválaszolni.  A program nagyon nem tetszett. Egyrészt nincsenek benne drag&amp;drop kérdések, melyek a valós tesztben vannak. Ha egy teljes tesztet végigcsinálunk, akkor van lehetőség riport nyomtatására. A riport csak a jó válaszokat tartalmazza, és nem tartalmazza, hogy mi mit válaszoltunk, szóval csak a memóriánkra hagyatkozhatunk. Így a riport tanulásra teljesen alkalmatlan. Ehelyett alkalmazzuk a quiz-t, open book-kal, ilyenkor tippet is kapunk, valamint a választ megadva azonnal láthatjuk a helyes válaszokat, meg is magyarázva. A program honlapján regisztrálva állítólag még egy példa tesztet le lehet tölteni, de ezt nem próbáltam.</p><p>Én a teljes vizsgára kb. 30 órát készültem. Ebben benne van a könyv végigolvasása, a Two-Minute Drill-ek kétszeri végigolvasása, a fejezetek végén lévő tesztek megoldása, valamint a két példateszt végigpróbálása, és a válaszok kielemzése. Ennek bőven elég kell lennie. A vizsga a könyv kérdéseihez képest sokkal egyszerűbb, szóval ha az előbbin átmegyünk, nem lesz gondunk az éles vizsgán sem.
Hasznos lehet még a JavaRanch.com-on lévő <a href="http://faq.javaranch.com/java/ScjpFaq">JSCP FAQ</a>, valamint a Sun <a href="http://java.sun.com/docs/books/tutorial/extra/certification/index.html">felkészítő anyaga</a>. Bevallom, én a CD mellékleten kívül egy szabadon elérhető tesztsort sem vittem végig. Amit még elolvastam, ismétlő jelleggel <a href="http://palacsint.hu/blog/20090221/scjp-csapdak">Palacsint blogjában található SCJP csapdák</a> poszt, mely nagyon jól használható. Innen vettem az ötletet, hogy én is összeírom a szerintem fontos dolgokat, melyet listaszerűen a poszt végén találsz.</p><p>Amire nagyon oda kell figyelni, az szerintem a collections, generics és concurrency.
</p><h3>Körítés</h3><p>A vizsgára a voucher-t a Sun-nál lehet megrendelni, jelenleg 300$, ehhez semmiféle járulékos költség nem adódik. A vizsgát valamelyik Prometric vizsgaközpontban lehet letenni, természetesen én a SZÁMALK-ot válaszotottam, a vizsga előtt kb. két héttel jelentkeztem be. A vizsgán feleletválasztós kérdések (egy helyes válasz esetén rádiógomb, több esetén meg van adva a helyes válaszok száma - szemben a könyvvel) és pár drag&amp;drop kérdés van (kódrészleteket kell kódrészletbe behuzigálni - egyet akár többször is, és nem kötelező mindet felhasználni). A rendelkezésre álló idő 180 perc, a 60 kérdésből 35-öt kell eltalálni a sikeres vizsgához (58.33 %). A vizsgára nem lehet íróeszközt, szatyrot, tárcát, telefont, kabátot bevinni, ezeket elzárják. Letörölhető jegyzettömböt adnak. Mindenképp érdemes vizet bevinni. Az idő nem kevés, én minden kérdésen még egyszer át tudtam menni. Ezt érdemes is megtenni, 4-5 kérdést biztos javítottam. A teszt közben ha valamelyik kérdésben nem vagy biztos, érdemes megjelölni, sőt a jegyzettömbre felírni, hogy melyik válaszra gyanakszol. A drag&amp;drop-ról sokan mondták, hogyha újból megjeleníted, elveszted a már beírt dolgokat, így nem is kísérleteztem vele, de szerencsére nagyon egyszerűek voltak, nem akartam őket újra átnézni. A vizsga eredménye nem jelenik meg a képernyőn, hanem ki kell nyomtatni, és kinn adja oda az adminisztrátor.</p><h3>Vélemény</h3><p>Kérdés, hogy mennyi értelme van letenni az SCJP vizsgát? Sajnos itthon nem annyira elfogadott, álláskereséskor inkább a céget képviselő programozó kérdéseire, általa összeállított tesztsorra kell válaszolgatni. Kint jobb a helyzet, németeknél pl. sokat számít a papír. Magam részéről úgy gondolom (, régebben gyakrabban felvételiztettem), hogy az SCJP vizsgától még nem lesz jó programozó az emberből, de jobb programozó lesz, és mindenképp becsülendő, hogyha valaki időt és pénzt áldozott a felkészülésre és a vizsga megcsinálására. Ha egy cégnél dolgozunk, akkor szép juttatás lehet a vizsga, és arra való felkészülésnek a biztosítása.</p><p>És a végén az általam összegyűjtött dolgok, melyre érdemes odafigyelni:</p><ul><li>Publikus osztályt nem tartalmazó állományt bárhogy elnevezhetünk.</li><li>Default hozzáféréssel rendelkező osztályok elérhetőek az ugyanabban a csomagban lévő osztályokból.</li><li>A példánymetódusok felüldefiniálásakor (override) az új metódus nem dobhat bővebb (broader, azaz nem azonos vagy leszármazott) ellenőrzött (checked) kivételeket.</li><li>A strictfp módosító osztályra és metódusra is alkalmazható.</li>Az enum deklaráció végén opcionális a pontosvessző.Ha egy statikus metódust hívunk egy változón keresztül, a fordító a változó deklarációjában szereplő osztályra cseréli ki.<li>Java 5-től kezdve a metódus felüldefiniálásakor a visszatérési érték lehet az eredeti visszatérési érték, vagy annak leszármazottai (covariant return)</li><li>Laza kötésre (loose coupling) és magas kohézióra (high cohesion) kell törekedni.</li><li>Az értékadó operátorok (pl. +=) automatikus típuskényszerítést végezhetnek</li><li>Az == használata autoboxing esetén trükkös, ugyanis byte, és -128 és 127 közötti Short, Integer értékek között egy pool van, így igazat fog visszaadni, e felett viszont hamist.</li><li>Egyenlőségvizsgálatnál ha két különböző
osztályhierarchiában lévő osztály típusú változót hasonlítunk össze, már fordításkor elszáll</li><li>A switch esetén a case paraméterének fordítási időben kiszámolhatónak kell lennie</li><li>Ha byte típust adok át egy switch-nek, és a case után nem fér bele a szám byte-ba, fordítási hiba keletezik</li><li>A default block középen is lehet</li><li>System.exit-nél nem fut le a finally</li><li>Assert Java 1.4-től van</li><li>Nem szerializálható ősosztályok konstruktora, inicializációja lefut deszerializáláskor. Statikus változó sosem kerül szerializálásra.</li><li>A StringBuffer equals() metódusa nincs felüldefiniálva, nem az értéket hasonlítja</li><li>A megtanulandó printf flag-ek: -, +, 0, "," , és (, formátumok:  %b, %c, %d, %f, %s. A %b boolean-ra, true-t ad minden non-null vagy non-boolean értékre.</li><li>Autoboxing esetén az equals() csak akkor igaz, ha a primitív típusok és az értékek is megegyeznek.</li><li>Queue interfész, PriorityQueue osztály</li><li>NavigableSet, NavigableMap interfészek: Java 6</li><li>A HashMap beenged null-t, a Hashtable nem</li><li>LinkedHashMap sorrendje: beszúrás vagy utolsó hozzáférés</li><li>equals metódusnál kötelező az Object típusú paraméter, compareTo-nál nem</li><li>headSet, subSet, tailSet - boolean paraméter - inclusive, ha nincs boolean, a kezdő mindig inclusive</li><li>Natural order: space, nagybetűk, kisbetűk</li><li>Generikus esetében a deklarációban és az értékadásban a generikus típusának pontosan meg kell egyeznie, amennyiben nem használunk wildcard karaktereket, azaz a List&lt;Animal&gt; aList = new ArrayList&lt;Dog&gt;(); nem fordul le, hiába a Dog az Animal leszármazottja
</dog></animal></li><li>Példányosításnál generics wildcard nem használható</li><li>new MyOuter().new MyInner(); vagy MyOuter.MyInner inner = mo.new MyInner();</li><li>MyOuter.this</li><li>A vizsga szempontjából metóduson belül definiált osztály módosítója vagy abstract vagy final.</li><li>JAR készítésekor az a könyvtár is belekerül, melyet paraméternek megadunk, nem csak az az alatti könyvtárak, állományok</li><li>A Runnable példánynak nincs referenciája a szálra, ami futtatja, ezt lehet elkérni a Thread.currentThread() metódussal</li><li>Ha egy szál el lett indítva, nem lehet többet újra elindítani</li><li>sleep, yield: statikus metódusok</li><li>sleep-nél nem vesznek el a lock-ok</li><li>Console a java.io csomagban van</li><li>Polimorfizmus csak a példánymetódusokra vonatkozik, se a statikus metódusokra, se bármilyen típusú változókra</li><li>A Throwable az osztály</li><li>Szerializációkor a pontos metódus: private void readObject(ObjectInputStream is) throws IOException, ClassNotFoundException</li></ul>