---
layout: post
title: AOP
date: 2002-11-29T08:00:00.000+01:00
author: Viczián István
tags:
---

<p>
Mostanában egyre többször szó esik a vezető
objektumorientált irányzatra épülő, vagy azzal teljesen
ellentmondó irányzatokról. Nemrég fedeztem fel az
aspektusorientált programozási módszertant (Aspect Oriented
Programming - AOP), melyet egy 1997-es <a href="http://citeseer.nj.nec.com/kiczales97aspectoriented.html">cikk</a>
indított el.</p>
<p>
Természetesen már van több Java nyelvű <a href="http://directory.google.com/Top/Computers/Programming/Languages/Java/Extensions/Aspect-Oriented/">
megvalósítás</a> is, ezek közül én az <a href="http://www.eclipse.org/aspectj/">AspectJ</a> eszközt
nézegettem.</p>
<p>
Az aspektusorientált programozás egy magasabb szintű
absztrakció, mely megpróbálja az olyan általános célú
kódrészelteket egységbe foglalni, melyek nehezen szedhetők
külön egy osztályba, hiszen egy tipikus objektumorientált
alkalmazásnál az osztályokban általában elszórva
helyezkednek el (cross-cut). Ezáltal a kód rövidebb,
tisztább, modulárisabb, érthetőbb, biztonságosabb és
könnyebben módosítható lesz. Használható képfeldolgozási
filterek, algoritmusok ciklusainak összevonására,
forgalomirányításra, naplózásra, hiba utáni
visszaállításra.</p>
<p>
Az AspectJ egy olyan eszköz, mely a Java nyelvet kibővíti
aspektusorientált funkciókkal. Nem a forrást piszkálja,
hanem a már kész bájtkódot.</p>
<p>
Mint ebből a <a href="http://developers.sun.com/tools/javatools/articles/aspectJ.html ">cikkből</a>
is kiderül, alapfogalmai a join point, mely egy Java program
egy végrehajtási pontja, mely lehet az a pont, ahonnan egy
metódust hívnak, egy metódus végrehajtásának eleje és egy
nem privát tag értékadása. A point-cut a join pointok
halmaza, bizonyos feltétellel feltételekkel definiálva. A
join point nem állhat magában. Az advice declaration egy
típust és egy kódrészt tartalmaz. Amikor a vezérlés egy join
pointra kerül, és a point-cutban megadott feltétel igaz,
akkor lefut a típusnak megfelelően az advice declaration
kódja. Az inter-type member declarationnal az osztályhoz
kívülről tagokat adhatunk a forrás változtatása nélkül. Az
aspektusok az osztályokkal megegyező szinten vannak, és
point-cutokat, advice declarationöket és inter-type member
declarationöket tartalmazhatnak.</p>
<p>
Hogyan használható ez pl. loggolásnál? Megadjuk, hogy a
join point egy metódus hívása legyen, és a feltételt
beállítjuk wildcard karakterekkel, hogy a <code>*.setNev(..)<code>
metódusoknál legyen igaz. Megadjuk a típust, hogy <code>before()</code>,
azaz a végrehajtás előtt fusson le a loggolást végző kód, és
implementáljuk a loggolást. Majd megadjuk, hogy mely
osztályokra vonatkozzon ez az aspektus. Így szépen
elválasztottuk, a loggolást az osztályoktól, és saját
komponensben (aspektusban) implementáltuk.</p>
<p>
Mostanában egyre hosszabbakat írok, megpróbálok
visszavenni.
</p>
