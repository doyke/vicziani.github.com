---
layout: post
title: Spring Data
date: '2014-07-12T16:22:00.000+02:00'
author: István Viczián
tags:
- Spring
- JPA
modified_time: '2014-09-17T22:28:11.266+02:00'
blogger_id: tag:blogger.com,1999:blog-7370998606556338092.post-2322684734980758092
blogger_orig_url: http://www.jtechlog.hu/2014/07/spring-data.html
---

<p>Használt technológiák: Spring Data 1.6</p>

<p>Be kell vallanom, első körben meglehetősen szkeptikus voltam a Spring Data projekttel kapcsolatban, és nem hittem, hogy bármi pluszt képes nyújtani a Spring JPA integrációjához képest, de kipróbálva hamar kiderült, hogy hasznos lenne alkalmazni. Amennyiben a projektedben találsz olyan (absztrakt) ősosztály(oka)t, melyek feladata tipikus CRUD műveletek végrehajtása, esetleg típus biztosan, hogy ne kelljen azokat újra implementálni, akkor a Spring Data neked is tetszeni fog.</p>

<p>A poszthoz egyszerű <a href="https://github.com/vicziani/jtechlog-spring-data">példaprojektet</a> is találsz a GitHub-on, valamint egy <a href="http://about.jtechlog.hu/artifacts/2014-06_spring_data/2014-06_spring_data.html">prezentációt</a>, amit nyugodtan felhasználhatsz arra, hogy meggyőzz másokat is.</p>

<p>A Spring Data alapvetően egy Spring Frameworkre épülő projekt, és segít abban, hogy egyszerűbben implementálhassuk alkalmazásaink perzisztens rétegét. Egy olyan projekt, mely több projektet is tartalmaz, ugyanis különböző perzisztens technológiákra implementálták, úgymint JPA, JDBC, REST, de olyan NoSQL megoldásokra is van implementációja, mint MongoDB, Neo4j, Redis, Hadoop, stb.</p>

<p>A Spring szóhasználatban <em>repository</em>-k megvalósítására való, és tipikus CRUD műveleteket lehet definiálni, ráadásul az olyan gyakori igények figyelembe vételével, mint a rendezés vagy a lapozás.</p>

<p>Az érdekessége, hogy egyszerűbb esetben nem nekünk kell implementálni a metódusokat. Nekünk elég az interfészben különböző névkonvenciók alapján definiálni a metódusokat, és a Spring Data implementálja azokat. A leggyakoribb metódusokat még definiálni sem kell, elég interfészünknek valamely már létező interfészből leszármaznia. Amennyiben azonban nem elegendő a Spring Data tudása, természetesen mi is implementálhatunk saját metódusokat.</p>

<p>A Spring Data projekt része a Spring Data JPA, mely a már meglévő Spring JPA integrációra épül rá. Ugyanúgy deklarálnunk kell a <code>DataSource</code>-t, <code>EntityManagerFactory</code>-t, <code>TransactionManager</code>-t és a JPA annotációkkal ellátott entitásokat. Eztán a következőket kell elvégeznünk. Maven használata esetén először definiáljuk a Spring Data JPA függőséget.</p>

<pre style="" class="prettyprint prettyprinted"><code class="language-xml"><span class="tag">&lt;dependency&gt;</span><span class="pln">
    </span><span class="tag">&lt;groupId&gt;</span><span class="pln">org.springframework.data</span><span class="tag">&lt;/groupId&gt;</span><span class="pln">
    </span><span class="tag">&lt;artifactId&gt;</span><span class="pln">spring-data-jpa</span><span class="tag">&lt;/artifactId&gt;</span><span class="pln">
    </span><span class="tag">&lt;version&gt;</span><span class="pln">1.6.0.RELEASE</span><span class="tag">&lt;/version&gt;</span><span class="pln">
</span><span class="tag">&lt;/dependency&gt;</span></code></pre>

<p>Amennyiben ez megvan, az application config xml állományban definiáljuk, hogy mely csomagban találhatóak a repository-k. (Természetesen lehetőség van Java Configban való megadásra is az <code>@EnableJpaRepositories</code> annotáció használatával.)</p>

<pre style="" class="prettyprint prettyprinted"><code class="language-xml"><span class="tag">&lt;jpa:repositories</span><span class="pln"> </span><span class="atn">base-package</span><span class="pun">=</span><span class="atv">"jtechlog.springdata"</span><span class="pln"> </span><span class="tag">/&gt;</span></code></pre>

<p>Eztán elegendő az interfészt definiálni. Leszármazhat a <code>Repository</code> interfészből, de mivel ennek nincs semmilyen előre definiált metódusa, használjuk inkább a <code>CrudRepository</code> interfészt ősnek, ami a következő metódusokat definiálja: <code>save(Employee)</code>, <code>save(Iterable&lt;Employee&gt;)</code>, <code>findOne(Long)</code>, <code>exists(Long)</code>, <code>findAll()</code>, <code>findAll(Iterable&lt;Long&gt;)</code>, <code>count()</code>, <code>delete(Long)</code>, <code>delete(Employee)</code>, <code>deleteAll()</code>.</p>

<p>Interfészünk tehát:</p>

<pre style="" class="prettyprint prettyprinted"><code class="language-java"><span class="kwd">import</span><span class="pln"> org</span><span class="pun">.</span><span class="pln">springframework</span><span class="pun">.</span><span class="pln">data</span><span class="pun">.</span><span class="pln">repository</span><span class="pun">.</span><span class="typ">CrudRepository</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">public</span><span class="pln"> interface </span><span class="typ">EmployeeRepository</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">CrudRepository</span><span class="pun">&lt;</span><span class="typ">Employee</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Long</span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>Eztán már azonnal használatba is vehetjük, hiszen ahogy említettem az implementációt a Spring Data JPA fogja elkészíteni. Tehát a teszt eset:</p>

<pre style="" class="prettyprint prettyprinted"><code class="language-java"><span class="lit">@Test</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> testSave_findAllShouldReturnOne</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    employeeRepository</span><span class="pun">.</span><span class="pln">save</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Employee</span><span class="pun">(</span><span class="str">"John Doe"</span><span class="pun">));</span><span class="pln">

    assertThat</span><span class="pun">(</span><span class="pln">employeeRepository</span><span class="pun">.</span><span class="pln">findAll</span><span class="pun">(),</span><span class="pln"> 
        contains</span><span class="pun">(</span><span class="pln">hasName</span><span class="pun">(</span><span class="pln">equalTo</span><span class="pun">(</span><span class="str">"John Doe"</span><span class="pun">))));</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>Ehhez új metódusokat adhatunk hozzá, melyhez a <a href="http://docs.spring.io/spring-data/jpa/docs/1.6.0.RELEASE/reference/html/jpa.repositories.html#jpa.query-methods.query-creation">névkonvenció</a> alapján automatikusan implementációt fog gyártani a Spring Data JPA.</p>

<pre style="" class="prettyprint prettyprinted"><code class="language-java"><span class="typ">Iterable</span><span class="pun">&lt;</span><span class="typ">Employee</span><span class="pun">&gt;</span><span class="pln"> findByNameStartingWith</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> namePrefix</span><span class="pun">);</span></code></pre>

<p>Amennyiben ez nem megfelelő, saját JPA query-t is definiálhatunk, a <code>@Query</code> annotáció használatával.</p>

<pre style="" class="prettyprint prettyprinted"><code class="language-java"><span class="lit">@Query</span><span class="pun">(</span><span class="str">"select e from Employee e where length(e.name) = :nameLength"</span><span class="pun">)</span><span class="pln">
</span><span class="typ">Iterable</span><span class="pun">&lt;</span><span class="typ">Employee</span><span class="pun">&gt;</span><span class="pln"> findByNameLength</span><span class="pun">(</span><span class="lit">@Param</span><span class="pun">(</span><span class="str">"nameLength"</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> nameLength</span><span class="pun">);</span></code></pre>

<p>Amennyiben egy metódushoz saját implementációt akarunk rendelni, akkor a metódust egy külön interfészbe definiáljuk, ami szintén őse legyen a repository interfészünknek, és adjuk meg hozzá az implementációt is a klasszikus JPA módon.</p>

<p>Saját interfész:</p>

<pre style="" class="prettyprint prettyprinted"><code class="language-java"><span class="kwd">public</span><span class="pln"> interface </span><span class="typ">EmployeeRepositoryCustom</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

    </span><span class="typ">List</span><span class="pun">&lt;</span><span class="typ">Employee</span><span class="pun">&gt;</span><span class="pln"> findByNameStartingWithAsList</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> namePrefix</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>Saját implementáció:</p>

<pre style="" class="prettyprint prettyprinted"><code class="language-java"><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">EmployeeRepositoryImpl</span><span class="pln"> </span><span class="kwd">implements</span><span class="pln"> </span><span class="typ">EmployeeRepositoryCustom</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

    </span><span class="lit">@Autowired</span><span class="pln">
    </span><span class="kwd">private</span><span class="pln"> </span><span class="typ">EntityManager</span><span class="pln"> entityManager</span><span class="pun">;</span><span class="pln">

    </span><span class="lit">@Override</span><span class="pln">
    </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">List</span><span class="pun">&lt;</span><span class="typ">Employee</span><span class="pun">&gt;</span><span class="pln"> findByNameStartingWithAsList</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> namePrefix</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> entityManager
            </span><span class="pun">.</span><span class="pln">createQuery</span><span class="pun">(</span><span class="pln">
                </span><span class="str">"select e from Employee e where e.name like :namePrefix"</span><span class="pun">,</span><span class="pln"> 
                </span><span class="typ">Employee</span><span class="pun">.</span><span class="kwd">class</span><span class="pun">)</span><span class="pln">
            </span><span class="pun">.</span><span class="pln">setParameter</span><span class="pun">(</span><span class="str">"namePrefix"</span><span class="pun">,</span><span class="pln"> namePrefix </span><span class="pun">+</span><span class="pln"> </span><span class="str">"%"</span><span class="pun">).</span><span class="pln">getResultList</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>És a repository interfész:</p>

<pre style="" class="prettyprint prettyprinted"><code class="language-java"><span class="kwd">public</span><span class="pln"> interface </span><span class="typ">EmployeeRepository</span><span class="pln"> 
    </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">CrudRepository</span><span class="pun">&lt;</span><span class="typ">Employee</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Long</span><span class="pun">&gt;,</span><span class="pln"> </span><span class="typ">EmployeeRepositoryCustom</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="com">// ...</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>Ha rendezni akarunk, akkor definiálhatjuk a metódus nevében:</p>

<pre style="" class="prettyprint prettyprinted"><code class="language-java"><span class="typ">Iterable</span><span class="pun">&lt;</span><span class="typ">Employee</span><span class="pun">&gt;</span><span class="pln"> findByNameStartingWithOrderByNameAsc</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> namePrefix</span><span class="pun">);</span></code></pre>

<p>Vagy ha ennél dinamikusabb megoldás akarunk, akkor használjuk a <code>Sort</code> típust paraméterként.</p>

<pre style="" class="prettyprint prettyprinted"><code class="language-java"><span class="typ">Iterable</span><span class="pun">&lt;</span><span class="typ">Employee</span><span class="pun">&gt;</span><span class="pln"> findByNameStartingWith</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> namePrefix</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Sort</span><span class="pln"> sort</span><span class="pun">);</span></code></pre>

<p>Mely így használható:</p>

<pre style="" class="prettyprint prettyprinted"><code class="language-java"><span class="pln">employeeRepository</span><span class="pun">.</span><span class="pln">findByNameStartingWith</span><span class="pun">(</span><span class="str">"J"</span><span class="pun">,</span><span class="pln"> 
    </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Sort</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Sort</span><span class="pun">.</span><span class="typ">Order</span><span class="pun">(</span><span class="typ">Sort</span><span class="pun">.</span><span class="typ">Direction</span><span class="pun">.</span><span class="pln">ASC</span><span class="pun">,</span><span class="pln"> </span><span class="str">"name"</span><span class="pun">)))</span></code></pre>

<p>Ha lapozást is akarunk, akkor a <code>Pageable</code> használandó:</p>

<pre style="" class="prettyprint prettyprinted"><code class="language-java"><span class="typ">Page</span><span class="pun">&lt;</span><span class="typ">Employee</span><span class="pun">&gt;</span><span class="pln"> findByNameStartingWith</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> namePrefix</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Pageable</span><span class="pln"> page</span><span class="pun">);</span></code></pre>

<p>Melyet a következő módon tudunk hívni:</p>

<pre style="" class="prettyprint prettyprinted"><code class="language-java"><span class="typ">Page</span><span class="pln"> page </span><span class="pun">=</span><span class="pln"> employeeRepository</span><span class="pun">.</span><span class="pln">findByNameStartingWith</span><span class="pun">(</span><span class="str">"J"</span><span class="pun">,</span><span class="pln"> 
    </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">PageRequest</span><span class="pun">(</span><span class="lit">3</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Sort</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Sort</span><span class="pun">.</span><span class="typ">Order</span><span class="pun">(</span><span class="typ">Sort</span><span class="pun">.</span><span class="typ">Direction</span><span class="pun">.</span><span class="pln">ASC</span><span class="pun">,</span><span class="pln"> </span><span class="str">"name"</span><span class="pun">))));</span></code></pre>

<p>A <code>Page</code> tartalmazza a lekérdezés eredményét, és a lapozáshoz szükséges többi információt is.</p>

<p>Látható, hogy a Spring Data használata rendkívül egyszerű, sok boilerplate kódtól szabadulhatunk meg. Nekem az is tetszik, hogy így metódusainknak szabványos nevet adhatunk meg. Fokozatosan lehet bevezetni a projektjeinkbe, akár DAO-nként állhatunk át, és az egyre bonyolultabb funkcióit is folyamatosan vehetjük használatba.</p>