---
layout: post
title: RESTful webszolgáltatások Jersey-vel
date: '2009-12-27T11:56:00.005+01:00'
author: István Viczián
tags:
- SOA
- JAX-RS
modified_time: '2014-01-12T16:45:14.048+01:00'
blogger_id: tag:blogger.com,1999:blog-7370998606556338092.post-2978305213591579409
blogger_orig_url: http://www.jtechlog.hu/2009/12/restful-web-szolgaltatasok-jersey-vel.html
---

<p>Frissítve: 2014. január 12.</p>

<p>Felhasznált technológiák: Java 7, Jersey 2.5.1, JQuery 1.8.3, Jackson 1.9.13, JUnit 4.11, Maven 3.0.3, Jetty 9.1.0</p>

<p>Az általam is már többször részletezett, nehézsúlyú, bonyolult SOAP alapú web szolgáltatások és API-k összetettségét ellensúlyozva jelent meg Roy Fielding PhD dolgozata alapján a REST fogalom.</p>

<p>Most egy egyszerű kliens-szerver alkalmazást kellett írnom, ahol különböző eseményeket kellett küldenem a szerver oldalra. Az RMI-t elvetettem, hiszen bonyolultabban vezethető át a protokollja a tűzfalon, és csak Java-ból használható, a SOAP-ot ágyúnak éreztem, képbe került még az XML-RPC, mely nem szabványos, így választásom a JAX-RS-re esett, mellyel Java-ban lehet RESTful web szolgáltatásokat építeni.</p>

<p>A JAX-RS egy specifikáció (JSR 311), melynek több implementációja is létezik, köztük a referencia implementáció, a Jersey.</p>

<p>A REST egy szoftver architektúra, mely létező, bevált protokollokra, szabványokra építkezik, ahelyett, hogy újat találjon ki. Úgynevezett erőforrásokból (resource) építkezik, és mindegyik ilyen erőforrásnak van egyedi azonosítója, és ezeket össze is lehet linkelni. A kliens ezen erőforrásokat kéri le, azok azonosítója alapján, de lehetőség van új erőforrás hozzáadására, módosítására, törlésére is. A kérések egymástól függetlenek, nem létezik munkamenet (session) fogalom, a kliens mindig az adott erőforrás egy adott állapotát kapja vissza. (Emiatt egyszerűbb az architektúra, könnyen megoldható a gyorsítótárazás - cache, valamint a terhelés elosztás.) Az erőforrásokat különböző módon lehet megjeleníteni, pl. egy számsort magával a számok sorozatával, de akár egy grafikonnal. Ezen tulajdonságok alapján jött a rövidítés: representational state transfer.</p>

<p>A felhasznált létező szabványok az URI, mellyel az erőforrások azonosítója adható meg. Az erőforrások különböző megjelenítési módjait MIME type-pal lehet megadni, ami lehet egyszerű szöveg, html, xml, vagy manapság az egyre divatosabb JSON is, vagy speciálisabb esetekben pl. kép is. A leggyakrabban használt protokoll a HTTP, hiszen ez biztosítja a kliens-szerver architektúrát, állapotmentességet, cache-elhetőséget, különböző rétegek kialakítását (akár transzarens módon a titkosítást, lásd https), valamint ez van átengedve a legtöbb hálózati eszközön, tűzfalon. A HTTP metódusaival a CRUD műveleteket is megvalósíthatóak, a legtöbbet használt GET, POST mellett létezik a PUT és DELETE is. Ugyanúgy, ahogy a klasszikus web szolgáltatások esetében, más protokoll is választható.</p>

<p>A JAX-RS a JAX-WS-hez hasonlóan egyszerű POJO-kkal dolgozik, melyekre annotációkat kell használni.</p>

<p>Használatának demonstrálására egy példa projektet készítettem, mely könyvjelzők nyilvántartását végzi, és <a href="https://github.com/vicziani/jtechlog-rest">elérhető a GitHub-on.</a> A következő URL-eket definiáltam:</p>

<ul>
  <li>/bookmarks: GET esetén XML vagy JSON formátumban adja vissza az eddig elküldött eseményeket, POST esetén az eseményt várja XML vagy JSON formátumban, melyet elment</li>
  <li>/bookmarks/14: XML vagy JSON formátumban adja vissza a 14-es azonosítójú eseményt</li>
</ul>

<p>Első esetben a visszaadott XML:</p>

<pre class="brush: xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
&lt;bookmarks&gt;
 &lt;bookmark&gt;
  &lt;id&gt;1&lt;/id&gt;
  &lt;url&gt;http://jtechlog.blogspot.hu&lt;/url&gt;
  &lt;title&gt;JTechLog&lt;/title&gt;
 &lt;/bookmark&gt;
&lt;/bookmarks&gt;</pre>

<p>Ugyanez JSON-ben:</p>
<pre class="brush: javascript">[{
 "id": 1,
 "url": "http://jtechlog.blogspot.hu",
 "title": "JTechLog"
}]</pre>

<p>Amennyiben egy könyvjelzőt szeretnénk lekérdezni, vagy felküldeni, csak a bookmark tag tartalma használandó. Amennyiben nem XML-lel akarunk dolgozni, használható az "application/xml" helyett pl. az "application/json" MIME type is.</p>

<p>Először készítsük el az eseményt reprezentáló osztályt:</p>

<pre class="brush: java">@XmlRootElement
public class Bookmark {
 private Long id;

 private String url;

 private String title;

 // konstruktorok, getter/setter metódusok
}</pre>

<p>Figyeljük meg a @XmlRootElement annotációt! Utána készítsük el az erőforrást reprezentáló osztályt:</p>

<pre class="brush: java">@Path(&quot;/bookmarks&quot;)
public class BookmarkResource {

    private static BookmarkDao bookmarkDao = BookmarkDao.getBookmarkDao();

    @GET
    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    public List&lt;Bookmark&gt; listBookmarks() {
        return bookmarkDao.listBookmarks();
    }

    @GET
    @Path(&quot;/{id}&quot;)
    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    public Bookmark findBookmark(@PathParam(&quot;id&quot;) long id) {
        Bookmark bookmark = bookmarkDao.findBookmark(id);
        if (bookmark == null) {
            throw new WebApplicationException(Response.Status.NOT_FOUND);
        }
        return bookmark;
    }

    @POST
    @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    @Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
    public Response createBookmark(Bookmark bookmark) {
        Bookmark createdBookmark = bookmarkDao.createBookmark(bookmark);
        return Response.status(Response.Status.CREATED).entity(createdBookmark).build();
    }
}</pre>

<p>Látható, hogy az erőforrásban három metódust definiáltunk, rendre a következő funkciókkal: könyvjelzők betöltése, könyvjelző betöltése, könyvjelzők mentése. Mindhárom a /bookmarks címen érhető el, mint az osztályon lévő @Path annotáció mutatja. Az első két funkció GET metódussal érhető el, és XML és JSON kimenetet is képes gyártani (@Produces annotáció), a harmadik POST metódussal, és képes XML és JSON bemenetet is fogadni (@Consumes annotáció). A második metódusnál figyeljük meg, hogy az URL-ben megadhatók változók is, melyre később a @PathParam annotációval hivatkozunk.</p>

<p>Ahhoz, hogy a kérés ki is legyen szolgálva, elegendő egy @ApplicationPath annotációval ellátott osztályt készíteni:</p><pre class="brush: java">@ApplicationPath("resources")
public class JtechlogRestApplication extends ResourceConfig {

    public JtechlogRestApplication() {
        register(org.glassfish.jersey.jackson.JacksonFeature.class);
        packages("jtechlog.rest");
    }
}</pre>

<p>És most nézzük a teszt esetet, mondjuk az események lekérdezését. Érdekessége, hogy elindít egy inmemory konténert, és azon keresztül történik a hívás.</p>

<pre class="brush: java">@Test
public void testListBookmark() {
 // Given
 BookmarkDao.getBookmarkDao().createBookmark(createBookmark(&quot;http://jtechlog.blogspot.hu&quot;, &quot;JTechLog&quot;));
 BookmarkDao.getBookmarkDao().createBookmark(createBookmark(&quot;https://github.com/vicziani&quot;, &quot;GitHub&quot;));

 // When
 List&lt;Bookmark&gt; bookmarks = target(&quot;bookmarks&quot;).request().accept(MediaType.APPLICATION_JSON_TYPE).get(new GenericType&lt;List&lt;Bookmark&gt;&gt;(){});

 // Then
 assertEquals(2, bookmarks.size());
 assertEquals(&quot;JTechLog&quot;, bookmarks.get(0).getTitle());
}</pre>

<p>Látható, hogy ez a RESTful web szolgáltatások használata nem csak az API ismeretét igényli, hanem egy másfajta gondolkodásmódot is.</p>