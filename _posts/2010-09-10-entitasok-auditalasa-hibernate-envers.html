---
layout: post
title: Entitások auditálása Hibernate Envers-szel
date: '2010-09-10T01:11:00.006+02:00'
author: István Viczián
tags: 
modified_time: '2014-01-04T21:32:48.308+01:00'
blogger_id: tag:blogger.com,1999:blog-7370998606556338092.post-8676689565958825145
blogger_orig_url: http://www.jtechlog.hu/2010/09/entitasok-auditalasa-hibernate-envers.html
---

<p>Frissítve: 2014. január 4.

<p>Felhasznált technológiák: Hibernate 4.3.0, HSQLDB 2.3.1, SLF4J 1.7.5, JUnit 4.11, Apache Commons DbUtils 1.5, Maven 3.0.3</p>

<p>A <a href="http://www.jboss.org/envers">Hibernate Envers</a>
egy nagyon egyszerű Hibernate modul arra, hogy az entitásokat auditáljuk, azaz módosításkor a régi értékek is
megmaradjanak az adatbázisban, és azokat bármikor előkereshessük.</p>
<p>Gyakori megrendelői igény, hogy látni lehessen, hogy ki, mikor és mit módosított bizonyos entitásokon,
 rekordokon. Az alkalmazásfejlesztő szeretné ezt minél transzparensebb módon kezelni, szóval lehetőleg ne kelljen
 ehhez a kódot módosítani. Egyszerű megoldás, hogy az aktuális és az audit rekordok is ugyanabban a táblában
 maradnak, és egy flag-et állítunk. Ezt meg lehet oldani alacsonyabb szinten is, pl.
 adatbázis triggerek alkalmazásával. Azaz a táblára kell tenni egy pre-insert, pre-delete és pre-update
 trigger-t, mely az adott rekordokat átmásolja egy másik, szerkezetileg hasonló táblába. Persze ehhez a triggert
 nekünk kell megírnunk. Az Oracle az audit rekordokat tartalmazó táblát Journal Table-nek nevezi, és bizonyos
 eszközök, pl. az Oracle Designer/2000, képesek ezeket, és a hozzá tartozó triggereket automatikusan legenerálni.
 Ha nem adatbázis alapú megoldást szeretnénk alkalmazni, használhatjuk pl. JPA esetén annak életciklus
 metódusait. Ennél azonban magasabb szintű, és szabványosabb megoldást biztosít a Hibernate Envers.
</p>
<p>Az Envers gyakorlatilag beépül a Hibernate-be, és akár natív módon, akár JPA-n keresztül használjuk,
 kihasználhatjuk az előnyeit. Működik különálló alkalmazásban, de alkalmazásszerveren belül is, ahol a Hibernate
 végzi a perzisztenciát. A Subversion-höz hasonlóan az Envers is bevezeti a revision fogalmát. Gyakorlatilag
 minden tranzakció, mely auditálandó entitást szúr be, módosít vagy töröl, kap egy revision számot, mely a
 rendszeren belül egyedi. Minden revision-höz elmenti annak dátumát is. Minden entitáshoz létrehoz egy audit
 táblát is, melybe módosításkor vagy törléskor elmenti az előző állapotot, és természetesen hozzácsapja ezt a
 revision számot is. Utána a standard lekérdezésekkel elérjük a normál entitásainkat, de lehetőségünk van akár
 revision szám, akár dátum alapján visszakeresnünk az entitásaink régebbi állapotait.
</p>
<p>Használata rendkívül egyszerű, 
 <a href="http://docs.jboss.org/hibernate/orm/4.2/devguide/en-US/html/ch15.html">jól dokumentált</a>
 mutatja be a lehetőségeit. Én is készítettem egy egyszerű Maven-es projektet, mely 
 <a href="https://github.com/vicziani/jtechlog-hibernate-envers">letölthető a GitHub-ról</a>. Ez 
 a tipikus Employee, Phone entitásokból áll, valamint az ezen CRUD műveleteket végző EmployeeService
 osztályból, mely JPA-t használ. Az EmployeeServiceTest teszt eset mutatja az Envers képességeit. A teszt esetek
 az mvn test parancs kiadásával futtathatóak. Adatbázis telepítése nem szükséges, memóriában futó HSQLDB-t
 használ.
</p>
<a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}"
   href="http://yuml.me/diagram/scruffy/class/%5BEmployee%7Cid;name;modifiedAt]++1-%3E*[Phone%7Ctype;number],%20[EmployeeService%7C%7CpersistEmployee%28%29;mergeEmployee%28%29;removeEmployee%28%29;listEmployees%28%29]-[Employee]">
 <img style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; width: 500px; height: 110px;"
   src="http://yuml.me/diagram/scruffy/class/%5BEmployee%7Cid;name;modifiedAt]++1-%3E*[Phone%7Ctype;number],%20[EmployeeService%7C%7CpersistEmployee%28%29;mergeEmployee%28%29;removeEmployee%28%29;listEmployees%28%29]-[Employee]"
   alt="" border="0"/>
</a>
<p>Az Envers használatához szükséges, hogy a classpath-ban legyen, ehhez a Maven-ben a következő függőséget kell
 felvennünk:
</p>
<pre class="brush: xml">&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-envers&lt;/artifactId&gt;
    &lt;version&gt;${hibernate.version}&lt;/version&gt;
&lt;/dependency&gt;</pre>
<p>Előző verziókban még konfigurálunk kellett a persistence.xml-ben a listenereket, most már elég, ha a jar a classpath-on van.</p>
<p>Ahhoz, hogy egy entitást az Envers auditáljon, el kell helyezni rajta az @Audited annotációt. Amennyiben nem
 akarjuk az összes mezőjét auditálni, elhelyezhetjük az annotációt a mezőkön is. A példában az Employee és a
 Phone entitáson is elhelyeztük az annotációt.
</p>
<pre class="brush: java">@Entity
@Audited
public class Employee implements Serializable {
...
}</pre>
<p>Az Envers használatához semmi több nem szükséges, a standard JPA műveleteket használva automatikusan megtörténik
 az auditálás. Ez annyit jelent, hogy sémageneráláskor az Employee és Phone tábla mellé létrehoz egy Employee_AUD
 és egy Phone_AUD táblát is, mely megegyezik az eredeti táblákkal, azzal a különbséggel, hogy kiegészíti egy REV
 és egy REVTYPE mezővel, valamint létrehoz egy REVINFO táblát, REV és REVTSTMP mezővel. Minden egyes beszúráskor,
 módosításkor, vagy törléskor, mely auditálandó entitást érint, létrehoz egy új revision-t, azaz beszúr egy új
 rekordot a REVINFO táblába. Ad neki egy egyedi azonosítót, mely egy automatikusan növekvő szám (REV mező), és a
 REVTSTMP mezőben letárolja az aktuális dátumot, időt. Az entitás előző értékét az _AUD végű táblába szúrja be,
 melynek REV mezője tartalmazza a revision egyedi azonosítóját, valamint azt, hogy milyen művelet történt (0: ADD
 - beszúrás, 1: MOD - módosítás, 2: DEL - törlés).
</p>
<p>Természetesen lehetőség van az auditált entitások lekérdezésére is. Erre a teszteset testForRevisionsOfEntity és
 testForEntitiesAtRevision metódusai mutatnak példákat. A legegyszerűbb lekérdezni egy revision-höz tartozó
 entitást:
</p>
<pre class="brush: java">AuditReader auditReader = AuditReaderFactory.get(em);
Employee revision = (Employee) auditReader.createQuery()
    .forEntitiesAtRevision(Employee.class, 1).getSingleResult();</pre>
<p>Látható, hogy az audit entitások kezelésére az AuditReader való. Ennek is vannak hasznos metódusai, mint a
 findRevision, getCurrentRevision, getRevisionDate, getRevisionNumberForDate, getRevisions, stb. De ezeknél
 sokkal rugalmasabb a Criteria API-hoz hasonlatos lekérdezési lehetőség a createQuery metódus használatával. Itt
 fluent interfész használatával további feltételeket tudunk megadni. Pl. nézzük meg az összes revision
 lekérdezését az Employee osztályhoz:
</p>
<pre class="brush: java">List revisions = auditReader.createQuery()
    .forRevisionsOfEntity(Employee.class, false, true).getResultList();</pre>
<p>Ez egy List&lt;Object[]&gt; példánnyal fog visszatérni. A lista elemei tartalmazzák a revision-öket. Egy elem
 három objektumot tartalmaz. Az első az audit entitás, a második egy DefaultRevisionEntity példány, mely
 tartalmazza a revision azonosítóját és dátumát, a harmadik a RevisionType enum egy értéke (ADD, MOD, DEL).
 Persze az AuditQueryCreator metódusaival ezt a lekérdezést tovább finomíthatjuk, hogy csak a számunkra fontos
 értékeket adja vissza.
</p>
<p>Az Envers-t természetesen tovább tudjuk konfigurálni, pl. globális paraméterek használatával, vagy további
 annotációkkal. Pl. megadhatjuk a táblák prefix-ét, suffix-ét, mezők neveit, sémát, katalógust. Az @AuditTable,
 @SecondaryAuditTable(s) annotációkkal entitásonként adhatjuk meg az audit tábla nevét. @AuditOverride(s)
 annotációval a mezők neveit tudjuk felülírni. Amennyiben egy kapcsolatban a cél entitást nem akarjuk auditálni,
 használjuk a @Audited(targetAuditMode = RelationTargetAuditMode.NOT_AUDITED) annotációt. Ekkor a betöltött audit
 entitás mindig az aktuális cél entitásra fog mutatni.
</p>
<p>Megtehetjük azt is, hogy minden revision-höz saját adatokat mentünk el. Pl. a módosítást végző felhasználó nevét.
 Ekkor vagy a DefaultRevisionEntity osztályt kell kiterjeszteni, vagy a @RevisionNumber és @RevisionTimestamp
 annotációkat használni, és felvenni a megfelelő attribútumokat. Mindkét esetben az osztályt el kell látni a
 @RevisionEntity annotációval, és meg kell adni egy RevisionListener interfészt megvalósító osztályt, mely
 newRevision metódusát hívja meg az Envers. Ebben lehet beállítani az előbb említett példa esetén a
 bejelentkezett felhasználó nevét.
</p>
<p>Itt érdemes megemlékezni a
 <a href="http://commons.apache.org/dbutils/">Commons DbUtils</a>
 projektről is. A teszt esetben ugyanis az audit táblák tartalmát JDBC-n keresztül akartam ellenőrizni. A JDBC
 túl nehézkes, Connection, Statement, ResultSet építésével és a kivételkezelésével. Nem akartam emiatt bevetni a
 Spring-et (ágyúval verébre), hogy a JdbcTemplate-et használhassam, így Commons DbUtils-ra esett a választásom,
 mellyel egyszerűen lehet adatbázis műveleteket futtatni. Nézzünk is néhány példát, melyek magukért beszélnek:
</p>
<pre class="brush: java">QueryRunner runner = new QueryRunner();
runner.update(conn, &quot;delete from Employee&quot;);

Map result = runner.query(conn,
&quot;select count(*) as cnt from revinfo&quot;, new MapHandler());
assertEquals(1, result.get(&quot;cnt&quot;));

List&lt;Map&gt;&lt;String, Object[]&gt; results = runner.query(conn,
&quot;select * from Employee_AUD order by rev&quot;, new MapListHandler());
assertEquals(1, results.size());
assertEquals(&quot;name1&quot;, results.get(0).get(&quot;name&quot;));</pre>